<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"moyun.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="TypeScript教程一、TypeScript 语言简介1.1 概述TypeScript（简称 TS）是微软公司开发的一种基于 JavaScript （简称 JS）语言的编程语言。 TypeScript 可以看成是 JavaScript 的超集（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript教程">
<meta property="og:url" content="http://moyun.com/typescript%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="MoYun">
<meta property="og:description" content="TypeScript教程一、TypeScript 语言简介1.1 概述TypeScript（简称 TS）是微软公司开发的一种基于 JavaScript （简称 JS）语言的编程语言。 TypeScript 可以看成是 JavaScript 的超集（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-29T14:47:57.472Z">
<meta property="article:modified_time" content="2024-05-29T14:49:14.055Z">
<meta property="article:author" content="墨韵">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="TypeScript">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://moyun.com/typescript%E6%95%99%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://moyun.com/typescript%E6%95%99%E7%A8%8B/","path":"typescript教程/","title":"TypeScript教程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TypeScript教程 | MoYun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="MoYun" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MoYun</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-demo"><a href="/demo/" rel="section"><i class="fa fa-file-code fa-fw"></i>demo</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TypeScript%E6%95%99%E7%A8%8B"><span class="nav-text">TypeScript教程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81TypeScript-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B"><span class="nav-text">一、TypeScript 语言简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1.2 类型的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.3 动态类型与静态类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">1.4 静态类型的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">1.5 静态类型的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81TypeScript-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">二、TypeScript 基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="nav-text">2.1 类型声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-text">2.2 类型推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-TypeScript-%E7%9A%84%E7%BC%96%E8%AF%91"><span class="nav-text">2.3 TypeScript 的编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%80%BC%E4%B8%8E%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.4 值与类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-TypeScript-Playground"><span class="nav-text">2.5 TypeScript Playground</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-tsc-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text">2.6 tsc 编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-ts-node-%E6%A8%A1%E5%9D%97"><span class="nav-text">2.7 ts-node 模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81any-%E7%B1%BB%E5%9E%8B%EF%BC%8Cunknown-%E7%B1%BB%E5%9E%8B%EF%BC%8Cnever-%E7%B1%BB"><span class="nav-text">三、any 类型，unknown 类型，never 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-any-%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.1 any 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89"><span class="nav-text">3.1.1 基本含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E9%97%AE%E9%A2%98"><span class="nav-text">3.1.2 类型推断问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98"><span class="nav-text">3.1.3 污染问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-unknown-%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.2 unknown 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-never-%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.3 never 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81TypeScript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-text">四、TypeScript 的类型系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.1 基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">4.1.1 概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.2 包装对象类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">4.2.1 包装对象的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.2.2 包装对象类型与字面量类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Object-%E7%B1%BB%E5%9E%8B%E4%B8%8E-object-%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.3 Object 类型与 object 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-Object-%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.3.1 Object 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-object-%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.3.2 object 类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-undefined-%E5%92%8C-null-%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="nav-text">4.4 undefined 和 null 的特殊性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.5 值类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.6 联合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.7 交叉类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-type-%E5%91%BD%E4%BB%A4"><span class="nav-text">4.8 type 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-typeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">4.9 typeof 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-%E5%9D%97%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="nav-text">4.10 块级类型声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9"><span class="nav-text">4.11 类型的兼容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81TypeScript-%E7%9A%84%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">五、TypeScript 的数组类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">5.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-text">5.2 数组的类型推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84%EF%BC%8Cconst-%E6%96%AD%E8%A8%80"><span class="nav-text">5.3 只读数组，const 断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">5.4 多维数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81TypeScript-%E7%9A%84%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">六、TypeScript 的元组类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">6.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%8F%AA%E8%AF%BB%E5%85%83%E7%BB%84"><span class="nav-text">6.2 只读元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%88%90%E5%91%98%E6%95%B0%E9%87%8F%E7%9A%84%E6%8E%A8%E6%96%AD"><span class="nav-text">6.3 成员数量的推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%88%90%E5%91%98%E6%95%B0%E9%87%8F"><span class="nav-text">6.4 扩展运算符与成员数量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81TypeScript-%E7%9A%84-symbol-%E7%B1%BB%E5%9E%8B"><span class="nav-text">七、TypeScript 的 symbol 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">7.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-unique-symbol"><span class="nav-text">7.2 unique symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-text">7.3 类型推断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81TypeScript-%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">八、TypeScript 的函数类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">8.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-Function-%E7%B1%BB%E5%9E%8B"><span class="nav-text">8.2 Function 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-text">8.3 箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="nav-text">8.4 可选参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">8.5 参数默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="nav-text">8.6 参数解构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7-rest-%E5%8F%82%E6%95%B0"><span class="nav-text">8.7 rest 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-readonly-%E5%8F%AA%E8%AF%BB%E5%8F%82%E6%95%B0"><span class="nav-text">8.8 readonly 只读参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-9-void-%E7%B1%BB%E5%9E%8B"><span class="nav-text">8.9 void 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-10-never-%E7%B1%BB%E5%9E%8B"><span class="nav-text">8.10 never 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-11-%E5%B1%80%E9%83%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">8.11 局部类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-12-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-text">8.12 高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-13-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-text">8.13 函数重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-14-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">8.14 构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81TypeScript-%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="nav-text">九、TypeScript 的对象类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">9.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="nav-text">9.2 可选属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="nav-text">9.3 只读属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-text">9.4 属性名的索引类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-text">9.5 解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%88%99"><span class="nav-text">9.6 结构类型原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-%E4%B8%A5%E6%A0%BC%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A3%80%E6%9F%A5"><span class="nav-text">9.7 严格字面量检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-8-%E6%9C%80%E5%B0%8F%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7%E8%A7%84%E5%88%99"><span class="nav-text">9.8 最小可选属性规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-9-%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">9.9 空对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81-TypeScript-%E7%9A%84-interface-%E6%8E%A5%E5%8F%A3"><span class="nav-text">十、 TypeScript 的 interface 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">10.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-interface-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-text">10.2 interface 的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-1-interface-%E7%BB%A7%E6%89%BF-interface"><span class="nav-text">10.2.1 interface 继承 interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-2-interface-%E7%BB%A7%E6%89%BF-type"><span class="nav-text">10.2.2 interface 继承 type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-3-interface-%E7%BB%A7%E6%89%BF-class"><span class="nav-text">10.2.3 interface 继承 class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-%E6%8E%A5%E5%8F%A3%E5%90%88%E5%B9%B6"><span class="nav-text">10.3 接口合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-interface-%E4%B8%8E-type-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-text">10.4 interface 与 type 的异同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81TypeScript-%E7%9A%84-class-%E7%B1%BB%E5%9E%8B"><span class="nav-text">十一、TypeScript 的 class 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">11.1 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-1-%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">11.1.1 属性的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-2-readonly-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">11.1.2 readonly 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-3-%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">11.1.3 方法的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-4-%E5%AD%98%E5%8F%96%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-text">11.1.4 存取器方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-5-%E5%B1%9E%E6%80%A7%E7%B4%A2%E5%BC%95"><span class="nav-text">11.1.5 属性索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-%E7%B1%BB%E7%9A%84-interface-%E6%8E%A5%E5%8F%A3"><span class="nav-text">11.2 类的 interface 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-1-implements-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">11.2.1 implements 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-2-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="nav-text">11.2.2 实现多个接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-3-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-text">11.2.3 类与接口的合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-Class-%E7%B1%BB%E5%9E%8B"><span class="nav-text">11.3 Class 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1-%E5%AE%9E%E4%BE%8B%E7%B1%BB%E5%9E%8B"><span class="nav-text">11.3.1 实例类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2-%E7%B1%BB%E7%9A%84%E8%87%AA%E8%BA%AB%E7%B1%BB%E5%9E%8B"><span class="nav-text">11.3.2 类的自身类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-3-%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%88%99"><span class="nav-text">11.3.3 结构类型原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-text">11.4 类的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">11.5 可访问性修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-5-1-public"><span class="nav-text">11.5.1 public</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-5-2-private"><span class="nav-text">11.5.2 private</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-5-3-protected"><span class="nav-text">11.5.3 protected</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-5-4-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%86%99%E5%BD%A2%E5%BC%8F"><span class="nav-text">11.5.4 实例属性的简写形式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">11.6 静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-7-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-text">11.7 泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-8-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E6%8A%BD%E8%B1%A1%E6%88%90%E5%91%98"><span class="nav-text">11.8 抽象类，抽象成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-9-this-%E9%97%AE%E9%A2%98"><span class="nav-text">11.9 this 问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81TypeScript-%E6%B3%9B%E5%9E%8B"><span class="nav-text">十二、TypeScript 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">12.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">12.2 泛型的写法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-1-%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%86%99%E6%B3%95"><span class="nav-text">12.2.1 函数的泛型写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%86%99%E6%B3%95"><span class="nav-text">12.2.2 接口的泛型写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-3-%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%86%99%E6%B3%95"><span class="nav-text">12.2.3 类的泛型写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-4-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%86%99%E6%B3%95"><span class="nav-text">12.2.4 类型别名的泛型写法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">12.3 类型参数的默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-%E6%95%B0%E7%BB%84%E7%9A%84%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA"><span class="nav-text">12.4 数组的泛型表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="nav-text">12.5 类型参数的约束条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-6-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">12.6 使用注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81TypeScript-%E7%9A%84-Enum-%E7%B1%BB%E5%9E%8B"><span class="nav-text">十三、TypeScript 的 Enum 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">13.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-Enum-%E6%88%90%E5%91%98%E7%9A%84%E5%80%BC"><span class="nav-text">13.2 Enum 成员的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-%E5%90%8C%E5%90%8D-Enum-%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-text">13.3 同名 Enum 的合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-4-%E5%AD%97%E7%AC%A6%E4%B8%B2-Enum"><span class="nav-text">13.4 字符串 Enum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-5-keyof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">13.5 keyof 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-6-%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="nav-text">13.6 反向映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81TypeScript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-text">十四、TypeScript 的类型断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">14.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">14.2 类型断言的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-as-const-%E6%96%AD%E8%A8%80"><span class="nav-text">14.3 as const 断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80"><span class="nav-text">14.4 非空断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0"><span class="nav-text">14.5 断言函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81TypeScript-%E6%A8%A1%E5%9D%97"><span class="nav-text">十五、TypeScript 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">15.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-import-type-%E8%AF%AD%E5%8F%A5"><span class="nav-text">15.2 import type 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3-importsNotUsedAsValues"><span class="nav-text">15.3 importsNotUsedAsValues</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-CommonJS-%E6%A8%A1%E5%9D%97"><span class="nav-text">15.4 CommonJS 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%BD%8D"><span class="nav-text">15.5 模块定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-5-1-%E7%9B%B8%E5%AF%B9%E6%A8%A1%E5%9D%97%EF%BC%8C%E9%9D%9E%E7%9B%B8%E5%AF%B9%E6%A8%A1%E5%9D%97"><span class="nav-text">15.5.1 相对模块，非相对模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-5-2-Classic-%E6%96%B9%E6%B3%95"><span class="nav-text">15.5.2 Classic 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-5-3-Node-%E6%96%B9%E6%B3%95"><span class="nav-text">15.5.3 Node 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-5-4-%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84"><span class="nav-text">15.5.4 路径映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-5-5-tsc-%E7%9A%84%E2%80%93traceResolution%E5%8F%82%E6%95%B0"><span class="nav-text">15.5.5 tsc 的–traceResolution参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-5-6-tsc-%E7%9A%84%E2%80%93noResolve%E5%8F%82%E6%95%B0"><span class="nav-text">15.5.6 tsc 的–noResolve参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E3%80%81TypeScript-namespace"><span class="nav-text">十六、TypeScript namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">16.1 基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-namespace-%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-text">16.2 namespace 的输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3-namespace-%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-text">16.3 namespace 的合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%83%E3%80%81TypeScript-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">十七、TypeScript 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">17.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">17.2 装饰器的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-3-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">17.3 装饰器的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-4-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">17.4 类装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-5-%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">17.5 方法装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-6-%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">17.6 属性装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-7-getter-%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%8Csetter-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">17.7 getter 装饰器，setter 装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-8-accessor-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">17.8 accessor 装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-9-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">17.9 装饰器的执行顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E6%97%A7%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="nav-text">十八、装饰器（旧语法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#18-1-experimentalDecorators-%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="nav-text">18.1 experimentalDecorators 编译选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-text">18.2 装饰器的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-3-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">18.3 类装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4-%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">18.4 方法装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-5-%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">18.5 属性装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-6-%E5%AD%98%E5%8F%96%E5%99%A8%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">18.6 存取器装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-7-%E5%8F%82%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">18.7 参数装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-8-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">18.8 装饰器的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-9-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-text">18.9 为什么装饰器不能用于函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-10-%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%90%88%E6%88%90"><span class="nav-text">18.10 多个装饰器的合成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81declare-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">十九、declare 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#19-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">19.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-2-declare-variable"><span class="nav-text">19.2 declare variable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-3-declare-function"><span class="nav-text">19.3 declare function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-4-declare-class"><span class="nav-text">19.4 declare class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-5-declare-module%EF%BC%8Cdeclare-namespace"><span class="nav-text">19.5 declare module，declare namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-6-declare-global"><span class="nav-text">19.6 declare global</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-7-declare-enum"><span class="nav-text">19.7 declare enum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-8-declare-module-%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="nav-text">19.8 declare module 用于类型声明文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81d-ts-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="nav-text">二十、d.ts 类型声明文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">20.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-2-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="nav-text">20.2 类型声明文件的来源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#20-2-1-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90"><span class="nav-text">20.2.1 自动生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-2-2-%E5%86%85%E7%BD%AE%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="nav-text">20.2.2 内置声明文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-2-3-%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="nav-text">20.2.3 外部类型声明文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-3-declare-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">20.3 declare 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-4-%E6%A8%A1%E5%9D%97%E5%8F%91%E5%B8%83"><span class="nav-text">20.4 模块发布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-5-%E4%B8%89%E6%96%9C%E6%9D%A0%E5%91%BD%E4%BB%A4"><span class="nav-text">20.5 三斜杠命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81TypeScript-%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">二十一、TypeScript 类型运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-keyof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">21.1 keyof 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#21-1-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">21.1.1 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-1-2-keyof-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-text">21.1.2 keyof 运算符的用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-2-in-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">21.2 in 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-3-%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">21.3 方括号运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-4-extends%E2%80%A6-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">21.4 extends…?: 条件运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-5-infer-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">21.5 infer 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-6-is-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">21.6 is 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-7-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">21.7 模板字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81TypeScript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="nav-text">二十二、TypeScript 的类型映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#22-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">22.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2-%E6%98%A0%E5%B0%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">22.2 映射修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-3-%E9%94%AE%E5%90%8D%E9%87%8D%E6%98%A0%E5%B0%84"><span class="nav-text">22.3 键名重映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#22-3-1-%E8%AF%AD%E6%B3%95"><span class="nav-text">22.3.1 语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-3-2-%E5%B1%9E%E6%80%A7%E8%BF%87%E6%BB%A4"><span class="nav-text">22.3.2 属性过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-3-3-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-text">22.3.3 联合类型的映射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81TypeScript-%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7"><span class="nav-text">二十三、TypeScript 类型工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#23-1-Awaited-lt-Type-gt"><span class="nav-text">23.1 Awaited&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-2-ConstructorParameters-lt-Type-gt"><span class="nav-text">23.2 ConstructorParameters&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3-Exclude-lt-UnionType-ExcludedMembers-gt"><span class="nav-text">23.3 Exclude&lt; UnionType, ExcludedMembers &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-4-Extract-lt-Type-Union-gt"><span class="nav-text">23.4 Extract&lt; Type, Union &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-5-InstanceType-lt-Type-gt"><span class="nav-text">23.5 InstanceType&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-6-NonNullable-lt-Type-gt"><span class="nav-text">23.6 NonNullable&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-7-Omit-lt-Type-Keys-gt"><span class="nav-text">23.7 Omit&lt; Type, Keys &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-8-OmitThisParameter-lt-Type-gt"><span class="nav-text">23.8 OmitThisParameter&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-9-Parameters-lt-Type-gt"><span class="nav-text">23.9 Parameters&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-10-Partial-lt-Type-gt"><span class="nav-text">23.10 Partial&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-11-Pick-lt-Type-Keys-gt"><span class="nav-text">23.11 Pick&lt; Type, Keys &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-12-Readonly-lt-Type-gt"><span class="nav-text">23.12 Readonly&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-13-Record-lt-Keys-Type-gt"><span class="nav-text">23.13 Record&lt; Keys, Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-14-Required-lt-Type-gt"><span class="nav-text">23.14 Required&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-15-ReadonlyArray-lt-Type-gt"><span class="nav-text">23.15 ReadonlyArray&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-16-ReturnType-lt-Type-gt"><span class="nav-text">23.16 ReturnType&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-17-ThisParameterType-lt-Type-gt"><span class="nav-text">23.17 ThisParameterType&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-18-ThisType-lt-Type-gt"><span class="nav-text">23.18 ThisType&lt; Type &gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-19-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7"><span class="nav-text">23.19 字符串类型工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81TypeScript-%E7%9A%84%E6%B3%A8%E9%87%8A%E6%8C%87%E4%BB%A4"><span class="nav-text">二十四、TypeScript 的注释指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#24-1-ts-nocheck"><span class="nav-text">24.1 &#x2F;&#x2F; @ts-nocheck</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-2-ts-check"><span class="nav-text">24.2 &#x2F;&#x2F; @ts-check</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-3-ts-ignore"><span class="nav-text">24.3 &#x2F;&#x2F; @ts-ignore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-4-JSDoc"><span class="nav-text">24.4 JSDoc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#24-4-1-typedef"><span class="nav-text">24.4.1 @typedef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-4-2-type"><span class="nav-text">24.4.2 @type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-4-3-param"><span class="nav-text">24.4.3 @param</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-4-4-return%EF%BC%8C-returns"><span class="nav-text">24.4.4 @return，@returns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-4-5-extends-%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">24.4.5 @extends 和类型修饰符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81tsconfig-json"><span class="nav-text">二十五、tsconfig.json</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#25-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">25.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-2-exclude"><span class="nav-text">25.2 exclude</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-3-extends"><span class="nav-text">25.3 extends</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-4-files"><span class="nav-text">25.4 files</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-5-include"><span class="nav-text">25.5 include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-6-references"><span class="nav-text">25.6 references</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-7-compileOptions"><span class="nav-text">25.7 compileOptions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-1-allowJs"><span class="nav-text">25.7.1 allowJs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-2-alwaysStrict"><span class="nav-text">25.7.2 alwaysStrict</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-3-allowSyntheticDefaultImports"><span class="nav-text">25.7.3 allowSyntheticDefaultImports</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-4-allowUnreachableCode"><span class="nav-text">25.7.4 allowUnreachableCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-5-allowUnusedLabels"><span class="nav-text">25.7.5 allowUnusedLabels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-6-baseUrl"><span class="nav-text">25.7.6 baseUrl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-7-checkJs"><span class="nav-text">25.7.7 checkJs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-8-composite"><span class="nav-text">25.7.8 composite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-9-declaration"><span class="nav-text">25.7.9 declaration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-10-declarationDir"><span class="nav-text">25.7.10 declarationDir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-11-declarationMap"><span class="nav-text">25.7.11 declarationMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-7-12-emitBOM"><span class="nav-text">25.7.12 emitBOM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81tsc-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text">二十六、tsc 命令行编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#26-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">26.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-text">26.2 命令行参数</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="墨韵"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">墨韵</p>
  <div class="site-description" itemprop="description">ZERO-学习博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/moyunzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moyunzero" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zero305747648@gmail.com" title="E-Mail → mailto:zero305747648@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://moyun.com/typescript%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="墨韵">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MoYun">
      <meta itemprop="description" content="ZERO-学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TypeScript教程 | MoYun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TypeScript教程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-05-29 22:47:57 / 修改时间：22:49:14" itemprop="dateCreated datePublished" datetime="2024-05-29T22:47:57+08:00">2024-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Frontend-Notes/" itemprop="url" rel="index"><span itemprop="name">Frontend Notes</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Frontend-Notes/TypeScript/" itemprop="url" rel="index"><span itemprop="name">TypeScript</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>160k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:26</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="TypeScript教程"><a href="#TypeScript教程" class="headerlink" title="TypeScript教程"></a>TypeScript教程</h1><h2 id="一、TypeScript-语言简介"><a href="#一、TypeScript-语言简介" class="headerlink" title="一、TypeScript 语言简介"></a>一、TypeScript 语言简介</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>TypeScript（简称 TS）是微软公司开发的一种基于 JavaScript （简称 JS）语言的编程语言。</p>
<p>TypeScript 可以看成是 JavaScript 的超集（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。<br>TypeScript 对 JavaScript 添加的最主要部分，就是一个独立的类型系统。</p>
<span id="more"></span>

<h3 id="1-2-类型的概念"><a href="#1-2-类型的概念" class="headerlink" title="1.2 类型的概念"></a>1.2 类型的概念</h3><p>类型（type）指的是一组具有相同特征的值。如果两个值具有某种共同的特征，就可以说，它们属于同一种类型。</p>
<p>类型是人为添加的一种编程约束和用法提示。 主要目的是在软件开发过程中，为编译器和开发工具提供更多的验证和帮助，帮助提高代码质量，减少错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addOne</span>(<span class="params">n:number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数addOne()有一个参数n，类型为数值（number），表示这个位置只能使用数值，传入其他类型的值就会报错。</p>
<p>TypeScript 是在开发阶段报错，这样有利于提早发现错误，避免使用时报错。另一方面，函数定义里面加入类型，具有提示作用，可以告诉开发者这个函数怎么用。</p>
<h3 id="1-3-动态类型与静态类型"><a href="#1-3-动态类型与静态类型" class="headerlink" title="1.3 动态类型与静态类型"></a>1.3 动态类型与静态类型</h3><p>TypeScript 的主要功能是为 JavaScript 添加类型系统。</p>
<p>在语法上，JavaScript 属于动态类型语言。</p>
<p>TypeScript 引入了一个更强大、更严格的类型系统，属于静态类型语言。</p>
<h3 id="1-4-静态类型的优点"><a href="#1-4-静态类型的优点" class="headerlink" title="1.4 静态类型的优点"></a>1.4 静态类型的优点</h3><p>（1）有利于代码的静态分析。<br>有了静态类型，不必运行代码，就可以确定变量的类型，从而推断代码有没有错误。这就叫做代码的静态分析。</p>
<p>（2）有利于发现错误。<br>由于每个值、每个变量、每个运算符都有严格的类型约束，TypeScript 就能轻松发现拼写错误、语义错误和方法调用错误，节省程序员的时间。</p>
<p>（3）更好的 IDE 支持，做到语法提示和自动补全。<br>IDE（集成开发环境，比如 VSCode）一般都会利用类型信息，提供语法提示功能（编辑器自动提示函数用法、参数等）和自动补全功能（只键入一部分的变量名或函数名，编辑器补全后面的部分）。<br>（4）提供了代码文档。<br>类型信息可以部分替代代码文档，解释应该如何使用这些代码，熟练的开发者往往只看类型，就能大致推断代码的作用。借助类型信息，很多工具能够直接生成文档。<br>（5）有助于代码重构。</p>
<p>修改他人的 JavaScript 代码，往往非常痛苦，项目越大越痛苦，因为不确定修改后是否会影响到其他部分的代码。<br>类型信息大大减轻了重构的成本。一般来说，只要函数或对象的参数和返回值保持类型不变，就能基本确定，重构后的代码也能正常运行。如果还有配套的单元测试，就完全可以放心重构。越是大型的、多人合作的项目，类型信息能够提供的帮助越大。<br>综上所述，TypeScript 有助于提高代码质量，保证代码安全，更适合用在大型的企业级项目。这就是为什么大量 JavaScript 项目转成 TypeScript 的原因。</p>
<h3 id="1-5-静态类型的缺点"><a href="#1-5-静态类型的缺点" class="headerlink" title="1.5 静态类型的缺点"></a>1.5 静态类型的缺点</h3><p>（1）丧失了动态类型的代码灵活性。<br>动态类型有非常高的灵活性，给予程序员很大的自由，静态类型将这些灵活性都剥夺了。<br>（2）增加了编程工作量。<br>有了类型之后，程序员不仅需要编写功能，还需要编写类型声明，确保类型正确。这增加了不少工作量，有时会显著拖长项目的开发时间。<br>（3）更高的学习成本。<br>类型系统通常比较复杂，要学习的东西更多，要求开发者付出更高的学习成本。<br>（4）引入了独立的编译步骤。<br>原生的 JavaScript 代码，可以直接在 JavaScript 引擎运行。添加类型系统以后，就多出了一个单独的编译步骤，检查类型是否正确，并将 TypeScript 代码转成JavaScript 代码，这样才能运行。<br>（5）兼容性问题。<br>TypeScript 依赖 JavaScript 生态，需要用到很多外部模块。但是，过去大部分JavaScript 项目都没有做 TypeScript 适配，虽然可以自己动手做适配，不过使用时难免还是会有一些兼容性问题。</p>
<h2 id="二、TypeScript-基本用法"><a href="#二、TypeScript-基本用法" class="headerlink" title="二、TypeScript 基本用法"></a>二、TypeScript 基本用法</h2><h3 id="2-1-类型声明"><a href="#2-1-类型声明" class="headerlink" title="2.1 类型声明"></a>2.1 类型声明</h3><p>TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。函数参数和返回值，也是这样来声明类型。</p>
<blockquote>
<p>变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。</p>
</blockquote>
<p>另外，TypeScript 规定，变量只有赋值后才能使用，否则就会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-类型推断"><a href="#2-2-类型推断" class="headerlink" title="2.2 类型推断"></a>2.2 类型推断</h3><p>类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。</p>
<p>TypeScript 也可以推断函数的返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 的设计思想是，类型声明是可选的，你可以加，也可以不加。即使不加类型声明，依然是有效的 TypeScript 代码，只是这时不能保证TypeScript 会正确推断出类型。由于这个原因。所有 JavaScript 代码都是合法的TypeScript 代码。</p>
<p>这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。</p>
<h3 id="2-3-TypeScript-的编译"><a href="#2-3-TypeScript-的编译" class="headerlink" title="2.3 TypeScript 的编译"></a>2.3 TypeScript 的编译</h3><p>JavaScript 的运行环境（浏览器和 Node.js）不认识 TypeScript 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“编译”（compile）。<br>TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。<br>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p>
<h3 id="2-4-值与类型"><a href="#2-4-值与类型" class="headerlink" title="2.4 值与类型"></a>2.4 值与类型</h3><p>“类型”是针对“值”的，可以视为是后者的一个元属性。每一个值在 TypeScript 里面都是有类型的。比如，3是一个值，它的类型是number。<br>TypeScript 代码只涉及类型，不涉及值。所有跟“值”相关的处理，都由 JavaScript 完成。<br>这一点务必牢记。TypeScript 项目里面，其实存在两种代码，一种是底层的“值代码”，另一种是上层的“类型代码”。前者使用 JavaScript 语法，后者使用 TypeScript的类型语法。<br>它们是可以分离的，TypeScript 的编译过程，实际上就是把“类型代码”全部拿掉，只保留“值代码”。<br>编写 TypeScript 项目时，不要混淆哪些是值代码，哪些是类型代码。</p>
<h3 id="2-5-TypeScript-Playground"><a href="#2-5-TypeScript-Playground" class="headerlink" title="2.5 TypeScript Playground"></a>2.5 TypeScript Playground</h3><p>最简单的 TypeScript 使用方法，就是使用官网的在线编译页面，叫做 TypeScriptPlayground。<br>只要打开这个网页，把 TypeScript 代码贴进文本框，它就会在当前页面自动编译出JavaScript 代码，还可以在浏览器执行编译产物。如果编译报错，它也会给出详细的报错信息。<br>这个页面还具有支持完整的 IDE 支持，可以自动语法提示。此外，它支持把代码片段和编译器设置保存成 URL，分享给他人。</p>
<h3 id="2-6-tsc-编译器"><a href="#2-6-tsc-编译器" class="headerlink" title="2.6 tsc 编译器"></a>2.6 tsc 编译器</h3><p>TypeScript 官方提供的编译器叫做 tsc，可以将 TypeScript 脚本编译成 JavaScript脚本。本机想要编译 TypeScript 代码，必须安装 tsc。<br>根据约定，TypeScript 脚本文件使用.ts后缀名，JavaScript 脚本文件使用.js后缀名。tsc 的作用就是把.ts脚本转变成.js脚本。</p>
<h3 id="2-7-ts-node-模块"><a href="#2-7-ts-node-模块" class="headerlink" title="2.7 ts-node 模块"></a>2.7 ts-node 模块</h3><p>ts-node 是一个非官方的 npm 模块，可以直接运行 TypeScript 代码。</p>
<h2 id="三、any-类型，unknown-类型，never-类"><a href="#三、any-类型，unknown-类型，never-类" class="headerlink" title="三、any 类型，unknown 类型，never 类"></a>三、any 类型，unknown 类型，never 类</h2><h3 id="3-1-any-类型"><a href="#3-1-any-类型" class="headerlink" title="3.1 any 类型"></a>3.1 any 类型</h3><h4 id="3-1-1-基本含义"><a href="#3-1-1-基本含义" class="headerlink" title="3.1.1 基本含义"></a>3.1.1 基本含义</h4><p>any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>变量类型一旦设为any，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="title function_">x</span>(<span class="number">1</span>) <span class="comment">// 不报错</span></span><br><span class="line">x.<span class="property">foo</span> = <span class="number">100</span>; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>由于这个原因，应该尽量避免使用any类型，否则就失去了使用 TypeScript 的意义。<br>实际开发中，any类型主要适用以下两个场合。<br>（1）出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为any。<br>（2）为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为any。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上any，TypeScript 编译时就不会报错。<br>总之，TypeScript 认为，只要开发者使用了any类型，就表示开发者想要自己来处理这些代码，所以就不对any类型进行任何限制，怎么使用都可以。<br>从集合论的角度看，any类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。</p>
<h4 id="3-1-2-类型推断问题"><a href="#3-1-2-类型推断问题" class="headerlink" title="3.1.2 类型推断问题"></a>3.1.2 类型推断问题</h4><p>对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是any。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>对于那些类型不明显的变量，一定要显式声明类型，防止被推断为any。</p>
<p>TypeScript 提供了一个编译选项noImplicitAny，打开该选项，只要推断出any类型就会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --noImplicitAny app.<span class="property">ts</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-污染问题"><a href="#3-1-3-污染问题" class="headerlink" title="3.1.3 污染问题"></a>3.1.3 污染问题</h4><p>any类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">y = x; <span class="comment">// 不报错</span></span><br><span class="line">y * <span class="number">123</span> <span class="comment">// 不报错</span></span><br><span class="line">y.<span class="title function_">toFixed</span>() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-unknown-类型"><a href="#3-2-unknown-类型" class="headerlink" title="3.2 unknown 类型"></a>3.2 unknown 类型</h3><p>为了解决any类型“污染”其他变量的问题，TypeScript 3.0 引入了unknown类型。它与any含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像any那样自由，可以视为严格版的any。</p>
<p>unknown跟any的相似之处，在于所有类型的值都可以分配给unknown类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">unknown</span>;</span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="number">42</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;Hello World&#x27;</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>unknown类型跟any类型的不同之处在于，它不能直接使用。主要有以下几个限制。</p>
<ol>
<li>unknown类型的变量，不能直接赋值给其他类型的变量（除了any类型和unknown类型）。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v</span>:<span class="built_in">unknown</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">boolean</span> = v; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">number</span> = v; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>变量v是unknown类型，赋值给any和unknown以外类型的变量都会报错，这就避免了污染问题，从而克服了any类型的一大缺点。</p>
<ol start="2">
<li>不能直接调用unknown类型变量的方法和属性。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">unknown</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">v1.<span class="property">foo</span>  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">v2.<span class="title function_">trim</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>:<span class="built_in">unknown</span> = <span class="function">(<span class="params">n = <span class="number">0</span></span>) =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="title function_">v3</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>unknown类型变量能够进行的运算是有限的，只能进行比较运算（运算符== 、===、!=、!==、||、&amp;&amp;、?）、取反运算（运算符!）、运算符和instanceof运算符这几种，其他运算都会报错。</li>
</ol>
<p>正确使用unknown类型变量。</p>
<p>只有经过“类型缩小”，unknown类型变量才可以使用。所谓“类型缩小”，就是缩小unknown变量的类型范围，确保不会出错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> r = a + <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unknown类型的变量a经过typeof运算以后，能够确定实际类型是number，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p>
<p>这样设计的目的是，只有明确unknown变量的实际类型，才允许使用它，防止像any那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p>
<p>总之，unknown可以看作是更安全的any。一般来说，凡是需要设为any类型的地方，通常都应该优先考虑设为unknown类型。<br>在集合论上，unknown也可以视为所有其他类型（除了any）的全集，所以它和any一样，也属于 TypeScript 的顶层类型。</p>
<h3 id="3-3-never-类型"><a href="#3-3-never-类型" class="headerlink" title="3.3 never 类型"></a>3.3 never 类型</h3><p>TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。<br>由于不存在任何属于“空类型”的值，所以该类型被称为never，即不可能发生这样的值。</p>
<p>never类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性，另外，不可能返回值的函数，返回值的类型就可以写成never。</p>
<p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于never类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x; <span class="comment">// never 类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>never类型的一个重要特点是，可以赋值给任意其他类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>:<span class="built_in">number</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>:<span class="built_in">string</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>:<span class="built_in">string</span> = <span class="title function_">f</span>(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么never类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了never类型。因此，never类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottomtype）。</p>
</blockquote>
<p>总之，TypeScript 有两个“顶层类型”（any和unknown），但是“底层类型”只有never唯一一个。</p>
<h2 id="四、TypeScript-的类型系统"><a href="#四、TypeScript-的类型系统" class="headerlink" title="四、TypeScript 的类型系统"></a>四、TypeScript 的类型系统</h2><h3 id="4-1-基本类型"><a href="#4-1-基本类型" class="headerlink" title="4.1 基本类型"></a>4.1 基本类型</h3><h4 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1 概述"></a>4.1.1 概述</h4><p>JavaScript 语言（注意，不是 TypeScript）将值分成8种类型。</p>
<ul>
<li><p>boolean</p>
<p>boolean类型只包含true和false两个布尔值。</p>
</li>
<li><p>string</p>
<p>string类型包含所有字符串。</p>
</li>
<li><p>number</p>
<p>number类型包含所有整数和浮点数。</p>
</li>
<li><p>bigint</p>
<p>bigint 类型包含所有的大整数。</p>
<p>bigint 与 number 类型不兼容。</p>
<blockquote>
<p>注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数target不低于es2020）。</p>
</blockquote>
</li>
<li><p>symbol</p>
<p>symbol 类型包含所有的 Symbol 值。</p>
</li>
<li><p>object</p>
<p>object 类型包含了所有对象、数组和函数。</p>
</li>
<li><p>undefined</p>
<p>undefined 类型只包含一个值undefined，表示未定义（即还未给出定义，以后可能会有定义）。</p>
</li>
<li><p>null</p>
<p>null 类型也只包含一个值null，表示为空（即此处没有值）。</p>
<blockquote>
<p>注意，如果没有声明类型的变量，被赋值为undefined或null，它们的类型会被推断为any。</p>
</blockquote>
</li>
</ul>
<p>TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。<br>注意，上面所有类型的名称都是小写字母，首字母大写的Number、String、Boolean等在 JavaScript 语言中都是内置对象，而不是类型名称。<br>另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。<br>这8种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p>
<h3 id="4-2-包装对象类型"><a href="#4-2-包装对象类型" class="headerlink" title="4.2 包装对象类型"></a>4.2 包装对象类型</h3><h4 id="4-2-1-包装对象的概念"><a href="#4-2-1-包装对象的概念" class="headerlink" title="4.2.1 包装对象的概念"></a>4.2.1 包装对象的概念</h4><p>JavaScript 的8种类型之中，undefined和null其实是两个特殊值，object属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p>
<ul>
<li><p>boolean</p>
</li>
<li><p>string</p>
</li>
<li><p>number</p>
</li>
<li><p>bigint</p>
</li>
<li><p>symbol</p>
</li>
</ul>
<p>上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p>
<p>在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会自动转为包装对象，charAt()方法其实是定义在包装对象上。<br>这样的设计大大方便了字符串处理，省去了将原始类型的值手动转成对象实例的麻烦。<br>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即Symbol()和BigInt()不能作为构造函数使用），但是剩下三种可以。</p>
<ul>
<li><p>Boolean()</p>
</li>
<li><p>String()</p>
</li>
<li><p>Number()</p>
</li>
</ul>
<p>以上三个构造函数，执行后可以直接获取某个原始类型值的包装对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> s <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">s.<span class="title function_">charAt</span>(<span class="number">1</span>) <span class="comment">// &#x27;e&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，String()只有当作构造函数使用时（即带有new命令调用），才会返回包装对象。如果当作普通函数使用（不带有new命令），返回就是一个普通字符串。其他两个构造函数Number()和Boolean()也是如此。</p>
</blockquote>
<h4 id="4-2-2-包装对象类型与字面量类型"><a href="#4-2-2-包装对象类型与字面量类型" class="headerlink" title="4.2.2 包装对象类型与字面量类型"></a>4.2.2 包装对象类型与字面量类型</h4><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> <span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 包装对象</span></span><br></pre></td></tr></table></figure>

<p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p>
<ul>
<li><p>Boolean 和 boolean</p>
</li>
<li><p>String 和 string</p>
</li>
<li><p>Number 和 number</p>
</li>
<li><p>BigInt 和 bigint</p>
</li>
<li><p>Symbol 和 symbol</p>
</li>
</ul>
<p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="title class_">String</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="title class_">String</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s3</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s4</span>:<span class="built_in">string</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p>
<h3 id="4-3-Object-类型与-object-类型"><a href="#4-3-Object-类型与-object-类型" class="headerlink" title="4.3 Object 类型与 object 类型"></a>4.3 Object 类型与 object 类型</h3><h4 id="4-3-1-Object-类型"><a href="#4-3-1-Object-类型" class="headerlink" title="4.3.1 Object 类型"></a>4.3.1 Object 类型</h4><p>大写的Object类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，是Object类型，这囊括了几乎所有的值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">Object</span>;</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">true</span>;</span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">obj = <span class="number">1</span>;</span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>事实上，除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型。</p>
<p>另外，空对象{}是Object类型的简写形式，所以使用Object时常常用空对象代替。</p>
<h4 id="4-3-2-object-类型"><a href="#4-3-2-object-类型" class="headerlink" title="4.3.2 object 类型"></a>4.3.2 object 类型</h4><p>小写的object类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">object</span>;</span><br><span class="line"></span><br><span class="line">obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">obj = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">obj = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line">obj = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">obj = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// 报错</span></span><br><span class="line">obj = <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型object，不使用大写类型Object。<br>注意，无论是大写的Object类型，还是小写的object类型，都只包含 JavaScript内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">o1</span>:<span class="title class_">Object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">o2</span>:<span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">0</span> &#125;;</span><br><span class="line">o1.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br><span class="line">o1.<span class="property">foo</span> <span class="comment">// 报错</span></span><br><span class="line">o2.<span class="title function_">toString</span>() <span class="comment">// 正确</span></span><br><span class="line">o2.<span class="property">foo</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-undefined-和-null-的特殊性"><a href="#4-4-undefined-和-null-的特殊性" class="headerlink" title="4.4 undefined 和 null 的特殊性"></a>4.4 undefined 和 null 的特殊性</h3><p>undefined和null既是值，又是类型。</p>
<p>作为值，它们有一个特殊的地方：任何其他类型的变量都可以赋值为undefined或null。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line">age = <span class="literal">null</span>;      <span class="comment">// 正确</span></span><br><span class="line">age = <span class="literal">undefined</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>这并不是因为undefined和null包含在number类型里面，而是故意这样设计，任何类型的变量都可以赋值为undefined和null，以便跟 JavaScript 的行为保持一致。<br>JavaScript 的行为是，变量如果等于undefined就表示还没有赋值，如果等于null就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="built_in">object</span> = <span class="literal">undefined</span>;</span><br><span class="line">obj.<span class="title function_">toString</span>() <span class="comment">// 编译不报错，运行就报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量obj等于undefined，编译不会报错。但是，实际执行时，调用obj.toString()就报错了，因为undefined不是对象，没有这个方法。<br>为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项strictNullChecks。只要打开这个选项，undefined和null就不能赋值给其他类型的变量（除了any类型和unknown类型）。<br>下面是 tsc 命令打开这个编译选项的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsc --strictNullChecks app.ts</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line">age = <span class="literal">null</span>;      <span class="comment">// 报错</span></span><br><span class="line">age = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>这个选项在配置文件tsconfig.json的写法如下。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>打开strictNullChecks以后，undefined和null这两种值也不能互相赋值了。</p>
<p>总之，打开strictNullChecks以后，undefined和null只能赋值给自身，或者any类型和unknown类型的变量。</p>
<h3 id="4-5-值类型"><a href="#4-5-值类型" class="headerlink" title="4.5 值类型"></a>4.5 值类型</h3><p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量x的类型是字符串hello，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。<br>TypeScript 推断类型时，遇到const命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 的类型是 &quot;https&quot;</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line"><span class="comment">// y 的类型是 string</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">&#x27;https&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量x是const命令声明的，TypeScript 就会推断它的类型是值https，而不是string类型。<br>这样推断是合理的，因为const命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。<br>注意，const命令声明的变量，如果赋值为对象，并不会推断为值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 的类型是 &#123; foo: number &#125;</span></span><br><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量x没有被推断为值类型，而是推断属性foo的类型是number。这是因为 JavaScript 里面，const变量赋值为对象时，属性值是可以改变的。<br>值类型可能会出现一些很奇怪的报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="number">5</span> = <span class="number">4</span> + <span class="number">1</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，等号左侧的类型是数值5，等号右侧4 + 1的类型，TypeScript 推测为number。由于5是number的子类型，number是5的父类型，父类型不能赋值给子类型，所以报错了。</p>
<p>但是，反过来是可以的，子类型可以赋值给父类型。</p>
<p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:<span class="number">5</span> = (<span class="number">4</span> + <span class="number">1</span>) <span class="keyword">as</span> <span class="number">5</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>在4 + 1后面加上as 5，就是告诉编译器，可以把4 + 1的类型视为值类型5，这样就不会报错了。</p>
<h3 id="4-6-联合类型"><a href="#4-6-联合类型" class="headerlink" title="4.6 联合类型"></a>4.6 联合类型</h3><p>联合类型（union types）指的是多个类型组成的一个新类型，使用符号|表示。<br>联合类型A|B表示，任何一个类型只要属于A或B，就属于联合类型A|B。</p>
<p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p>
<p>打开编译选项strictNullChecks后，其他类型的变量不能赋值为undefined或null。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>:<span class="built_in">string</span>|<span class="literal">null</span>;</span><br><span class="line">name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">name = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>联合类型的第一个成员前面，也可以加上竖杠|，这样便于多行书写。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:</span><br><span class="line">  | <span class="string">&#x27;one&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;two&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;three&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;four&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  id:<span class="built_in">number</span>|<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>()); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法就是对参数id做一下类型缩小，确定它的类型以后再进行处理。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  id:<span class="built_in">number</span>|<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPort</span>(<span class="params"></span></span><br><span class="line"><span class="params">  scheme: <span class="string">&#x27;http&#x27;</span>|<span class="string">&#x27;https&#x27;</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (scheme) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;http&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;https&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">443</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-交叉类型"><a href="#4-7-交叉类型" class="headerlink" title="4.7 交叉类型"></a>4.7 交叉类型</h3><p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号&amp;表示。<br>交叉类型A&amp;B表示，任何一个类型必须同时属于A和B，才属于交叉类型A&amp;B，即交叉类型同时满足A和B的特征。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>&amp;<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>交叉类型的主要用途是表示对象的合成。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:</span><br><span class="line">  &#123; <span class="attr">foo</span>: <span class="built_in">string</span> &#125; &amp;</span><br><span class="line">  &#123; <span class="attr">bar</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line">obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>交叉类型常常用来为对象类型添加新属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">foo</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = A &amp; &#123; <span class="attr">bar</span>: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-type-命令"><a href="#4-8-type-命令" class="headerlink" title="4.8 type 命令"></a>4.8 type 命令</h3><p>type命令用来定义一个类型的别名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="title class_">Age</span> = <span class="number">55</span>;</span><br></pre></td></tr></table></figure>

<p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。<br>别名不允许重名。</p>
<p>别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。</p>
<p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌<br>套。</p>
<p>type命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p>
<h3 id="4-9-typeof-运算符"><a href="#4-9-typeof-运算符" class="headerlink" title="4.9 typeof 运算符"></a>4.9 typeof 运算符</h3><p>avaScript 语言中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;foo&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意，这时 typeof 的操作数是一个值。<br>JavaScript 里面，typeof运算符只可能返回八种结果，而且都是字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1337</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;foo&quot;</span>; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">parseInt</span>; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(); <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">127n</span> <span class="comment">// &quot;bigint&quot;</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 将typeof运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="keyword">typeof</span> a;   <span class="comment">// &#123; x: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="keyword">typeof</span> a.<span class="property">x</span>; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>这种用法的typeof返回的是 TypeScript 类型，所以只能用在类型运算之中（即跟类型相关的代码之中），不能用在值运算。<br>也就是说，同一段代码可能存在两种typeof运算符，一种用在值相关的 JavaScript代码部分，另一种用在类型相关的 TypeScript 代码部分。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="keyword">typeof</span> a;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，用到了两个typeof，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。<br>JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p>
<p>由于编译时不会进行 JavaScript 的值运算，所以TypeScript 规定，typeof 的参数只能是标识符，不能是需要运算的表达式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> <span class="title class_">Date</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>另外，typeof命令的参数不能是类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyAge</span> = <span class="keyword">typeof</span> <span class="title class_">Age</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="4-10-块级类型声明"><a href="#4-10-块级类型声明" class="headerlink" title="4.10 块级类型声明"></a>4.10 块级类型声明</h3><p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">type</span> T = <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">v</span>:T = <span class="number">5</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> T = <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">v</span>:T = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-11-类型的兼容"><a href="#4-11-类型的兼容" class="headerlink" title="4.11 类型的兼容"></a>4.11 类型的兼容</h3><p>TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="built_in">number</span>|<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:T = a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量a和b的类型是不一样的，但是变量a赋值给变量b并不会报错。这时，我们就认为，b的类型兼容a的类型。<br>TypeScript 为这种情况定义了一个专门术语。如果类型A的值可以赋值给类型B，那么类型A就称为类型B的子类型（subtype）。</p>
<p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="string">&#x27;hi&#x27;</span> = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">b = a; <span class="comment">// 正确</span></span><br><span class="line">a = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p>
<h2 id="五、TypeScript-的数组类型"><a href="#五、TypeScript-的数组类型" class="headerlink" title="五、TypeScript 的数组类型"></a>五、TypeScript 的数组类型</h2><p>JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。</p>
<h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><p>TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。<br>数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>如果数组成员的类型比较复杂，可以写在圆括号里面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:(<span class="built_in">number</span>|<span class="built_in">string</span>)[];</span><br></pre></td></tr></table></figure>

<p>这个例子里面的圆括号是必须的，否则因为竖杠（|）的优先级低于[]，TypeScript 会把number|string[]理解成number和string[]的联合类型。<br>如果数组成员可以是任意类型，写成any[]。当然，这种写法是应该避免的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">any</span>[];</span><br></pre></td></tr></table></figure>

<p>数组类型的第二种写法是使用 TypeScipt 内置的 Array 接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组arr的类型是Array&lt;**number**&gt;，其中number表示成员类型是<br>number。<br>这种写法对于成员类型比较复杂的数组，代码可读性会稍微好一些。</p>
<p>数组类型声明了以后，成员数量是不限制的，任意数量的成员都可以，也可以是空数组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">number</span>[];</span><br><span class="line">arr = [];</span><br><span class="line">arr = [<span class="number">1</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>这种规定的隐藏含义就是，数组的成员是可以动态变化的。</p>
<p>正是由于成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。</p>
<p>TypeScript 允许使用方括号读取数组成员的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="number">0</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>由于数组成员的索引类型都是number，所以读取成员类型也可以写成下面这样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">Names</span>[<span class="built_in">number</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-数组的类型推断"><a href="#5-2-数组的类型推断" class="headerlink" title="5.2 数组的类型推断"></a>5.2 数组的类型推断</h3><p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。<br>如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是any[]。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断为 any[]</span></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br></pre></td></tr></table></figure>

<p>后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断为 any[]</span></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="comment">// 推断类型为 number[]</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 推断类型为 (string | number)[]</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断类型为 number[]</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">123</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-只读数组，const-断言"><a href="#5-3-只读数组，const-断言" class="headerlink" title="5.3 只读数组，const 断言"></a>5.3 只读数组，const 断言</h3><p>JavaScript 规定，const命令声明的数组变量是可以改变成员的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>TypeScript 允许声明只读数组，方法是在数组类型前面加上readonly关键字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">3</span>); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">0</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，arr是一个只读数组，删除、修改、新增数组成员都会报错。<br>TypeScript 将readonly number[]与number[]视为两种不一样的类型，后者是前者的子类型。<br>这是因为只读数组没有pop()、push()之类会改变原数组的方法，所以number[]的方法数量要多于readonly number[]，这意味着number[]其实是readonly number[]的子类型。<br>子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型number[]可以用于所有使用父类型的场合，反过来就不行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>:<span class="built_in">number</span>[] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = a1; <span class="comment">// 正确</span></span><br><span class="line">a1 = a2; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>由于只读数组是数组的父类型，所以它不能代替数组。这一点很容易产生令人困惑的报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">s:<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_">getSum</span>(arr) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>注意，readonly关键字不能与数组的泛型写法一起使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="keyword">readonly</span> <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a1</span>:<span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a2</span>:<span class="title class_">Readonly</span>&lt;<span class="built_in">number</span>[]&gt; = [<span class="number">0</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>泛型ReadonlyArray&lt;**T**&gt;和Readonly&lt;**T[]**&gt;都可以用来生成只读数组类型。两者尖括号里面的写法不一样，Readonly&lt;**T[]**&gt;的尖括号里面是整个数组（number[]），而ReadonlyArray&lt;**T**&gt;的尖括号里面是数组成员（number）。<br>只读数组还有一种声明方法，就是使用“const 断言”。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">arr[<span class="number">0</span>] = [<span class="number">2</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-多维数组"><a href="#5-4-多维数组" class="headerlink" title="5.4 多维数组"></a>5.4 多维数组</h3><p>TypeScript 使用T[][]的形式，表示二维数组，T是最底层数组成员的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">multi</span>:<span class="built_in">number</span>[][] =</span><br><span class="line">  [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>]];</span><br></pre></td></tr></table></figure>

<h2 id="六、TypeScript-的元组类型"><a href="#六、TypeScript-的元组类型" class="headerlink" title="六、TypeScript 的元组类型"></a>六、TypeScript 的元组类型</h2><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h3><p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。<br>元组必须明确声明每个成员的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>]</span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>元组类型的写法，与上一章的数组有一个重大差异。数组的成员类型写在方括号外面（number[]），元组的成员类型是写在方括号里面（[number]）。<br>TypeScript 的区分方法是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:[<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>使用元组时，必须明确给出类型声明（上例的[number]），不能省略，否则TypeScript 会把一个值自动推断为数组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 的类型为 (number | boolean)[]</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p>元组成员的类型可以添加问号后缀（?），表示该成员是可选的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:[<span class="built_in">number</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myTuple = [</span><br><span class="line">  <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">number</span>?,</span><br><span class="line">  <span class="built_in">string</span>?</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:[<span class="built_in">string</span>, <span class="built_in">string</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">x[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>但是，使用扩展运算符（…），可以表示不限成员数量的元组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NamedNums</span> = [</span><br><span class="line">  <span class="built_in">string</span>,</span><br><span class="line">  ...<span class="built_in">number</span>[]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="title class_">NamedNums</span> = [<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">NamedNums</span> = [<span class="string">&#x27;B&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>扩展运算符用在元组的任意位置都可以，但是它后面只能是数组或元组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];</span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t3 = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<p>如果不确定元组成员的类型和数量，可以写成下面这样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [...<span class="built_in">any</span>[]];</span><br></pre></td></tr></table></figure>

<p>元组可以通过方括号，读取成员类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Tuple</span>[<span class="number">1</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>由于元组的成员都是数值索引，即索引类型都是number，所以可以像下面这样读取。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="title class_">Date</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TupleEl</span> = <span class="title class_">Tuple</span>[<span class="built_in">number</span>];  <span class="comment">// string|number|Date</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-只读元组"><a href="#6-2-只读元组" class="headerlink" title="6.2 只读元组"></a>6.2 只读元组</h3><p>元组也可以是只读的，不允许修改，有两种写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">type</span> t = <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">string</span>]</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">type</span> t = <span class="title class_">Readonly</span>&lt;[<span class="built_in">number</span>, <span class="built_in">string</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种写法都可以得到只读元组，其中写法二是一个泛型，用到了工具类型Readonly&lt;**T**&gt;。<br>跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> t1 = <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> t2 = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:t2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:t1 = x; <span class="comment">// 正确</span></span><br><span class="line">x = y; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>由于只读元组不能替代元组，所以会产生一些令人困惑的报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distanceFromOrigin</span>(<span class="params">[x, y]:[<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(x**<span class="number">2</span> + y**<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point = [<span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="title function_">distanceFromOrigin</span>(point); <span class="comment">// 报错 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例报错的解决方法</span></span><br><span class="line"><span class="title function_">distanceFromOrigin</span>(</span><br><span class="line">  point <span class="keyword">as</span> [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-成员数量的推断"><a href="#6-3-成员数量的推断" class="headerlink" title="6.3 成员数量的推断"></a>6.3 成员数量的推断</h3><p>如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">point: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (point.<span class="property">length</span> === <span class="number">3</span>) &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果包含了可选成员，TypeScript 会推断出可能的成员数量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  point:[<span class="built_in">number</span>, <span class="built_in">number</span>?, <span class="built_in">number</span>?]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (point.<span class="property">length</span> === <span class="number">4</span>) &#123;  <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用了扩展运算符，TypeScript 就无法推断出成员数量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">myTuple</span>:[...<span class="built_in">string</span>[]]</span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (myTuple.<span class="property">length</span> === <span class="number">4</span>) &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-扩展运算符与成员数量"><a href="#6-4-扩展运算符与成员数量" class="headerlink" title="6.4 扩展运算符与成员数量"></a>6.4 扩展运算符与成员数量</h3><p>扩展运算符（…）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。<br>这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(...arr) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>有些函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:[<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(...arr) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>另一种写法是使用as const断言。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<h2 id="七、TypeScript-的-symbol-类型"><a href="#七、TypeScript-的-symbol-类型" class="headerlink" title="七、TypeScript 的 symbol 类型"></a>七、TypeScript 的 symbol 类型</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h3><p>Symbol 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个Symbol 值都是独一无二的，与其他任何值都不相等。<br>Symbol 值通过Symbol()函数生成。在 TypeScript 里面，Symbol 的类型使用symbol表示。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line">x === y <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-unique-symbol"><a href="#7-2-unique-symbol" class="headerlink" title="7.2 unique symbol"></a>7.2 unique symbol</h3><p>symbol类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。</p>
<p>为了解决这个问题，TypeScript 设计了symbol的一个子类型unique symbol，它表示单个的、某个具体的 Symbol 值。<br>因为unique symbol表示单个值，所以这个类型的变量是不能修改值的，只能用const命令声明，不能用let声明。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>const命令为变量赋值 Symbol 值时，变量类型默认就是unique symbol，所以类型可以省略不写。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>每个声明为unique symbol类型的变量，它们的值都是不一样的，其实属于两个值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="string">&#x27;world&#x27;</span> = <span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量a和b都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较。<br>而且，由于变量a和b是两个类型，就不能把一个赋值给另一个。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = a; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上例变量b的类型，如果要写成与变量a同一个unique symbol值类型，只能写成类型为typeof a。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="keyword">typeof</span> a = a; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>相同参数的Symbol.for()方法会返回相同的 Symbol 值。TypeScript 目前无法识别这种情况，所以可能出现多个 unique symbol 类型的变量，等于同一个 Symbol 值的情况。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>unique symbol 类型是 symbol 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="built_in">symbol</span> = a; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:unique <span class="built_in">symbol</span> = b; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>unique symbol 类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的 Symbol 值当作属性名，那么它的类型只能是 unique symbol，不能是 symbol。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">x</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  [x]: <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br><span class="line">  [y]: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unique symbol类型也可以用作类（class）的属性值，但只能赋值给类的readonly static属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="attr">foo</span>:unique <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这时static和readonly两个限定符缺一不可，这是为了保证这个属性是固定不变的。</p>
<h3 id="7-3-类型推断"><a href="#7-3-类型推断" class="headerlink" title="7.3 类型推断"></a>7.3 类型推断</h3><p>如果变量声明时没有给出类型，TypeScript 会推断某个 Symbol 值变量的类型。</p>
<p>let命令声明的变量，推断类型为 symbol。</p>
<p>const命令声明的变量，推断类型为 unique symbol。</p>
<p>但是，const命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">const</span> y = x;</span><br></pre></td></tr></table></figure>

<p>let命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">// 类型为 symbol</span></span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure>

<h2 id="八、TypeScript-的函数类型"><a href="#八、TypeScript-的函数类型" class="headerlink" title="八、TypeScript 的函数类型"></a>八、TypeScript 的函数类型</h2><h3 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h3><p>函数的类型声明，需要在声明函数时，给出参数的类型和返回值的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  txt:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数hello()在声明时，需要给出参数txt的类型（string），以及返回值的类型（void），后者写在参数列表的圆括号后面。void类型表示没有返回值。</p>
<p>如果不指定参数类型（比如上例不写txt的类型），TypeScript 就会推断参数类型，如果缺乏足够信息，就会推断该参数的类型为any。<br>返回值的类型通常可以不写，因为 TypeScript 自己会推断出来。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果变量被赋值为一个函数，变量的类型有两种写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span> (<span class="params">txt:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>:</span><br><span class="line">  <span class="function">(<span class="params">txt:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">= <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量hello被赋值为一个函数，它的类型有两种写法。写法一是通过等号右边的函数类型，推断出变量hello的类型；写法二则是使用箭头函数的形式，为变量hello指定类型，参数的类型写在箭头左侧，返回值的类型写在箭头右侧。<br>写法二有两个地方需要注意。<br>首先，函数的参数要放在圆括号里面，不放会报错。<br>其次，类型里面的参数名（本例是txt）是必须的。</p>
<p>函数类型里面的参数名与实际参数名，可以不一致。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">f</span>:<span class="function">(<span class="params">x:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">function</span> (<span class="params">y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果函数的类型定义很冗长，或者多个函数使用同一种类型，写法二用起来就很麻烦。因此，往往用type命令为函数类型定义一个别名，便于指定给其他变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyFunc</span> = <span class="function">(<span class="params">txt:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>:<span class="title class_">MyFunc</span> = <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即TypeScript 允许省略参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>:</span><br><span class="line">  <span class="function">(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">myFunc = <span class="function">(<span class="params">a:<span class="built_in">number</span></span>) =&gt;</span> a; <span class="comment">// 正确</span></span><br><span class="line">myFunc = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a:<span class="built_in">number</span>, b:<span class="built_in">number</span>, c:<span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> a + b + c; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果一个变量要套用另一个函数类型，有一个小技巧，就是使用typeof运算符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>:<span class="keyword">typeof</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数类型还可以采用对象的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">add</span>:&#123;</span><br><span class="line">  (<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数类型的对象写法如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  (参数列表): 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这种写法的函数参数与返回值之间，间隔符是冒号:，而不是正常写法的箭头=&gt;，因为这里采用的是对象类型的写法，对象的属性名与属性值之间使用的是冒号。</p>
<p>这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">f.<span class="property">version</span> = <span class="string">&#x27;1.0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数f()本身还有一个属性foo。这时，f完全就是一个对象，类型就要使用对象的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: &#123;</span><br><span class="line">  (<span class="attr">x</span>:<span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span></span><br><span class="line">&#125; = f;</span><br></pre></td></tr></table></figure>

<p>函数类型也可以使用 Interface 来声明，这种写法就是对象写法的翻版。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> myfn &#123;</span><br><span class="line">  (<span class="attr">a</span>:<span class="built_in">number</span>, <span class="attr">b</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">add</span>:myfn = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>

<p>上面示例中，interface 命令定义了接口myfn，这个接口的类型就是一个用对象表示的函数。</p>
<h3 id="8-2-Function-类型"><a href="#8-2-Function-类型" class="headerlink" title="8.2 Function 类型"></a>8.2 Function 类型</h3><p>TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">f:<span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Function 类型的值都可以直接执行。<br>Function 类型的函数可以接受任意数量的参数，每个参数的类型都是any，返回值的类型也是any，代表没有任何约束，所以不建议使用这个类型，给出函数详细的类型声明会更好。</p>
<h3 id="8-3-箭头函数"><a href="#8-3-箭头函数" class="headerlink" title="8.3 箭头函数"></a>8.3 箭头函数</h3><p>箭头函数是普通函数的一种简化写法，它的类型写法与普通函数类似。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> repeat = (</span><br><span class="line">  <span class="attr">str</span>:<span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">times</span>:<span class="built_in">number</span></span><br><span class="line">):<span class="function"><span class="params">string</span> =&gt;</span> str.<span class="title function_">repeat</span>(times);</span><br></pre></td></tr></table></figure>

<p>注意，类型写在箭头函数的定义里面，与使用箭头函数表示函数类型，写法有所不同。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span></span><br><span class="line"><span class="params">  fn:(a:<span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数greet()的参数fn是一个函数，类型就用箭头函数表示。这时，fn的返回值类型要写在箭头右侧，而不是写在参数列表的圆括号后面。<br>下面再看一个例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> people = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;jan&#x27;</span>].<span class="title function_">map</span>(</span><br><span class="line">  (name):<span class="function"><span class="params">Person</span> =&gt;</span> (&#123;name&#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面示例中，Person是一个类型别名，代表一个对象，该对象有属性name。变量people是数组的map()方法的返回值。<br>map()方法的参数是一个箭头函数(name):Person =&gt; ({name})，该箭头函数的参数name的类型省略了，因为可以从map()的类型定义推断出来，箭头函数的返回值类型为Person。相应地，变量people的类型是Person[]。<br>至于箭头后面的({name})，表示返回一个对象，该对象有一个属性name，它的属性值为变量name的值。这里的圆括号是必须的，否则(name):Person =&gt; {name}的大括号表示函数体，即函数体内有一行语句name，同时由于没有return语句，这个函数不会返回任何值。</p>
<h3 id="8-4-可选参数"><a href="#8-4-可选参数" class="headerlink" title="8.4 可选参数"></a>8.4 可选参数</h3><p>如果函数的某个参数可以省略，则在参数名后面加问号表示。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>参数名带有问号，表示该参数的类型实际上是原始类型|undefined，它有可能为undefined。比如，上例的x虽然类型声明为number，但是实际上是number|undefined。</p>
<p>但是，反过来就不成立，类型显式设为undefined的参数，就不能省略。</p>
<p>函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。</p>
<p>如果前部参数有可能为空，这时只能显式注明该参数类型可能为undefined。</p>
<p>函数体内部用到可选参数时，需要判断该参数是否为undefined。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFunc</span>:</span><br><span class="line">  <span class="function">(<span class="params">a:<span class="built_in">number</span>, b?:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>; </span><br><span class="line">myFunc = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-参数默认值"><a href="#8-5-参数默认值" class="headerlink" title="8.5 参数默认值"></a>8.5 参数默认值</h3><p>TypeScript 函数的参数默认值写法，与 JavaScript 一致。<br>设置了默认值的参数，就是可选的。如果不传入该参数，它就会等于默认值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span> = <span class="number">0</span></span></span><br><span class="line"><span class="params"></span>):[<span class="built_in">number</span>, <span class="built_in">number</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createPoint</span>() <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<p>可选参数与默认值不能同时使用。</p>
<p>设有默认值的参数，如果传入undefined，也会触发默认值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">456</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f2</span>(<span class="literal">undefined</span>) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p>具有默认值的参数如果不位于参数列表的末尾，调用时不能省略，如果要触发默认值，必须显式传入undefined。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">add</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h3 id="8-6-参数解构"><a href="#8-6-参数解构" class="headerlink" title="8.6 参数解构"></a>8.6 参数解构</h3><p>函数参数如果存在变量解构，类型写法如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  [x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span></span><br><span class="line"><span class="params">  &#123; a, b, c &#125;: &#123;</span></span><br><span class="line"><span class="params">     a: <span class="built_in">number</span>;</span></span><br><span class="line"><span class="params">     b: <span class="built_in">number</span>;</span></span><br><span class="line"><span class="params">     c: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数结构可以结合类型别名（type 命令）一起使用，代码会看起来简洁一些。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">ABC</span> = &#123; <span class="attr">a</span>:<span class="built_in">number</span>; <span class="attr">b</span>:<span class="built_in">number</span>; <span class="attr">c</span>:<span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;:ABC</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-7-rest-参数"><a href="#8-7-rest-参数" class="headerlink" title="8.7 rest 参数"></a>8.7 rest 参数</h3><p>rest 参数表示函数剩余的所有参数，它可以是数组（剩余参数类型相同），也可能是元组（剩余参数类型不同）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rest 参数为数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">joinNumbers</span>(<span class="params">...nums:<span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rest 参数为元组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args:[<span class="built_in">boolean</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，元组需要声明每一个剩余参数的类型。如果元组里面的参数是可选的，则要使用可选参数。</p>
<p>rest 参数甚至可以嵌套。</p>
<p>rest 参数可以与变量解构结合使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params"></span></span><br><span class="line"><span class="params">  ...[str, times]: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span></span><br><span class="line"><span class="params"></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">repeat</span>(times);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params"></span></span><br><span class="line"><span class="params">  str: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  times: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">repeat</span>(times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-8-readonly-只读参数"><a href="#8-8-readonly-只读参数" class="headerlink" title="8.8 readonly 只读参数"></a>8.8 readonly 只读参数</h3><p>如果函数内部不能修改某个参数，可以在函数定义时，在参数类型前面加上readonly关键字，表示这是只读参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraySum</span>(<span class="params"></span></span><br><span class="line"><span class="params">  arr:<span class="keyword">readonly</span> <span class="built_in">number</span>[]</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-9-void-类型"><a href="#8-9-void-类型" class="headerlink" title="8.9 void 类型"></a>8.9 void 类型</h3><p>void 类型表示函数没有返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果返回其他值，就会报错。</p>
<p>void 类型允许返回undefined或null。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果打开了strictNullChecks编译选项，那么 void 类型只允许返回undefined。如果返回null，就会报错。这是因为 JavaScript 规定，如果函数没有返回值，就等同于返回undefined。</p>
<p>需要特别注意的是，如果变量、对象方法、函数参数的类型是 void 类型的函数，那么并不代表不能赋值为有返回值的函数。恰恰相反，该变量、对象方法和函数参数可以接受返回任意值的函数，这时并不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">f</span>:voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，这种情况仅限于变量、对象方法和函数参数，函数字面量如果声明了返回值是void 类型，还是不能有返回值。</p>
<p>除了函数，其他变量声明为void类型没有多大意义，因为这时只能赋值为undefined或者null（假定没有打开strictNullChecks) 。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 没有打开 strictNullChecks 的情况下</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:<span class="built_in">void</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-10-never-类型"><a href="#8-10-never-类型" class="headerlink" title="8.10 never 类型"></a>8.10 never 类型</h3><p>never类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。<br>它主要有以下两种情况。<br>（1）抛出错误的函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params">msg:<span class="built_in">string</span></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，只有抛出错误，才是 never 类型。如果显式用return语句返回一个 Error 对象，返回值就不是 never 类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>):<span class="title class_">Error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）无限执行的函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sing = <span class="keyword">function</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，never类型不同于void类型。前者表示函数没有执行结束，不可能有返回值；后者表示函数正常执行结束，但是不返回值，或者说返回undefined。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sing</span>(<span class="params"></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sing</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sing&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数sing()虽然没有return语句，但实际上是省略了return undefined这行语句，真实的返回值是undefined。所以，它的返回值类型要写成void，而不是never，写成never会报错。<br>如果一个函数抛出了异常或者陷入了死循环，那么该函数无法正常返回一个值，因此该函数的返回值类型就是never。如果程序中调用了一个返回值类型为never的函数，那么就意味着程序会在该函数的调用位置终止，永远不会继续执行后续的代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">neverReturns</span>(<span class="params"></span>):<span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x:<span class="built_in">string</span>|<span class="literal">undefined</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">neverReturns</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  x; <span class="comment">// 推断为 string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-11-局部类型"><a href="#8-11-局部类型" class="headerlink" title="8.11 局部类型"></a>8.11 局部类型</h3><p>函数内部允许声明其他类型，该类型只在函数内部有效，称为局部类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">txt:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">type</span> message = <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">newTxt</span>:message = <span class="string">&#x27;hello &#x27;</span> + txt;</span><br><span class="line">  <span class="keyword">return</span> newTxt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">newTxt</span>:message = <span class="title function_">hello</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="8-12-高阶函数"><a href="#8-12-高阶函数" class="headerlink" title="8.12 高阶函数"></a>8.12 高阶函数</h3><p>一个函数的返回值还是一个函数，那么前一个函数就称为高阶函数（higher-order function）。<br>下面就是一个例子，箭头函数返回的还是一个箭头函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="attr">someValue</span>: <span class="built_in">number</span>) =&gt; <span class="function">(<span class="params">multiplier: <span class="built_in">number</span></span>) =&gt;</span> someValue * </span><br><span class="line">multiplier;</span><br></pre></td></tr></table></figure>

<h3 id="8-13-函数重载"><a href="#8-13-函数重载" class="headerlink" title="8.13 函数重载"></a>8.13 函数重载</h3><p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载（function overload）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">reverse</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#x27;cba&#x27;</span></span><br><span class="line"><span class="title function_">reverse</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p>这意味着，该函数内部有处理字符串和数组的两套逻辑，根据参数类型的不同，分别执行对应的逻辑。这就叫“函数重载”。<br>TypeScript 对于“函数重载”的类型声明方法是，逐一定义每一种情况的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">str:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">any</span>[];</span><br></pre></td></tr></table></figure>

<p>上面示例中，分别对函数reverse()的两种参数情况，给予了类型声明。但是，到这里还没有结束，后面还必须对函数reverse()给予完整的类型声明。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">str:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">any</span>[];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params"></span></span><br><span class="line"><span class="params">  stringOrArray:<span class="built_in">string</span>|<span class="built_in">any</span>[]</span></span><br><span class="line"><span class="params"></span>):<span class="built_in">string</span>|<span class="built_in">any</span>[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> stringOrArray === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> stringOrArray.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> stringOrArray.<span class="title function_">slice</span>().<span class="title function_">reverse</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，重载的个别类型描述与函数的具体实现之间，不能有其他代码，否则报错。</p>
<p>另外，虽然函数的具体实现里面，有完整的类型声明。但是，函数实际调用的类型，以前面的类型声明为准。</p>
<p>函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">boolean</span></span>):<span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span></span>):<span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">number</span>|<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载声明的排序很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。</p>
<p>对象的方法也可以使用重载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringBuilder</span> &#123;</span><br><span class="line">  #data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">bool</span>:<span class="built_in">boolean</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">str</span>:<span class="built_in">string</span>): <span class="variable language_">this</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">value</span>:<span class="built_in">any</span>): <span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#data += <span class="title class_">String</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数重载也可以用来精确描述函数参数与返回值之间的对应关系。</p>
<p>由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用联合类型替代函数重载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">s:<span class="built_in">string</span></span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x:<span class="built_in">any</span></span>):<span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x:<span class="built_in">any</span>[]|<span class="built_in">string</span></span>):<span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-14-构造函数"><a href="#8-14-构造函数" class="headerlink" title="8.14 构造函数"></a>8.14 构造函数</h3><p>JavaScript 语言使用构造函数，生成对象的实例。<br>构造函数的最大特点，就是必须使用new命令调用。</p>
<p>构造函数的类型写法，就是在参数列表前面加上new命令。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">numLegs</span>:<span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalConstructor</span> = <span class="keyword">new</span> () =&gt; <span class="title class_">Animal</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">c:AnimalConstructor</span>):<span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">create</span>(<span class="title class_">Animal</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数还有另一种类型写法，就是采用对象形式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>:<span class="built_in">string</span>): <span class="built_in">object</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>某些函数既是构造函数，又可以当作普通函数使用，比如Date()。这时，类型声明可以写成下面这样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>:<span class="built_in">string</span>): <span class="built_in">object</span>;</span><br><span class="line">  (n?:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、TypeScript-的对象类型"><a href="#九、TypeScript-的对象类型" class="headerlink" title="九、TypeScript 的对象类型"></a>九、TypeScript 的对象类型</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><p>对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>属性的类型可以用分号结尾，也可以用逗号结尾。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性类型以分号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 属性类型以逗号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后一个属性后面，可以写分号或逗号，也可以不写。<br>一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">o1</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">o2</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">1</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>读写不存在的属性也会报错。</p>
<p>同样地，也不能删除类型声明中存在的属性，修改属性值是可以的。</p>
<p>对象的方法使用函数类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 或者写成</span></span><br><span class="line">  <span class="comment">// add: (x:number, y:number) =&gt; number;</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象类型可以使用方括号读取属性的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="title class_">User</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>除了type命令可以为对象类型声明一个别名，TypeScript 还提供了interface命令，可以把对象类型提炼为一个接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>注意，TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="title function_">toString</span>(): <span class="built_in">string</span>; <span class="comment">// 继承的属性</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="built_in">number</span>; <span class="comment">// 自身的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyInterface</span> = &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="attr">prop</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-可选属性"><a href="#9-2-可选属性" class="headerlink" title="9.2 可选属性"></a>9.2 可选属性</h3><p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>可选属性等同于允许赋值为undefined，下面两种写法是等效的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>|<span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同理，读取一个可选属性时，有可能返回undefined。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span>,</span><br><span class="line">  y?: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123; <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line">obj.<span class="property">y</span>.<span class="title function_">toLowerCase</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>所以，读取可选属性之前，必须检查一下是否为undefined。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">user</span>:&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  lastName?: <span class="built_in">string</span>;</span><br><span class="line">&#125; = &#123; <span class="attr">firstName</span>: <span class="string">&#x27;Foo&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (user.<span class="property">lastName</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议使用下面的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> firstName = (user.<span class="property">firstName</span> === <span class="literal">undefined</span>)</span><br><span class="line">  ? <span class="string">&#x27;Foo&#x27;</span> : user.<span class="property">firstName</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = (user.<span class="property">lastName</span> === <span class="literal">undefined</span>)</span><br><span class="line">  ? <span class="string">&#x27;Bar&#x27;</span> : user.<span class="property">lastName</span>;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> firstName = user.<span class="property">firstName</span> ?? <span class="string">&#x27;Foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = user.<span class="property">lastName</span> ?? <span class="string">&#x27;Bar&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-只读属性"><a href="#9-3-只读属性" class="headerlink" title="9.3 只读属性"></a>9.3 只读属性</h3><p>属性名前面加上readonly关键字，表示这个属性是只读属性，不能修改。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">prop</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只读属性只能在对象初始化期间赋值，此后就不能修改该属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">p.<span class="property">x</span> = <span class="number">100</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>注意，如果属性值是一个对象，readonly修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">resident</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">h</span>:<span class="title class_">Home</span> = &#123;</span><br><span class="line">  <span class="attr">resident</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vicky&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">h.<span class="property">resident</span>.<span class="property">age</span> = <span class="number">32</span>; <span class="comment">// 正确</span></span><br><span class="line">h.<span class="property">resident</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Kate&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span> </span><br><span class="line">&#125; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>另一个需要注意的地方是，如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyPerson</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">w</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Vicky&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">r</span>:<span class="title class_">ReadonlyPerson</span> = w;</span><br><span class="line">w.<span class="property">age</span> += <span class="number">1</span>;</span><br><span class="line">r.<span class="property">age</span> <span class="comment">// 43</span></span><br></pre></td></tr></table></figure>

<p>如果希望属性值是只读的，除了声明时加上readonly关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言as const。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sabrina&quot;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">myUser.<span class="property">name</span> = <span class="string">&quot;Cynthia&quot;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>注意，上面的as const属于 TypeScript 的类型推断，如果变量明确地声明了类型，那么 TypeScript 会以声明的类型为准。</p>
<h3 id="9-4-属性名的索引类型"><a href="#9-4-属性名的索引类型" class="headerlink" title="9.4 属性名的索引类型"></a>9.4 属性名的索引类型</h3><p>如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。<br>索引类型里面，最常见的就是属性名的字符串索引。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>JavaScript 对象的属性名（即上例的property）的类型有三种可能，除了上例的string，还有number和symbol。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = &#123;</span><br><span class="line">  [<span class="attr">property</span>: <span class="built_in">symbol</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  [<span class="attr">n</span>:<span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索性。但是，数值索性不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。</p>
<p>同样地，可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名符合属性名索引的范围，两者不能有冲突，否则报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">boolean</span>; <span class="comment">// 报错</span></span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。另外，属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及length属性，因为类型里面没有定义这些东西。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyArr</span> = &#123;</span><br><span class="line">  [<span class="attr">n</span>:<span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>:<span class="title class_">MyArr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="9-5-解构赋值"><a href="#9-5-解构赋值" class="headerlink" title="9.5 解构赋值"></a>9.5 解构赋值</h3><p>解构赋值用于直接从对象中提取属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, price&#125; = product;</span><br></pre></td></tr></table></figure>

<p>解构赋值的类型写法，跟为对象声明类型是一样的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;id, name, price&#125;:&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">price</span>: <span class="built_in">number</span></span><br><span class="line">&#125; = product;</span><br></pre></td></tr></table></figure>

<p>注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: foo, <span class="attr">y</span>: bar &#125; = obj;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> foo = obj.<span class="property">x</span>;</span><br><span class="line"><span class="keyword">let</span> bar = obj.<span class="property">y</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，冒号不是表示属性x和y的类型，而是为这两个属性指定新的变量名。如果要为x和y指定类型，不得不写成下面这样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: foo, <span class="attr">y</span>: bar &#125;</span><br><span class="line">  : &#123; <span class="attr">x</span>: <span class="built_in">string</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125; = obj;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  shape: Shape,</span></span><br><span class="line"><span class="params">  xPos: <span class="built_in">number</span> = <span class="number">100</span>,</span></span><br><span class="line"><span class="params">  yPos: <span class="built_in">number</span> = <span class="number">100</span></span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myShape = shape; <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">let</span> x = xPos; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数draw()的参数是一个对象解构，里面的冒号很像是为变量指定类型，其实是为对应的属性指定新的变量名。所以，TypeScript 就会解读成，函数体内不存在变量shape，而是属性shape的值被赋值给了变量Shape。</p>
<h3 id="9-6-结构类型原则"><a href="#9-6-结构类型原则" class="headerlink" title="9.6 结构类型原则"></a>9.6 结构类型原则</h3><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structual typing）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> B = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。<br>TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。<br>如果类型 B 可以赋值给类型 A，TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。</p>
<h3 id="9-7-严格字面量检查"><a href="#9-7-严格字面量检查" class="headerlink" title="9.7 严格字面量检查"></a>9.7 严格字面量检查</h3><p>如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">1</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPoint = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:&#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125; = myPoint; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。</p>
<p>规避严格字面量检查，可以使用中间变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myOptions = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Obj</span>:<span class="title class_">Options</span> = myOptions;</span><br></pre></td></tr></table></figure>

<p>如果你确认字面量没有错误，也可以使用类型断言规避严格字面量检查。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Obj</span>:<span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;我的网页&#x27;</span>,</span><br><span class="line">  <span class="attr">darkmode</span>: <span class="literal">true</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">Options</span>;</span><br></pre></td></tr></table></figure>

<p>如果允许字面量有多余属性，可以像下面这样在类型里面定义一个通用属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;;</span><br><span class="line">x = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">baz</span>: <span class="number">2</span> &#125;;  <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<p>由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeDistance</span>(<span class="params">point: Point</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="title function_">computeDistance</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;); <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">computeDistance</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>编译器选项suppressExcessPropertyErrors，可以关闭多余属性检查。下面是它在 tsconfig.json 文件里面的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;suppressExcessPropertyErrors&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8-最小可选属性规则"><a href="#9-8-最小可选属性规则" class="headerlink" title="9.8 最小可选属性规则"></a>9.8 最小可选属性规则</h3><p>如果一个对象的所有属性都是可选的，会触发最小可选属性规则。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Options</span> = &#123;</span><br><span class="line">  a?:<span class="built_in">number</span>;</span><br><span class="line">  b?:<span class="built_in">number</span>;</span><br><span class="line">  c?:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = &#123;</span><br><span class="line">  <span class="attr">d</span>: <span class="number">123</span> <span class="comment">// 报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了避免这种情况，TypeScript 添加了最小可选属性规则，规定这时属于Options类型的对象，必须至少存在一个可选属性，不能所有可选属性都不存在。这就是为什么上例的myObj对象会报错的原因。<br>这条规则无法通过中间变量规避。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myOptions = &#123; <span class="attr">d</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:<span class="title class_">Options</span> = myOptions; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="9-9-空对象"><a href="#9-9-空对象" class="headerlink" title="9.9 空对象"></a>9.9 空对象</h3><p>空对象是 TypeScript 的一种特殊值，也是一种特殊类型。</p>
<p>空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象Object.prototype的属性。</p>
<p>TypeScript 不允许动态添加属性，所以对象不能分步生成，必须生成时一次性声明所有属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;&#125;;</span><br><span class="line">pt.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">pt.<span class="property">y</span> = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果确实需要分步声明，一个比较好的方法是，使用扩展运算符（…）合成一个新对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pt0 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> pt1 = &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> pt2 = &#123; <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> pt = &#123;</span><br><span class="line">  ...pt0, ...pt1, ...pt2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>空对象作为类型，其实是Object类型的简写形式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">d</span>:&#123;&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// let d:Object;</span></span><br><span class="line">d = &#123;&#125;;</span><br><span class="line">d = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">d = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">d = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>因为Object可以接受各种类型的值，而空对象是Object类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Empty</span> &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">Empty</span> = &#123;<span class="attr">myProp</span>: <span class="number">1</span>, <span class="attr">anotherProp</span>: <span class="number">2</span>&#125;; <span class="comment">// 正确</span></span><br><span class="line">b.<span class="property">myProp</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果想强制使用没有任何属性的对象，可以采用下面的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">WithoutProperties</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">never</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:<span class="title class_">WithoutProperties</span> = &#123; <span class="attr">prop</span>: <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="十、-TypeScript-的-interface-接口"><a href="#十、-TypeScript-的-interface-接口" class="headerlink" title="十、 TypeScript 的 interface 接口"></a>十、 TypeScript 的 interface 接口</h2><h3 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h3><p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现该接口很简单，只要指定它作为对象的类型即可。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Smith&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方括号运算符可以取出 interface 某个属性的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Foo</span>[<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>interface 可以表示对象的各种语法，它的成员有5种形式。</p>
<ul>
<li><p>对象属性</p>
</li>
<li><p>对象的属性索引</p>
</li>
<li><p>对象方法</p>
</li>
<li><p>函数</p>
</li>
<li><p>构造函数</p>
</li>
</ul>
<p>（1）对象属性</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性之间使用分号或逗号分隔，最后一个属性结尾的分号或逗号可以省略。<br>如果属性是可选的，就在属性名后面加一个问号。</p>
<p>如果属性是只读的，需要加上readonly修饰符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）对象的属性索引</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性索引共有string、number和symbol三种类型。<br>一个接口中，最多只能定义一个字符串索引。字符串索引会约束该类型中所有名字为字符串的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">boolean</span>;      <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性的数值索引，其实是指定数组的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>:A = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>同样的，一个接口中最多只能定义一个数值索引。数值索引会约束所有名称为数值的属性。<br>如果一个 interface 同时定义了字符串索引和数值索引，那么数值索性必须服从于字符串索引。因为在 JavaScript 中，数值属性名最终是自动转换成字符串属性名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数值索引必须兼容字符串索引的类型声明。</p>
<p>（3）对象的方法</p>
<p>对象的方法共有三种写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">f</span>: <span class="function">(<span class="params">x: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">interface</span> C &#123;</span><br><span class="line">  <span class="attr">f</span>: &#123; (<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性名可以采用表达式，所以下面的写法也是可以的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [f](<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型方法可以重载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(): <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params"></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params">x: <span class="built_in">boolean</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunc</span>(<span class="params"></span></span><br><span class="line"><span class="params">  x?:<span class="built_in">boolean</span>|<span class="built_in">string</span>, y?:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">number</span>|<span class="built_in">boolean</span>|<span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="literal">undefined</span> &amp;&amp; y === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;boolean&#x27;</span> &amp;&amp; y === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> </span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong parameters&#x27;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = &#123;</span><br><span class="line">  <span class="attr">f</span>: <span class="title class_">MyFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）函数<br>interface 也可以用来声明独立的函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">myAdd</span>:<span class="title class_">Add</span> = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>

<p>（5）构造函数<br>interface 内部可以使用new关键字，表示构造函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ErrorConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (message?: <span class="built_in">string</span>): <span class="title class_">Error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-interface-的继承"><a href="#10-2-interface-的继承" class="headerlink" title="10.2 interface 的继承"></a>10.2 interface 的继承</h3><h4 id="10-2-1-interface-继承-interface"><a href="#10-2-1-interface-继承-interface" class="headerlink" title="10.2.1 interface 继承 interface"></a>10.2.1 interface 继承 interface</h4><p>interface 可以使用extends关键字，继承其他 interface。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>extends关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性。<br>interface 允许多重继承。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Style</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Style</span>, <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多重接口继承，实际上相当于多个父接口的合并。<br>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_">Foo</span>, <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2-2-interface-继承-type"><a href="#10-2-2-interface-继承-type" class="headerlink" title="10.2.2 interface 继承 type"></a>10.2.2 interface 继承 type</h4><p>interface 可以继承type命令定义的对象类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CountryWithPop</span> <span class="keyword">extends</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  <span class="attr">population</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果type命令定义的类型不是对象，interface 就无法继承。</p>
<h4 id="10-2-3-interface-继承-class"><a href="#10-2-3-interface-继承-class" class="headerlink" title="10.2.3 interface 继承 class"></a>10.2.3 interface 继承 class</h4><p>inteface 还可以继承 class，即继承该类的所有成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title function_">y</span>():<span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些类拥有私有成员和保护成员，interface 可以继承这样的类，但是意义不大。</p>
<h3 id="10-3-接口合并"><a href="#10-3-接口合并" class="headerlink" title="10.3 接口合并"></a>10.3 接口合并</h3><p>多个同名接口会合并成一个接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>这样的设计主要是为了兼容 JavaScript 的行为。JavaScript 开发者常常对全局对象或者外部库，添加自己的属性和方法。那么，只要使用 interface 给出这些自定义属性和方法的类型，就能自动跟原始的 interface 合并，使得扩展外部类型非常方便。</p>
<p>同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cloner</span> &#123;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Dog</span>): <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Cat</span>): <span class="title class_">Cat</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Sheep</span>): <span class="title class_">Sheep</span>;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">animal</span>: <span class="title class_">Animal</span>): <span class="title class_">Animal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个规则有一个例外。同名方法之中，如果有一个参数是字面量类型，字面量类型有更高的优先级。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="string">&#x27;foo&#x27;</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="string">&#x27;foo&#x27;</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="attr">x</span>:<span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个实际的例子是 Document 对象的createElement()方法，它会根据参数的不同，而生成不同的 HTML 节点对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;canvas&quot;</span>): <span class="title class_">HTMLCanvasElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;div&quot;</span>): <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="string">&quot;span&quot;</span>): <span class="title class_">HTMLSpanElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">string</span>): <span class="title class_">HTMLElement</span>;</span><br><span class="line">  <span class="title function_">createElement</span>(<span class="attr">tagName</span>: <span class="built_in">any</span>): <span class="title class_">Element</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个 interface 组成的联合类型存在同名属性，那么该属性的类型也是联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">bigint</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="attr">area</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Circle</span> | <span class="title class_">Rectangle</span>;</span><br><span class="line">s.<span class="property">area</span>;   <span class="comment">// bigint | number</span></span><br></pre></td></tr></table></figure>

<h3 id="10-4-interface-与-type-的异同"><a href="#10-4-interface-与-type-的异同" class="headerlink" title="10.4 interface 与 type 的异同"></a>10.4 interface 与 type 的异同</h3><p>interface命令与type命令作用类似，都可以表示对象类型。<br>很多对象类型即可以用 interface 表示，也可以用 type 表示。而且，两者往往可以换用，几乎所有的 interface 命令都可以改写为 type 命令。<br>它们的相似之处，首先表现在都能为对象类型起名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coutry</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用type或interface。</p>
<p>interface 与 type 的区别有下面几点。<br>（1）type能够表示非对象类型，而interface只能表示对象类型（包括数组、函数等）。<br>（2）interface可以继承其他类型，type不支持继承。<br>继承的主要作用是添加属性，type定义的对象类型如果想要添加属性，只能使用&amp;运算符，重新定义一个类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bear</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为比较，interface添加属性，采用的是继承的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bear</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承时，type 和 interface 是可以换用的。interface 可以继承 type。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type 也可以继承 interface。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Foo</span> &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>（3）同名interface会自动合并，同名type则会报错。也就是说，TypeScript 不允许使用type多次定义同一个类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">foo</span>:<span class="built_in">number</span> &#125;; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">bar</span>:<span class="built_in">number</span> &#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>作为比较，interface则会自动合并。</p>
<p>这表明，inteface 是开放的，可以添加属性，type 是封闭的，不能添加属性，只能定义新的 type。</p>
<p>（4）interface不能包含属性映射（mapping），type可以。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointCopy1</span> = &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Point</span>]: <span class="title class_">Point</span>[<span class="title class_">Key</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PointCopy2</span> &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> keyof <span class="title class_">Point</span>]: <span class="title class_">Point</span>[<span class="title class_">Key</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（5）this关键字只能用于interface。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">num</span>:<span class="built_in">number</span>): <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（6）type 可以扩展原始数据类型，interface 不行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyStr</span> = <span class="built_in">string</span> &amp; &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;new&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyStr</span> <span class="keyword">extends</span> <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;new&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（7）interface无法表达某些复杂类型（比如交叉类型和联合类型），但是type可以。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AorB</span> = A | B;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AorBwithName</span> = <span class="title class_">AorB</span> &amp; &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="十一、TypeScript-的-class-类型"><a href="#十一、TypeScript-的-class-类型" class="headerlink" title="十一、TypeScript 的 class 类型"></a>十一、TypeScript 的 class 类型</h2><h3 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h3><p>类（class）是面向对象编程的基本构件，封装了属性和方法，TypeScript 给予了全面支持。</p>
<h4 id="11-1-1-属性的类型"><a href="#11-1-1-属性的类型" class="headerlink" title="11.1.1 属性的类型"></a>11.1.1 属性的类型</h4><p>类的属性可以在顶层声明，也可以在构造方法内部声明。<br>对于顶层声明的属性，可以在声明时同时给出类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不给出类型，TypeScript 会认为x和y的类型都是any。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x;</span><br><span class="line">  y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 有一个配置项strictPropertyInitialization，只要打开，就会检查属性是否设置了初值，如果没有就报错。<br>如果你打开了这个设置，但是某些情况下，不是在声明时赋值或在构造方法里面赋值，为了防止这个设置报错，可以使用非空断言。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!:<span class="built_in">number</span>;</span><br><span class="line">  y!:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性x和y没有初值，但是属性名后面添加了感叹号，表示这两个属性肯定不会为空，所以 TypeScript 就不报错了。</p>
<h4 id="11-1-2-readonly-修饰符"><a href="#11-1-2-readonly-修饰符" class="headerlink" title="11.1.2 readonly 修饰符"></a>11.1.2 readonly 修饰符</h4><p>属性名前面加上 readonly 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> id = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>:<span class="built_in">string</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法修改只读属性的值也是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。</p>
<h4 id="11-1-3-方法的类型"><a href="#11-1-3-方法的类型" class="headerlink" title="11.1.3 方法的类型"></a>11.1.3 方法的类型</h4><p>类的方法就是普通函数，类型声明方式与函数一致。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">point:Point</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> + point.<span class="property">x</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> + point.<span class="property">y</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法constructor()和普通方法add()都注明了参数类型，但是省略了返回值类型，因为 TypeScript 可以自己推断出来。<br>类的方法跟普通函数一样，可以使用参数默认值，以及函数重载。<br>下面是参数默认值的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果新建实例时，不提供属性x和y的值，它们都等于默认值0。</span></span><br></pre></td></tr></table></figure>

<p>下面是函数重载的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">s:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">xs:<span class="built_in">number</span>|<span class="built_in">string</span>, y?:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//，构造方法可以接受一个参数，也可以接受两个参数，采用函数重载进行类型声明。</span></span><br></pre></td></tr></table></figure>

<p>另外，构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>):<span class="built_in">object</span> &#123; <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-1-4-存取器方法"><a href="#11-1-4-存取器方法" class="headerlink" title="11.1.4 存取器方法"></a>11.1.4 存取器方法</h4><p>存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。</p>
<p>它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get name()是取值器，其中get是关键词，name是属性名。外部读取name属性时，实例对象会自动调用这个方法，该方法的返回值就是name属性的值。<br>set name()是存值器，其中set是关键词，name是属性名。外部写入name属性时，实例对象会自动调用这个方法，并将所赋的值作为函数参数传入。<br>TypeScript 对存取器有以下规则。<br>（1）如果某个属性只有get方法，没有set方法，那么该属性自动成为只读属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">name</span> = <span class="string">&#x27;bar&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>（2）set方法的参数类型，必须兼容get方法的返回值类型，否则报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value; <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  _name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>():<span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value:<span class="built_in">number</span>|<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="title class_">String</span>(value); <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，set方法的参数类型（number|return）兼容get方法的返回值类型（string），这是允许的。但是，最终赋值的时候，还是必须保证与get方法的返回值类型一致。<br>另外，如果set方法的参数没有指定类型，那么会推断为与get方法返回值类型一致。<br>（3）get方法与set方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。</p>
<h4 id="11-1-5-属性索引"><a href="#11-1-5-属性索引" class="headerlink" title="11.1.5 属性索引"></a>11.1.5 属性索引</h4><p>类允许定义属性索引。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span> |</span><br><span class="line">    (<span class="function">(<span class="params">s:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[s] <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，[s:string]表示所有属性名类型为字符串的属性，它们的属性值要么是布尔值，要么是返回布尔值的函数。<br>注意，由于类的方法是一种特殊属性（属性值为函数的属性），所以属性索引的类型定义也涵盖了方法。如果一个对象同时定义了属性索引和方法，那么前者必须包含后者的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性索引的类型里面不包括方法，导致后面的方法f()定义直接报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>:<span class="built_in">string</span>]: <span class="built_in">boolean</span> | (<span class="function">() =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性存取器等同于方法，也必须包括在属性索性里面。</p>
<h3 id="11-2-类的-interface-接口"><a href="#11-2-类的-interface-接口" class="headerlink" title="11.2 类的 interface 接口"></a>11.2 类的 interface 接口</h3><h4 id="11-2-1-implements-关键字"><a href="#11-2-1-implements-关键字" class="headerlink" title="11.2.1 implements 关键字"></a>11.2.1 implements 关键字</h4><p>interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Country</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">capital</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCountry</span> <span class="keyword">implements</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  capital = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，interface或type都可以定义一个对象类型。类MyCountry使用implements关键字，表示该类的实例对象满足这个外部类型。<br>interface 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class自身的类型声明。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">name</span>:<span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s</span>) &#123; <span class="comment">// s 的类型是 any</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类B实现了接口A，但是后者并不能代替B的类型声明。因此，B的get()方法的参数s的类型是any，而不是string。B类依然需要声明参数s的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">y</span> = <span class="number">10</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，接口A有一个可选属性y，类B没有声明这个属性，所以可以通过类型检查。但是，如果给B的实例对象的属性y赋值，就会报错。所以，B类还是需要声明可选属性y。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，类可以定义接口没有声明的方法和属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPoint</span> <span class="keyword">implements</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">1</span>;</span><br><span class="line">  <span class="attr">z</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>implements关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="attr">id</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">move</span>():<span class="built_in">void</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  id = <span class="number">2</span>; <span class="comment">// 不可省略</span></span><br><span class="line">  <span class="title function_">move</span>():<span class="built_in">void</span> &#123;&#125;;   <span class="comment">// 不可省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，implements后面是类Car，这时 TypeScript 就把Car视为一个接口，要求MyCar实现Car里面的每一个属性和方法，否则就会报错。所以，这时不能因为Car类已经实现过一次，而在MyCar类省略属性或方法。<br>注意，interface 描述的是类的对外接口，也就是实例的公开属性和公开方法，不能定义私有的属性和方法。这是因为 TypeScript 设计者认为，私有属性是类的内部实现，接口作为模板，不应该涉及类的内部代码写法。</p>
<h4 id="11-2-2-实现多个接口"><a href="#11-2-2-实现多个接口" class="headerlink" title="11.2.2 实现多个接口"></a>11.2.2 实现多个接口</h4><p>类可以实现多个接口（其实是接受多重限制），每个接口之间使用逗号分隔。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span>, <span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它必须部署这三个接口声明的所有属性和方法，满足它们的所有条件。</p>
<p>但是，同时实现多个接口并不是一个好的写法，容易使得代码难以管理，可以使用两种方法替代。<br>第一种方法是类的继承。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecretCar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">////接口继承</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SuperCar</span> <span class="keyword">extends</span> <span class="title class_">MotoVehicle</span>,<span class="title class_">Flyable</span>, <span class="title class_">Swimmable</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecretCar</span> <span class="keyword">implements</span> <span class="title class_">SuperCar</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是接口的继承。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  <span class="attr">b</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，发生多重实现时（即一个接口同时实现多个接口），不同接口不能有互相冲突的属性。</p>
<h4 id="11-2-3-类与接口的合并"><a href="#11-2-3-类与接口的合并" class="headerlink" title="11.2.3 类与接口的合并"></a>11.2.3 类与接口的合并</h4><p>TypeScript 不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">y</span> = <span class="number">10</span>;</span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 1</span></span><br><span class="line">a.<span class="property">y</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="11-3-Class-类型"><a href="#11-3-Class-类型" class="headerlink" title="11.3 Class 类型"></a>11.3 Class 类型</h3><h4 id="11-3-1-实例类型"><a href="#11-3-1-实例类型" class="headerlink" title="11.3.1 实例类型"></a>11.3.1 实例类型</h4><p>TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">green</span>:<span class="title class_">Color</span> = <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="string">&#x27;green&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，定义了一个类Color。它的类名就代表一种类型，实例对象green就属于该类型。<br>对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为Interface，因为两者都代表实例对象的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">MotorVehicle</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:<span class="title class_">Car</span> = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:<span class="title class_">MotorVehicle</span> = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量c的类型可以写成类Car，也可以写成接口MotorVehicle。它们的区别是，如果类Car有接口MotoVehicle没有的属性和方法，那么只有变量c1可以调用这些属性和方法。<br>作为类型使用时，类名只能表示实例的类型，不能表示类的自身类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass:Point,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数createPoint()的第一个参数PointClass，需要传入 Point 这个类，但是如果把参数的类型写成Point就会报错，因为Point描述的是实例类型，而不是 Class 的自身类型。<br>由于类名作为类型使用，实际上代表一个对象，因此可以把类看作为对象类型起名。事实上，TypeScript 有三种方法可以为对象类型起名：type、interface 和 class。</p>
<h4 id="11-3-2-类的自身类型"><a href="#11-3-2-类的自身类型" class="headerlink" title="11.3.2 类的自身类型"></a>11.3.2 类的自身类型</h4><p>要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass:<span class="keyword">typeof</span> Point,</span></span><br><span class="line"><span class="params">  x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，createPoint()的第一个参数PointClass是Point类自身，要声明这个参数的类型，简便的方法就是使用typeof Point。因为Point类是一个值，typeof Point返回这个值的类型。注意，createPoint()的返回值类型是Point，代表实例类型。<br>JavaScript 语言中，类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: <span class="keyword">new</span> (x:<span class="built_in">number</span>, y:<span class="built_in">number</span>) =&gt; Point,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数也可以写成对象形式，所以参数PointClass的类型还有另一种写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">new</span> (x:<span class="built_in">number</span>, y:<span class="built_in">number</span>): Point</span></span><br><span class="line"><span class="params">  &#125;,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的写法，可以把构造函数提取出来，单独定义一个接口（interface），这样可以大大提高代码的通用性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointConstructor</span> &#123;</span><br><span class="line">  <span class="title function_">new</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="title class_">Point</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPoint</span>(<span class="params"></span></span><br><span class="line"><span class="params">  PointClass: PointConstructor,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  y: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>):<span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PointClass</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，类的自身类型就是一个构造函数，可以单独定义一个接口来表示。</p>
<h4 id="11-3-3-结构类型原则"><a href="#11-3-3-结构类型原则" class="headerlink" title="11.3.3 结构类型原则"></a>11.3.3 结构类型原则</h4><p>Class 也遵循“结构类型原则”。一个对象只要满足 Class 的实例结构，就跟该 Class属于同一个类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  id!:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arg:Foo</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>(bar); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>如果两个类的实例结构相同，那么这两个类就是兼容的，可以用在对方的使用场合。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，Person和Customer是两个结构相同的类，TypeScript 将它们视为相同类型，因此Person可以用在类型为Customer的场合。<br>现在修改一下代码，Person类添加一个属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，Person类添加了一个属性age，跟Customer类的结构不再相同。但是这种情况下，TypeScript 依然认为，Person属于Customer类型。<br>这是因为根据“结构类型原则”，只要Person类具有name属性，就满足Customer类型的实例结构，所以可以代替它。反过来就不行，如果Customer类多出一个属性，就会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cust</span>:<span class="title class_">Customer</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>总之，只要 A 类具有 B 类的结构，哪怕还有额外的属性和方法，TypeScript 也认为A 兼容 B 的类型。<br>不仅是类，如果某个对象跟某个 class 的实例结构相同，TypeScript 也认为两者的类型相同。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Person</span> = obj; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>由于这种情况，运算符instanceof不适用于判断某个对象是否跟某个 class 属于同一类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，运算符instanceof确认变量obj不是 Person 的实例，但是两者的类型是相同的。</p>
<p>空类不包含任何成员，任何其他类都可以看作与空类结构相同。因此，凡是类型为空类的地方，所有类（包括对象）都可以使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:Empty</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br></pre></td></tr></table></figure>

<p>注意，确定两个类的兼容关系时，只检查实例成员，不考虑静态成员和构造方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">t</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>:<span class="title class_">Point</span> = <span class="keyword">new</span> <span class="title class_">Position</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，Point与Position的静态属性和构造方法都不一样，但因为Point的实例成员与Position相同，所以Position兼容Point。<br>如果类中存在私有成员（private）或保护成员（protected），那么确定兼容关系时，TypeScript 要求私有成员和保护成员来自同一个类，这意味着两个类需要存在继承关系。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，A和B都有私有成员（或保护成员）name，这时只有在B继承A的情况下（class B extends A），B才兼容A。</p>
<h3 id="11-4-类的继承"><a href="#11-4-类的继承" class="headerlink" title="11.4 类的继承"></a>11.4 类的继承</h3><p>类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">greet</span>() <span class="comment">// &quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>根据结构类型原则，子类也可以用于类型为基类的场合。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = b;</span><br><span class="line">a.<span class="title function_">greet</span>()</span><br></pre></td></tr></table></figure>

<p>子类可以覆盖基类的同名方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">greet</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类B定义了一个方法greet()，覆盖了基类A的同名方法。其中，参数name省略时，就调用基类A的greet()方法，这里可以写成super.greet()，使用super关键字指代基类是常见做法。<br>但是，子类的同名方法不能与基类的类型定义相冲突。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果基类包括保护成员（protected修饰符），子类可以将该成员的可访问性设置为公开（public修饰符），也可以保持保护成员不变，但是不能改用私有成员（private修饰符）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">x</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">y</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">z</span>: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，extends关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from A&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello from B&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">greeting</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GreeterConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (): <span class="title class_">Greeter</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeterBase</span>(<span class="params"></span>):<span class="title class_">GreeterConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt;= <span class="number">0.5</span> ? A : B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">getGreeterBase</span>() &#123;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">greeting</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于那些只设置了类型、没有初值的顶层属性，有一个细节需要注意。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Animal</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">animal:Animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog:Dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类DogHouse的顶层成员resident只设置了类型（Dog），没有设置初值。这段代码在不同的编译设置下，编译结果不一样。<br>如果编译设置的target设成大于等于ES2022，或者useDefineForClassFields设成true，那么下面代码的执行结果是不一样的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  <span class="attr">animalStuff</span>: <span class="string">&#x27;animal&#x27;</span>,</span><br><span class="line">  <span class="attr">dogStuff</span>: <span class="string">&#x27;dog&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> dogHouse = <span class="keyword">new</span> <span class="title class_">DogHouse</span>(dog);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dogHouse.<span class="property">resident</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，DogHouse实例的属性resident输出的是undefined，而不是预料的dog。原因在于 ES2022 标准的 Class Fields 部分，与早期的 TypeScript 实现不一致，导致子类的那些只设置类型、没有设置初值的顶层成员在基类中被赋值后，会在子类被重置为undefined。</p>
<p>解决方法就是使用declare命令，去声明顶层成员的类型，告诉 TypeScript 这些成员的赋值由基类实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog:Dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，resident属性的类型声明前面用了declare命令，这样就能确保在编译目标大于等于ES2022时（或者打开useDefineForClassFields时），代码行为正确。</p>
<h3 id="11-5-可访问性修饰符"><a href="#11-5-可访问性修饰符" class="headerlink" title="11.5 可访问性修饰符"></a>11.5 可访问性修饰符</h3><p>类的内部成员的外部可访问性，由三个可访问性修饰符（access modifiers）控制：public、private和protected。<br>这三个修饰符的位置，都写在属性或方法的最前面。</p>
<h4 id="11-5-1-public"><a href="#11-5-1-public" class="headerlink" title="11.5.1 public"></a>11.5.1 public</h4><p>public修饰符表示这是公开成员，外部可以自由访问。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p>public修饰符是默认修饰符，如果省略不写，实际上就带有该修饰符。因此，类的属性和方法默认都是外部可访问的。<br>正常情况下，除非为了醒目和代码可读性，public都是省略不写的。</p>
<h4 id="11-5-2-private"><a href="#11-5-2-private" class="headerlink" title="11.5.2 private"></a>11.5.2 private</h4><p>private修饰符表示私有成员，只能用在当前类的内部，类的实例和子类都不能使用该成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">showX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，子类不能定义父类私有成员的同名成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在类的内部，当前类的实例可以获取私有成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params">obj:A</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="title function_">f</span>(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>严格地说，private定义的私有成员，并不是真正意义的私有成员。一方面，编译成 JavaScript 后，private关键字就被剥离了，这时外部访问该成员就不会报错。另一方面，由于前一个原因，TypeScript 对于访问private成员没有严格禁止，使用方括号写法（[]）或者in运算符，实例对象就能访问该成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> a) &#123; <span class="comment">// 正确</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于private存在这些问题，加上它是 ES6 标准发布前出台的，而 ES6 引入了自己的私有成员写法#propName。因此建议不使用private，改用 ES6 的写法，获得真正意义的私有成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  #x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，采用了 ES6 的私有成员写法（属性名前加#），TypeScript 就正确识别了实例对象没有属性x，从而报错。<br>构造方法也可以是私有的，这就直接防止了使用new命令生成实例对象，只能在类的内部创建实例对象。<br>这时一般会有一个静态方法，充当工厂函数，强制所有实例都通过该方法生成。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> instance?: <span class="title class_">Singleton</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Singleton</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br></pre></td></tr></table></figure>

<h4 id="11-5-3-protected"><a href="#11-5-3-protected" class="headerlink" title="11.5.3 protected"></a>11.5.3 protected</h4><p>protected修饰符表示该成员是保护成员，只能在类的内部使用该成员，实例无法使用该成员，但是子类内部可以使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">getX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line">b.<span class="title function_">getX</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>子类不仅可以拿到父类的保护成员，还可以定义同名成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，子类B定义了父类A的同名成员x，并且父类的x是保护成员，子类将其改成了公开成员。B类的x属性前面没有修饰符，等同于修饰符是public，外界可以读取这个属性。<br>在类的外部，实例对象不能读取保护成员，但是在类的内部可以。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params">obj:A</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="property">x</span> <span class="comment">// 报错</span></span><br><span class="line">a.<span class="title function_">f</span>(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="11-5-4-实例属性的简写形式"><a href="#11-5-4-实例属性的简写形式" class="headerlink" title="11.5.4 实例属性的简写形式"></a>11.5.4 实例属性的简写形式</h4><p>实际开发中，很多实例属性的值，是通过构造方法传入的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法等于对同一个属性要声明两次类型，一次在类的头部，另一次在构造方法的参数里面。这有些累赘，TypeScript 就提供了一种简写形式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">p.<span class="property">x</span> <span class="comment">// 10</span></span><br><span class="line">p.<span class="property">y</span> <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，构造方法的参数x前面有public修饰符，这时 TypeScript 就会自动声明一个公开属性x，不必在构造方法里面写任何代码，同时还会设置x的值为构造方法的参数值。注意，这里的public不能省略。<br>除了public修饰符，构造方法的参数名只要有private、protected、readonly修饰符，都会自动声明对应修饰符的实例属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> a: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> b: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> c: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">readonly</span> d: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a;</span><br><span class="line">    b;</span><br><span class="line">    c;</span><br><span class="line">    d;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a, b, c, d</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">b</span> = b;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">c</span> = c;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">d</span> = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readonly还可以与其他三个可访问性修饰符，一起使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> <span class="keyword">readonly</span> y:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> z:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-6-静态成员"><a href="#11-6-静态成员" class="headerlink" title="11.6 静态成员"></a>11.6 静态成员</h3><p>类的内部可以使用staic关键字，定义静态成员。<br>静态成员是只能通过类本身使用的成员，不能通过实例对象使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span> <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>static关键字前面可以使用 public、private、protected 修饰符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">x</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性x前面有private修饰符，表示只能在MyClass内部使用，如果在外部调用这个属性就会报错。</p>
<p>静态私有属性也可以用 ES6 语法的#前缀表示，上面示例可以改写如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>public和protected的静态成员可以被继承。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getY</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> B.<span class="property">y</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">B.<span class="property">x</span> <span class="comment">// 1</span></span><br><span class="line">B.<span class="title function_">getY</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="11-7-泛型类"><a href="#11-7-泛型类" class="headerlink" title="11.7 泛型类"></a>11.7 泛型类</h3><p>类也可以写成泛型，使用类型参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value:Type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>:<span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，类Box有类型参数Type，因此属于泛型类。新建实例时，变量的类型声明需要带有类型参数的值，不过本例等号左边的Box&lt;**string**&gt;可以省略不写，因为可以从等号右边推断得到。<br>注意，静态成员不能使用泛型的类型参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">defaultContents</span>: <span class="title class_">Type</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，静态属性defaultContents的类型写成类型参数Type会报错。因为这意味着调用时必须给出类型参数（即写成Box&lt;**string**&gt;.defaultContents），并且类型参数发生变化，这个属性也会跟着变，这并不是好的做法。</p>
<h3 id="11-8-抽象类，抽象成员"><a href="#11-8-抽象类，抽象成员" class="headerlink" title="11.8 抽象类，抽象成员"></a>11.8 抽象类，抽象成员</h3><p>TypeScript 允许在类的定义前面，加上关键字abstract，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abastract class）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>抽象类只能当作基类使用，用来在它的基础上定义子类。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  amount = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">id</span> <span class="comment">// 1</span></span><br><span class="line">b.<span class="property">amount</span> <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>抽象类的子类也可以是抽象类，也就是说，抽象类可以继承其他抽象类。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="attr">bar</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类的内部可以有已经实现好的属性和方法，也可以有还未实现的属性和方法。后者就叫做“抽象成员”（abstract member），即属性名和方法名有abstract关键字，表示该方法需要子类实现。如果子类没有实现抽象成员，就会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">bar</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  foo = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，抽象类A定义了抽象属性foo，子类B必须实现这个属性，否则会报错。</p>
<p>如果抽象类的属性前面加上abstract，就表明子类必须给出该方法的实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">execute</span>():<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`B executed`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个注意点。<br>（1）抽象成员只能存在于抽象类，不能存在于普通类。<br>（2）抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加abstract关键字。<br>（3）抽象成员前也不能有private修饰符，否则无法在子类中实现该成员。<br>（4）一个子类最多只能继承一个抽象类。<br>总之，抽象类的作用是，确保各种相关的子类都拥有跟基类相同的接口，可以看作是模板。其中的抽象成员都是必须由子类实现的成员，非抽象成员则表示基类已经实现的、由所有子类共享的成员。</p>
<h3 id="11-9-this-问题"><a href="#11-9-this-问题" class="headerlink" title="11.9 this 问题"></a>11.9 this 问题</h3><p>类的方法经常用到this关键字，它表示该方法当前所在的对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">a.<span class="title function_">getName</span>() <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: a.<span class="property">getName</span></span><br><span class="line">&#125;;</span><br><span class="line">b.<span class="title function_">getName</span>() <span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量a和b的getName()是同一个方法，但是执行结果不一样，原因就是它们内部的this指向不一样的对象。如果getName()在变量a上运行，this指向a；如果在b上运行，this指向b。<br>有些场合需要给出this类型，但是 JavaScript 函数通常不带有this参数，这时TypeScript 允许函数增加一个名为this的参数，放在参数列表的第一位，用来描述函数内部的this关键字的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: SomeType,</span></span><br><span class="line"><span class="params">  x: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数fn()的第一个参数是this，用来声明函数内部的this的类型。编译时，TypeScript 一旦发现函数的第一个参数名为this，则会去除这个参数，即编译结果不会带有该参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"><span class="variable language_">this</span>: A</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="property">getName</span>;</span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类A的getName()添加了this参数，如果直接调用这个方法，this的类型就会跟声明的类型不一致，从而报错。<br>this参数的类型可以声明为各种对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: &#123; name: <span class="built_in">string</span> &#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">0</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="number">123</span> &#125;); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 提供了一个noImplicitThis编译选项。如果打开了这个设置项，如果this的值推断为any类型，就会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noImplicitThis 打开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> width:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> height:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getAreaFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">width</span> * <span class="variable language_">this</span>.<span class="property">height</span>; <span class="comment">// 报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，getAreaFunction()方法返回一个函数，这个函数里面用到了this，但是这个this跟Rectangle这个类没关系，它的类型推断为any，所以就报错了。<br>在类的内部，this本身也可以当作类型使用，表示当前类的实例对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">  <span class="attr">contents</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title function_">set</span>(<span class="attr">value</span>:<span class="built_in">string</span>):<span class="variable language_">this</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，this类型不允许应用于静态成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">a</span>:<span class="variable language_">this</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些方法返回一个布尔值，表示当前的this是否属于某种类型。这时，这些方法的返回值类型可以写成this is Type的形式，其中用到了is运算符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemObject</span> &#123;</span><br><span class="line">  <span class="title function_">isFile</span>(): <span class="variable language_">this</span> is <span class="title class_">FileRep</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">FileRep</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isDirectory</span>(): <span class="variable language_">this</span> is <span class="title class_">Directory</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Directory</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两个方法的返回值类型都是布尔值，写成this is Type的形式，可以精确表示返回值。</p>
<h2 id="十二、TypeScript-泛型"><a href="#十二、TypeScript-泛型" class="headerlink" title="十二、TypeScript 泛型"></a>十二、TypeScript 泛型</h2><h3 id="12-1-简介"><a href="#12-1-简介" class="headerlink" title="12.1 简介"></a>12.1 简介</h3><p>有些时候，函数返回值的类型与参数类型是相关的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFirst</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arr:<span class="built_in">any</span>[]</span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，TypeScript 就引入了“泛型”（generics）。泛型的特点就是带有“类型参数”（type parameter）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirst&lt;T&gt;(<span class="attr">arr</span>:T[]):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数getFirst()的函数名后面尖括号的部分<T>，就是类型参数，参数要放在一对尖括号（&lt;&gt;）里面。本例只有一个类型参数T，可以将其理解为类型声明需要的变量，需要在调用时传入具体的参数类型。</T></p>
<p>函数调用时，需要提供类型参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFirst&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>为了方便，函数调用时，往往省略不写类型参数的值，让 TypeScript 自己推断。</p>
<p>有些复杂的使用场景，TypeScript 可能推断不出类型参数的值，这时就必须显式给出了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comb&lt;T&gt;(<span class="attr">arr1</span>:T[], <span class="attr">arr2</span>:T[]):T[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="title function_">comb</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>类型参数的名字，可以随便取，但是必须为合法的标识符。习惯上，类型参数的第一个字符往往采用大写字母。一般会使用T（type 的第一个字母）作为类型参数的名字。如果有多个类型参数，则使用 T 后面的 U、V 等字母命名，各个参数之间使用逗号（“,”）分隔。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> map&lt;T, U&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[],</span><br><span class="line">  <span class="attr">f</span>:<span class="function">(<span class="params">arg:T</span>) =&gt;</span> U</span><br><span class="line">):U[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法实例</span></span><br><span class="line">map&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>],</span><br><span class="line">  <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">parseInt</span>(n)</span><br><span class="line">); <span class="comment">// 返回 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>总之，泛型可以理解成一段类型逻辑，需要类型参数来表达。有了类型参数以后，可以在输入类型与输出类型之间，建立一一对应关系。</p>
<h3 id="12-2-泛型的写法"><a href="#12-2-泛型的写法" class="headerlink" title="12.2 泛型的写法"></a>12.2 泛型的写法</h3><p>泛型主要用在四个场合：函数、接口、类和别名。</p>
<h4 id="12-2-1-函数的泛型写法"><a href="#12-2-1-函数的泛型写法" class="headerlink" title="12.2.1 函数的泛型写法"></a>12.2.1 函数的泛型写法</h4><p>function关键字定义的泛型函数，类型参数放在尖括号中，写在函数名后面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> id&lt;T&gt;(<span class="attr">arg</span>:T):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么对于变量形式定义的函数，泛型有下面两种写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:&lt;T&gt;<span class="function">(<span class="params">arg:T</span>) =&gt;</span> T = id;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:&#123; &lt;T&gt;(<span class="attr">arg</span>:T): T &#125; = id;</span><br></pre></td></tr></table></figure>

<h4 id="12-2-2-接口的泛型写法"><a href="#12-2-2-接口的泛型写法" class="headerlink" title="12.2.2 接口的泛型写法"></a>12.2.2 接口的泛型写法</h4><p>interface 也可以采用泛型的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">box</span>:<span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">compareTo</span>(<span class="attr">value</span>:T): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;<span class="title class_">Rectangle</span>&gt; &#123;</span><br><span class="line">  <span class="title function_">compareTo</span>(<span class="attr">value</span>:<span class="title class_">Rectangle</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口还有第二种写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fn</span> &#123;</span><br><span class="line">  &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>:<span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> id&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>:<span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myId</span>:<span class="title class_">Fn</span> = id;</span><br></pre></td></tr></table></figure>

<p>此外，第二种写法还有一个差异之处。那就是它的类型参数定义在某个方法之中，其他属性和方法不能使用该类型参数。前面的第一种写法，类型参数定义在整个接口，接口内部的所有属性和方法都可以使用该类型参数。</p>
<h4 id="12-2-3-类的泛型写法"><a href="#12-2-3-类的泛型写法" class="headerlink" title="12.2.3 类的泛型写法"></a>12.2.3 类的泛型写法</h4><p>泛型类的类型参数写在类名后面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;K, V&gt; &#123;</span><br><span class="line">  <span class="attr">key</span>: K;</span><br><span class="line">  <span class="attr">value</span>: V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是继承泛型类的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类A有一个类型参数T，使用时必须给出T的类型，所以类B继承时要写成A&lt;**any**&gt;。<br>泛型也可以用在类表达式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Container</span> = <span class="keyword">class</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> data:T</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">  value!: <span class="title class_">NumType</span>;</span><br><span class="line">  add!: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> C&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">foo.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">foo.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>JavaScript 的类本质上是一个构造函数，因此也可以把泛型类写成构造函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyClass</span>&lt;T&gt; = <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; T;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法实例</span></span><br><span class="line"><span class="keyword">function</span> createInstance&lt;T&gt;(</span><br><span class="line">  <span class="title class_">AnyClass</span>: <span class="title class_">MyClass</span>&lt;T&gt;,</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">):T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnyClass</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，泛型类描述的是类的实例，不包括静态属性和静态方法，因为这两者定义在类的本身。因此，它们不能引用类型参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">data</span>: T;  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> value:T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-2-4-类型别名的泛型写法"><a href="#12-2-4-类型别名的泛型写法" class="headerlink" title="12.2.4 类型别名的泛型写法"></a>12.2.4 类型别名的泛型写法</h4><p>type 命令定义的类型别名，也可以使用泛型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Nullable</span>&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是另一个例子。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">Container</span>&lt;<span class="built_in">number</span>&gt; = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Container</span>&lt;<span class="built_in">string</span>&gt; = &#123; <span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 下面是定义树形结构的例子。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">  <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">&#125;;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-3-类型参数的默认值"><a href="#12-3-类型参数的默认值" class="headerlink" title="12.3 类型参数的默认值"></a>12.3 类型参数的默认值</h3><p>类型参数可以设置默认值。使用时，如果没有给出类型参数的值，就会使用默认值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getFirst&lt;T = <span class="built_in">string</span>&gt;(</span><br><span class="line">  <span class="attr">arr</span>:T[]</span><br><span class="line">):T &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，T = string表示类型参数的默认值是string。调用getFirst()时，如果不给出T的值，TypeScript 就认为T等于string。<br>但是，因为 TypeScript 会从实际参数推断出T的值，从而覆盖掉默认值，所以下面的代码不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getFirst</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>类型参数的默认值，往往用在类中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T = <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="attr">list</span>:T[] = []</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">t:T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Generic</span>();</span><br><span class="line">g.<span class="title function_">add</span>(<span class="number">4</span>) <span class="comment">// 报错</span></span><br><span class="line">g.<span class="title function_">add</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>新建Generic的实例g时，没有给出类型参数T的值，所以T就等于string。因此，向add()方法传入一个数值会报错，传入字符串就不会。</p>
<p>一旦类型参数有默认值，就表示它是可选参数。如果有多个类型参数，可选参数必须在必选参数之后。</p>
<h3 id="12-4-数组的泛型表示"><a href="#12-4-数组的泛型表示" class="headerlink" title="12.4 数组的泛型表示"></a>12.4 数组的泛型表示</h3><p>数组类型有一种表示方法是Array&lt;**T**&gt;。这就是泛型的写法，Array是 TypeScript 原生的一个类型接口，T是它的类型参数。声明数组时，需要提供T的值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>同样的，如果数组成员都是字符串，那么类型就写成Array&lt;**string**&gt;。事实上，在TypeScript 内部，数组类型的另一种写法number[]、string[]，只是Array&lt;**number**&gt;、Array&lt;**string**&gt;的简写形式。<br>在 TypeScript 内部，Array是一个泛型接口，类型定义基本是下面的样子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">pop</span>(): <span class="title class_">Type</span>|<span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">push</span>(...<span class="attr">items</span>:<span class="title class_">Type</span>[]): <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的 TypeScript 内部数据结构，比如Map、Set和Promise，其实也是泛型接口，完整的写法是Map&lt;**K, V**&gt;、Set&lt;**T**&gt;和Promise&lt;**T**&gt;。<br>TypeScript 默认还提供一个ReadonlyArray&lt;**T**&gt;接口，表示只读数组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params"></span></span><br><span class="line"><span class="params">  values:ReadonlyArray&lt;<span class="built_in">string</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  values.<span class="title function_">push</span>(<span class="string">&#x27;hello!&#x27;</span>);  <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不希望函数内部改动参数数组，就可以将该参数数组声明为ReadonlyArray&lt;**T**&gt;类型。</p>
<h3 id="12-5-类型参数的约束条件"><a href="#12-5-类型参数的约束条件" class="headerlink" title="12.5 类型参数的约束条件"></a>12.5 类型参数的约束条件</h3><p>很多类型参数并不是无限制的，对于传入的类型存在约束条件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;<span class="title class_">Type</span>&gt;(<span class="attr">a</span>:<span class="title class_">Type</span>, <span class="attr">b</span>:<span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 提供了一种语法，允许在类型参数上面写明约束条件，如果不满足条件，编译时就会报错。这样也可以有良好的语义，对类型参数进行说明。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> comp&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">  <span class="attr">a</span>: T,</span><br><span class="line">  <span class="attr">b</span>: T</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，T extends { length: number }就是约束条件，表示类型参数 T 必须满足{ length: number }，否则就会报错。</p>
<p>类型参数的约束条件采用下面的形式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TypeParameter</span> <span class="keyword">extends</span> <span class="title class_">ConstraintType</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上面语法中，TypeParameter表示类型参数，extends是关键字，这是必须的，ConstraintType表示类型参数要满足的条件，即类型参数应该是ConstraintType的子类型。<br>类型参数可以同时设置约束条件和默认值，前提是默认值必须满足约束条件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span>&lt;A <span class="keyword">extends</span> <span class="built_in">string</span>, B <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&#x27;world&#x27;</span>&gt;</span><br><span class="line">  =  [A, B];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Fn</span>&lt;<span class="string">&#x27;hello&#x27;</span>&gt; <span class="comment">// [&quot;hello&quot;, &quot;world&quot;]</span></span><br></pre></td></tr></table></figure>

<p>泛型本质上是一个类型函数，通过输入参数，获得结果，两者是一一对应关系。<br>如果有多个类型参数，一个类型参数的约束条件，可以引用其他参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T, U <span class="keyword">extends</span> T&gt;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">&lt;T <span class="keyword">extends</span> U, U&gt;</span><br></pre></td></tr></table></figure>

<p>但是，约束条件不能引用类型参数自身。</p>
<h3 id="12-6-使用注意点"><a href="#12-6-使用注意点" class="headerlink" title="12.6 使用注意点"></a>12.6 使用注意点</h3><p>（1）尽量少用泛型。<br>泛型虽然灵活，但是会加大代码的复杂性，使其变得难读难写。一般来说，只要使用了泛型，类型声明通常都不太易读，容易写得很复杂。因此，可以不用泛型就不要用。</p>
<p>（2）类型参数越少越好。<br>多一个类型参数，多一道替换步骤，加大复杂性。因此，类型参数越少越好。</p>
<p>（3）类型参数需要出现两次。<br>如果类型参数在定义后只出现一次，那么很可能是不必要的。</p>
<p>只有当类型参数用到两次或两次以上，才是泛型的适用场合。</p>
<p>（4）泛型可以嵌套。<br>类型参数可以是另一个泛型。</p>
<h2 id="十三、TypeScript-的-Enum-类型"><a href="#十三、TypeScript-的-Enum-类型" class="headerlink" title="十三、TypeScript 的 Enum 类型"></a>十三、TypeScript 的 Enum 类型</h2><p>Enum 是 TypeScript 新增的一种数据结构和类型，中文译为“枚举”。</p>
<h3 id="13-1-简介"><a href="#13-1-简介" class="headerlink" title="13.1 简介"></a>13.1 简介</h3><p>实际开发中，经常需要定义一组相关的常量。</p>
<p>TypeScript 就设计了 Enum 结构，用来将相关常量放在一个容器里面，方便使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,     <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span>,   <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Blue</span>     <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时，调用 Enum 的某个成员，与调用对象属性的写法一样，可以使用点运算符，也可以使用方括号运算符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Color</span>[<span class="string">&#x27;Green&#x27;</span>]; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>Enum 结构本身也是一种类型。比如，上例的变量c等于1，它的类型可以是Color，也可以是number。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="built_in">number</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>Enum 结构的特别之处在于，它既是一种类型，也是一个值。绝大多数 TypeScript语法都是类型语法，编译后会全部去除，但是 Enum 结构是一个值，编译后会变成JavaScript 对象，留在代码中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,     <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span>,   <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Blue</span>     <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Color</span> = &#123;</span><br><span class="line">  <span class="title class_">Red</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Blue</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例是 Enum 结构编译前后的对比。<br>由于 TypeScript 的定位是 JavaScript 语言的类型增强，所以官方建议谨慎使用Enum 结构，因为它不仅仅是类型，还会为编译后的代码加入一个对象。<br>Enum 结构比较适合的场景是，成员的值不重要，名字更重要，从而增加代码的可读性和可维护性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">  <span class="variable constant_">ADD</span>,</span><br><span class="line">  <span class="variable constant_">DIV</span>,</span><br><span class="line">  <span class="variable constant_">MUL</span>,</span><br><span class="line">  <span class="variable constant_">SUB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compute</span>(<span class="params"></span></span><br><span class="line"><span class="params">  op:Operator,</span></span><br><span class="line"><span class="params">  a:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  b:<span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">ADD</span>:</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">DIV</span>:</span><br><span class="line">      <span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">MUL</span>:</span><br><span class="line">      <span class="keyword">return</span> a * b;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Operator</span>.<span class="property">SUB</span>:</span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;wrong operator&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 作为类型有一个缺点，就是输入任何数值都不报错。</p>
<p>另外，由于 Enum 结构编译后是一个对象，所以不能有与它同名的变量（包括对象、函数、类等）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Color</span> = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>很大程度上，Enum 结构可以被对象的as const断言替代。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">A</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">B</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">C</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">if</span> （x === <span class="title class_">Foo</span>.<span class="property">A</span>）&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="title class_">Bar</span>.<span class="property">A</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-Enum-成员的值"><a href="#13-2-Enum-成员的值" class="headerlink" title="13.2 Enum 成员的值"></a>13.2 Enum 成员的值</h3><p>Enum 成员默认不必赋值，系统会从零开始逐一递增，按照顺序为每个成员赋值。</p>
<p>但是，也可以为 Enum 成员显式赋值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员的值可以是任意数值，但不能是大整数（Bigint）。</p>
<p>成员的值甚至可以相同。</p>
<p>如果只设定第一个成员的值，后面成员的值就会从这个值开始递增。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">Green</span>,  <span class="comment">// 8</span></span><br><span class="line">  <span class="title class_">Blue</span>   <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>, <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">Blue</span> <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 成员的值也可以使用计算式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Permission</span> &#123;</span><br><span class="line">  <span class="title class_">UserRead</span>     = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">  <span class="title class_">UserWrite</span>    = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">  <span class="title class_">UserExecute</span>  = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">  <span class="title class_">GroupRead</span>    = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  <span class="title class_">GroupWrite</span>   = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">  <span class="title class_">GroupExecute</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  <span class="title class_">AllRead</span>      = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">AllWrite</span>     = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">AllExecute</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">  <span class="title class_">No</span> = <span class="number">123</span>,</span><br><span class="line">  <span class="title class_">Yes</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 成员值都是只读的，不能重新赋值。</p>
<p>为了让这一点更醒目，通常会在 enum 关键字前面加上const修饰，表示这是常量，不能再次赋值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上const还有一个好处，就是编译为 JavaScript 代码后，代码中 Enum 成员会被替换成对应的值，这样能提高性能表现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="title class_">Color</span>.<span class="property">Blue</span>;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">0</span> <span class="comment">/* Color.Red */</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">1</span> <span class="comment">/* Color.Green */</span>;</span><br><span class="line"><span class="keyword">const</span> z = <span class="number">2</span> <span class="comment">/* Color.Blue */</span>;</span><br></pre></td></tr></table></figure>

<p>如果希望加上const关键词后，运行时还能访问 Enum 结构（即编译后依然将Enum 转成对象），需要在编译时打开preserveConstEnums编译选项。</p>
<h3 id="13-3-同名-Enum-的合并"><a href="#13-3-同名-Enum-的合并" class="headerlink" title="13.3 同名 Enum 的合并"></a>13.3 同名 Enum 的合并</h3><p>多个同名的 Enum 结构会自动合并。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  C = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B = <span class="number">1</span>，</span><br><span class="line">  C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 结构合并时，只允许其中一个的首成员省略初始值，否则报错。</p>
<p>同名 Enum 合并时，不能有同名成员，否则报错。</p>
<p>同名 Enum 合并的另一个限制是，所有定义必须同为 const 枚举或者非 const 枚举，不允许混合使用。</p>
<p>同名 Enum 的合并，最大用处就是补充外部定义的 Enum 结构。</p>
<h3 id="13-4-字符串-Enum"><a href="#13-4-字符串-Enum" class="headerlink" title="13.4 字符串 Enum"></a>13.4 字符串 Enum</h3><p>Enum 成员的值除了设为数值，还可以设为字符串。也就是说，Enum 也可以用作一组相关字符串的集合。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，字符串枚举的所有成员值，都必须显式设置。如果没有设置，成员值默认为数值，且位置必须在字符串成员之前。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  A, <span class="comment">// 0</span></span><br><span class="line">  B = <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  C <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum 成员可以是字符串和数值混合赋值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">  <span class="title class_">Three</span> = <span class="number">3</span>,</span><br><span class="line">  <span class="title class_">Four</span> = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了数值和字符串，Enum 成员不允许使用其他值（比如 Symbol 值）。<br>变量类型如果是字符串 Enum，就不能再赋值为字符串，这跟数值 Enum 不一样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">MyEnum</span>.<span class="property">One</span>;</span><br><span class="line">s = <span class="string">&#x27;One&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>由于这个原因，如果函数的参数类型是字符串 Enum，传参时就不能直接传入字符串，而要传入 Enum 成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  <span class="title class_">One</span> = <span class="string">&#x27;One&#x27;</span>,</span><br><span class="line">  <span class="title class_">Two</span> = <span class="string">&#x27;Two&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">arg:MyEnum</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;arg is &#x27;</span> + arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="string">&#x27;One&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>所以，字符串 Enum 作为一种类型，有限定函数参数的作用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">MediaTypes</span> &#123;</span><br><span class="line">  <span class="title class_">JSON</span> = <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">XML</span> = <span class="string">&#x27;application/xml&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="title class_">Accept</span>: <span class="title class_">MediaTypes</span>.<span class="property">JSON</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>字符串 Enum 可以使用联合类型（union）代替。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"></span></span><br><span class="line"><span class="params">  where:<span class="string">&#x27;Up&#x27;</span>|<span class="string">&#x27;Down&#x27;</span>|<span class="string">&#x27;Left&#x27;</span>|<span class="string">&#x27;Right&#x27;</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意，字符串 Enum 的成员值，不能使用表达式赋值。</p>
<h3 id="13-5-keyof-运算符"><a href="#13-5-keyof-运算符" class="headerlink" title="13.5 keyof 运算符"></a>13.5 keyof 运算符</h3><p>keyof 运算符可以取出 Enum 结构的所有成员名，作为联合类型返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;A&#x27;|&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="keyword">typeof</span> <span class="title class_">MyEnum</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这里的typeof是必需的，否则keyof MyEnum相当于keyof number。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = keyof <span class="title class_">MyEnum</span>;</span><br><span class="line"><span class="comment">// &quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; |</span></span><br><span class="line"><span class="comment">// &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，类型Foo等于类型number的所有原生属性名组成的联合类型。<br>这是因为 Enum 作为类型，本质上属于number或string的一种变体，而typeof MyEnum会将MyEnum当作一个值处理，从而先其转为对象类型，就可以再用keyof运算符返回该对象的所有属性名。<br>如果要返回 Enum 所有的成员值，可以使用in运算符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123; a：any, b: any &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123; [key <span class="keyword">in</span> <span class="title class_">MyEnum</span>]: <span class="built_in">any</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-6-反向映射"><a href="#13-6-反向映射" class="headerlink" title="13.6 反向映射"></a>13.6 反向映射</h3><p>数值 Enum 存在反向映射，即可以通过成员值获得成员名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekdays</span> &#123;</span><br><span class="line">  <span class="title class_">Monday</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Tuesday</span>,</span><br><span class="line">  <span class="title class_">Wednesday</span>,</span><br><span class="line">  <span class="title class_">Thursday</span>,</span><br><span class="line">  <span class="title class_">Friday</span>,</span><br><span class="line">  <span class="title class_">Saturday</span>,</span><br><span class="line">  <span class="title class_">Sunday</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Weekdays</span>[<span class="number">3</span>]) <span class="comment">// Wednesday</span></span><br></pre></td></tr></table></figure>

<p>这是因为 TypeScript 会将上面的 Enum 结构，编译成下面的 JavaScript 代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Weekdays</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Weekdays</span>) &#123;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Tuesday&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Wednesday&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Thursday&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Friday&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Saturday&quot;</span>] = <span class="number">6</span>] = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">    <span class="title class_">Weekdays</span>[<span class="title class_">Weekdays</span>[<span class="string">&quot;Sunday&quot;</span>] = <span class="number">7</span>] = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Weekdays</span> || (<span class="title class_">Weekdays</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>上面代码中，实际进行了两组赋值，以第一个成员为例。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Weekdays</span>[</span><br><span class="line">  <span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span></span><br><span class="line">] = <span class="string">&quot;Monday&quot;</span>;  </span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="title class_">Weekdays</span>[<span class="string">&quot;Monday&quot;</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Weekdays</span>[<span class="number">1</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这种情况只发生在数值 Enum，对于字符串 Enum，不存在反向映射。这是因为字符串 Enum 编译后只有一组赋值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A = <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  B = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyEnum</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">MyEnum</span>) &#123;</span><br><span class="line">    <span class="title class_">MyEnum</span>[<span class="string">&quot;A&quot;</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="title class_">MyEnum</span>[<span class="string">&quot;B&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">MyEnum</span> || (<span class="title class_">MyEnum</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="十四、TypeScript-的类型断言"><a href="#十四、TypeScript-的类型断言" class="headerlink" title="十四、TypeScript 的类型断言"></a>十四、TypeScript 的类型断言</h2><h3 id="14-1-简介"><a href="#14-1-简介" class="headerlink" title="14.1 简介"></a>14.1 简介</h3><p>对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是 TypeScript 推断变量foo的类型是string，而变量bar的类型是’a’|’b’|’c’，前者是后者的父类型。父类型不能赋值给子类型，所以就报错了。<br>TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。<br>这种做法的实质是，允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>最后一行的foo as T表示告诉编译器，变量foo的类型断言为T，所以这一行不再需要类型推断了，编译器直接把foo的类型当作T，就不会报错了。</p>
<p>总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。<br>类型断言有两种语法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法一：&lt;类型&gt;值</span></span><br><span class="line">&lt;<span class="title class_">Type</span>&gt;value</span><br><span class="line"><span class="comment">// 语法二：值 as 类型</span></span><br><span class="line">value <span class="keyword">as</span> <span class="title class_">Type</span></span><br></pre></td></tr></table></figure>

<p>上面两种语法是等价的，value表示值，Type表示类型。早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二。目前，推荐使用语法二。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = &lt;T&gt;foo;</span><br><span class="line"><span class="comment">// 语法二</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bar</span>:T = foo <span class="keyword">as</span> T;</span><br></pre></td></tr></table></figure>

<p>下面看一个例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，等号右侧是一个对象字面量，多出了属性y，导致报错。解决方法就是使用类型断言，可以用两种不同的断言。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p0</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>:&#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125; =</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="keyword">as</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，两种类型断言都是正确的。第一种断言将类型改成与等号左边一致，第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错。</p>
<p>下面是一个网页编程的实际例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (username) &#123;</span><br><span class="line">  (username <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">value</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，上例的类型断言的圆括号是必需的，否则username会被断言成HTMLInputElement.value，从而报错。<br>类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">data</span>:<span class="built_in">object</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">data.<span class="property">length</span>; <span class="comment">// 报错</span></span><br><span class="line">(data <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;).<span class="property">length</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量data是一个对象，没有length属性。但是通过类型断言，可以将它的类型断言为数组，这样使用length属性就能通过类型检查。但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译。<br>类型断言的一大用处是，指定 unknown 类型的变量的具体类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">value</span>:<span class="built_in">unknown</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">string</span> = value; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">string</span> = value <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，unknown 类型的变量value不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了。<br>另外，类型断言也适合指定联合类型的值的具体类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">s1</span>:<span class="built_in">number</span>|<span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">s2</span>:<span class="built_in">number</span> = s1 <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<h3 id="14-2-类型断言的条件"><a href="#14-2-类型断言的条件" class="headerlink" title="14.2 类型断言的条件"></a>14.2 类型断言的条件</h3><p>类型断言并不意味着，可以把某个值断言为任意类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>类型断言的使用前提是，值的实际类型与断言的类型必须满足一个条件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr <span class="keyword">as</span> T</span><br></pre></td></tr></table></figure>

<p>上面代码中，expr是实际的值，T是类型断言，它们必须满足下面的条件：expr是T的子类型，或者T是expr的子类型。<br>也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。<br>但是，如果真的要断言成一个完全无关的类型，也是可以做到的。那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。因为any类型和unknown类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> T </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="built_in">string</span> = n <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h3 id="14-3-as-const-断言"><a href="#14-3-as-const-断言" class="headerlink" title="14.3 as const 断言"></a>14.3 as const 断言</h3><p>如果没有声明变量类型，let 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一；const 命令声明的变量，则被推断为值类型常量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型推断为基本类型 string</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="comment">// 类型推断为字符串 “JavaScript”</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量s1的类型被推断为string，变量s2的类型推断为值类型JavaScript。后者是前者的子类型，相当于 const 命令有更强的限定作用，可以缩小变量的类型范围。<br>有些时候，let 变量会出现一些意想不到的报错，变更成 const 变量就能消除报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lang</span> =</span><br><span class="line">  |<span class="string">&#x27;JavaScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;TypeScript&#x27;</span></span><br><span class="line">  |<span class="string">&#x27;Python&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setLang</span>(<span class="params">language:Lang</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setLang</span>(s); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，最后一行报错，原因是函数setLang()的参数language类型是Lang，这是一个联合类型。但是，传入的字符串s的类型被推断为string，属于Lang的父类型。父类型不能替代子类型，导致报错。<br>一种解决方法就是把 let 命令改成 const 命令。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>另一种解决方法是使用类型断言。TypeScript 提供了一种特殊的类型断言as const，用于告诉编译器，推断类型时，可以将这个值推断为常量，即把 let 变量断言为 const 变量，从而把内置的基本类型变更为值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>使用了as const断言以后，let 变量就不能再改变值了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">s = <span class="string">&#x27;Python&#x27;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>注意，as const断言只能用于字面量，不能用于变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line"><span class="title function_">setLang</span>(s <span class="keyword">as</span> <span class="keyword">const</span>); <span class="comment">// 报错 </span></span><br></pre></td></tr></table></figure>

<p>另外，as const也不能用于表达式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = (<span class="string">&#x27;Java&#x27;</span> + <span class="string">&#x27;Script&#x27;</span>) <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>as const也可以写成前置的形式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置形式</span></span><br><span class="line">expr <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="comment">// 前置形式</span></span><br><span class="line">&lt;<span class="keyword">const</span>&gt;expr</span><br></pre></td></tr></table></figure>

<p>as const断言可以用于整个对象，也可以用于对象的单个属性，这时它的类型缩小效果是不一样的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: number; y: number; &#125;</span></span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125;; <span class="comment">// 类型是 &#123; x: 1; y: number; &#125;</span></span><br><span class="line"><span class="keyword">const</span> v3 = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// 类型是 &#123; readonly x: 1; readonly y: 2; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第二种写法是对属性x缩小类型，第三种写法是对整个对象缩小类型。<br>总之，as const会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。</p>
<p>下面是数组的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 的类型推断为 number[]</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a2 的类型推断为 readonly [1, 2, 3]</span></span><br><span class="line"><span class="keyword">const</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>由于as const会将数组变成只读元组，所以很适合用于函数的 rest 参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量nums的类型推断为number[]，导致使用扩展运算符…传入函数add()会报错，因为add()只能接受两个参数，而…nums并不能保证参数的个数。</p>
<p>事实上，对于固定参数个数的函数，如果传入的参数包含扩展运算符，那么扩展运算符只能用于元组。只有当函数定义使用了 rest 参数，扩展运算符才能用于数组。<br>解决方法就是使用as const断言，将数组变成元组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">add</span>(...nums); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>Enum 成员也可以使用as const断言。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  X,</span><br><span class="line">  Y,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> e1 = <span class="title class_">Foo</span>.<span class="property">X</span>;            <span class="comment">// Foo</span></span><br><span class="line"><span class="keyword">let</span> e2 = <span class="title class_">Foo</span>.<span class="property">X</span> <span class="keyword">as</span> <span class="keyword">const</span>;   <span class="comment">// Foo.X</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，如果不使用as const断言，变量e1的类型被推断为整个 Enum 类型；使用了as const断言以后，变量e2的类型被推断为 Enum 的某个成员，这意味着它不能变更为其他成员。</p>
<h3 id="14-4-非空断言"><a href="#14-4-非空断言" class="headerlink" title="14.4 非空断言"></a>14.4 非空断言</h3><p>对于那些可能为空的变量（即可能等于undefined或null），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号!。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="title function_">validateNumber</span>(x); <span class="comment">// 自定义函数，确保 x 是数值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x!.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateNumber</span>(<span class="params">e?:<span class="built_in">number</span>|<span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> e !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非空断言在实际编程中很有用，有时可以省去一些额外的判断。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，getElementById()有可能返回空值null，即变量root可能为空，这时对它调用addEventListener()方法就会报错，通不过编译。但是，开发者如果可以确认root元素肯定会在网页中存在，这时就可以使用非空断言。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)!;</span><br></pre></td></tr></table></figure>

<p>不过，非空断言会造成安全隐患，只有在确定一个表达式的值不为空时才能使用。比较保险的做法还是手动检查一下是否为空。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unable to find DOM element #root&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">root.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>非空断言还可以用于赋值断言。TypeScript 有一个编译设置，要求类的属性必须初始化（即有初始值），如果不对属性赋值就会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>; <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，属性x和y会报错，因为 TypeScript 认为它们没有初始化。<br>这时就可以使用非空断言，表示这两个属性肯定会有值，这样就不会报错了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">  y!:<span class="built_in">number</span>; <span class="comment">// 正确</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，非空断言只有在打开编译选项strictNullChecks时才有意义。如果不打开选项，编译器就不会检查某个变量是否可能为undefined或null。</p>
<h3 id="14-5-断言函数"><a href="#14-5-断言函数" class="headerlink" title="14.5 断言函数"></a>14.5 断言函数</h3><p>断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//用法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">aValue</span>:<span class="built_in">string</span>|<span class="built_in">number</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="title function_">isString</span>(aValue);</span><br></pre></td></tr></table></figure>

<p>断言函数的类型可以写成下面这样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数参数value的类型是unknown，返回值类型是void，即没有返回值。可以看到，单单从这样的类型声明，很难看出isString()是一个断言函数。</p>
<p>为了更清晰地表达断言函数，TypeScript 3.7 引入了新的类型写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数isString()的返回值类型写成asserts value is string，其中asserts和is都是关键词，value是函数的参数名，string是函数参数的预期类型。它的意思是，该函数用来断言参数value的类型是string，如果达不到要求，程序就会在这里中断。<br>使用了断言函数的新写法以后，TypeScript 就会自动识别，只要执行了该函数，对应的变量都为断言的类型。<br>注意，函数返回值的断言写法，只是用来更清晰地表达函数意图，真正的检查是需要开发者自己部署的。而且，如果内部的检查与断言不一致，TypeScript 也不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数的断言是参数value类型为字符串，但是实际上，内部检查的却是它是否为数值，如果不是就抛错。这段代码能够正常通过编译，表示 TypeScript并不会检查断言与实际的类型检查是否一致。<br>另外，断言函数的asserts语句等同于void类型，所以如果返回除了undefined和null以外的值，都会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">unknown</span></span>):asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a string&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要断言参数非空，可以使用工具类型NonNullable&lt;**T**&gt;。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> assertIsDefined&lt;T&gt;(</span><br><span class="line">  <span class="attr">value</span>:T</span><br><span class="line">):asserts value is <span class="title class_">NonNullable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span> || value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not defined`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要将断言函数用于函数表达式，可以采用下面的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> assertIsNumber = (</span><br><span class="line">  <span class="attr">value</span>:<span class="built_in">unknown</span></span><br><span class="line">):asserts value is <span class="built_in">number</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AssertIsNumber</span> =</span><br><span class="line">  <span class="function">(<span class="params">value:<span class="built_in">unknown</span></span>) =&gt;</span> asserts value is <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">assertIsNumber</span>:<span class="title class_">AssertIsNumber</span> = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not a number&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，断言函数与类型保护函数（type guard）是两种不同的函数。它们的区别是，断言函数不返回值，而类型保护函数总是返回一个布尔值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">unknown</span></span></span><br><span class="line"><span class="params"></span>):value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例就是一个类型保护函数isString()，作用是检查参数value是否为字符串。如果是的，返回true，否则返回false。该函数的返回值类型是value is string，其中的is是一个类型运算符，如果左侧的值符合右侧的类型，则返回true，否则返回false。</p>
<p>如果要断言某个参数保证为真（即不等于false、undefined和null），TypeScript 提供了断言函数的一种简写形式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数assert()的断言部分，asserts x省略了谓语和宾语，表示参数x保证为真（true）。<br>同样的，参数为真的实际检查需要开发者自己实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">x:<span class="built_in">unknown</span></span>):asserts x &#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`<span class="subst">$&#123;x&#125;</span> should be a truthy value.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种断言函数的简写形式，通常用来检查某个操作是否成功。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  email?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadPerson</span>(<span class="params"></span>): <span class="title class_">Person</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">loadPerson</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params"></span></span><br><span class="line"><span class="params">  condition: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  message: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):asserts condition &#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: Person is not defined</span></span><br><span class="line"><span class="title function_">assert</span>(person, <span class="string">&#x27;Person is not defined&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有loadPerson()返回结果为真（即操作成功），assert()才不会报错。</p>
<h2 id="十五、TypeScript-模块"><a href="#十五、TypeScript-模块" class="headerlink" title="十五、TypeScript 模块"></a>十五、TypeScript 模块</h2><h3 id="15-1-简介"><a href="#15-1-简介" class="headerlink" title="15.1 简介"></a>15.1 简介</h3><p>任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。<br>模块本身就是一个作用域，不属于全局作用域。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的。暴露给外部的接口，必须用 export 命令声明；如果其他文件要使用模块的接口，必须用 import 命令来输入。<br>如果一个文件不包含 export 语句，但是希望把它当作一个模块（即内部变量对外不可见），可以在脚本头部添加一行语句。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这行语句不产生任何实际作用，但会让当前文件被当作模块处理，所有它的代码都变成了内部代码。</p>
<p>TypeScript 模块除了支持所有 ES 模块的语法，特别之处在于允许输出和输入类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Bool</span> = <span class="literal">true</span> | <span class="literal">false</span>; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bool</span> = <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Bool</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>假定上面的模块文件为a.ts，另一个文件b.ts就可以使用 import 语句，输入这个类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Bool</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>:<span class="title class_">Bool</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>TypeScript 允许加载模块时，省略模块文件的后缀名，它会自动定位。</p>
<p>编译时，可以两个脚本同时编译。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc a.<span class="property">ts</span> b.<span class="property">ts</span></span><br></pre></td></tr></table></figure>

<p>也可以只编译b.ts，因为它是入口脚本，tsc 会自动编译它依赖的所有脚本。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc b.<span class="property">ts</span></span><br></pre></td></tr></table></figure>

<p>上面命令发现b.ts依赖a.js，就会自动寻找a.ts，也将其同时编译，因此编译产物还是a.js和b.js两个文件。<br>如果想将a.ts和b.ts编译成一个文件，可以使用–outFile参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --outFile result.<span class="property">js</span> b.<span class="property">ts</span></span><br></pre></td></tr></table></figure>

<h3 id="15-2-import-type-语句"><a href="#15-2-import-type-语句" class="headerlink" title="15.2 import type 语句"></a>15.2 import type 语句</h3><p>import 在一条语句中，可以同时输入类型和正常接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A, a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这样很不利于区分类型和正常接口，容易造成混淆。为了解决这个问题，TypeScript引入了两个解决方法。<br>第一个方法是在 import 语句输入的类型前面加上type关键字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">type</span> A, a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，import 语句输入的类型A前面有type关键字，表示这是一个类型。<br>第二个方法是使用 import type 语句，这个语句只能输入类型，不能输入正常接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>import type 语句也可以输入默认类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> <span class="title class_">DefaultType</span> <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>import type 在一个名称空间下，输入所有类型的写法如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> * <span class="keyword">as</span> <span class="title class_">TypeNS</span> <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>同样的，export 语句也有两种方法，表示输出的是类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> B = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">type</span> A, <span class="keyword">type</span> B&#125;;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> &#123;A, B&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，方法一是使用type关键字作为前缀，表示输出的是类型；方法二是使用 export type 语句，表示整行输出的都是类型。</p>
<p>下面是 export type 将一个类作为类型输出的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> &#123; <span class="title class_">Point</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，由于使用了 export type 语句，输出的并不是 Point 这个类，而是Point 代表的实例类型。输入时，只能作为类型输入。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Point</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="15-3-importsNotUsedAsValues"><a href="#15-3-importsNotUsedAsValues" class="headerlink" title="15.3 importsNotUsedAsValues"></a>15.3 importsNotUsedAsValues</h3><p>TypeScript 提供了importsNotUsedAsValues编译设置项，有三个可能的值。</p>
<p>（1）remove：这是默认值，自动删除输入类型的 import 语句。</p>
<p>（2）preserve：保留输入类型的 import 语句。</p>
<p>（3）error：保留输入类型的 import 语句（与preserve相同），但是必须写成import type 的形式，否则报错。</p>
<p>下面是一个输入类型的 import 语句。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，TypeA是一个类型。<br>remove的编译结果会将该语句删掉。<br>preserve的编译结果会保留该语句，但会把删掉类型的部分。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，编译后的 import 语句不从a.js输入任何接口，但是会引发a.js的执行，因此会保留a.js里面的副作用。<br>error的结果与preserve相同，但是编译过程会报错，因为输入类型的 import 语句必须写成 import type 的形式。原始语句改成下面的形式，就不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="15-4-CommonJS-模块"><a href="#15-4-CommonJS-模块" class="headerlink" title="15.4 CommonJS 模块"></a>15.4 CommonJS 模块</h3><p>CommonJS 是 Node.js 的专用模块格式，与 ES 模块格式不兼容。</p>
<p>TypeScript 使用import =语句输入 CommonJS 模块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> code = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;hello.ts&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，使用import =语句和require()命令输入了一个 CommonJS 模块。模块本身的用法跟 Node.js 是一样的。<br>除了使用import =语句，TypeScript 还允许使用import * as [接口名] from “模块文件”输入 CommonJS 模块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>TypeScript 使用export =语句，输出 CommonJS 模块的对象，等同于 CommonJS的module.exports对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> = obj;</span><br></pre></td></tr></table></figure>

<p>export = 语句输出的对象，只能使用import =语句加载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> obj = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h3 id="15-5-模块定位"><a href="#15-5-模块定位" class="headerlink" title="15.5 模块定位"></a>15.5 模块定位</h3><p>模块定位（module resolution）指的是确定 import 语句和 export 语句里面的模块文件位置。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TypeA</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>模块定位有两种方法，一种称为 Classic 方法，另一种称为 Node 方法。可以使用编译参数moduleResolution，指定使用哪一种方法。<br>没有指定定位方法时，就看原始脚本采用什么模块格式。如果模块格式是CommonJS（即编译时指定–module commonjs），那么模块定位采用 Node 方法，否则采用 Classic 方法（模块格式为 es2015、 esnext、amd, system, umd 等等）。</p>
<h4 id="15-5-1-相对模块，非相对模块"><a href="#15-5-1-相对模块，非相对模块" class="headerlink" title="15.5.1 相对模块，非相对模块"></a>15.5.1 相对模块，非相对模块</h4><p>加载模块时，目标模块分为相对模块（relative import）和非相对模块两种（nonrelative import）。<br>相对模块指的是路径以/、./、../开头的模块。下面 import 语句加载的模块，都是相对模块。</p>
<ul>
<li><p>import Entry from “./components/Entry”;</p>
</li>
<li><p>import { DefaultHeaders } from “../constants/http”;</p>
</li>
<li><p>import “/mod”;</p>
</li>
</ul>
<p>非相对模块指的是不带有路径信息的模块。下面 import 语句加载的模块，都是非相对模块。</p>
<ul>
<li><p>import * as $ from “jquery”;</p>
</li>
<li><p>import { Component } from “@angular/core”;</p>
</li>
</ul>
<h4 id="15-5-2-Classic-方法"><a href="#15-5-2-Classic-方法" class="headerlink" title="15.5.2 Classic 方法"></a>15.5.2 Classic 方法</h4><p>Classic 方法以当前脚本的路径作为“基准路径”，计算相对模块的位置。比如，脚本a.ts里面有一行代码import { b } from “./b”，那么 TypeScript 就会在a.ts<br>所在的目录，查找b.ts和b.d.ts。<br>至于非相对模块，也是以当前脚本的路径作为起点，一层层查找上级目录。比如，脚本a.ts里面有一行代码import { b } from “b”，那么就会查找b.ts和b.d.ts。</p>
<h4 id="15-5-3-Node-方法"><a href="#15-5-3-Node-方法" class="headerlink" title="15.5.3 Node 方法"></a>15.5.3 Node 方法</h4><p>Node 方法就是模拟 Node.js 的模块加载方法。<br>相对模块依然是以当前脚本的路径作为“基准路径”。比如，脚本文件a.ts里面有一行代码let x = require(“./b”);，TypeScript 按照以下顺序查找。</p>
<ol>
<li>当前目录是否包含b.ts、b.tsx、b.d.ts。</li>
<li>当前目录是否有子目录b，该子目录是否存在文件package.json，该文件的<br>types字段是否指定了入口文件，如果是的就加载该文件。</li>
<li>当前目录的子目录b是否包含index.ts、index.tsx、index.d.ts。</li>
</ol>
<p>非相对模块则是以当前脚本的路径作为起点，逐级向上层目录查找是否存在子目录node_modules。比如，脚本文件a.js有一行let x = require(“b”);，<br>TypeScript 按照以下顺序进行查找。</p>
<ol>
<li>当前目录的子目录node_modules是否包含b.ts、b.tsx、b.d.ts。</li>
<li>当前目录的子目录node_modules，是否存在文件package.json，该文件的types字段是否指定了入口文件，如果是的就加载该文件。</li>
<li>当前目录的子目录node_modules里面，是否包含子目录@types，在该目录中查找文件b.d.ts。</li>
<li>当前目录的子目录node_modules里面，是否包含子目录b，在该目录中查找index.ts、index.tsx、index.d.ts。</li>
<li>进入上一层目录，重复上面4步，直到找到为止。</li>
</ol>
<h4 id="15-5-4-路径映射"><a href="#15-5-4-路径映射" class="headerlink" title="15.5.4 路径映射"></a>15.5.4 路径映射</h4><p>TypeScript 允许开发者在tsconfig.json文件里面，手动指定脚本模块的路径。</p>
<p>（1）baseUrl</p>
<p>baseUrl字段可以手动指定脚本模块的基准目录。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//上面示例中，baseUrl是一个点，表示基准目录就是tsconfig.json所在的目录。</span></span><br></pre></td></tr></table></figure>

<p>（2）paths<br>paths字段指定非相对路径的模块与实际脚本的映射。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;jquery&quot;</span>: [<span class="string">&quot;node_modules/jquery/dist/jquery&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//上面示例中，加载模块jquery时，实际加载的脚本是</span></span><br><span class="line"><span class="comment">//node_modules/jquery/dist/jquery，它的位置要根据baseUrl字段计算得到。</span></span><br><span class="line"><span class="comment">//注意，上例的jquery属性的值是一个数组，可以指定多个路径。如果第一个脚本路</span></span><br><span class="line"><span class="comment">//径不存在，那么就加载第二个路径，以此类推。</span></span><br></pre></td></tr></table></figure>

<p>（3）rootDirs<br>rootDirs字段指定模块定位时必须查找的其他目录。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rootDirs&quot;</span>: [<span class="string">&quot;src/zh&quot;</span>, <span class="string">&quot;src/de&quot;</span>, <span class="string">&quot;src/#&#123;locale&#125;&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//上面示例中，rootDirs指定了模块定位时，需要查找的不同的国际化目录。</span></span><br></pre></td></tr></table></figure>

<h4 id="15-5-5-tsc-的–traceResolution参数"><a href="#15-5-5-tsc-的–traceResolution参数" class="headerlink" title="15.5.5 tsc 的–traceResolution参数"></a>15.5.5 tsc 的–traceResolution参数</h4><p>由于模块定位的过程很复杂，tsc 命令有一个–traceResolution参数，能够在编译时在命令行显示模块定位的每一步。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --traceResolution </span><br><span class="line"><span class="comment">//traceResolution会输出模块定位的判断过程。</span></span><br></pre></td></tr></table></figure>

<h4 id="15-5-6-tsc-的–noResolve参数"><a href="#15-5-6-tsc-的–noResolve参数" class="headerlink" title="15.5.6 tsc 的–noResolve参数"></a>15.5.6 tsc 的–noResolve参数</h4><p>tsc 命令的–noResolve参数，表示模块定位时，只考虑在命令行传入的模块。</p>
<p>举例来说，app.ts包含如下两行代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> A <span class="keyword">from</span> <span class="string">&quot;moduleA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> B <span class="keyword">from</span> <span class="string">&quot;moduleB&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>使用下面的命令进行编译。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tsc app.<span class="property">ts</span> moduleA.<span class="property">ts</span> --noResolve </span><br><span class="line"><span class="comment">// 上面命令使用--noResolve参数，因此可以定位到moduleA.ts，因为它从命令行传</span></span><br><span class="line"><span class="comment">//入了；无法定位到moduleB，因为它没有传入，因此会报错。</span></span><br></pre></td></tr></table></figure>

<h2 id="十六、TypeScript-namespace"><a href="#十六、TypeScript-namespace" class="headerlink" title="十六、TypeScript namespace"></a>十六、TypeScript namespace</h2><p>namespace 是一种将相关代码组织在一起的方式，中文译为“命名空间”。</p>
<h3 id="16-1-基本用法"><a href="#16-1-基本用法" class="headerlink" title="16.1 基本用法"></a>16.1 基本用法</h3><p>namespace 用来建立一个容器，内部的所有变量和函数，都必须在这个容器里面使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&#x27;no&#x27;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果要在命名空间以外使用内部成员，就必须为该成员加上export前缀，表示对外输出该成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">log</span>(<span class="string">&#x27;Call me&#x27;</span>);</span><br><span class="line"><span class="title class_">Utility</span>.<span class="title function_">error</span>(<span class="string">&#x27;maybe!&#x27;</span>); </span><br><span class="line"><span class="comment">//只要加上export前缀，就可以在命名空间外部使用内部成员。</span></span><br></pre></td></tr></table></figure>

<p>编译出来的 JavaScript 代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Utility</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Utility</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Utility</span>.<span class="property">log</span> = log;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Utility</span>.<span class="property">error</span> = error;</span><br><span class="line">&#125;)(<span class="title class_">Utility</span> || (<span class="title class_">Utility</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>上面代码中，命名空间Utility变成了 JavaScript 的一个对象，凡是export的内部成员，都成了该对象的属性。<br>这就是说，namespace 会变成一个值，保留在编译后的代码中。这一点要小心，它不是纯的类型代码。<br>namespace 内部还可以使用import命令输入外部成员，相当于为外部成员起别名。当外部成员的名字比较长时，别名能够简化代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">value:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> isString = <span class="title class_">Utils</span>.<span class="property">isString</span>;</span><br><span class="line">  <span class="title function_">isString</span>(<span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="title class_">Utils</span>.<span class="title function_">isString</span>(<span class="string">&#x27;yes&#x27;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//import命令指定在命名空间App里面，外部成员Utils.isString的别名为isString。</span></span><br></pre></td></tr></table></figure>

<p>import命令也可以在 namespace 外部，指定别名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Polygons</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> polygons = <span class="title class_">Shapes</span>.<span class="property">Polygons</span>;</span><br><span class="line"><span class="comment">// 等同于 new Shapes.Polygons.Square()</span></span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.<span class="title class_">Square</span>(); </span><br><span class="line"><span class="comment">//import命令在命名空间Shapes的外部，指定 Shapes.Polygons的别名为polygons。</span></span><br></pre></td></tr></table></figure>

<p>namespace 可以嵌套。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Messaging</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Utils</span>.<span class="property">Messaging</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，如果要在外部使用Messaging，必须在它前面加上export命令。<br>使用嵌套的命名空间，必须从最外层开始引用，比如Utils.Messaging.log()。<br>namespace 不仅可以包含实义代码，还可以包括类型代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>namespace 与模块的作用是一致的，都是把相关代码组织在一起，对外输出接口。区别是一个文件只能有一个模块，但可以有多个 namespace。由于模块可以取代namespace，而且是 JavaScript 的标准语法，还不需要编译转换，所以建议总是使用模块，替代 namespace。</p>
<p>如果 namespace 代码放在一个单独的文件里，那么引入这个文件需要使用三斜杠的语法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="16-2-namespace-的输出"><a href="#16-2-namespace-的输出" class="headerlink" title="16.2 namespace 的输出"></a>16.2 namespace 的输出</h3><p>namespace 本身也可以使用export命令输出，供其他文件使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他脚本文件使用import命令，加载这个命名空间。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Shapes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./shapes&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">Shapes</span>.<span class="title class_">Triangle</span>();</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">&quot;./shapes&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.<span class="property">Shapes</span>.<span class="title class_">Triangle</span>();</span><br></pre></td></tr></table></figure>

<p>不过，更好的方法还是建议使用模块，采用模块的输出和输入。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shapes.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shapeConsumer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shapes <span class="keyword">from</span> <span class="string">&quot;./shapes&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> shapes.<span class="title class_">Triangle</span>();</span><br></pre></td></tr></table></figure>

<h3 id="16-3-namespace-的合并"><a href="#16-3-namespace-的合并" class="headerlink" title="16.3 namespace 的合并"></a>16.3 namespace 的合并</h3><p>多个同名的 namespace 会自动合并，这一点跟 interface 一样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Legged</span> &#123;</span><br><span class="line">    <span class="attr">numberOfLegs</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Animals</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Legged</span> &#123;</span><br><span class="line">    <span class="attr">numberOfLegs</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的目的是，如果同名的命名空间分布在不同的文件中，TypeScript 最终会它们合并在一起。这样就比较方便扩展别人的代码。<br>合并命名空间时，命名空间中的非export的成员不会被合并，但是它们只能在各自的命名空间中使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">foo</span>(); <span class="comment">// 正确</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间还可以跟同名函数合并，但是要求同名函数必须在命名空间之前声明。这样做是为了确保先创建出一个函数对象，然后同名的命名空间就相当于给这个函数对象添加额外的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> f.<span class="property">version</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> f &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> version = <span class="string">&#x27;1.0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>()   <span class="comment">// &#x27;1.0&#x27;</span></span><br><span class="line">f.<span class="property">version</span> <span class="comment">// &#x27;1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>命名空间也能与同名 class 合并，同样要求class 必须在命名空间之前声明，原因同上。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> C &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">C.<span class="property">bar</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>命名空间还能于同名 Enum 合并。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> E &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(E.<span class="property">C</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">E.<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>注意，Enum 成员与命名空间导出成员不允许同名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  A, <span class="comment">// 报错</span></span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> E &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十七、TypeScript-装饰器"><a href="#十七、TypeScript-装饰器" class="headerlink" title="十七、TypeScript 装饰器"></a>十七、TypeScript 装饰器</h2><h3 id="17-1-简介"><a href="#17-1-简介" class="headerlink" title="17.1 简介"></a>17.1 简介</h3><p>装饰器（Decorator）是一种语法结构，用来在定义时修改类（class）的行为。<br>在语法上，装饰器有如下几个特征。<br>（1）第一个字符（或者说前缀）是@，后面是一个表达式。<br>（2）@后面的表达式，必须是一个函数（或者执行后可以得到一个函数）。<br>（3）这个函数接受所修饰对象的一些相关值作为参数。<br>（4）这个函数要么不返回值，要么返回一个新对象取代所修饰的目标对象。</p>
<p>下面就是一个最简单的装饰器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDecorator</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  context:<span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi, this is &#x27;</span> + target);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@simpleDecorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125; <span class="comment">// &quot;hi, this is class A &#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>类A在执行前会先执行装饰器simpleDecorator()，并且会向装饰器自动传入参数就可以了。<br>装饰器有多种形式，基本上只要在@符号后面添加表达式都是可以的。下面都是合法的装饰器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@myFunc</span></span><br><span class="line"><span class="meta">@myFuncFactory</span>(arg1, arg2)</span><br><span class="line"><span class="meta">@libraryModule</span>.<span class="property">prop</span></span><br><span class="line"><span class="meta">@someObj</span>.<span class="title function_">method</span>(<span class="number">123</span>)</span><br><span class="line">@(<span class="title function_">wrap</span>(dict[<span class="string">&#x27;prop&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>注意，@后面的表达式，最终执行后得到的应该是一个函数。<br>相比使用子类改变父类，装饰器更加简洁优雅，缺点是不那么直观，功能也受到一些限制。所以，装饰器一般只用来为类添加某种特定行为。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@frozen</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="meta">@enumerable</span>(<span class="literal">true</span>)</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@throttle</span>(<span class="number">500</span>)</span><br><span class="line">  <span class="title function_">expensiveMethod</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，一共有四个装饰器，一个用在类本身（@frozen），另外三个用在类的方法（@configurable、@enumerable、@throttle）。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。</p>
<h3 id="17-2-装饰器的版本"><a href="#17-2-装饰器的版本" class="headerlink" title="17.2 装饰器的版本"></a>17.2 装饰器的版本</h3><p>目前，TypeScript 5.0 同时支持两种装饰器语法。标准语法可以直接使用，传统语法需要打开–experimentalDecorators编译参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --target <span class="title class_">ES5</span> --experimentalDecorators</span><br></pre></td></tr></table></figure>

<h3 id="17-3-装饰器的结构"><a href="#17-3-装饰器的结构" class="headerlink" title="17.3 装饰器的结构"></a>17.3 装饰器的结构</h3><p>装饰器函数的类型定义如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Decorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: DecoratedValue,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="built_in">string</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer?(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>?: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      get?(): <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">      set?(value: <span class="built_in">unknown</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span> | <span class="title class_">ReplacementValue</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Decorator是装饰器的类型定义。它是一个函数，使用时会接收到<br>value和context两个参数。</p>
<ul>
<li><p>value：所装饰的对象。</p>
</li>
<li><p>context：上下文对象，TypeScript 提供一个原生接口ClassMethodDecoratorContext，描述这个对象。</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decorator</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  context:ClassMethodDecoratorContext</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个装饰器函数，其中第二个参数context的类型就可以写成ClassMethodDecoratorContext。</p>
<p>context对象的属性，根据所装饰对象的不同而不同，其中只有两个属性（kind和name）是必有的，其他都是可选的。<br>（1）kind：字符串，表示所装饰对象的类型，可能取以下的值。</p>
<ul>
<li><p>‘class’</p>
</li>
<li><p>‘method’</p>
</li>
<li><p>‘getter’</p>
</li>
<li><p>‘setter’</p>
</li>
<li><p>‘field’</p>
</li>
<li><p>‘accessor’</p>
</li>
</ul>
<p>这表示一共有六种类型的装饰器。</p>
<p>（2）name：字符串或者 Symbol 值，所装饰对象的名字，比如类名、属性名等。<br>（3）addInitializer()：函数，用来添加类的初始化逻辑。以前，这些逻辑通常放在构造函数里面，对方法进行初始化，现在改成以函数形式传入addInitializer()方法。注意，addInitializer()没有返回值。<br>（4）private：布尔值，表示所装饰的对象是否为类的私有成员。<br>（5）static：布尔值，表示所装饰的对象是否为类的静态成员。<br>（6）access：一个对象，包含了某个值的 get 和 set 方法。</p>
<h3 id="17-4-类装饰器"><a href="#17-4-类装饰器" class="headerlink" title="17.4 类装饰器"></a>17.4 类装饰器</h3><p>类装饰器的类型描述如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;class&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>类装饰器接受两个参数：value（当前类本身）和context（上下文对象）。其中，context对象的kind属性固定为字符串class。<br>类装饰器一般用来对类进行操作，可以不返回任何值，请看下面的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    value.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.<span class="title function_">greet</span>(); <span class="comment">// &quot;你好&quot; </span></span><br><span class="line"><span class="comment">//类装饰器@Greeter在类User的原型对象上，添加了一个greet()方法，实例就可以直接使用该方法。</span></span><br></pre></td></tr></table></figure>

<p>类装饰器可以返回一个函数，替代当前类的构造方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value:<span class="built_in">any</span>, context:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> wrapper = <span class="keyword">function</span> (<span class="params">...args:<span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    instanceCount++;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    instance.<span class="property">count</span> = instanceCount;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">MyClass</span>;</span><br><span class="line">  wrapper.<span class="property"><span class="keyword">prototype</span></span> = value.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// A</span></span><br><span class="line">  <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span> <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span> <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">//类装饰器@countInstances返回一个函数，替换了类MyClass的构造方法。新的构造方法实现了实例的计数，每新建一个实例，计数器就会加一，并且对实例添加count属性，表示当前实例的编号。</span></span><br></pre></td></tr></table></figure>

<p>注意，上例为了确保新构造方法继承定义在MyClass的原型之上的成员，特别加入A行，确保两者的原型对象是一致的。否则，新的构造函数wrapper的原型对象，与MyClass不同，通不过instanceof运算符。</p>
<p>类装饰器也可以返回一个新的类，替代原来所装饰的类。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countInstances</span>(<span class="params">value:<span class="built_in">any</span>, context:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instanceCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> value &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(...args);</span><br><span class="line">      instanceCount++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = instanceCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@countInstances</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> inst1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">inst1 <span class="keyword">instanceof</span> <span class="title class_">MyClass</span> <span class="comment">// true</span></span><br><span class="line">inst1.<span class="property">count</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>下面的例子是通过类装饰器，禁止使用new命令新建类的实例。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionCallable</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value <span class="keyword">as</span> <span class="built_in">any</span>, &#123;kind&#125; <span class="keyword">as</span> <span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;This function can’t be new-invoked&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">value</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@functionCallable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> robin = <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line">robin.<span class="property">name</span> <span class="comment">// &#x27;Robin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类装饰器的上下文对象context的addInitializer()方法，用来定义一个类的初始化函数，在类完全定义结束后执行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">customElement</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;<span class="title class_">Input</span> <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    value: Input,</span></span></span><br><span class="line"><span class="params"><span class="function">    context: ClassDecoratorContext</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> &#123;</span><br><span class="line">    context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      customElements.<span class="title function_">define</span>(name, value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@customElement</span>(<span class="string">&quot;hello-world&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;h1&gt;Hello World&lt;/h1&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//上面示例中，类MyComponent定义完成后，会自动执行类装饰器@customElement()给出的初始化函数，该函数会将当前类注册为指定名称（本例为&lt;hello-world&gt;）的自定义 HTML 元素。</span></span><br></pre></td></tr></table></figure>

<h3 id="17-5-方法装饰器"><a href="#17-5-方法装饰器" class="headerlink" title="17.5 方法装饰器"></a>17.5 方法装饰器</h3><p>方法装饰器用来装饰类的方法（method）。它的类型描述如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassMethodDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;method&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>方法装饰器是一个函数，接受两个参数：value和context。<br>参数value是方法本身，参数context是上下文对象，有以下属性。</p>
<ul>
<li><p>kind：值固定为字符串method，表示当前为方法装饰器。</p>
</li>
<li><p>name：所装饰的方法名，类型为字符串或 Symbol 值。</p>
</li>
<li><p>static：布尔值，表示是否为静态方法。该属性为只读属性。</p>
</li>
<li><p>private：布尔值，表示是否为私有方法。该属性为只读属性。</p>
</li>
<li><p>access：对象，包含了方法的存取器，但是只有get()方法用来取值，没有</p>
</li>
<li><p>set()方法进行赋值。</p>
</li>
<li><p>addInitializer()：为方法增加初始化函数。</p>
</li>
</ul>
<p>方法装饰器会改写类的原始方法，实质等同于下面的操作。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trace</span>(<span class="params">decoratedMethod</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@trace</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `@trace` 等同于</span></span><br><span class="line"><span class="comment">// C.prototype.toString = trace(C.prototype.toString);</span></span><br></pre></td></tr></table></figure>

<p>如果方法装饰器返回一个新的函数，就会替代所装饰的原始函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`How are you, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>?`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@replaceMethod</span></span><br><span class="line">  <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> robin = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Robin&#x27;</span>);</span><br><span class="line">robin.<span class="title function_">hello</span>() <span class="comment">// &#x27;How are you, Robin?&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器@replaceMethod返回的函数，就成为了新的hello()方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">originalMethod:<span class="built_in">any</span>, </span></span><br><span class="line"><span class="params">context:ClassMethodDecoratorContext</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> methodName = <span class="title class_">String</span>(context.<span class="property">name</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">replacementMethod</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`LOG: Entering method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27;.`</span>)</span><br><span class="line">    <span class="keyword">const</span> result = originalMethod.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`LOG: Exiting method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27;.`</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> replacementMethod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">person.<span class="title function_">greet</span>()</span><br><span class="line"><span class="comment">// &quot;LOG: Entering method &#x27;greet&#x27;.&quot;</span></span><br><span class="line"><span class="comment">// &quot;Hello, my name is 张三.&quot;</span></span><br><span class="line"><span class="comment">// &quot;LOG: Exiting method &#x27;greet&#x27;.&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器@log的返回值是一个函数replacementMethod，替代了原始方法greet()。在replacementMethod()内部，通过执行originalMethod.call()完成了对原始方法的调用。<br>利用方法装饰器，可以将类的方法变成延迟执行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">milliseconds: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">value, context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">kind</span> === <span class="string">&quot;method&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          value.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, milliseconds);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="meta">@delay</span>(<span class="number">1000</span>)</span><br><span class="line">  <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> logger = <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">logger.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，方法装饰器@delay(1000)将方法log()的执行推迟了1秒（1000毫秒）。这里真正的方法装饰器，是delay()执行后返回的函数，delay()的作用是接收参数，用来设置推迟执行的时间。这种通过高阶函数返回装饰器的做法，称为“工厂模式”，即可以像工厂那样生产出一个模子的装饰器。<br>方法装饰器的参数context对象里面，有一个addInitializer()方法。它是一个钩子方法，用来在类的初始化阶段，添加回调函数。这个回调函数就是作为addInitializer()的参数传入的，它会在构造方法执行期间执行，早于属性（field）的初始化。<br>下面是addInitializer()方法的一个例子。我们知道，类的方法往往需要在构造方法里面，进行this的绑定。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="comment">// greet() 绑定 this</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greet</span> = <span class="variable language_">this</span>.<span class="property">greet</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>).<span class="property">greet</span>;</span><br><span class="line"><span class="title function_">g</span>() <span class="comment">// &quot;Hello, my name is 张三.&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，类Person的构造方法内部，将this与greet()方法进行了绑定。如果没有这一行，将greet()赋值给变量g进行调用，就会报错了。<br>this的绑定必须放在构造方法里面，因为这必须在类的初始化阶段完成。现在，它可以移到方法装饰器的addInitializer()里面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params"></span></span><br><span class="line"><span class="params">  originalMethod:<span class="built_in">any</span>, context:ClassMethodDecoratorContext</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> methodName = context.<span class="property">name</span>;</span><br><span class="line">  <span class="keyword">if</span> (context.<span class="property">private</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`不能绑定私有方法 <span class="subst">$&#123;methodName <span class="keyword">as</span> <span class="built_in">string</span>&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context.<span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[methodName] = <span class="variable language_">this</span>[methodName].<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面再看一个例子，通过addInitializer()将选定的方法名，放入一个集合。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">collect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value,</span></span><br><span class="line"><span class="params">  &#123;name, addInitializer&#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">addInitializer</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">collectedMethodKeys</span>.<span class="title function_">add</span>(name);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@collect</span></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@collect</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="meta">@collect</span> <span class="comment">// new Set([&#x27;toString&#x27;, Symbol.iterator])</span></span><br></pre></td></tr></table></figure>

<h3 id="17-6-属性装饰器"><a href="#17-6-属性装饰器" class="headerlink" title="17.6 属性装饰器"></a>17.6 属性装饰器</h3><p>属性装饰器用来装饰定义在类顶部的属性（field）。它的类型描述如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassFieldDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;field&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span>, set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>注意，装饰器的第一个参数value的类型是undefined，这意味着这个参数实际上没用的，装饰器不能从value获取所装饰属性的值。另外，第二个参数context对象的kind属性的值为字符串field，而不是“property”或“attribute”，这一点是需要注意的。<br>属性装饰器要么不返回值，要么返回一个函数，该函数会自动执行，用来对所装饰属性进行初始化。该函数的参数是所装饰属性的初始值，该函数的返回值是该属性的最终值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, name &#125; = context;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;field&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">initialValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`initializing <span class="subst">$&#123;name&#125;</span> with value </span></span><br><span class="line"><span class="string"><span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> name = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> color = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line"><span class="comment">// &quot;initializing name with value green&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性装饰器@logged装饰属性name。@logged的返回值是一个函数，该函数用来对属性name进行初始化，它的参数initialValue就是属性name的初始值green。新建实例对象color时，该函数会自动执行。</p>
<p>属性装饰器的返回值函数，可以用来更改属性的初始值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twice</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">initialValue</span> =&gt;</span> initialValue * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@twice</span></span><br><span class="line">  field = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">field</span> <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>属性装饰器的上下文对象context的access属性，提供所装饰属性的存取器，请看<br>下面的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> acc;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exposeAccess</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value, &#123;access&#125;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  acc = access;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="meta">@exposeAccess</span></span><br><span class="line">  name = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> green = <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">green.<span class="property">name</span> <span class="comment">// &#x27;green&#x27;</span></span><br><span class="line">acc.<span class="title function_">get</span>(green) <span class="comment">// &#x27;green&#x27;</span></span><br><span class="line">acc.<span class="title function_">set</span>(green, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">green.<span class="property">name</span> <span class="comment">// &#x27;red&#x27; </span></span><br><span class="line"><span class="comment">//上面示例中，access包含了属性name的存取器，可以对该属性进行取值和赋值。</span></span><br></pre></td></tr></table></figure>

<h3 id="17-7-getter-装饰器，setter-装饰器"><a href="#17-7-getter-装饰器，setter-装饰器" class="headerlink" title="17.7 getter 装饰器，setter 装饰器"></a>17.7 getter 装饰器，setter 装饰器</h3><p>getter 装饰器和 setter 装饰器，是分别针对类的取值器（getter）和存值器（setter）的装饰器。它们的类型描述如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassGetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;getter&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get: () =&gt; <span class="built_in">unknown</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ClassSetterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&#x27;setter&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; set: (value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">Function</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>注意，getter 装饰器的上下文对象context的access属性，只包含get()方法；setter 装饰器的access属性，只包含set()方法。<br>这两个装饰器要么不返回值，要么返回一个函数，取代原来的取值器或存值器。<br>下面的例子是将取值器的结果，保存为一个属性，加快后面的读取。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@lazy</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在计算……&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;开销大的计算结果&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  &#123;kind, name&#125;:<span class="built_in">any</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&#x27;getter&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = value.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">        <span class="variable language_">this</span>, name,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">value</span>: result,</span><br><span class="line">          <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">inst.<span class="property">value</span></span><br><span class="line"><span class="comment">// 正在计算……</span></span><br><span class="line"><span class="comment">// &#x27;开销大的计算结果&#x27;</span></span><br><span class="line">inst.<span class="property">value</span></span><br><span class="line"><span class="comment">// &#x27;开销大的计算结果&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，第一次读取inst.value，会进行计算，然后装饰器@lazy将结果存入只读属性value，后面再读取这个属性，就不会进行计算了。</p>
<h3 id="17-8-accessor-装饰器"><a href="#17-8-accessor-装饰器" class="headerlink" title="17.8 accessor 装饰器"></a>17.8 accessor 装饰器</h3><p>装饰器语法引入了一个新的属性修饰符accessor。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  accessor x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>accessor修饰符等同于为属性x自动生成取值器和存值器，它们作用于私有属性x。也就是说，上面的代码等同于下面的代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">x</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">x</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#x = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>accessor也可以与静态属性和私有属性一起使用。 </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> accessor x = <span class="number">1</span>;</span><br><span class="line">  accessor #y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>accessor 装饰器的类型如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassAutoAccessorDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    get: () =&gt; <span class="built_in">unknown</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    set(value: <span class="built_in">unknown</span>) =&gt; <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    kind: <span class="string">&quot;accessor&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="built_in">string</span> | <span class="built_in">symbol</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    access: &#123; get(): <span class="built_in">unknown</span>, set(value: <span class="built_in">unknown</span>): <span class="built_in">void</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>: <span class="built_in">boolean</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    addInitializer(initializer: () =&gt; <span class="built_in">void</span>): <span class="built_in">void</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  get?: <span class="function">() =&gt;</span> <span class="built_in">unknown</span>;</span><br><span class="line">  set?: <span class="function">(<span class="params">value: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  init?: <span class="function">(<span class="params">initialValue: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">unknown</span>;</span><br><span class="line">&#125; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>accessor 装饰器的value参数，是一个包含get()方法和set()方法的对象。该装饰器可以不返回值，或者返回一个新的对象，用来取代原来的get()方法和set()方法。此外，装饰器返回的对象还可以包括一个init()方法，用来改变私有属性的初始值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@logged</span> accessor x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logged</span>(<span class="params">value, &#123; kind, name &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kind === <span class="string">&quot;accessor&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; get, set &#125; = value;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> get.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;name&#125;</span> to <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> set.<span class="title function_">call</span>(<span class="variable language_">this</span>, val);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">init</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`initializing <span class="subst">$&#123;name&#125;</span> with value </span></span><br><span class="line"><span class="string"><span class="subst">$&#123;initialValue&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> initialValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">x</span>;</span><br><span class="line"><span class="comment">// getting x</span></span><br><span class="line">c.<span class="property">x</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setting x to 123 </span></span><br><span class="line"><span class="comment">//装饰器@logged为属性x的存值器和取值器，加上了日志输出。</span></span><br></pre></td></tr></table></figure>

<h3 id="17-9-装饰器的执行顺序"><a href="#17-9-装饰器的执行顺序" class="headerlink" title="17.9 装饰器的执行顺序"></a>17.9 装饰器的执行顺序</h3><p>装饰器的执行分为两个阶段。</p>
<p>（1）评估（evaluation）：计算@符号后面的表达式的值，得到的应该是函数。<br>（2）应用（application）：将评估装饰器后得到的函数，应用于所装饰对象。<br>也就是说，装饰器的执行顺序是，先评估所有装饰器表达式的值，再将其应用于当前类。<br>应用装饰器时，顺序依次为方法装饰器和属性装饰器，然后是类装饰器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">d</span>(<span class="params">str:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`评估 @d(): <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    value:<span class="built_in">any</span>, context:<span class="built_in">any</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`应用 @d(): <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">str:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@d</span>(<span class="string">&#x27;类装饰器&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">  <span class="meta">@d</span>(<span class="string">&#x27;静态属性装饰器&#x27;</span>)</span><br><span class="line">  <span class="keyword">static</span> staticField = <span class="title function_">log</span>(<span class="string">&#x27;静态属性值&#x27;</span>);</span><br><span class="line">  <span class="meta">@d</span>(<span class="string">&#x27;原型方法&#x27;</span>)</span><br><span class="line">  [<span class="title function_">log</span>(<span class="string">&#x27;计算方法名&#x27;</span>)]() &#123;&#125;</span><br><span class="line">  <span class="meta">@d</span>(<span class="string">&#x27;实例属性&#x27;</span>)</span><br><span class="line">  instanceField = <span class="title function_">log</span>(<span class="string">&#x27;实例属性值&#x27;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// &quot;评估 @d(): 类装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;评估 @d(): 静态属性装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;评估 @d(): 原型方法&quot;</span></span><br><span class="line"><span class="comment">// &quot;计算方法名&quot;</span></span><br><span class="line"><span class="comment">// &quot;评估 @d(): 实例属性&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 原型方法&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 静态属性装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 实例属性&quot;</span></span><br><span class="line"><span class="comment">// &quot;应用 @d(): 类装饰器&quot;</span></span><br><span class="line"><span class="comment">// &quot;静态属性值&quot;</span></span><br></pre></td></tr></table></figure>

<p>类载入的时候，代码按照以下顺序执行。<br>（1）装饰器评估：这一步计算装饰器的值，首先是类装饰器，然后是类内部的装饰器，按照它们出现的顺序。<br>注意，如果属性名或方法名是计算值（本例是“计算方法名”），则它们在对应的装饰器评估之后，也会进行自身的评估。<br>（2）装饰器应用：实际执行装饰器函数，将它们与对应的方法和属性进行结合。<br>原型方法的装饰器首先应用，然后是静态属性和静态方法装饰器，接下来是实例属性装饰器，最后是类装饰器。<br>注意，“实例属性值”在类初始化的阶段并不执行，直到类实例化时才会执行。<br>如果一个方法或属性有多个装饰器，则内层的装饰器先执行，外层的装饰器后执行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@bound</span></span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//greet()有两个装饰器，内层的@log先执行，外层的@bound针对得到的结果再执行。</span></span><br></pre></td></tr></table></figure>

<h2 id="十八、装饰器（旧语法）"><a href="#十八、装饰器（旧语法）" class="headerlink" title="十八、装饰器（旧语法）"></a>十八、装饰器（旧语法）</h2><p>TypeScript 早在2014年就支持装饰器，不过使用的是旧语法。</p>
<h3 id="18-1-experimentalDecorators-编译选项"><a href="#18-1-experimentalDecorators-编译选项" class="headerlink" title="18.1 experimentalDecorators 编译选项"></a>18.1 experimentalDecorators 编译选项</h3><p>使用装饰器的旧语法，需要打开–experimentalDecorators编译选项。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --target <span class="title class_">ES5</span> --experimentalDecorators</span><br></pre></td></tr></table></figure>

<p>此外，还有另外一个编译选项–emitDecoratorMetadata，用来产生一些装饰器的元数据，供其他工具或某些模块（比如 reflect-metadata ）使用。<br>这两个编译选项可以在命令行设置，也可以在tsconfig.json文件里面进行设置。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-2-装饰器的种类"><a href="#18-2-装饰器的种类" class="headerlink" title="18.2 装饰器的种类"></a>18.2 装饰器的种类</h3><p>按照所装饰的不同对象，装饰器可以分成五类。</p>
<ul>
<li><p>类装饰器（Class Decorators）：用于类。</p>
</li>
<li><p>属性装饰器（Property Decorators）：用于属性。</p>
</li>
<li><p>方法装饰器（Method Decorators）：用于方法。</p>
</li>
<li><p>存取器装饰器（Accessor Decorators）：用于类的 set 或 get 方法。</p>
</li>
<li><p>参数装饰器（Parameter Decorators）：用于方法的参数。</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ClassDecorator</span>() <span class="comment">// （A）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="meta">@PropertyDecorator</span>() <span class="comment">// （B）</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@MethodDecorator</span>() <span class="comment">//（C）</span></span><br><span class="line">  <span class="title function_">fly</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@ParameterDecorator</span>() <span class="comment">// （D）</span></span></span><br><span class="line"><span class="params">    meters: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AccessorDecorator</span>() <span class="comment">// （E）</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">egg</span>() &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">egg</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//A 是类装饰器，B 是属性装饰器，C 是方法装饰器，D 是参数装饰器，E 是存取器装饰器。</span></span><br></pre></td></tr></table></figure>

<p>注意，构造方法没有方法装饰器，只有参数装饰器。类装饰器其实就是在装饰构造方法。<br>另外，装饰器只能用于类，要么应用于类的整体，要么应用于类的内部成员，不能用于独立的函数。</p>
<h3 id="18-3-类装饰器"><a href="#18-3-类装饰器" class="headerlink" title="18.3 类装饰器"></a>18.3 类装饰器</h3><p>类装饰器应用于类（class），但实际上是应用于类的构造方法。<br>类装饰器有唯一参数，就是构造方法，可以在装饰器内部，对构造方法进行各种改造。如果类装饰器有返回值，就会替换掉原来的构造方法。<br>类装饰器的类型定义如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = &lt;<span class="title class_">TFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span>&gt;</span><br><span class="line">  <span class="function">(<span class="params">target: TFunction</span>) =&gt;</span> <span class="title class_">TFunction</span> | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>上面定义中，类型参数TFunction必须是函数，实际上就是构造方法。类装饰器的返回值，要么是返回处理后的原始构造方法，要么返回一个新的构造方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;apply decorator&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@f</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 输出：apply decorator </span></span><br><span class="line"><span class="comment">//使用了装饰器@f，因此类A的构造方法会自动传入f。</span></span><br></pre></td></tr></table></figure>

<p>类A不需要新建实例，装饰器也会执行。装饰器会在代码加载阶段执行，而不是在运行时执行，而且只会执行一次。<br>由于 TypeScript 存在编译阶段，所以装饰器对类的行为的改变，实际上发生在编译阶段。这意味着，TypeScript 装饰器能在编译阶段运行代码，也就是说，它本质就是编译时执行的函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BugReport</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> = <span class="string">&quot;report&quot;</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">t:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sealed</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//装饰器@sealed()会锁定BugReport这个类，使得它无法新增或删除静态成员和实例成员。</span></span><br></pre></td></tr></table></figure>

<p>如果除了构造方法，类装饰器还需要其他参数，可以采取“工厂模式”，即把装饰器写在一个函数里面，该函数可以接受其他参数，执行后返回装饰器。但是，这样就需要调用装饰器的时候，先执行一次工厂函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factory</span>(<span class="params">info:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;received: &#x27;</span>, info);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;apply decorator&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@factory</span>(<span class="string">&#x27;log something&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125; </span><br><span class="line"><span class="comment">//函数factory()的返回值才是装饰器，所以加载装饰器的时候，要先执行一次@factory(&#x27;log something&#x27;)，才能得到装饰器。这样做的好处是，可以加入额外的参数，本例是参数info。</span></span><br></pre></td></tr></table></figure>

<p>总之，@后面要么是一个函数名，要么是函数表达式，甚至可以写出下面这样的代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@(<span class="function">(<span class="params">constructor: <span class="built_in">Function</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;log something&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InlineDecoratorExample</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//@后面是一个箭头函数，这也是合法的。</span></span><br></pre></td></tr></table></figure>

<p>类装饰器可以没有返回值，如果有返回值，就会替代所装饰的类的构造函数。由于JavaScript 的类等同于构造函数的语法糖，所以装饰器通常返回一个新的类，对原有的类进行修改或扩展。</p>
<h3 id="18-4-方法装饰器"><a href="#18-4-方法装饰器" class="headerlink" title="18.4 方法装饰器"></a>18.4 方法装饰器</h3><p>方法装饰器用来装饰类的方法，它的类型定义如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MethodDecorator</span> = &lt;T&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>方法装饰器一共可以接受三个参数。</p>
<ul>
<li><p>target：（对于类的静态方法）类的构造函数，或者（对于类的实例方法）类的原型。</p>
</li>
<li><p>propertyKey：所装饰方法的方法名，类型为string|symbol。</p>
</li>
<li><p>descriptor：所装饰方法的描述对象。</p>
</li>
</ul>
<p>方法装饰器的返回值（如果有的话），就是修改后的该方法的描述对象，可以覆盖原始方法的描述对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    descriptor.<span class="property">enumerable</span> = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法装饰器@enumerable()装饰 Greeter 类的greet()方法，作用是修改该方法的描述对象的可遍历性属性enumerable。@enumerable(false)表示将该方法修改成不可遍历。</p>
<h3 id="18-5-属性装饰器"><a href="#18-5-属性装饰器" class="headerlink" title="18.5 属性装饰器"></a>18.5 属性装饰器</h3><p>属性装饰器用来装饰属性，类型定义如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropertyDecorator</span> =</span><br><span class="line">  <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>属性装饰器函数接受两个参数。</p>
<ul>
<li><p>target：（对于实例属性）类的原型对象（prototype），或者（对于静态属性）类的构造函数。</p>
</li>
<li><p>propertyKey：所装饰属性的属性名，注意类型有可能是字符串，也有可能是Symbol 值。</p>
</li>
</ul>
<p>属性装饰器不需要返回值，如果有的话，也会被忽略。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ValidRange</span>(<span class="params">min:<span class="built_in">number</span>, max:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target:<span class="built_in">Object</span>, key:<span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">      <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">v:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; min || v &gt; max) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Not allowed value <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 Installing ValidRange on year</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="meta">@ValidRange</span>(<span class="number">1920</span>, <span class="number">2020</span>)</span><br><span class="line">  year!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> stud = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// 报错 Not allowed value 2022 </span></span><br><span class="line">stud.<span class="property">year</span> = <span class="number">2022</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器ValidRange对属性year设立了一个上下限检查器，只要该属性赋值时，超过了上下限，就会报错。<br>注意，属性装饰器的第一个参数，对于实例属性是类的原型对象，而不是实例对象（即不是this对象）。这是因为装饰器执行时，类还没有新建实例，所以实例对象不存在。<br>由于拿不到this，所以属性装饰器无法获得实例属性的值。这也是它没有在参数里面提供属性描述对象的原因。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProperty</span>(<span class="params">target: <span class="built_in">Object</span>, member: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prop = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, member);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Property <span class="subst">$&#123;member&#125;</span> <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyExample</span> &#123;</span><br><span class="line">  <span class="meta">@logProperty</span></span><br><span class="line">  <span class="attr">name</span>:<span class="built_in">string</span> = <span class="string">&#x27;Foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 Property name undefined</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，属性装饰器@logProperty内部想要获取实例属性name的属性描述对象，结果拿到的是undefined。因为上例的target是类的原型对象，不是实例对象，所以拿不到name属性，也就是说target.name是不存在的，所以拿到的是undefined。只有通过this.name才能拿到name属性，但是这时this还不存在。<br>属性装饰器不仅无法获得实例属性的值，也不能初始化或修改实例属性，而且它的返回值也会被忽略。因此，它的作用很有限。<br>不过，如果属性装饰器设置了当前属性的存取器（getter/setter），然后在构造函数里面就可以对实例属性进行读写。</p>
<h3 id="18-6-存取器装饰器"><a href="#18-6-存取器装饰器" class="headerlink" title="18.6 存取器装饰器"></a>18.6 存取器装饰器</h3><p>存取器装饰器用来装饰类的存取器（accessor）。所谓“存取器”指的是某个属性的取值器（getter）和存值器（setter）。<br>存取器装饰器的类型定义，与方法装饰器一致。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AccessorDecorator</span> = &lt;T&gt;<span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>存取器装饰器有三个参数。</p>
<ul>
<li><p>target：（对于静态属性的存取器）类的构造函数，或者（对于实例属性的存取器）类的原型。</p>
</li>
<li><p>propertyKey：存取器的属性名。</p>
</li>
<li><p>descriptor：存取器的属性描述对象。</p>
</li>
</ul>
<p>存取器装饰器的返回值（如果有的话），会作为该属性新的描述对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">configurable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    descriptor: PropertyDescriptor</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    descriptor.<span class="property">configurable</span> = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_y</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x:<span class="built_in">number</span>, y:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">x</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_x</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">y</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_y</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，装饰器@configurable(false)关闭了所装饰属性（x和y）的属性描述对象的configurable键（即关闭了属性的可配置性）。</p>
<p>TypeScript 不允许对同一个属性的存取器（getter 和 setter）使用同一个装饰器，也就是说只能装饰两个存取器里面的一个，且必须是排在前面的那一个，否则报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Decorator</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">n:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Decorator</span> <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，下面的写法不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Decorator</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">n:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，@Decorator只装饰它后面第一个出现的存值器（set name()），并不装饰取值器（get name()），所以不报错。<br>装饰器之所以不能同时用于同一个属性的存值器和取值器，原因是装饰器可以从属性描述对象上面，同时拿到取值器和存值器，因此只调用一次就够了。</p>
<h3 id="18-7-参数装饰器"><a href="#18-7-参数装饰器" class="headerlink" title="18.7 参数装饰器"></a>18.7 参数装饰器</h3><p>参数装饰器用来装饰构造方法或者其他方法的参数。它的类型定义如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ParameterDecorator</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parameterIndex: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p>参数装饰器接受三个参数。</p>
<ul>
<li><p>target：（对于静态方法）类的构造函数，或者（对于类的实例方法）类的原型对象。</p>
</li>
<li><p>propertyKey：所装饰的方法的名字，类型为string|symbol。</p>
</li>
<li><p>parameterIndex：当前参数在方法的参数序列的位置（从0开始）。</p>
</li>
</ul>
<p>该装饰器不需要返回值，如果有的话会被忽略。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  propertyKey: <span class="built_in">string</span>|<span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">  parameterIndex: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>(propertyKey)&#125;</span> NO.<span class="subst">$&#123;parameterIndex&#125;</span> </span></span><br><span class="line"><span class="string">Parameter`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="title function_">member</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@log</span> x:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="meta">@log</span> y:<span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`member Paremeters: <span class="subst">$&#123;x&#125;</span> <span class="subst">$&#123;y&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="title function_">member</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// member NO.1 Parameter</span></span><br><span class="line"><span class="comment">// member NO.0 Parameter </span></span><br><span class="line"><span class="comment">// member Paremeters: 5 5</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，参数装饰器会输出参数的位置序号。注意，后面的参数会先输出。</p>
<p>跟其他装饰器不同，参数装饰器主要用于输出信息，没有办法修改类的行为。</p>
<h3 id="18-8-装饰器的执行顺序"><a href="#18-8-装饰器的执行顺序" class="headerlink" title="18.8 装饰器的执行顺序"></a>18.8 装饰器的执行顺序</h3><p>装饰器只会执行一次，就是在代码解析时执行，哪怕根本没有调用类新建实例，也会执行，而且从此就不再执行了。<br>执行装饰器时，按照如下顺序执行。</p>
<ol>
<li>实例相关的装饰器。</li>
<li>静态相关的装饰器。</li>
<li>构造方法的参数装饰器。</li>
<li>类装饰器。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@f</span>(<span class="string">&#x27;类装饰器&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;实例方法&#x27;</span>)</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="meta">@f</span>(<span class="string">&#x27;构造方法参数&#x27;</span>) foo:<span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//执行： 实例方法</span></span><br><span class="line"><span class="comment">//执行： 静态方法</span></span><br><span class="line"><span class="comment">//执行： 构造方法参数</span></span><br><span class="line"><span class="comment">//执行： 类装饰器</span></span><br></pre></td></tr></table></figure>

<p>同一级装饰器的执行顺序，是按照它们的代码顺序。但是，参数装饰器的执行总是早于方法装饰器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;方法1&#x27;</span>)</span><br><span class="line">  <span class="title function_">m1</span>(<span class="params"><span class="meta">@f</span>(<span class="string">&#x27;参数1&#x27;</span>) foo:<span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;属性1&#x27;</span>)</span><br><span class="line">  <span class="attr">p1</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;方法2&#x27;</span>)</span><br><span class="line">  <span class="title function_">m2</span>(<span class="params"><span class="meta">@f</span>(<span class="string">&#x27;参数2&#x27;</span>) foo:<span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;属性2&#x27;</span>)</span><br><span class="line">  <span class="attr">p2</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//执行： 参数1</span></span><br><span class="line"><span class="comment">//执行： 方法1</span></span><br><span class="line"><span class="comment">//执行： 属性1</span></span><br><span class="line"><span class="comment">//执行： 参数2</span></span><br><span class="line"><span class="comment">//执行： 方法2</span></span><br><span class="line"><span class="comment">//执行： 属性2</span></span><br></pre></td></tr></table></figure>

<p>如果同一个方法或属性有多个装饰器，那么装饰器将顺序加载、逆序执行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载：&#x27;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">  <span class="title function_">m1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载： A</span></span><br><span class="line"><span class="comment">// 加载： B</span></span><br><span class="line"><span class="comment">// 加载： C</span></span><br><span class="line"><span class="comment">// 执行： C</span></span><br><span class="line"><span class="comment">// 执行： B</span></span><br><span class="line"><span class="comment">// 执行： A</span></span><br></pre></td></tr></table></figure>

<p>如果同一个方法有多个参数，那么参数也是顺序加载、逆序执行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key:<span class="built_in">string</span></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载：&#x27;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行：&#x27;</span>, key);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@f</span>(<span class="string">&#x27;A&#x27;</span>) a:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    <span class="meta">@f</span>(<span class="string">&#x27;B&#x27;</span>) b:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    <span class="meta">@f</span>(<span class="string">&#x27;C&#x27;</span>) c:<span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载： A</span></span><br><span class="line"><span class="comment">// 加载： B</span></span><br><span class="line"><span class="comment">// 加载： C</span></span><br><span class="line"><span class="comment">// 执行： C</span></span><br><span class="line"><span class="comment">// 执行： B</span></span><br><span class="line"><span class="comment">// 执行： A</span></span><br></pre></td></tr></table></figure>

<h3 id="18-9-为什么装饰器不能用于函数？"><a href="#18-9-为什么装饰器不能用于函数？" class="headerlink" title="18.9 为什么装饰器不能用于函数？"></a>18.9 为什么装饰器不能用于函数？</h3><p>装饰器只能用于类和类的方法，不能用于函数，主要原因是存在函数提升。<br>JavaScript 的函数不管在代码的什么位置，都会提升到代码顶部。</p>
<p>如果允许装饰器可以用于普通函数，那么就有可能导致意想不到的情况。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">@add</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@add</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。<br>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行，没必要写成装饰器。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loggingDecorator</span>(<span class="params">wrapped</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Starting&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finished&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapped = <span class="title function_">loggingDecorator</span>(doSomething);</span><br></pre></td></tr></table></figure>

<h3 id="18-10-多个装饰器的合成"><a href="#18-10-多个装饰器的合成" class="headerlink" title="18.10 多个装饰器的合成"></a>18.10 多个装饰器的合成</h3><p>多个装饰器可以应用于同一个目标对象，可以写在一行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@f</span> <span class="meta">@g</span> x</span><br></pre></td></tr></table></figure>

<p>多个装饰器也可以写成多行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@f</span></span><br><span class="line"><span class="meta">@g</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>多个装饰器的效果，类似于函数的合成，按照从里到外的顺序执行。对于上例来说，就是执行f(g(x))。<br>前面也说过，如果f和g是表达式，那么需要先从外到里求值。</p>
<h2 id="十九、declare-关键字"><a href="#十九、declare-关键字" class="headerlink" title="十九、declare 关键字"></a>十九、declare 关键字</h2><h3 id="19-1-简介"><a href="#19-1-简介" class="headerlink" title="19.1 简介"></a>19.1 简介</h3><p>declare 关键字用来告诉编译器，某个类型是存在的，可以在当前文件中使用。<br>它的主要作用，就是让当前文件可以使用其他文件声明的类型。</p>
<p>declare 关键字可以描述以下类型。</p>
<ul>
<li><p>变量（const、let、var 命令声明）</p>
</li>
<li><p>type 或者 interface 命令声明的类型</p>
</li>
<li><p>class</p>
</li>
<li><p>enum</p>
</li>
<li><p>函数（function）</p>
</li>
<li><p>模块（module）</p>
</li>
<li><p>命名空间（namespace）</p>
</li>
</ul>
<p>declare 关键字的重要特点是，它只是通知编译器某个类型是存在的，不用给出具体实现。</p>
<p>declare 只能用来描述已经存在的变量和数据结构，不能用来声明新的变量和数据结构。另外，所有 declare 语句都不会出现在编译后的文件里面。</p>
<h3 id="19-2-declare-variable"><a href="#19-2-declare-variable" class="headerlink" title="19.2 declare variable"></a>19.2 declare variable</h3><p>declare 关键字可以给出外部变量的类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前脚本使用了其他脚本定义的全局变量x。</span></span><br><span class="line">x = <span class="number">123</span>; <span class="comment">// 报错 </span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量x是其他脚本定义的，当前脚本不知道它的类型，编译器就会报错。<br>这时使用 declare 命令给出它的类型，就不会报错了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果 declare 关键字没有给出变量的具体类型，那么变量类型就是any。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> x;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>下面的例子是脚本使用浏览器全局对象document。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="variable language_">document</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 告诉编译器，变量document的类型是外部定义的（具体定义在 TypeScript 内置文件lib.d.ts）。<br>如果 TypeScript 没有找到document的外部定义，这里就会假定它的类型是any。<br>注意，declare 关键字只用来给出类型描述，是纯的类型代码，不允许设置变量的初始值，即不能涉及值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="19-3-declare-function"><a href="#19-3-declare-function" class="headerlink" title="19.3 declare function"></a>19.3 declare function</h3><p>declare 关键字可以给出外部函数的类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">void</span>;</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，这种单独的函数类型声明语句，只能用于declare命令后面。一方面，TypeScript 不支持单独的函数类型声明语句；另一方面，declare 关键字后面也不能带有函数的具体实现。</p>
<h3 id="19-4-declare-class"><a href="#19-4-declare-class" class="headerlink" title="19.4 declare class"></a>19.4 declare class</h3><p>declare 给出 class 的描述描述写法如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">sleep</span>():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="comment">// 静态成员</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">s0</span>():<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">s1</span>:<span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">a</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">b</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">arg:<span class="built_in">number</span></span>);</span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="title function_">m</span>(<span class="attr">x</span>:<span class="built_in">number</span>, <span class="attr">y</span>:<span class="built_in">number</span>):<span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 存取器</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">c</span>():<span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">c</span>(<span class="params">value:<span class="built_in">number</span></span>);</span><br><span class="line">  <span class="comment">// 索引签名</span></span><br><span class="line">  [<span class="attr">index</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>declare 后面不能给出 Class 的具体实现或初始值。</p>
<h3 id="19-5-declare-module，declare-namespace"><a href="#19-5-declare-module，declare-namespace" class="headerlink" title="19.5 declare module，declare namespace"></a>19.5 declare module，declare namespace</h3><p>如果想把变量、函数、类组织在一起，可以将 declare 与 module 或 namespace 一起使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>():<span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>():<span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="title class_">AnimalLib</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">eat</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">sleep</span>(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="string">&#x27;Fish&#x27;</span> | <span class="string">&#x27;Dog&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，declare 关键字给出了 module 或 namespace 的类型描述。<br>declare module 和 declare namespace 里面，加不加 export 关键字都可以。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">a</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;io&#x27;</span> &#123;</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">filename:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子是当前脚本使用了myLib这个外部库，它有方法makeGreeting()和属性numberOfGreetings。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = myLib.<span class="title function_">makeGreeting</span>(<span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;欢迎词：&#x27;</span> + result);</span><br><span class="line"><span class="keyword">let</span> count = myLib.<span class="property">numberOfGreetings</span>;</span><br></pre></td></tr></table></figure>

<p>myLib的类型描述就可以这样写。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> myLib &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">makeGreeting</span>(<span class="params">s:<span class="built_in">string</span></span>):<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">numberOfGreetings</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>declare 关键字的另一个用途，是为外部模块添加属性和方法时，给出新增部分的类型描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Foo</span> <span class="keyword">as</span> <span class="title class_">Bar</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moduleA&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="attr">custom</span>: &#123;</span><br><span class="line">      <span class="attr">prop1</span>:<span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。一个项目有多个模块，可以在一个模型中，对另一个模块的接口进行类型扩展。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;./a&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，脚本a.ts定义了一个接口A，脚本b.ts为这个接口添加了属性y。declare module ‘./a’ {}表示对a.ts里面的模块，进行类型声明，而同名interface 会自动合并，所以等同于扩展类型。</p>
<p>使用这种语法进行模块的类型扩展时，有两点需要注意：<br>（1）declare module NAME语法里面的模块名NAME，跟 import 和 export 的模块名规则是一样的，且必须跟当前文件加载该模块的语句写法（上例import { A } from ‘./a’）保持一致。<br>（2）不能创建新的顶层类型。也就是说，只能对a.ts模块中已经存在的类型进行扩展，不允许增加新的顶层类型，比如新定义一个接口B。<br>（3）不能对默认的default接口进行扩展，只能对 export 命令输出的命名接口进行扩充。这是因为在进行类型扩展时，需要依赖输出的接口名。</p>
<p>某些第三方模块，原始作者没有提供接口类型，这时可以在自己的脚本顶部加上下面一行命令。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;模块名&quot;</span>;</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;hot-new-module&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>加上上面的命令以后，外部模块即使没有类型，也可以通过编译。但是，从该模块输入的所有接口都将为any类型。<br>declare module 描述的模块名可以使用通配符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;my-plugin-*&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">PluginOptions</span> &#123;</span><br><span class="line">    <span class="attr">enabled</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">priority</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params">options: PluginOptions</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="keyword">export</span> = initialize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-6-declare-global"><a href="#19-6-declare-global" class="headerlink" title="19.6 declare global"></a>19.6 declare global</h3><p>如果要为 JavaScript 引擎的原生对象添加属性和方法，可以使用declare global {}语法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">toSmallString</span>(): <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toSmallString</span> = ():<span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 具体实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个示例第一行的空导出语句export {}，作用是强制编译器将这个脚本当作模块处理。这是因为declare global必须用在模块里面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> window &#123;</span><br><span class="line">    <span class="attr">myAppConfig</span>:<span class="built_in">object</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> config = <span class="variable language_">window</span>.<span class="property">myAppConfig</span>;</span><br></pre></td></tr></table></figure>

<p>declare global 只能扩充现有对象的类型描述，不能增加新的顶层类型。</p>
<h3 id="19-7-declare-enum"><a href="#19-7-declare-enum" class="headerlink" title="19.7 declare enum"></a>19.7 declare enum</h3><p>declare 关键字给出 enum 类型描述的例子如下，下面的写法都是允许的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E1</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="variable constant_">E2</span> &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="variable constant_">E3</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> c</span><br></pre></td></tr></table></figure>

<h3 id="19-8-declare-module-用于类型声明文件"><a href="#19-8-declare-module-用于类型声明文件" class="headerlink" title="19.8 declare module 用于类型声明文件"></a>19.8 declare module 用于类型声明文件</h3><p>我们可以为每个模块脚本，定义一个.d.ts文件，把该脚本用到的类型定义都放在这个文件里面。但是，更方便的做法是为整个项目，定义一个大的.d.ts文件，在这个文件里面使用declare module定义每个模块脚本的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;url&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Url</span> &#123;</span><br><span class="line">    protocol?: <span class="built_in">string</span>;</span><br><span class="line">    hostname?: <span class="built_in">string</span>;</span><br><span class="line">    pathname?: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params"></span></span><br><span class="line"><span class="params">    urlStr: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    parseQueryString?,</span></span><br><span class="line"><span class="params">    slashesDenoteHost?</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Url</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;path&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> <span class="attr">sep</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时，自己的脚本使用三斜杠命令，加载这个类型声明文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没有上面这一行命令，自己的脚本使用外部模块时，就需要在脚本里面使用declare 命令单独给出外部模块的类型。</p>
<h2 id="二十、d-ts-类型声明文件"><a href="#二十、d-ts-类型声明文件" class="headerlink" title="二十、d.ts 类型声明文件"></a>二十、d.ts 类型声明文件</h2><h3 id="20-1-简介"><a href="#20-1-简介" class="headerlink" title="20.1 简介"></a>20.1 简介</h3><p>单独使用的模块，一般会同时提供一个单独的类型声明文件（declaration file），把本模块的外部接口的所有类型都写在这个文件里面，便于模块使用者了解接口，也便于编译器检查使用者的用法是否正确。<br>类型声明文件里面只有类型代码，没有具体的代码实现。它的文件名一般为[模块名].d.ts的形式，其中的d表示 declaration（声明）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInterval = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  getArrayLength,</span><br><span class="line">  maxInterval,</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//它的类型声明文件可以写成下面这样。 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getArrayLength</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">maxInterval</span>: <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>类型声明文件也可以使用export =命令，输出对外接口。下面是 moment 模块的类型声明文件的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">moment</span>(<span class="params"></span>): <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">export</span> = moment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块moment内部有一个函数moment()，而export =表示module.exports输出的就是这个函数。<br>除了使用export =，模块输出在类型声明文件中，也可以使用export default表示。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块输出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="number">3.142</span>;</span><br><span class="line"><span class="comment">// 类型输出文件</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">pi</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> pi;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">pi</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span>= pi;</span><br></pre></td></tr></table></figure>

<p>下面是一个如何使用类型声明文件的简单例子。有一个类型声明文件types.d.ts。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">  catchphrase?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，就可以在 TypeScript 脚本里面导入该文件声明的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Character</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./types&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">character</span>:<span class="title class_">Character</span> = &#123;</span><br><span class="line">  <span class="attr">catchphrase</span>: <span class="string">&quot;Yee-haw!&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Sandy Cheeks&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型声明文件也可以包括在项目的 tsconfig.json 文件里面，这样的话，编译器打包项目时，会自动将类型声明文件加入编译，而不必在每个脚本里面加载类型声明文件。比如，moment 模块的类型声明文件是moment.d.ts，使用 moment 模块的项目可以将其加入项目的 tsconfig.json 文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;src/index.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typings/moment.d.ts&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-2-类型声明文件的来源"><a href="#20-2-类型声明文件的来源" class="headerlink" title="20.2 类型声明文件的来源"></a>20.2 类型声明文件的来源</h3><p>类型声明文件主要有以下三种来源。</p>
<ul>
<li><p>TypeScript 编译器自动生成。</p>
</li>
<li><p>TypeScript 内置类型文件。</p>
</li>
<li><p>外部模块的类型声明文件，需要自己安装。</p>
</li>
</ul>
<h4 id="20-2-1-自动生成"><a href="#20-2-1-自动生成" class="headerlink" title="20.2.1 自动生成"></a>20.2.1 自动生成</h4><p>只要使用编译选项declaration，编译器就会在编译时自动生成单独的类型声明文<br>件。<br>下面是在tsconfig.json文件里面，打开这个选项。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在命令行打开这个选项。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --declaration</span><br></pre></td></tr></table></figure>

<h4 id="20-2-2-内置声明文件"><a href="#20-2-2-内置声明文件" class="headerlink" title="20.2.2 内置声明文件"></a>20.2.2 内置声明文件</h4><p>安装 TypeScript 语言时，会同时安装一些内置的类型声明文件，主要是内置的全局对象（JavaScript 语言接口和运行环境 API）的类型声明。<br>这些内置声明文件位于 TypeScript 语言安装目录的lib文件夹内，数量大概有几十个。</p>
<p>这些内置声明文件的文件名统一为“lib.[description].d.ts”的形式，其中description部分描述了文件内容。</p>
<p>TypeScript 编译器会自动根据编译目标target的值，加载对应的内置声明文件，所以不需要特别的配置。但是，可以使用编译选项lib，指定加载哪些内置声明文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;es2021&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译选项noLib会禁止加载任何内置声明文件。</p>
<h4 id="20-2-3-外部类型声明文件"><a href="#20-2-3-外部类型声明文件" class="headerlink" title="20.2.3 外部类型声明文件"></a>20.2.3 外部类型声明文件</h4><p>如果项目中使用了外部的某个第三方代码库，那么就需要这个库的类型声明文件。</p>
<p>（1）这个库自带了类型声明文件。<br>一般来说，如果这个库的源码包含了[vendor].d.ts文件，那么就自带了类型声明文件。其中的vendor表示这个库的名字，比如moment这个库就自带moment.d.ts。使用这个库可能需要单独加载它的类型声明文件。<br>（2）这个库没有自带，但是可以找到社区制作的类型声明文件。<br>第三方库如果没有提供类型声明文件，社区往往会提供。TypeScript 社区主要使用DefinitelyTyped 仓库，各种类型声明文件都会提交到那里，已经包含了几千个第三方库。<br>这些声明文件都会作为一个单独的库，发布到 npm 的@types名称空间之下。</p>
<p>如果类型声明文件不是index.d.ts，那么就需要在package.json的types或typings字段，指定类型声明文件的文件名。<br>TypeScript 会自动加载node_modules/@types目录下的模块，但可以使用编译选项typeRoots改变这种行为。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [<span class="string">&quot;./typings&quot;</span>, <span class="string">&quot;./vendor/types&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，TypeScript 会自动加载typeRoots目录里的所有模块，编译选项types可以指定加载哪些模块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;types&quot;</span> : [<span class="string">&quot;jquery&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面设置中，types属性是一个数组，成员是所要加载的类型模块，要加载几个模块，这个数组就有几个成员，每个类型模块在typeRoots目录下都有一个自己的子目录。这样的话，TypeScript 就会自动去jquery子目录，加载 jQuery 的类型声明文件。<br>（3）找不到类型声明文件，需要自己写。<br>有时实在没有第三方库的类型声明文件，又很难完整给出该库的类型描述，这时你可以告诉 TypeScript 相关对象的类型是any。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>:<span class="built_in">any</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">JQuery</span> = <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">$</span>:<span class="title class_">JQuery</span>;</span><br></pre></td></tr></table></figure>

<p>也可以采用下面的写法，将整个外部模块的类型设为any。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;模块名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="20-3-declare-关键字"><a href="#20-3-declare-关键字" class="headerlink" title="20.3 declare 关键字"></a>20.3 declare 关键字</h3><p>类型声明文件只包含类型描述，不包含具体实现，所以非常适合使用 declare 语句来描述类型。</p>
<p>类型声明文件里面，变量的类型描述必须使用declare命令，否则会报错，因为变量声明语句是值相关代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">foo</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>interface 类型有没有declare都可以，因为 interface 是完全的类型代码。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;&#125; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;&#125; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>类型声明文件里面，顶层可以使用export命令，也可以不用，除非使用者脚本会显式使用export命令输入类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是类型声明文件的一些例子。先看 moment 模块的类型描述文件moment.d.ts。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Moment</span> &#123;</span><br><span class="line">    <span class="title function_">format</span>(<span class="attr">format</span>:<span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">add</span>(</span><br><span class="line">      <span class="attr">amount</span>: <span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">unit</span>: <span class="string">&#x27;days&#x27;</span> | <span class="string">&#x27;months&#x27;</span> | <span class="string">&#x27;years&#x27;</span></span><br><span class="line">    ): <span class="title class_">Moment</span>;</span><br><span class="line">    <span class="title function_">subtract</span>(</span><br><span class="line">      <span class="attr">amount</span>:<span class="built_in">number</span>,</span><br><span class="line">      <span class="attr">unit</span>:<span class="string">&#x27;days&#x27;</span> | <span class="string">&#x27;months&#x27;</span> | <span class="string">&#x27;years&#x27;</span></span><br><span class="line">    ): <span class="title class_">Moment</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">moment</span>(<span class="params"></span></span><br><span class="line"><span class="params">    input?: <span class="built_in">string</span> | <span class="built_in">Date</span></span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Moment</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> moment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-4-模块发布"><a href="#20-4-模块发布" class="headerlink" title="20.4 模块发布"></a>20.4 模块发布</h3><p>当前模块如果包含自己的类型声明文件，可以在 package.json 文件里面添加一个types字段或typings字段，指明类型声明文件的位置。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;awesome&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vandelay Industries&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果类型声明文件名为index.d.ts，且在项目的根目录中，那就不需要在package.json里面注明了。<br>有时，类型声明文件会单独发布成一个 npm 模块，这时用户就必须同时加载该模块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;browserify-typescript-extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vandelay Industries&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./lib/main.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;types&quot;</span>: <span class="string">&quot;./lib/main.d.ts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@types/browserify&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span>: <span class="string">&quot;next&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个模块的 package.json 文件，该模块需要 browserify 模块。由于后者的类型声明文件是一个单独的模块@types/browserify，所以还需要加载那个模块。</p>
<h3 id="20-5-三斜杠命令"><a href="#20-5-三斜杠命令" class="headerlink" title="20.5 三斜杠命令"></a>20.5 三斜杠命令</h3><p>如果类型声明文件的内容非常多，可以拆分成多个文件，然后入口文件使用三斜杠命令，加载其他拆分后的文件。</p>
<p>三斜杠命令（///）是一个 TypeScript 编译器命令，用来指定编译器行为。它只能用在文件的头部，如果用在其他地方，会被当作普通的注释。另外，若一个文件中使用了三斜线命令，那么在三斜线命令之前只允许使用单行注释、多行注释和其他三斜线命令，否则三斜杠命令也会被当作普通的注释。<br>除了拆分类型声明文件，三斜杠命令也可以用于普通脚本加载类型声明文件。<br>三斜杠命令主要包含三个参数，代表三种不同的命令。</p>
<ul>
<li><p>path</p>
</li>
<li><p>types</p>
</li>
<li><p>lib</p>
</li>
</ul>
<p>/// &lt;**reference path=””** /&gt;是最常见的三斜杠命令，告诉编译器在编译时需要包括的文件，常用来声明当前脚本依赖的类型文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;./lib.ts&quot; /&gt;</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例表示，当前脚本依赖于./lib.ts，里面是add()的定义。编译当前脚本时，还会同时编译./lib.ts。编译产物会有两个 JS 文件，一个当前脚本，另一个就是./lib.js。</p>
<p>下面的例子是当前脚本依赖于 Node.js 类型声明文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">URL</span> <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> myUrl = <span class="variable constant_">URL</span>.<span class="title function_">parse</span>(<span class="string">&quot;https://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会在预处理阶段，找出所有三斜杠引用的文件，将其添加到编译列表中，然后一起编译。<br>path参数指定了所引入文件的路径。如果该路径是一个相对路径，则基于当前脚本的路径进行计算。<br>使用该命令时，有以下两个注意事项。</p>
<ul>
<li><p>path参数必须指向一个存在的文件，若文件不存在会报错。</p>
</li>
<li><p>path参数不允许指向当前文件。</p>
</li>
</ul>
<p>默认情况下，每个三斜杠命令引入的脚本，都会编译成单独的 JS 文件。如果希望编译后只产出一个合并文件，可以使用编译选项outFile。但是，outFile编译选项不支持合并 CommonJS 模块和 ES 模块，只有当编译参数module的值设为 None、System 或 AMD 时，才能编译成一个文件。<br>如果打开了编译参数noResolve，则忽略三斜杠指令。将其当作一般的注释，原样保留在编译产物中。</p>
<p>types 参数用来告诉编译器当前脚本依赖某个 DefinitelyTyped 类型库，通常安装在node_modules/@types目录。<br>types 参数的值是类型库的名称，也就是安装到node_modules/@types目录中的子目录的名字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;node&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，这个三斜杠命令表示编译时添加 Node.js 的类型库，实际添加的脚本是node_modules目录里面的@types/node/index.d.ts。<br>可以看到，这个命令的作用类似于import命令。<br>注意，这个命令只在你自己手写类型声明文件（.d.ts文件）时，才有必要用到，也就是说，只应该用在.d.ts文件中，普通的.ts脚本文件不需要写这个命令。如果是普通的.ts脚本，可以使用tsconfig.json文件的types属性指定依赖的类型库。</p>
<p>/// &lt;**reference lib=”…”** /&gt;命令允许脚本文件显式包含内置 lib 库，等同于在tsconfig.json文件里面使用lib属性指定 lib 库。</p>
<h2 id="二十一、TypeScript-类型运算符"><a href="#二十一、TypeScript-类型运算符" class="headerlink" title="二十一、TypeScript 类型运算符"></a>二十一、TypeScript 类型运算符</h2><h3 id="21-1-keyof-运算符"><a href="#21-1-keyof-运算符" class="headerlink" title="21.1 keyof 运算符"></a>21.1 keyof 运算符</h3><h4 id="21-1-1-简介"><a href="#21-1-1-简介" class="headerlink" title="21.1.1 简介"></a>21.1.1 简介</h4><p>keyof 是一个单目运算符，接受一个对象类型作为参数，返回该对象的所有键名组成的联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">MyObj</span>; <span class="comment">// &#x27;foo&#x27;|&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于 JavaScript 对象的键名只有三种类型，所以对于任意对象的键名的联合类型就是string|number|symbol。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string | number | symbol</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>对于没有自定义键名的类型使用 keyof 运算符，返回never类型，表示不可能有这样类型的键名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof <span class="built_in">object</span>;  <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>由于 keyof 返回的类型是string|number|symbol，如果有些场合只需要其中的一种类型，那么可以采用交叉类型的写法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Capital</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="title class_">Capitalize</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyKeys</span>&lt;<span class="title class_">Obj</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = <span class="title class_">Capital</span>&lt;keyof <span class="title class_">Obj</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>类型Capital只接受字符串作为类型参数，传入keyof Obj会报错，原因是这时的类型参数是string|number|symbol，跟字符串不兼容。采用下面的交叉类型写法，就不会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyKeys</span>&lt;<span class="title class_">Obj</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = <span class="title class_">Capital</span>&lt;<span class="built_in">string</span> &amp; keyof <span class="title class_">Obj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>如果对象属性名采用索引形式，keyof 会返回属性名的索引类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T;</span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;</span><br><span class="line">  [<span class="attr">prop</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// string|number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof T;</span><br></pre></td></tr></table></figure>

<p>上面的示例二，keyof T返回的类型是string|number，原因是 JavaScript 属性名为字符串时，包含了属性名为数值的情况，因为数值属性名会自动转为字符串。<br>如果 keyof 运算符用于数组或元组类型，得到的结果可能出人意料。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = keyof [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// 返回 number | &quot;0&quot; | &quot;1&quot; | &quot;2&quot;</span></span><br><span class="line"><span class="comment">// | &quot;length&quot; | &quot;pop&quot; | &quot;push&quot; | ···</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，keyof 会返回数组的所有键名，包括数字键名和继承的键名。<br>对于联合类型，keyof 返回成员共有的键名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">z</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="comment">// 返回 &#x27;z&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof (A | B);</span><br></pre></td></tr></table></figure>

<p>对于交叉类型，keyof 返回所有键名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">x</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// 返回 &#x27;a&#x27; | &#x27;x&#x27; | &#x27;b&#x27; | &#x27;y&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyT</span> = keyof (A &amp; B);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">keyof (A &amp; B) ≡ keyof A | keyof B</span><br></pre></td></tr></table></figure>

<p>keyof 取出的是键名组成的联合类型，如果想取出键值组成的联合类型，可以像下面这样写。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">MyObj</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Values</span> = <span class="title class_">MyObj</span>[<span class="title class_">Keys</span>]; <span class="comment">// number|string</span></span><br></pre></td></tr></table></figure>

<h4 id="21-1-2-keyof-运算符的用途"><a href="#21-1-2-keyof-运算符的用途" class="headerlink" title="21.1.2 keyof 运算符的用途"></a>21.1.2 keyof 运算符的用途</h4><p>keyof 运算符往往用于精确表达对象的属性类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例来说，取出对象的某个指定属性的值，JavaScript 版本可以写成下面这样。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prop</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//上面这个函数添加类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prop</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj:<span class="built_in">object</span>, key:<span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>):<span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的类型声明有两个问题，一是无法表示参数key与参数obj之间的关系，二是返回值类型只能写成any。<br>有了 keyof 以后，就可以解决这两个问题，精确表达返回值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> prop&lt;<span class="title class_">Obj</span>, K <span class="keyword">extends</span> keyof <span class="title class_">Obj</span>&gt;(</span><br><span class="line">  <span class="attr">obj</span>:<span class="title class_">Obj</span>, <span class="attr">key</span>:K</span><br><span class="line">):<span class="title class_">Obj</span>[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keyof 的另一个用途是用于属性映射，即将一个类型的所有属性逐一映射成其他值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NewProps</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123; <span class="attr">foo</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="comment">// 等于 &#123; foo: boolean; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">NewProps</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，类型NewProps是类型Obj的映射类型，前者继承了后者的所有属性，但是把所有属性值类型都改成了boolean。</p>
<p>下面的例子是去掉 readonly 修饰符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]: <span class="title class_">Obj</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等于 &#123; foo: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">Mutable</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，[Prop in keyof Obj]是Obj类型的所有属性名，-readonly表示去除这些属性的只读特性。对应地，还有+readonly的写法，表示添加只读属性设置。<br>下面的例子是让可选属性变成必有的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Obj</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Obj</span>]-?: <span class="title class_">Obj</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  foo?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等于 &#123; foo: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewObj</span> = <span class="title class_">Concrete</span>&lt;<span class="title class_">MyObj</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，[Prop in keyof Obj]后面的-?表示去除可选属性设置。对应地，还有+?的写法，表示添加可选属性设置。</p>
<h3 id="21-2-in-运算符"><a href="#21-2-in-运算符" class="headerlink" title="21.2 in 运算符"></a>21.2 in 运算符</h3><p>JavaScript 语言中，in运算符用来确定对象是否包含某个属性名。</p>
<p>TypeScript 语言的类型运算中，in运算符有不同的用法，用来取出（遍历）联合类型的每一个成员类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> U = <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> U]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-3-方括号运算符"><a href="#21-3-方括号运算符" class="headerlink" title="21.3 方括号运算符"></a>21.3 方括号运算符</h3><p>方括号运算符（[]）用于取出对象的键值类型，比如T[K]会返回对象T的属性K的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">alive</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Age 的类型是 number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&#x27;age&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>方括号的参数如果是联合类型，那么返回的也是联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">alive</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// number|string</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="comment">// number|string|boolean</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Person</span>[keyof <span class="title class_">Obj</span>];</span><br></pre></td></tr></table></figure>

<p>如果访问不存在的属性，会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="title class_">Person</span>[<span class="string">&#x27;notExisted&#x27;</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>方括号运算符的参数也可以是属性名的索引类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  [<span class="attr">key</span>:<span class="built_in">string</span>]: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Obj</span>[<span class="built_in">string</span>];</span><br></pre></td></tr></table></figure>

<p>上面示例中，Obj的属性名是字符串的索引类型，所以可以写成Obj[string]，代表所有字符串属性名，返回的就是它们的类型number。<br>这个语法对于数组也适用，可以使用number作为方括号的参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyArray 的类型是 &#123; [key:number]：string &#125;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyArray</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// 等同于 (typeof MyArray)[number]</span></span><br><span class="line"><span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<p>注意，方括号里面不能有值的运算。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key]; <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;g&#x27;</span> + <span class="string">&#x27;e&#x27;</span>]; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="21-4-extends…-条件运算符"><a href="#21-4-extends…-条件运算符" class="headerlink" title="21.4 extends…?: 条件运算符"></a>21.4 extends…?: 条件运算符</h3><p>TypeScript 提供类似 JavaScript 的?:运算符这样的三元运算符，但多出了一个extends关键字。<br>条件运算符extends…?:可以根据当前类型是否符合某种条件，返回不同的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>

<p>上面式子中的extends用来判断，类型T是否可以赋值给类型U，即T是否为U的子类型，这里的T和U可以是任意类型。<br>如果T能够赋值给类型U，表达式的结果为类型X，否则结果为类型Y。</p>
<p>一般来说，调换extends两侧类型，会返回相反的结果。</p>
<p>如果需要判断的类型是一个联合类型，那么条件运算符会展开这个联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(A|B) <span class="keyword">extends</span> U ? X : Y</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">(A <span class="keyword">extends</span> U ? X : Y) |</span><br><span class="line">(B <span class="keyword">extends</span> U ? X : Y)</span><br></pre></td></tr></table></figure>

<p>上面示例中，A|B是一个联合类型，进行条件运算时，相当于A和B分别进行运算符，返回结果组成一个联合类型。<br>如果不希望联合类型被条件运算符展开，可以把extends两侧的操作数都放在方括号里面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// string[]|number[]</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  [<span class="title class_">Type</span>] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// (string | number)[]</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>条件运算符还可以嵌套使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LiteralTypeName</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">bigint</span> ? <span class="string">&quot;bigint&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">  <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例是一个多重判断，返回一个字符串的值类型，对应当前类型。下面是它的用法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="title class_">LiteralTypeName</span>&lt;<span class="number">123n</span>&gt;;</span><br><span class="line"><span class="comment">// &quot;string&quot; | &quot;number&quot; | &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="title class_">LiteralTypeName</span>&lt;<span class="literal">true</span> | <span class="number">1</span> | <span class="string">&#x27;a&#x27;</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="21-5-infer-关键字"><a href="#21-5-infer-关键字" class="headerlink" title="21.5 infer 关键字"></a>21.5 infer 关键字</h3><p>infer关键字用来定义泛型里面推断出来的类型参数，而不是外部传入的类型参数。<br>它通常跟条件运算符一起使用，用在extends关键字后面的父类型之中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，Type是外部传入的类型参数，如果它是数组Array的子类型，那么就将类型变量Item推断为T，即Item代表数组的成员类型，写成infer Item，表示Item这个类型参数是从当前信息中推断出来的。<br>一旦定义了Item，后面的代码就可以使用这个类型参数了。<br>下面是上例的泛型Flatten&lt;**Type**&gt;的用法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">string</span>[]&gt;;</span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，第一个例子Flatten&lt;**string[]**&gt;传入的类型参数是string[]，可以推断出Item的类型是string，所以返回的是string。第二个例子Flatten&lt;**number**&gt;传入的类型参数是number，它不是数组的子类型，所以直接返回自身。<br>如果不用infer定义类型参数，那么就要传入两个类型参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>, <span class="title class_">Item</span>&gt; =</span><br><span class="line">  <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure>

<p>下面的例子使用infer，推断函数的参数类型和返回值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnPromise</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R </span><br><span class="line">  ? <span class="function">(<span class="params">...args: A</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;R&gt; </span><br><span class="line">  : T;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果T是函数，就返回这个函数的 Promise 版本，否则原样返回。infer A表示该函数的参数类型为A，infer R表示该函数的返回值类型为R。</p>
<p>下面是infer提取对象指定属性的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: infer M,</span><br><span class="line">    <span class="attr">b</span>: infer N</span><br><span class="line">  &#125; ? [M, N] : <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// 用法示例</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">MyType</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125;&gt;;</span><br><span class="line"><span class="comment">// [string, number]</span></span><br></pre></td></tr></table></figure>

<p>下面是infer通过正则匹配提取类型参数的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="string">&#x27;foo-bar&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = <span class="title class_">Str</span> <span class="keyword">extends</span> <span class="string">`foo-<span class="subst">$&#123;infer rest&#125;</span>`</span> ? rest : <span class="built_in">never</span> <span class="comment">// &#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="21-6-is-运算符"><a href="#21-6-is-运算符" class="headerlink" title="21.6 is 运算符"></a>21.6 is 运算符</h3><p>函数返回布尔值的时候，可以使用is运算符，限定返回值与参数之间的关系。<br>is运算符用来描述返回值属于true还是false。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params"></span></span><br><span class="line"><span class="params">  pet: Fish|Bird</span></span><br><span class="line"><span class="params"></span>):pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is运算符总是用于描述函数的返回值类型，写法采用parameterName is Type的形式，即左侧为当前函数的参数名，右侧为某一种类型。它返回一个布尔值，表示左侧参数是否属于右侧的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123; <span class="attr">b</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isTypeA</span>(<span class="params">x: A|B</span>): x is A &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is运算符可以用于类型保护。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCat</span>(<span class="params">a:<span class="built_in">any</span></span>): a is <span class="title class_">Cat</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">name</span> === <span class="string">&#x27;kitty&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="title class_">Cat</span>|<span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isCat</span>(x)) &#123;</span><br><span class="line">  x.<span class="title function_">meow</span>(); <span class="comment">// 正确，因为 x 肯定是 Cat 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数isCat()的返回类型是a is Cat，它是一个布尔值。后面的if语句就用这个返回值进行判断，从而起到类型保护的作用，确保x是 Cat 类型，从而x.meow()不会报错（假定Cat类型拥有meow()方法）。<br>is运算符还有一种特殊用法，就是用在类（class）的内部，描述类的方法的返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="title function_">isStudent</span>():<span class="variable language_">this</span> is <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">isStudent</span>():<span class="variable language_">this</span> is <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，this is T这种写法，只能用来描述方法的返回值类型，而不能用来描述属性的类型。</p>
<h3 id="21-7-模板字符串"><a href="#21-7-模板字符串" class="headerlink" title="21.7 模板字符串"></a>21.7 模板字符串</h3><p>TypeScript 允许使用模板字符串，构建类型。<br>模板字符串的最大特点，就是内部可以引用其他类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">World</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Greeting</span> = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>注意，模板字符串可以引用的类型一共6种，分别是 string、number、bigint、boolean、null、undefined。引用这6种以外的类型会报错。</p>
<p>模板字符串里面引用的类型，如果是一个联合类型，那么它返回的也是一个联合类型，即模板字符串可以展开联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;A&#x27;</span>|<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="comment">// &quot;A_id&quot;|&quot;B_id&quot;</span></span><br><span class="line"><span class="keyword">type</span> U = <span class="string">`<span class="subst">$&#123;T&#125;</span>_id`</span>;</span><br></pre></td></tr></table></figure>

<p>如果模板字符串引用两个联合类型，它会交叉展开这两个类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="string">&#x27;A&#x27;</span>|<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> U = <span class="string">&#x27;1&#x27;</span>|<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="comment">// &#x27;A1&#x27;|&#x27;A2&#x27;|&#x27;B1&#x27;|&#x27;B2&#x27;</span></span><br><span class="line"><span class="keyword">type</span> V = <span class="string">`<span class="subst">$&#123;T&#125;</span><span class="subst">$&#123;U&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="二十二、TypeScript-的类型映射"><a href="#二十二、TypeScript-的类型映射" class="headerlink" title="二十二、TypeScript 的类型映射"></a>二十二、TypeScript 的类型映射</h2><h3 id="22-1-简介"><a href="#22-1-简介" class="headerlink" title="22.1 简介"></a>22.1 简介</h3><p>映射（mapping）指的是，将一种类型按照映射规则，转换成另一种类型，通常用于对象类型。<br>举例来说，现有一个类型A和另一个类型B。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用类型映射，就可以从类型A得到类型B。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [prop <span class="keyword">in</span> keyof A]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在语法上，[prop in keyof A]是一个属性名表达式，表示这里的属性名需要计算得到。具体的计算规则如下：</p>
<ul>
<li><p>prop：属性名变量，名字可以随便起。</p>
</li>
<li><p>in：运算符，用来取出右侧的联合类型的每一个成员。</p>
</li>
<li><p>Keyof A：返回类型A的每一个属性名，组成一个联合类型。</p>
</li>
</ul>
<p>下面是复制原始类型的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [prop <span class="keyword">in</span> keyof A]: A[prop];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了增加代码复用性，可以把常用的映射写成泛型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToBoolean</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不使用联合类型，直接使用某种具体类型进行属性名映射，也是可以的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="string">&#x27;foo&#x27;</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  [<span class="attr">p</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，[p in string]就是属性名索引形式[p: string]的映射写法。<br>通过映射，可以某个对象的所有属性改成可选属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof A]?: A[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事实上，TypeScript 的内置工具类型Partial&lt;**T**&gt;，就是这样实现的。<br>TypeScript内置的工具类型Readonly&lt;**T**&gt;可以将所有属性改为只读属性，实现也是通过映射。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 T 的所有属性改为只读属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//它的用法如下。 </span></span><br><span class="line"><span class="keyword">type</span> T = &#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyT</span> = <span class="title class_">Readonly</span>&lt;T&gt;;</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   readonly a: string;</span></span><br><span class="line"><span class="comment">//   readonly b: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="22-2-映射修饰符"><a href="#22-2-映射修饰符" class="headerlink" title="22.2 映射修饰符"></a>22.2 映射修饰符</h3><p>映射会原样复制原始对象的可选属性和只读属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  a?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof A]: A[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  a?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果要删改可选和只读这两个特性，并不是很方便。为了解决这个问题，TypeScript引入了两个映射修饰符，用来在映射时添加或移除某个属性的?修饰符和readonly修饰符。</p>
<ul>
<li><p>+修饰符：写成+?或+readonly，为映射属性添加?修饰符或readonly修饰符。</p>
</li>
<li><p>–修饰符：写成-?或-readonly，为映射属性移除?修饰符或readonly修饰符。</p>
</li>
</ul>
<p>下面是添加或移除可选属性的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加可选属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Optional</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]+?: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 移除可选属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]-?: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，+?或-?要写在属性名的后面。<br>下面是添加或移除只读属性的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 readonly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateImmutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 移除 readonly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [<span class="title class_">Prop</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Prop</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，+readonly和-readonly要写在属性名的前面。<br>如果同时增删?和readonly这两个修饰符，写成下面这样。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span>&lt;T&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]+?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 原生的工具类型Required&lt;**T**&gt;专门移除可选属性，就是使用-?修饰符实现的。<br>注意，–?修饰符移除了可选属性以后，该属性就不能等于undefined了，实际变成必选属性了。但是，这个修饰符不会移除null类型。<br>另外，+?修饰符可以简写成?，+readonly修饰符可以简写成readonly。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A&lt;T&gt; = &#123;</span><br><span class="line">  +<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]+?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> B&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="22-3-键名重映射"><a href="#22-3-键名重映射" class="headerlink" title="22.3 键名重映射"></a>22.3 键名重映射</h3><h4 id="22-3-1-语法"><a href="#22-3-1-语法" class="headerlink" title="22.3.1 语法"></a>22.3.1 语法</h4><p>TypeScript 4.1 引入了键名重映射（key remapping），允许改变键名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> keyof A <span class="keyword">as</span> <span class="string">`<span class="subst">$&#123;p&#125;</span>ID`</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">fooID</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">barID</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>键名重映射的语法是在键名映射的后面加上as + 新类型子句。这里的“新类型”通常是一个模板字符串，里面可以对原始键名进行各种操作。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T</span><br><span class="line">    <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; P&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = &#123;</span><br><span class="line">  <span class="attr">getName</span>: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">getAge</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">getLocation</span>: <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的修改键名的代码是一个模板字符串get${Capitalize&lt;**string &amp; P**&gt;}，下面是各个部分的解释。</p>
<ul>
<li><p>get：为键名添加的前缀。</p>
</li>
<li><p>Capitalize&lt;**T**&gt;：一个原生的工具泛型，用来将T的首字母变成大写。</p>
</li>
<li><p>string &amp; P：一个交叉类型，其中的P是 keyof 运算符返回的键名联合类型string|number|symbol，但是Capitalize&lt;**T**&gt;只能接受字符串作为类型参数，因此string &amp; P只返回P的字符串属性名。</p>
</li>
</ul>
<h4 id="22-3-2-属性过滤"><a href="#22-3-2-属性过滤" class="headerlink" title="22.3.2 属性过滤"></a>22.3.2 属性过滤</h4><p>键名重映射还可以过滤掉某些属性。下面的例子是只保留字符串属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Filter</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T</span><br><span class="line">    <span class="keyword">as</span> T[K] <span class="keyword">extends</span> <span class="built_in">string</span> ? K : <span class="built_in">never</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FilteredUser</span> = <span class="title class_">Filter</span>&lt;<span class="title class_">User</span>&gt; <span class="comment">// &#123; name: string &#125;</span></span><br></pre></td></tr></table></figure>

<p>它的键名重映射as T[K] extends string ? K : never]，使用了条件运算符。如果属性值T[K]的类型是字符串，那么属性名不变，否则属性名类型改为never，即这个属性名不存在。这样就等于过滤了不符合条件的属性，只保留属性值为字符串的属性。</p>
<h4 id="22-3-3-联合类型的映射"><a href="#22-3-3-联合类型的映射" class="headerlink" title="22.3.3 联合类型的映射"></a>22.3.3 联合类型的映射</h4><p>由于键名重映射可以修改键名类型，所以原始键名的类型不必是string|number|symbol，任意的联合类型都可以用来进行键名重映射。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;square&#x27;</span>,</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> C = &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyEvents</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">  [E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&#x27;kind&#x27;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = <span class="title class_">MyEvent</span>&lt;S|C&gt;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = &#123;</span><br><span class="line">  <span class="attr">square</span>: <span class="function">(<span class="params">event:S</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">circle</span>: <span class="function">(<span class="params">event:C</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始键名的映射是E in Events，这里的Events是两个对象组成的联合类型S|C。所以，E是一个对象，然后再通过键名重映射，得到字符串键名E[‘kind’]。</p>
<h2 id="二十三、TypeScript-类型工具"><a href="#二十三、TypeScript-类型工具" class="headerlink" title="二十三、TypeScript 类型工具"></a>二十三、TypeScript 类型工具</h2><p>TypeScript 内置了17个类型工具，可以直接使用。</p>
<h3 id="23-1-Awaited-lt-Type-gt"><a href="#23-1-Awaited-lt-Type-gt" class="headerlink" title="23.1 Awaited&lt; Type &gt;"></a>23.1 Awaited&lt; Type &gt;</h3><p>Awaited&lt;**Type**&gt;用来取出 Promise 的返回值类型，适合用在描述then()方法和await 命令的参数类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Awaited</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>它也可以返回多重 Promise 的返回值类型。</p>
<p>如果它的类型参数不是 Promise 类型，那么就会原样返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number | boolean</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">Awaited</span>&lt;<span class="built_in">boolean</span> | <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>Awaited&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Awaited</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? T :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">object</span> &amp; &#123;</span><br><span class="line">    <span class="title function_">then</span>(</span><br><span class="line">      <span class="attr">onfulfilled</span>: infer F,</span><br><span class="line">      ...<span class="attr">args</span>: infer _</span><br><span class="line">    ): <span class="built_in">any</span>;</span><br><span class="line">  &#125; ? F <span class="keyword">extends</span> (</span><br><span class="line">    <span class="attr">value</span>: infer V,</span><br><span class="line">    ...<span class="attr">args</span>: infer _</span><br><span class="line">  ) =&gt; <span class="built_in">any</span> ? <span class="title class_">Awaited</span>&lt;...&gt; : <span class="attr">never</span>:</span><br><span class="line">  T;</span><br></pre></td></tr></table></figure>

<h3 id="23-2-ConstructorParameters-lt-Type-gt"><a href="#23-2-ConstructorParameters-lt-Type-gt" class="headerlink" title="23.2 ConstructorParameters&lt; Type &gt;"></a>23.2 ConstructorParameters&lt; Type &gt;</h3><p>ConstructorParameters&lt;**Type**&gt;提取构造方法Type的参数类型，组成一个元组类型返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">number</span>) =&gt; <span class="built_in">object</span></span><br><span class="line">&gt;; <span class="comment">// [x: string, y: number]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="keyword">new</span> (x?: <span class="built_in">string</span>) =&gt; <span class="built_in">object</span></span><br><span class="line">&gt;; <span class="comment">// [x?: string | undefined]</span></span><br></pre></td></tr></table></figure>

<p>它可以返回一些内置构造方法的参数类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="title class_">ErrorConstructor</span></span><br><span class="line">&gt;; <span class="comment">// [message?: string]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="title class_">FunctionConstructor</span></span><br><span class="line">&gt;; <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  <span class="title class_">RegExpConstructor</span></span><br><span class="line">&gt;; <span class="comment">// [pattern:string|RegExp, flags?:string]</span></span><br></pre></td></tr></table></figure>

<p>如果参数类型不是构造方法，就会报错。</p>
<p>any类型和never类型是两个特殊值，分别返回unknown[]和never。</p>
<p>ConstructorParameters&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructorParameters</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer P) </span><br><span class="line">  =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h3 id="23-3-Exclude-lt-UnionType-ExcludedMembers-gt"><a href="#23-3-Exclude-lt-UnionType-ExcludedMembers-gt" class="headerlink" title="23.3 Exclude&lt; UnionType, ExcludedMembers &gt;"></a>23.3 Exclude&lt; UnionType, ExcludedMembers &gt;</h3><p>Exclude&lt;**UnionType, ExcludedMembers**&gt;用来从联合类型UnionType里面，删除某些类型ExcludedMembers，组成一个新的类型返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// &#x27;b&#x27;|&#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// &#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Exclude</span>&lt;<span class="built_in">string</span>|(<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="title class_">Function</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Exclude</span>&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[], <span class="built_in">any</span>[]&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Exclude</span>&lt;(<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="literal">null</span>, <span class="title class_">Function</span>&gt;; <span class="comment">// null</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">Exclude</span>&lt;<span class="number">200</span> | <span class="number">400</span>, <span class="number">200</span> | <span class="number">201</span>&gt;; <span class="comment">// 400</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T7</span> = <span class="title class_">Exclude</span>&lt;<span class="built_in">number</span>, <span class="built_in">boolean</span>&gt;; <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>Exclude&lt;**UnionType, ExcludedMembers**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p>上面代码中，等号右边的部分，表示先判断T是否兼容U，如果是的就返回never类型，否则返回当前类型T。由于never类型是任何其他类型的子类型，它跟其他类型组成联合类型时，可以直接将never类型从联合类型中“消掉”，因此Exclude&lt;**T, U**&gt;就相当于删除兼容的类型，剩下不兼容的类型。</p>
<h3 id="23-4-Extract-lt-Type-Union-gt"><a href="#23-4-Extract-lt-Type-Union-gt" class="headerlink" title="23.4 Extract&lt; Type, Union &gt;"></a>23.4 Extract&lt; Type, Union &gt;</h3><p>Extract&lt;**UnionType, Union**&gt;用来从联合类型UnionType之中，提取指定类型Union，组成一个新类型返回。它与Exclude&lt;**T, U**&gt;正好相反。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Extract</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;; <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Extract</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>&gt;; <span class="comment">// &#x27;a&#x27;|&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Extract</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>|<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;d&#x27;</span>&gt;; <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Extract</span>&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[], <span class="built_in">any</span>[]&gt;; <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Extract</span>&lt;(<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="literal">null</span>, <span class="title class_">Function</span>&gt;; <span class="comment">// () =&gt; void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">Extract</span>&lt;<span class="number">200</span> | <span class="number">400</span>, <span class="number">200</span> | <span class="number">201</span>&gt;; <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<p>如果参数类型Union不包含在联合类型UnionType之中，则返回never类型。</p>
<p>Extract&lt;**UnionType, Union**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<h3 id="23-5-InstanceType-lt-Type-gt"><a href="#23-5-InstanceType-lt-Type-gt" class="headerlink" title="23.5 InstanceType&lt; Type &gt;"></a>23.5 InstanceType&lt; Type &gt;</h3><p>InstanceType&lt;**Type**&gt;提取构造函数的返回值的类型（即实例类型），参数Type是一个构造函数，等同于构造函数的ReturnType&lt;**Type**&gt;。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = <span class="title class_">InstanceType</span>&lt;</span><br><span class="line">  <span class="keyword">new</span> () =&gt; <span class="built_in">object</span></span><br><span class="line">&gt;; <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>下面是一些例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="title class_">InstanceType</span>&lt;<span class="title class_">ErrorConstructor</span>&gt;; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">InstanceType</span>&lt;<span class="title class_">FunctionConstructor</span>&gt;; <span class="comment">// Function</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">InstanceType</span>&lt;<span class="title class_">RegExpConstructor</span>&gt;; <span class="comment">// RegExp</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，InstanceType&lt;**T**&gt;的参数都是 TypeScript 内置的原生对象的构造函数类型，InstanceType&lt;**T**&gt;的返回值就是这些构造函数的实例类型。<br>由于 Class 作为类型，代表实例类型。要获取它的构造方法，必须把它当成值，然后用typeof运算符获取它的构造方法类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> C&gt;; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>

<p>如果类型参数不是构造方法，就会报错。</p>
<p>如果类型参数是any或never两个特殊值，分别返回any和never。</p>
<p>InstanceType&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">InstanceType</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>:<span class="built_in">any</span>) =&gt; <span class="built_in">any</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R :</span><br><span class="line">  <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<h3 id="23-6-NonNullable-lt-Type-gt"><a href="#23-6-NonNullable-lt-Type-gt" class="headerlink" title="23.6 NonNullable&lt; Type &gt;"></a>23.6 NonNullable&lt; Type &gt;</h3><p>NonNullable&lt;**Type**&gt;用来从联合类型Type删除null类型和undefined类型，组成一个新类型返回，也就是返回Type的非空类型版本。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string|number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span>|<span class="built_in">number</span>|<span class="literal">undefined</span>&gt;;</span><br><span class="line"><span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span>[]|<span class="literal">null</span>|<span class="literal">undefined</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">boolean</span>&gt;; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">number</span>|<span class="literal">null</span>&gt;; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span>|<span class="literal">undefined</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">NonNullable</span>&lt;<span class="literal">null</span>|<span class="literal">undefined</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>NonNullable&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T &amp; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，T &amp; {}等同于求T &amp; Object的交叉类型。由于 TypeScript 的非空值都属于Object的子类型，所以会返回自身；而null和undefined不属于Object，会返回never类型。</p>
<h3 id="23-7-Omit-lt-Type-Keys-gt"><a href="#23-7-Omit-lt-Type-Keys-gt" class="headerlink" title="23.7 Omit&lt; Type, Keys &gt;"></a>23.7 Omit&lt; Type, Keys &gt;</h3><p>Omit&lt;**Type, Keys**&gt;用来从对象类型Type中，删除指定的属性Keys，组成一个新的对象类型返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Omit</span>&lt;A, <span class="string">&#x27;x&#x27;</span>&gt;;       <span class="comment">// &#123; y: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Omit</span>&lt;A, <span class="string">&#x27;y&#x27;</span>&gt;;       <span class="comment">// &#123; x: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Omit</span>&lt;A, <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt;; <span class="comment">// &#123; &#125;</span></span><br></pre></td></tr></table></figure>

<p>指定删除的键名Keys可以是对象类型Type中不存在的属性，但必须兼容string|number|symbol。</p>
<p>Omit&lt;**Type, Keys**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; </span><br><span class="line">  = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="23-8-OmitThisParameter-lt-Type-gt"><a href="#23-8-OmitThisParameter-lt-Type-gt" class="headerlink" title="23.8 OmitThisParameter&lt; Type &gt;"></a>23.8 OmitThisParameter&lt; Type &gt;</h3><p>OmitThisParameter&lt;**Type**&gt;从函数类型中移除 this 参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">OmitThisParameter</span>&lt;<span class="keyword">typeof</span> toHex&gt;; <span class="comment">// () =&gt; string</span></span><br></pre></td></tr></table></figure>

<p>如果函数没有 this 参数，则返回原始函数类型。</p>
<p>OmitThisParameter&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OmitThisParameter</span>&lt;T&gt; =</span><br><span class="line">  <span class="built_in">unknown</span> <span class="keyword">extends</span> <span class="title class_">ThisParameterType</span>&lt;T&gt; ? T :</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; infer R ?</span><br><span class="line">  <span class="function">(<span class="params">...args: A</span>) =&gt;</span> R : T;</span><br></pre></td></tr></table></figure>

<h3 id="23-9-Parameters-lt-Type-gt"><a href="#23-9-Parameters-lt-Type-gt" class="headerlink" title="23.9 Parameters&lt; Type &gt;"></a>23.9 Parameters&lt; Type &gt;</h3><p>Parameters&lt;**Type**&gt;从函数类型Type里面提取参数类型，组成一个元组返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">s:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// [s:string]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Parameters</span>&lt;&lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt;;    <span class="comment">// [arg: unknown]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">Parameters</span>&lt;</span><br><span class="line">  <span class="function">(<span class="params">x:&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&gt;; <span class="comment">// [x: &#123; a: number, b: string &#125;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">Parameters</span>&lt;</span><br><span class="line">  <span class="function">(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">&gt;; <span class="comment">// [a:number, b:number]</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，Parameters&lt;**Type**&gt;的返回值会包括函数的参数名，这一点需要注意。<br>如果参数类型Type不是带有参数的函数形式，会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Parameters</span>&lt;<span class="title class_">Function</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>由于any和never是两个特殊值，会返回unknown[]和never。</p>
<p>Parameters&lt;**Type**&gt;主要用于从外部模块提供的函数类型中，获取参数类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SecretName</span> &#123;</span><br><span class="line">  <span class="attr">first</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">last</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SecretSanta</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">SecretName</span>;</span><br><span class="line">  <span class="attr">gift</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getGift</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: SecretName,</span></span><br><span class="line"><span class="params">  gift: <span class="built_in">string</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">SecretSanta</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，模块只输出了函数getGift()，没有输出参数SecretName和返回值SecretSanta。这时就可以通过Parameters&lt;**T**&gt;和ReturnType&lt;**T**&gt;拿到这两个接口类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ParaT</span> = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> getGift&gt;[<span class="number">0</span>]; <span class="comment">// SecretName</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnT</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> getGift&gt;; <span class="comment">// SecretSanta</span></span><br></pre></td></tr></table></figure>

<p>Parameters&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P)</span><br><span class="line">  =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h3 id="23-10-Partial-lt-Type-gt"><a href="#23-10-Partial-lt-Type-gt" class="headerlink" title="23.10 Partial&lt; Type &gt;"></a>23.10 Partial&lt; Type &gt;</h3><p>Partial&lt;**Type**&gt;返回一个新类型，将参数类型Type的所有属性变为可选属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Partial</span>&lt;A&gt;; <span class="comment">// &#123; x?: number; y?: number; &#125;</span></span><br></pre></td></tr></table></figure>

<p>Partial&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="23-11-Pick-lt-Type-Keys-gt"><a href="#23-11-Pick-lt-Type-Keys-gt" class="headerlink" title="23.11 Pick&lt; Type, Keys &gt;"></a>23.11 Pick&lt; Type, Keys &gt;</h3><p>Pick&lt;**Type, Keys**&gt;返回一个新的对象类型，第一个参数Type是一个对象类型，第二个参数Keys是Type里面被选定的键名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;x&#x27;</span>&gt;; <span class="comment">// &#123; x: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;y&#x27;</span>&gt;; <span class="comment">// &#123; y: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;x&#x27;</span>|<span class="string">&#x27;y&#x27;</span>&gt;;  <span class="comment">// &#123; x: number; y: number &#125;</span></span><br></pre></td></tr></table></figure>

<p>指定的键名Keys必须是对象键名Type里面已经存在的键名，否则会报错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Pick</span>&lt;A, <span class="string">&#x27;z&#x27;</span>&gt;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>Pick&lt;**Type, Keys**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="23-12-Readonly-lt-Type-gt"><a href="#23-12-Readonly-lt-Type-gt" class="headerlink" title="23.12 Readonly&lt; Type &gt;"></a>23.12 Readonly&lt; Type &gt;</h3><p>Readonly&lt;**Type**&gt;返回一个新类型，将参数类型Type的所有属性变为只读属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123; readonly x: number; readonly y?: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Readonly</span>&lt;A&gt;;</span><br></pre></td></tr></table></figure>

<p>Readonly&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="23-13-Record-lt-Keys-Type-gt"><a href="#23-13-Record-lt-Keys-Type-gt" class="headerlink" title="23.13 Record&lt; Keys, Type &gt;"></a>23.13 Record&lt; Keys, Type &gt;</h3><p>Record&lt;**Keys, Type**&gt;返回一个对象类型，参数Keys用作键名，参数Type用作键值类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; a: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>参数Keys可以是联合类型，这时会依次展开为多个键。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; a: number, b: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Record</span>&lt;<span class="string">&#x27;a&#x27;</span>|<span class="string">&#x27;b&#x27;</span>, <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>如果参数Type是联合类型，就表明键值是联合类型。</p>
<p>参数Keys的类型必须兼容string|number|symbol，否则不能用作键名，会报错。<br>Record&lt;**Keys, Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>|<span class="built_in">number</span>|<span class="built_in">symbol</span>, T&gt;</span><br><span class="line">  = &#123; [P <span class="keyword">in</span> K]: T; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-14-Required-lt-Type-gt"><a href="#23-14-Required-lt-Type-gt" class="headerlink" title="23.14 Required&lt; Type &gt;"></a>23.14 Required&lt; Type &gt;</h3><p>Required&lt;**Type**&gt;返回一个新类型，将参数类型Type的所有属性变为必选属性。它与Partial&lt;**Type**&gt;的作用正好相反。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">Required</span>&lt;A&gt;; <span class="comment">// &#123; x: number; y: number; &#125;</span></span><br></pre></td></tr></table></figure>

<p>Required&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="23-15-ReadonlyArray-lt-Type-gt"><a href="#23-15-ReadonlyArray-lt-Type-gt" class="headerlink" title="23.15 ReadonlyArray&lt; Type &gt;"></a>23.15 ReadonlyArray&lt; Type &gt;</h3><p>ReadonlyArray&lt;**Type**&gt;用来生成一个只读数组类型，类型参数Type表示数组成员的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">values</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">string</span>&gt; </span><br><span class="line">  = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">values[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>; <span class="comment">// 报错</span></span><br><span class="line">values.<span class="title function_">push</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// 报错</span></span><br><span class="line">values.<span class="title function_">pop</span>(); <span class="comment">// 报错</span></span><br><span class="line">values.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量values的类型是一个只读数组，所以修改成员会报错，并且那些会修改源数组的方法push()、pop()、splice()等都不存在。<br>ReadonlyArray&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyArray</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> [<span class="attr">n</span>: <span class="built_in">number</span>]: T;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-16-ReturnType-lt-Type-gt"><a href="#23-16-ReturnType-lt-Type-gt" class="headerlink" title="23.16 ReturnType&lt; Type &gt;"></a>23.16 ReturnType&lt; Type &gt;</h3><p>ReturnType&lt;**Type**&gt;提取函数类型Type的返回值类型，作为一个新类型返回。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;; <span class="comment">// &#123; a: string; b: number &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">(<span class="params">s:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// void</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="function">() =&gt;</span> <span class="built_in">any</span>[]&gt;; <span class="comment">// () =&gt; any[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T5</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Math</span>.<span class="property">random</span>&gt;; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T6</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property">isArray</span>&gt;; <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<p>如果参数类型是泛型函数，返回值取决于泛型类型。如果泛型不带有限制条件，就会返回unknown。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;&lt;T&gt;<span class="function">() =&gt;</span> T&gt;; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">ReturnType</span>&lt;</span><br><span class="line">  &lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> <span class="built_in">number</span>[]&gt;<span class="function">() =&gt;</span> T</span><br><span class="line">&gt;; <span class="comment">// number[]</span></span><br></pre></td></tr></table></figure>

<p>如果类型不是函数，会报错。</p>
<p>any和never是两个特殊值，分别返回any和never。</p>
<p>ReturnType&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span></span><br><span class="line">&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<h3 id="23-17-ThisParameterType-lt-Type-gt"><a href="#23-17-ThisParameterType-lt-Type-gt" class="headerlink" title="23.17 ThisParameterType&lt; Type &gt;"></a>23.17 ThisParameterType&lt; Type &gt;</h3><p>ThisParameterType&lt;**Type**&gt;提取函数类型中this参数的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="title class_">ThisParameterType</span>&lt;<span class="keyword">typeof</span> toHex&gt;; <span class="comment">// numbers</span></span><br></pre></td></tr></table></figure>

<p>如果函数没有this参数，则返回unknown。<br>ThisParameterType&lt;**Type**&gt;的实现如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ThisParameterType</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> (</span><br><span class="line">    <span class="attr">this</span>: infer U,</span><br><span class="line">    ...<span class="attr">args</span>: <span class="built_in">never</span></span><br><span class="line">  ) =&gt; <span class="built_in">any</span> ? U : <span class="built_in">unknown</span>；</span><br></pre></td></tr></table></figure>

<h3 id="23-18-ThisType-lt-Type-gt"><a href="#23-18-ThisType-lt-Type-gt" class="headerlink" title="23.18 ThisType&lt; Type &gt;"></a>23.18 ThisType&lt; Type &gt;</h3><p>ThisType&lt;**Type**&gt;不返回类型，只用来跟其他类型组成交叉类型，用来提示TypeScript 其他类型里面的this的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HelperThisValue</span> &#123;</span><br><span class="line">  <span class="attr">logError</span>: <span class="function">(<span class="params">error:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">helperFunctions</span>:</span><br><span class="line">  &#123; [<span class="attr">name</span>: <span class="built_in">string</span>]: <span class="title class_">Function</span> &#125; &amp;</span><br><span class="line">  <span class="title class_">ThisType</span>&lt;<span class="title class_">HelperThisValue</span>&gt;</span><br><span class="line">= &#123;</span><br><span class="line">  <span class="attr">hello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">logError</span>(<span class="string">&quot;Error: Something wrong!&quot;</span>); <span class="comment">// 正确</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量helperFunctions的类型是一个正常的对象类型与ThisType&lt;**HelperThisValue**&gt;组成的交叉类型。<br>这里的ThisType的作用是提示 TypeScript，变量helperFunctions的this应该满足HelperThisValue的条件。所以，this.logError()可以正确调用，而this.update()会报错，因为HelperThisValue里面没有这个方法。<br>注意，使用这个类型工具时，必须打开noImplicitThis设置。</p>
<p>ThisType&lt;**Type**&gt;的实现就是一个空接口。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ThisType</span>&lt;T&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-19-字符串类型工具"><a href="#23-19-字符串类型工具" class="headerlink" title="23.19 字符串类型工具"></a>23.19 字符串类型工具</h3><p>TypeScript 内置了四个字符串类型工具，专门用来操作字符串类型。这四个工具类型都定义在 TypeScript 自带的.d.ts文件里面。<br>它们的实现都是在底层调用 JavaScript 引擎提供 JavaScript 字符操作方法。</p>
<p>Uppercase&lt;**StringType**&gt;将字符串类型的每个字符转为大写。</p>
<p>Lowercase&lt;**StringType**&gt;将字符串的每个字符转为小写。</p>
<p>Capitalize&lt;**StringType**&gt;将字符串的第一个字符转为大写。</p>
<p>Uncapitalize&lt;**StringType**&gt; 将字符串的第一个字符转为小写。</p>
<h2 id="二十四、TypeScript-的注释指令"><a href="#二十四、TypeScript-的注释指令" class="headerlink" title="二十四、TypeScript 的注释指令"></a>二十四、TypeScript 的注释指令</h2><p>TypeScript 接受一些注释指令。<br>所谓“注释指令”，指的是采用 JS 双斜杠注释的形式，向编译器发出的命令。</p>
<h3 id="24-1-ts-nocheck"><a href="#24-1-ts-nocheck" class="headerlink" title="24.1 // @ts-nocheck"></a>24.1 // @ts-nocheck</h3><p>// @ts-nocheck告诉编译器不对当前脚本进行类型检查，可以用于 TypeScript 脚本，也可以用于 JavaScript 脚本。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-nocheck</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="number">123</span>); </span><br><span class="line"><span class="comment">//document.getElementById(123)存在类型错误，但是编译器不对该脚本进行类型检查，所以不会报错。</span></span><br></pre></td></tr></table></figure>

<h3 id="24-2-ts-check"><a href="#24-2-ts-check" class="headerlink" title="24.2 // @ts-check"></a>24.2 // @ts-check</h3><p>如果一个 JavaScript 脚本顶部添加了// @ts-check，那么编译器将对该脚本进行类型检查，不论是否启用了checkJs编译选项。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"><span class="keyword">let</span> isChecked = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isChceked); <span class="comment">// 报错 </span></span><br><span class="line"><span class="comment">//上面示例是一个 JavaScript 脚本，// @ts-check告诉 TypeScript 编译器对其进行类型检查，所以最后一行会报错，提示拼写错误。</span></span><br></pre></td></tr></table></figure>

<h3 id="24-3-ts-ignore"><a href="#24-3-ts-ignore" class="headerlink" title="24.3 // @ts-ignore"></a>24.3 // @ts-ignore</h3><p>// @ts-ignore或// @ts-expect-error，告诉编译器不对下一行代码进行类型检查，可以用于 TypeScript 脚本，也可以用于 JavaScript 脚本。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line">x = <span class="literal">false</span>; <span class="comment">// 不报错 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一行是类型错误，变量x的类型是number，不能等于布尔值。但是因为前面加上了// @ts-expect-error，编译器会跳过这一行的类型检查，所以不会报错。</span></span><br></pre></td></tr></table></figure>

<h3 id="24-4-JSDoc"><a href="#24-4-JSDoc" class="headerlink" title="24.4 JSDoc"></a>24.4 JSDoc</h3><p>TypeScript 直接处理 JS 文件时，如果无法推断出类型，会使用 JS 脚本里面的 JSDoc注释。<br>使用 JSDoc 时，有两个基本要求。<br>（1）JSDoc 注释必须以/*<em>开始，其中星号（</em>）的数量必须为两个。若使用其他形式的多行注释，则 JSDoc 会忽略该条注释。<br>（2）JSDoc 注释必须与它描述的代码处于相邻的位置，并且注释在上，代码在下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">somebody</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">somebody</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + somebody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 编译器支持大部分的 JSDoc 声明。</p>
<h4 id="24-4-1-typedef"><a href="#24-4-1-typedef" class="headerlink" title="24.4.1 @typedef"></a>24.4.1 @typedef</h4><p>@typedef命令创建自定义类型，等同于 TypeScript 里面的类型别名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">(number | string)</span>&#125; <span class="variable">NumberLike</span></span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="comment">//定义了一个名为NumberLike的新类型，它是由number和string构成的联合类型，等同于 TypeScript 的如下语句。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumberLike</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<h4 id="24-4-2-type"><a href="#24-4-2-type" class="headerlink" title="24.4.2 @type"></a>24.4.2 @type</h4><p>@type命令定义变量的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure>

<p>在@type命令中可以使用由@typedef命令创建的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">(number | string)</span>&#125; <span class="variable">NumberLike</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> &#123;<span class="type">NumberLike</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在@type命令中允许使用 TypeScript 类型及其语法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**<span class="doctag">@type</span> &#123;<span class="type">true | false</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">number[]</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Array&lt;number&gt;</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">&#123; readonly x: number, y?: string </span>&#125;&#125; */</span></span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">(s: string, b: boolean) =&gt; number</span>&#125; */</span></span><br><span class="line"><span class="keyword">let</span> e;</span><br></pre></td></tr></table></figure>

<h4 id="24-4-3-param"><a href="#24-4-3-param" class="headerlink" title="24.4.3 @param"></a>24.4.3 @param</h4><p>@param命令用于定义函数参数的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125;  <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果是可选参数，需要将参数名放在方括号[]里面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125;  [x]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>方括号里面，还可以指定参数默认值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; [x=&quot;bar&quot;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-4-4-return，-returns"><a href="#24-4-4-return，-returns" class="headerlink" title="24.4.4 @return，@returns"></a>24.4.4 @return，@returns</h4><p>@return和@returns命令的作用相同，指定函数返回值的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-4-5-extends-和类型修饰符"><a href="#24-4-5-extends-和类型修饰符" class="headerlink" title="24.4.5 @extends 和类型修饰符"></a>24.4.5 @extends 和类型修饰符</h4><p>@extends命令用于定义继承的基类。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> &#123;<span class="type">Base</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@public、@protected、@private分别指定类的公开成员、保护成员和私有成员。</p>
<p>@readonly指定只读成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@public</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@readonly</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二十五、tsconfig-json"><a href="#二十五、tsconfig-json" class="headerlink" title="二十五、tsconfig.json"></a>二十五、tsconfig.json</h2><h3 id="25-1-简介"><a href="#25-1-简介" class="headerlink" title="25.1 简介"></a>25.1 简介</h3><p>tsconfig.json是 TypeScript 项目的配置文件，放在项目的根目录。反过来说，如果一个目录里面有tsconfig.json，TypeScript 就认为这是项目的根目录。<br>如果项目源码是 JavaScript，但是想用 TypeScript 处理，那么配置文件的名字是jsconfig.json，它跟tsconfig的写法是一样的。<br>tsconfig.json文件主要供tsc编译器使用，它的命令行参数–project或-p可以指定tsconfig.json的位置（目录或文件皆可）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -p ./dir</span><br></pre></td></tr></table></figure>

<p>如果不指定配置文件的位置，tsc就会在当前目录下搜索tsconfig.json文件，如果不存在，就到上一级目录搜索，直到找到为止。<br>tsconfig.json文件的格式，是一个 JSON 对象，最简单的情况可以只放置一个空对象{}。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./built&quot;</span>,</span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;./src/**/*&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tsconfig.json文件可以不必手写，使用 tsc 命令的–init参数自动生成。</p>
<p>也可以使用别人预先写好的 tsconfig.json 文件，npm 的@tsconfig名称空间下面有很多模块，都是写好的tsconfig.json样本，比如 @tsconfig/recommended和@tsconfig/node16。</p>
<h3 id="25-2-exclude"><a href="#25-2-exclude" class="headerlink" title="25.2 exclude"></a>25.2 exclude</h3><p>exclude属性是一个数组，必须与include属性一起使用，用来从编译列表中去除指定的文件。它也支持使用与include属性相同的通配符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;**/*&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;**/*.spec.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-3-extends"><a href="#25-3-extends" class="headerlink" title="25.3 extends"></a>25.3 extends</h3><p>tsconfig.json可以继承另一个tsconfig.json文件的配置。如果一个项目有多个配置，可以把共同的配置写成tsconfig.base.json，其他的配置文件继承该文件，这样便于维护和修改。<br>extends属性用来指定所要继承的配置文件。它可以是本地文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;../tsconfig.base.json&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果extends属性指定的路径不是以./或../开头，那么编译器将在node_modules目录下查找指定的配置文件。<br>extends属性也可以继承已发布的 npm 模块里面的 tsconfig 文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;@tsconfig/node12/tsconfig.json&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>extends指定的tsconfig.json会先加载，然后加载当前的tsconfig.json。如果两者有重名的属性，后者会覆盖前者。</p>
<h3 id="25-4-files"><a href="#25-4-files" class="headerlink" title="25.4 files"></a>25.4 files</h3><p>files属性指定编译的文件列表，如果其中有一个文件不存在，就会报错。<br>它是一个数组，排在前面的文件先编译。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [<span class="string">&quot;a.ts&quot;</span>, <span class="string">&quot;b.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该属性必须逐一列出文件，不支持文件匹配。如果文件较多，建议使用include和exclude属性。</p>
<h3 id="25-5-include"><a href="#25-5-include" class="headerlink" title="25.5 include"></a>25.5 include</h3><p>include属性指定所要编译的文件列表，既支持逐一列出文件，也支持通配符。文件位置相对于当前配置文件而定。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src/**/*&quot;</span>, <span class="string">&quot;tests/**/*&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>include属性支持三种通配符。</p>
<ul>
<li><p>?：指代单个字符</p>
</li>
<li><p>*：指代任意字符，不含路径分隔符</p>
</li>
<li><p>**：指定任意目录层级。</p>
</li>
</ul>
<p>如果不指定文件后缀名，默认包括.ts、.tsx和.d.ts文件。如果打开了allowJs，那么还包括.js和.jsx。</p>
<h3 id="25-6-references"><a href="#25-6-references" class="headerlink" title="25.6 references"></a>25.6 references</h3><p>references属性是一个数组，数组成员为对象，适合一个大项目由许多小项目构成的情况，用来设置需要引用的底层项目。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;references&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;path&quot;</span>: <span class="string">&quot;../pkg1&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;path&quot;</span>: <span class="string">&quot;../pkg2/tsconfig.json&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>references数组成员对象的path属性，既可以是含有文件tsconfig.json的目录，也可以直接是该文件。<br>与此同时，引用的底层项目的tsconfig.json必须启用composite属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;composite&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-7-compileOptions"><a href="#25-7-compileOptions" class="headerlink" title="25.7 compileOptions"></a>25.7 compileOptions</h3><p>compilerOptions属性用来定制编译行为。这个属性可以省略，这时编译器将使用默认设置。</p>
<h4 id="25-7-1-allowJs"><a href="#25-7-1-allowJs" class="headerlink" title="25.7.1 allowJs"></a>25.7.1 allowJs</h4><p>allowJs允许 TypeScript 项目加载 JS 脚本。编译时，也会将 JS 文件，一起拷贝到输出目录。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-7-2-alwaysStrict"><a href="#25-7-2-alwaysStrict" class="headerlink" title="25.7.2 alwaysStrict"></a>25.7.2 alwaysStrict</h4><p>alwaysStrict确保脚本以 ECMAScript 严格模式进行解析，因此脚本头部不用写”use strict”。它的值是一个布尔值，默认为true。</p>
<h4 id="25-7-3-allowSyntheticDefaultImports"><a href="#25-7-3-allowSyntheticDefaultImports" class="headerlink" title="25.7.3 allowSyntheticDefaultImports"></a>25.7.3 allowSyntheticDefaultImports</h4><p>allowSyntheticDefaultImports允许import命令默认加载没有default输出的模块。<br>比如，打开这个设置，就可以写import React from “react”;，而不是import * as React from “react”;。</p>
<h4 id="25-7-4-allowUnreachableCode"><a href="#25-7-4-allowUnreachableCode" class="headerlink" title="25.7.4 allowUnreachableCode"></a>25.7.4 allowUnreachableCode</h4><p>allowUnreachableCode设置是否允许存在不可能执行到的代码。它的值有三种可能。</p>
<ul>
<li><p>undefined： 默认值，编辑器显示警告。</p>
</li>
<li><p>true：忽略不可能执行到的代码。</p>
</li>
<li><p>false：编译器报错。</p>
</li>
</ul>
<h4 id="25-7-5-allowUnusedLabels"><a href="#25-7-5-allowUnusedLabels" class="headerlink" title="25.7.5 allowUnusedLabels"></a>25.7.5 allowUnusedLabels</h4><p>allowUnusedLabels设置是否允许存在没有用到的代码标签（label）。它的值有三种可能。</p>
<ul>
<li><p>undefined： 默认值，编辑器显示警告。</p>
</li>
<li><p>true：忽略没有用到的代码标签。</p>
</li>
<li><p>false：编译器报错。</p>
</li>
</ul>
<h4 id="25-7-6-baseUrl"><a href="#25-7-6-baseUrl" class="headerlink" title="25.7.6 baseUrl"></a>25.7.6 baseUrl</h4><p>baseUrl的值为字符串，指定 TypeScript 项目的基准目录。</p>
<p>由于默认是以 tsconfig.json 的位置作为基准目录，所以一般情况不需要使用该属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-7-7-checkJs"><a href="#25-7-7-checkJs" class="headerlink" title="25.7.7 checkJs"></a>25.7.7 checkJs</h4><p>checkJS设置对 JS 文件同样进行类型检查。打开这个属性，也会自动打开allowJs。它等同于在 JS 脚本的头部添加// @ts-check命令。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-7-8-composite"><a href="#25-7-8-composite" class="headerlink" title="25.7.8 composite"></a>25.7.8 composite</h4><p>composite打开某些设置，使得 TypeScript 项目可以进行增量构建，往往跟incremental属性配合使用。</p>
<h4 id="25-7-9-declaration"><a href="#25-7-9-declaration" class="headerlink" title="25.7.9 declaration"></a>25.7.9 declaration</h4><p>declaration设置编译时是否为每个脚本生成类型声明文件.d.ts。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-7-10-declarationDir"><a href="#25-7-10-declarationDir" class="headerlink" title="25.7.10 declarationDir"></a>25.7.10 declarationDir</h4><p>declarationDir设置生成的.d.ts文件所在的目录。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;declarationDir&quot;</span>: <span class="string">&quot;./types&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-7-11-declarationMap"><a href="#25-7-11-declarationMap" class="headerlink" title="25.7.11 declarationMap"></a>25.7.11 declarationMap</h4><p>declarationMap设置生成.d.ts类型声明文件的同时，还会生成对应的 SourceMap 文件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;declarationMap&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-7-12-emitBOM"><a href="#25-7-12-emitBOM" class="headerlink" title="25.7.12 emitBOM"></a>25.7.12 emitBOM</h4><p>emitBOM设置是否在编译结果的文件头添加字节顺序标志 BOM，默认值是false。</p>
<h2 id="二十六、tsc-命令行编译器"><a href="#二十六、tsc-命令行编译器" class="headerlink" title="二十六、tsc 命令行编译器"></a>二十六、tsc 命令行编译器</h2><h3 id="26-1-简介"><a href="#26-1-简介" class="headerlink" title="26.1 简介"></a>26.1 简介</h3><p>tsc 是 TypeScript 官方的命令行编译器，用来检查代码，并将其编译成 JavaScript 代码。<br>tsc 默认使用当前目录下的配置文件tsconfig.json，但也可以接受独立的命令行参数。命令行参数会覆盖tsconfig.json，比如命令行指定了所要编译的文件，那么tsc 就会忽略tsconfig.json的files属性。<br>tsc 的基本用法如下。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 使用 tsconfig.<span class="property">json</span> 的配置</span><br><span class="line">$ tsc</span><br><span class="line"># 只编译 index.<span class="property">ts</span></span><br><span class="line">$ tsc index.<span class="property">ts</span></span><br><span class="line"># 编译 src 目录的所有 .<span class="property">ts</span> 文件</span><br><span class="line">$ tsc src<span class="comment">/*.ts</span></span><br><span class="line"><span class="comment"># 指定编译配置文件</span></span><br><span class="line"><span class="comment">$ tsc --project tsconfig.production.json</span></span><br><span class="line"><span class="comment"># 只生成类型声明文件，不编译出 JS 文件</span></span><br><span class="line"><span class="comment">$ tsc index.js --declaration --emitDeclarationOnly</span></span><br><span class="line"><span class="comment"># 多个 TS 文件编译成单个 JS 文件</span></span><br><span class="line"><span class="comment">$ tsc app.ts util.ts --target esnext --outfile index.js</span></span><br></pre></td></tr></table></figure>

<h3 id="26-2-命令行参数"><a href="#26-2-命令行参数" class="headerlink" title="26.2 命令行参数"></a>26.2 命令行参数</h3><p>tsc 的命令行参数，大部分与 tsconfig.json 的属性一一对应。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/Webchat.png" alt="墨韵 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>墨韵
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://moyun.com/typescript%E6%95%99%E7%A8%8B/" title="TypeScript教程">http://moyun.com/typescript教程/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
              <a href="/tags/TypeScript/" rel="tag"><i class="fa fa-tag"></i> TypeScript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/es6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/" rel="prev" title="ES6标准入门">
                  <i class="fa fa-chevron-left"></i> ES6标准入门
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MOYUN</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">21:51</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!-- 网站运行时间的设置 -->
<span id="sitetime"></span>
<script language=javascript>
  	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
         		*/
		var t1 = Date.UTC(2020,02,13,15,00,00); //北京时间2018-2-13 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>
    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- 多级目录 -->
  <script type="text/javascript" src="/js/category.js"></script>
</body>
</html>
