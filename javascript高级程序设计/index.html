<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"moyun.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="JavaScript高级程序设计一、什么是JavaScript1.1 JavaScript完整的JavaScript实现包含以下：  核心（ECMAScript）  文档对象模型（DOM）  浏览器对象模型（BOM）">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript高级程序设计">
<meta property="og:url" content="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="MoYun">
<meta property="og:description" content="JavaScript高级程序设计一、什么是JavaScript1.1 JavaScript完整的JavaScript实现包含以下：  核心（ECMAScript）  文档对象模型（DOM）  浏览器对象模型（BOM）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="file:///D:/dell/Documents/img/2023-05-05-22-17-03-image.png">
<meta property="og:image" content="file:///D:/dell/Documents/img/2023-05-05-22-17-23-image.png">
<meta property="og:image" content="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell/Documents/img/2024-02-08-17-51-05-image.png">
<meta property="og:image" content="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell/Documents/img/2024-02-19-11-20-55-image.png">
<meta property="og:image" content="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell/Documents/img/2024-02-19-11-32-19-image.png">
<meta property="og:image" content="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell/Documents/img/2024-02-20-15-19-02-image.png">
<meta property="og:image" content="d:\dell\Documents\img\2024-02-21-17-06-17-image.png">
<meta property="og:image" content="d:\dell\Documents\img\2024-02-21-17-07-22-image.png">
<meta property="og:image" content="d:\dell\Documents\img\2024-02-21-17-08-37-image.png">
<meta property="article:published_time" content="2024-03-20T07:46:56.809Z">
<meta property="article:modified_time" content="2024-03-20T08:54:24.933Z">
<meta property="article:author" content="墨韵">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="file:///D:/dell/Documents/img/2023-05-05-22-17-03-image.png">


<link rel="canonical" href="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","path":"javascript高级程序设计/","title":"JavaScript高级程序设计"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaScript高级程序设计 | MoYun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="MoYun" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MoYun</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-demo"><a href="/demo/" rel="section"><i class="fa fa-file-code fa-fw"></i>demo</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">JavaScript高级程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJavaScript"><span class="nav-text">一、什么是JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JavaScript"><span class="nav-text">1.1 JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-ECMAScript"><span class="nav-text">1.1.1 ECMAScript</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-DOM"><span class="nav-text">1.1.2 DOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-BOM"><span class="nav-text">1.1.3 BOM</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B0%8F%E7%BB%93"><span class="nav-text">1.2 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81HTML%E4%B8%AD%E7%9A%84JavaScript"><span class="nav-text">二、HTML中的JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-lt-script-gt-%E5%85%83%E7%B4%A0"><span class="nav-text">2.1 &lt;**script**&gt;元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%A0%87%E7%AD%BE%E4%BD%8D%E7%BD%AE"><span class="nav-text">2.1.1 标签位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC"><span class="nav-text">2.1.2 动态加载脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%A1%8C%E5%86%85%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6"><span class="nav-text">2.2 行内代码与外部文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.3 文档模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A0%87%E7%AD%BE%E5%87%BD%E6%95%B0"><span class="nav-text">模板字面量标签函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">原始字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-Symbol-%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.7 Symbol 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">符号的基本使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="nav-text">使用全局符号注册表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7"><span class="nav-text">使用符号作为属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.2 位操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E9%9D%9E"><span class="nav-text">按位非</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="nav-text">按位与</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96"><span class="nav-text">按位或</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="nav-text">按位异或</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%B7%A6%E7%A7%BB"><span class="nav-text">有符号左移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-text">有符号右移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-text">无符号右移</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.3 布尔操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-text">逻辑非</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E"><span class="nav-text">逻辑与</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.4 乘性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%98%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">乘法操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%A4%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">除法操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%96%E6%A8%A1%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">取模操作符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-5-%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.5 指数操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-6-%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.6 加性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="nav-text">加法操作符（+）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%8F%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="nav-text">减法操作符（-）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.7 关系操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-8-%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.8 相等操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%89%E4%BA%8E%E5%92%8C%E4%B8%8D%E7%AD%89%E4%BA%8E"><span class="nav-text">等于和不等于</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E7%AD%89%E5%92%8C%E4%B8%8D%E5%85%A8%E7%AD%89"><span class="nav-text">全等和不全等</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-9-%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.9 条件操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-10-%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.10 逗号操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-if-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.1 if 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-do-while-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.2 do-while 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-while-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.3 while 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4-for-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.4 for 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-5-for-in-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.5 for-in 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-6-for-of-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.6 for-of 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-7-%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.7 标签语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-8-break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.8 break和continue语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-9-with%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.9 with语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-10-switch-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.10 switch 语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E5%87%BD%E6%95%B0"><span class="nav-text">3.7 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E5%B0%8F%E7%BB%93"><span class="nav-text">3.8 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98"><span class="nav-text">四、变量、作用域和内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E5%80%BC"><span class="nav-text">4.1 原始值和引用值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7"><span class="nav-text">4.1.1 动态属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%A4%8D%E5%88%B6%E5%80%BC"><span class="nav-text">4.1.2 复制值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-text">4.1.3 传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.1.4 确定类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">4.2 执行上下文和作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%A2%9E%E5%BC%BA"><span class="nav-text">4.2.1 作用域链增强</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-text">4.2.2 变量声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#var%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%A3%B0%E6%98%8E"><span class="nav-text">var的函数作用域声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#let%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%A3%B0%E6%98%8E"><span class="nav-text">let的块级作用域声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#const%E7%9A%84%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-text">const的常量声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E6%9F%A5%E6%89%BE"><span class="nav-text">标识符查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">4.3 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%A0%87%E8%AE%B0%E6%B8%85%E7%90%86"><span class="nav-text">4.3.1 标记清理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">4.3.2 引用计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">4.3.3 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87const%E5%92%8Clet%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="nav-text">通过const和let声明提升性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E7%B1%BB%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text">隐藏类和删除操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-text">静态分配与对象池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%B0%8F%E7%BB%93"><span class="nav-text">4.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">五、基本引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Date"><span class="nav-text">5.1 Date</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">5.1.1 继承的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-text">5.1.2 日期格式化方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="nav-text">5.1.3 日期&#x2F;时间组件方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-RegExp"><span class="nav-text">5.2 RegExp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-RegExp%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-text">5.2.1 RegExp实例属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-RegExp-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">5.2.2 RegExp 实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-RegExp-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="nav-text">5.2.3 RegExp 构造函数属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-text">5.3 原始值包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-Boolean"><span class="nav-text">5.3.1 Boolean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-Number"><span class="nav-text">5.3.2 Number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-String"><span class="nav-text">5.3.3 String</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JavaScript-%E5%AD%97%E7%AC%A6"><span class="nav-text">JavaScript 字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#normalize%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><span class="nav-text">normalize（）方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-text">字符串操作方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="nav-text">字符串位置方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95"><span class="nav-text">字符串包含方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trim%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><span class="nav-text">trim（）方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#repeat-%E6%96%B9%E6%B3%95"><span class="nav-text">repeat()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#padStart%EF%BC%88%EF%BC%89%E5%92%8C-padEnd%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95"><span class="nav-text">padStart（）和 padEnd（）方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%AD%E4%BB%A3%E5%92%8C%E7%BB%93%E6%9E%84"><span class="nav-text">字符串迭代和结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="nav-text">字符串大小写转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%B3%95"><span class="nav-text">字符串匹配模式方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#localeCompare-%E6%96%B9%E6%B3%95"><span class="nav-text">localeCompare()方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%8D%95%E4%BE%8B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="nav-text">5.4 单例内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-Global"><span class="nav-text">5.4.1 Global</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URL%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-text">URL编码方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eval-%E6%96%B9%E6%B3%95"><span class="nav-text">eval() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#window%E5%AF%B9%E8%B1%A1"><span class="nav-text">window对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-Math"><span class="nav-text">5.4.2 Math</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#min-%E5%92%8C-max-%E6%96%B9%E6%B3%95"><span class="nav-text">min() 和 max() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%88%8D%E5%85%A5%E6%96%B9%E6%B3%95"><span class="nav-text">舍入方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#random-%E6%96%B9%E6%B3%95"><span class="nav-text">random() 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%B0%8F%E7%BB%93"><span class="nav-text">5.5 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">六、集合引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Object"><span class="nav-text">6.1 Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Array"><span class="nav-text">6.2 Array</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-text">6.2.1 创建数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D"><span class="nav-text">6.2.2 数组空位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="nav-text">6.2.3  数组索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84"><span class="nav-text">6.2.4 检测数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.5 迭代器方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-6-%E5%A4%8D%E5%88%B6%E5%92%8C%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.6 复制和填充方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-7-%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.7 转换方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-8-%E6%A0%88%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.8 栈方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-9-%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.9 队列方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-10-%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.10 排序方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-11-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.11 操作方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-12-%E6%90%9C%E7%B4%A2%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.12 搜索和位置方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-13-%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.13 迭代方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-14-%E5%BD%92%E5%B9%B6%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.14 归并方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E5%AE%9A%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="nav-text">6.3 定型函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-ArrayBuffer"><span class="nav-text">6.3.1 ArrayBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-DataView"><span class="nav-text">6.3.2 DataView</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-text">6.3.4 定型数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-Map"><span class="nav-text">6.4 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.4.1 基本API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-text">6.4.2 顺序与迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-Object-%E5%92%8C-Map-%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">6.4.3 Object 和 Map 的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-WeakMap"><span class="nav-text">6.5 WeakMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.5.1 基本API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-2-%E5%BC%B1%E9%94%AE"><span class="nav-text">6.5.2 弱键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-3-%E4%B8%8D%E5%8F%AF%E8%BF%AD%E4%BB%A3%E9%94%AE"><span class="nav-text">6.5.3 不可迭代键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-4-%E4%BD%BF%E7%94%A8%E5%BC%B1%E6%98%A0%E5%B0%84"><span class="nav-text">6.5.4 使用弱映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-Set"><span class="nav-text">6.6 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.6.1 基本API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-2-%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-text">6.6.2 顺序与迭代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-WeakSet"><span class="nav-text">6.7 WeakSet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.7.1 基本API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-2-%E5%BC%B1%E5%80%BC"><span class="nav-text">6.7.2 弱值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-3-%E4%B8%8D%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%80%BC"><span class="nav-text">6.7.3 不可迭代值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-4-%E4%BD%BF%E7%94%A8%E5%BC%B1%E9%9B%86%E5%90%88"><span class="nav-text">6.7.4 使用弱集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-%E8%BF%AD%E4%BB%A3%E4%B8%8E%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C"><span class="nav-text">6.8 迭代与扩展操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-%E5%B0%8F%E7%BB%93"><span class="nav-text">6.9 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">七、迭代器与生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E8%BF%AD%E4%BB%A3"><span class="nav-text">7.1 迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-text">7.2 迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.2.1 可迭代协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="nav-text">7.2.2 迭代器协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-%E6%8F%90%E5%89%8D%E7%BB%88%E6%AD%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">7.2.3 提前终止迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">7.3 生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-%E7%94%9F%E6%88%90%E5%99%A8%E5%9F%BA%E7%A1%80"><span class="nav-text">7.3.1 生成器基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-%E9%80%9A%E8%BF%87-yield-%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C"><span class="nav-text">7.3.2 通过 yield 中断执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-3-%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">7.3.3 生成器作为默认迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-4-%E6%8F%90%E5%89%8D%E7%BB%88%E6%AD%A2%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">7.3.4 提前终止生成器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E5%B0%8F%E7%BB%93"><span class="nav-text">7.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-text">八、对象、类与面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E5%AF%B9%E8%B1%A1"><span class="nav-text">8.1 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-1-%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B"><span class="nav-text">8.1.1 属性类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2-%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="nav-text">8.1.2 定义多个属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-3-%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">8.1.3 读取属性的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-4-%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="nav-text">8.1.4 合并对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-5-%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86%E5%8F%8A%E7%9B%B8%E7%AD%89%E5%88%A4%E5%AE%9A"><span class="nav-text">8.1.5 对象标识及相等判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-6-%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="nav-text">8.1.6 增强的对象语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-7-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="nav-text">8.1.7 对象解构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">8.2 创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">8.2.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-text">8.2.2 工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="nav-text">8.2.3 构造函数模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">8.2.4 原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-5-%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3"><span class="nav-text">8.2.5 对象迭代</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E7%BB%A7%E6%89%BF"><span class="nav-text">8.3 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-text">8.3.1 原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2-%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">8.3.2 盗用构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-text">8.3.3 组合继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-4-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="nav-text">8.3.4 原型式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-5-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="nav-text">8.3.5 寄生式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-6-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-text">8.3.6 寄生式组合继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E7%B1%BB"><span class="nav-text">8.4 类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-1-%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-text">8.4.1 类定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-2-%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">8.4.2 类构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-3-%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-text">8.4.3 实例、原型和类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-4-%E7%BB%A7%E6%89%BF"><span class="nav-text">8.4.4 继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-%E5%B0%8F%E7%BB%93"><span class="nav-text">8.5 小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="nav-text">九、代理与反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80"><span class="nav-text">9.1 代理基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-1-%E5%88%9B%E5%BB%BA%E7%A9%BA%E4%BB%A3%E7%90%86"><span class="nav-text">9.1.1 创建空代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-2-%E5%AE%9A%E4%B9%89%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="nav-text">9.1.2 定义捕获器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-3-%E6%8D%95%E8%8E%B7%E5%99%A8%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%8D%E5%B0%84-API"><span class="nav-text">9.1.3 捕获器参数和反射 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-4-%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8D%E5%AE%9A%E5%BC%8F"><span class="nav-text">9.1.4 捕获器不定式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-5-%E5%8F%AF%E6%92%A4%E9%94%80%E4%BB%A3%E7%90%86"><span class="nav-text">9.1.5 可撤销代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-6-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84API"><span class="nav-text">9.1.6 使用反射API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-7-%E4%BB%A3%E7%90%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86"><span class="nav-text">9.1.7 代理另一个代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-8-%E4%BB%A3%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="nav-text">9.1.8 代理的问题与不足</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95"><span class="nav-text">9.2 代理捕获器与反射方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-1-get"><span class="nav-text">9.2.1 get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-2-set"><span class="nav-text">9.2.2 set()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-3-has"><span class="nav-text">9.2.3 has()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-4-defineProperty"><span class="nav-text">9.2.4 defineProperty()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-5-getOwnPropertyDescriptor"><span class="nav-text">9.2.5 getOwnPropertyDescriptor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-6-deleteProperty"><span class="nav-text">9.2.6 deleteProperty()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-7-ownKeys"><span class="nav-text">9.2.7 ownKeys()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-8-getPrototypeOf"><span class="nav-text">9.2.8 getPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-9-setPrototypeOf"><span class="nav-text">9.2.9 setPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-10-isExtensible"><span class="nav-text">9.2.10 isExtensible()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-11-preventExtensions"><span class="nav-text">9.2.11 preventExtensions()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-12-apply"><span class="nav-text">9.2.12 apply()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-13-construct"><span class="nav-text">9.2.13 construct()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-text">9.3 代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-1-%E8%B7%9F%E8%B8%AA%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE"><span class="nav-text">9.3.1 跟踪属性访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-2-%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7"><span class="nav-text">9.3.2 隐藏属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-3-%E5%B1%9E%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="nav-text">9.3.3 属性验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-4-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81"><span class="nav-text">9.3.4 函数与构造参数验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-5-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%AF%B9%E8%B1%A1"><span class="nav-text">9.3.5 数据绑定与可观察对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-%E5%B0%8F%E7%BB%93"><span class="nav-text">9.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-text">十、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-text">10.1 箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-%E5%87%BD%E6%95%B0%E5%90%8D"><span class="nav-text">10.2 函数名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-%E7%90%86%E8%A7%A3%E5%8F%82%E6%95%B0"><span class="nav-text">10.3 理解参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD"><span class="nav-text">10.4 没有重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-text">10.5 默认参数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E4%B8%8E%E6%94%B6%E9%9B%86"><span class="nav-text">10.6 参数扩展与收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-6-1-%E6%89%A9%E5%B1%95%E5%8F%82%E6%95%B0"><span class="nav-text">10.6.1 扩展参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-6-2-%E6%94%B6%E9%9B%86%E5%8F%82%E6%95%B0"><span class="nav-text">10.6.2 收集参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-7-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.7 函数声明与函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-8-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC"><span class="nav-text">10.8 函数作为值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-9-%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8"><span class="nav-text">10.9 函数内部</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-9-1-arguments"><span class="nav-text">10.9.1 arguments</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-9-2-this"><span class="nav-text">10.9.2 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-9-3-caller"><span class="nav-text">10.9.3 caller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-9-4-new-target"><span class="nav-text">10.9.4 new.target</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-10-%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-text">10.10 函数属性与方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-11-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.11 函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-12-%E9%80%92%E5%BD%92"><span class="nav-text">10.12 递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-13-%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="nav-text">10.13 尾调用优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-13-1-%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">10.13.1 尾调用优化的条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-14-%E9%97%AD%E5%8C%85"><span class="nav-text">10.14 闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-14-1-this%E5%AF%B9%E8%B1%A1"><span class="nav-text">10.14.1 this对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-15-%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.15 立即调用的函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-16-%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="nav-text">10.16 私有变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-16-1-%E9%9D%99%E6%80%81%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="nav-text">10.16.1 静态私有变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-16-2-%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.16.2 模块模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-16-3-%E6%A8%A1%E5%9D%97%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.16.3 模块增强模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-17-%E5%B0%8F%E7%BB%93"><span class="nav-text">10.17 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="nav-text">十一、期约与异步函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-text">11.1 异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-1-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="nav-text">11.1.1 同步与异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-2-%E4%BB%A5%E5%BE%80%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">11.1.2 以往的异步编程模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-%E6%9C%9F%E7%BA%A6"><span class="nav-text">11.2 期约</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-1-%E6%9C%9F%E7%BA%A6%E5%9F%BA%E7%A1%80"><span class="nav-text">11.2.1 期约基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-3-%E6%9C%9F%E7%BA%A6%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">11.2.3 期约的实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-4-%E6%9C%9F%E7%BA%A6%E8%BF%9E%E9%94%81%E4%B8%8E%E6%9C%9F%E7%BA%A6%E5%90%88%E6%88%90"><span class="nav-text">11.2.4 期约连锁与期约合成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-5-%E6%9C%9F%E7%BA%A6%E6%89%A9%E5%B1%95"><span class="nav-text">11.2.5 期约扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="nav-text">11.3 异步函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="nav-text">11.3.1 异步函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2-%E5%81%9C%E6%AD%A2%E5%92%8C%E6%81%A2%E5%A4%8D%E6%89%A7%E8%A1%8C"><span class="nav-text">11.3.2 停止和恢复执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-3-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%AD%96%E7%95%A5"><span class="nav-text">11.3.3 异步函数策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-%E5%B0%8F%E7%BB%93"><span class="nav-text">11.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81-BOM"><span class="nav-text">十二、 BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-window%E5%AF%B9%E8%B1%A1"><span class="nav-text">12.1 window对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-1-Global%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">12.1.1 Global作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-2-%E7%AA%97%E5%8F%A3%E5%85%B3%E7%B3%BB"><span class="nav-text">12.1.2 窗口关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-3-%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%83%8F%E7%B4%A0%E6%AF%94"><span class="nav-text">12.1.3 窗口位置与像素比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-4-%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="nav-text">12.1.4 窗口大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-5-%E8%A7%86%E5%8F%A3%E4%BD%8D%E7%BD%AE"><span class="nav-text">12.1.5 视口位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-6-%E5%AF%BC%E8%88%AA%E4%B8%8E%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3"><span class="nav-text">12.1.6 导航与打开新窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-7-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">12.1.7 定时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-8-%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-text">12.1.8 系统对话框</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-location%E5%AF%B9%E8%B1%A1"><span class="nav-text">12.2 location对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-1-%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">12.2.1 查询字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-2-%E6%93%8D%E4%BD%9C%E5%9C%B0%E5%9D%80"><span class="nav-text">12.2.2 操作地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-navigator%E5%AF%B9%E8%B1%A1"><span class="nav-text">12.3 navigator对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-1-%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6"><span class="nav-text">12.3.1 检测插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-2-%E6%B3%A8%E5%86%8C%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">12.3.2 注册处理程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-screen%E5%AF%B9%E8%B1%A1"><span class="nav-text">12.4 screen对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5-history%E5%AF%B9%E8%B1%A1"><span class="nav-text">12.5 history对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-5-1-%E5%AF%BC%E8%88%AA"><span class="nav-text">12.5.1 导航</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-5-2-%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-text">12.5.2 历史状态管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-6-%E5%B0%8F%E7%BB%93"><span class="nav-text">12.6 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B"><span class="nav-text">十三、客户端检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B"><span class="nav-text">13.1 能力检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-1-1-%E5%AE%89%E5%85%A8%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B"><span class="nav-text">13.1.1 安全能力检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-1-2-%E5%9F%BA%E4%BA%8E%E8%83%BD%E5%8A%9B%E6%A3%80%E6%B5%8B%E8%BF%9B%E8%A1%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%86%E6%9E%90"><span class="nav-text">13.1.2 基于能力检测进行浏览器分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B"><span class="nav-text">13.2 用户代理检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-1-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="nav-text">13.2.1 用户代理的历史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%86%E6%9E%90"><span class="nav-text">13.2.2 浏览器分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%A1%AC%E4%BB%B6%E6%A3%80%E6%B5%8B"><span class="nav-text">13.3 软件与硬件检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-3-1-%E8%AF%86%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">13.3.1 识别浏览器与操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-3-2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">13.3.2 浏览器元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-3-3-%E7%A1%AC%E4%BB%B6"><span class="nav-text">13.3.3 硬件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-4-%E5%B0%8F%E7%BB%93"><span class="nav-text">13.4 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81DOM"><span class="nav-text">十四、DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-%E8%8A%82%E7%82%B9%E5%B1%82%E7%BA%A7"><span class="nav-text">14.1 节点层级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-1-Node%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.1 Node类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-2-Document%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.2 Document类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-3-Element%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.3 Element类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-4-Text%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.4 Text类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-5-Comment%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.5 Comment类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-6-CDATASection%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.6 CDATASection类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-7-DocumentType%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.7 DocumentType类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-8-DocumentFragment%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.8 DocumentFragment类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-1-9-Attr%E7%B1%BB%E5%9E%8B"><span class="nav-text">14.1.9 Attr类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-DOM-%E7%BC%96%E7%A8%8B"><span class="nav-text">14.2 DOM 编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-1-%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC"><span class="nav-text">14.2.1 动态脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-2-%E5%8A%A8%E6%80%81%E6%A0%B7%E5%BC%8F"><span class="nav-text">14.2.2 动态样式</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="墨韵"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">墨韵</p>
  <div class="site-description" itemprop="description">ZERO-学习博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/moyunzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moyunzero" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zero305747648@gmail.com" title="E-Mail → mailto:zero305747648@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="墨韵">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MoYun">
      <meta itemprop="description" content="ZERO-学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JavaScript高级程序设计 | MoYun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript高级程序设计
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-20 15:46:56 / 修改时间：16:54:24" itemprop="dateCreated datePublished" datetime="2024-03-20T15:46:56+08:00">2024-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Frontend-Notes/" itemprop="url" rel="index"><span itemprop="name">Frontend Notes</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Frontend-Notes/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>458k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6:57</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="JavaScript高级程序设计"><a href="#JavaScript高级程序设计" class="headerlink" title="JavaScript高级程序设计"></a>JavaScript高级程序设计</h1><h2 id="一、什么是JavaScript"><a href="#一、什么是JavaScript" class="headerlink" title="一、什么是JavaScript"></a>一、什么是JavaScript</h2><h3 id="1-1-JavaScript"><a href="#1-1-JavaScript" class="headerlink" title="1.1 JavaScript"></a>1.1 JavaScript</h3><p>完整的JavaScript实现包含以下：</p>
<ul>
<li><p>核心（<strong>ECMAScript</strong>）</p>
</li>
<li><p>文档对象模型（<strong>DOM</strong>）</p>
</li>
<li><p>浏览器对象模型（<strong>BOM</strong>）</p>
</li>
</ul>
<span id="more"></span>

<h4 id="1-1-1-ECMAScript"><a href="#1-1-1-ECMAScript" class="headerlink" title="1.1.1 ECMAScript"></a>1.1.1 ECMAScript</h4><p>即ECMA-262定义的语言，不局限于Web浏览器。ECMAScript只是对实现规范描述的所有方面的一门语言的称呼。<strong>Web 浏览器</strong>只是 ECMAScript 实现可能存在的一种<strong>宿主环境</strong>（host environment）。</p>
<p>在基本层面，描述这门语言的如下部分：</p>
<ul>
<li><p>语法</p>
</li>
<li><p>类型</p>
</li>
<li><p>语句</p>
</li>
<li><p>关键词</p>
</li>
<li><p>保留字</p>
</li>
<li><p>操作符</p>
</li>
<li><p>全局变量</p>
</li>
</ul>
<h4 id="1-1-2-DOM"><a href="#1-1-2-DOM" class="headerlink" title="1.1.2 DOM"></a>1.1.2 DOM</h4><p><strong>文档对象模型（DOM,Document Object Model）</strong> 是一个应用编程接口（API），用于HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据。</p>
<p>!()[/images/2023-05-05-22-17-03-image.png]</p>
<p>!()[/images/2023-05-05-22-17-23-image.png]</p>
<p><img src="file:///D:/dell/Documents/img/2023-05-05-22-17-03-image.png" title alt width="312"><img src="file:///D:/dell/Documents/img/2023-05-05-22-17-23-image.png" title alt width="150"></p>
<blockquote>
<p>这些代码可通过DOM表示为一组分层节点。</p>
</blockquote>
<h4 id="1-1-3-BOM"><a href="#1-1-3-BOM" class="headerlink" title="1.1.3 BOM"></a>1.1.3 BOM</h4><p>BOM(<strong>浏览器对象模型</strong>)，用于支持访问和操作浏览器的窗口</p>
<p>BOM主要针对浏览器窗口和子窗口（frame）</p>
<h3 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2 小结"></a>1.2 小结</h3><p><strong>JavaScript</strong>是一门用来与网页交互的脚本语言，包含以下三个组成部分</p>
<ul>
<li><p><strong>ECMAScript</strong>：由ECMA-262定义并提供核心功能</p>
</li>
<li><p>文档对象模型（<strong>DOM</strong>）：提供与网页内容交互的方法和接口</p>
</li>
<li><p>浏览器对象模型（<strong>BOM</strong>）：提供与浏览器交互的方法和接口</p>
</li>
</ul>
<p>JavaScript 的这三个部分得到了五大 Web 浏览器（IE、Firefox、Chrome、Safari 和 Opera）不同程度的支持。</p>
<h2 id="二、HTML中的JavaScript"><a href="#二、HTML中的JavaScript" class="headerlink" title="二、HTML中的JavaScript"></a>二、HTML中的JavaScript</h2><h3 id="2-1-lt-script-gt-元素"><a href="#2-1-lt-script-gt-元素" class="headerlink" title="2.1 &lt;**script**&gt;元素"></a>2.1 &lt;**script**&gt;元素</h3><p>利用&lt;**script**&gt;元素实现将JavaScript插入HTML。</p>
<p>有以下元素属性：</p>
<ul>
<li><strong>async</strong>：可选，异步执行脚本<ul>
<li><p>表示应立即开始脚本，且不阻止其他页面动作。</p>
</li>
<li><p>只适用于外部脚本。</p>
</li>
<li><p><strong>不能保证</strong>相关脚本按顺序执行。</p>
</li>
<li><p>异步脚本保证会在页面的load事件之前执行，但可能会在DOMContentLoaded之前或之后</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于 XHTML 文档，指定async属性时应该写成async=”async”。</p>
</blockquote>
<ul>
<li><p>charset：可选 </p>
<ul>
<li>使用src属性指定的代码字符集。</li>
</ul>
</li>
<li><p>crossorigin：可选</p>
<ul>
<li><p>配置相关请求的CORS（跨源资源共享）设置。</p>
</li>
<li><p><strong>默认</strong>不使用 CORS。</p>
</li>
<li><p>crossorigin= “anonymous”配置文件请求不必设置凭据标志。</p>
</li>
<li><p>crossorigin=”use-credentials”设置凭据标志，意味着出站请求会包含凭据。</p>
</li>
</ul>
</li>
<li><p><strong>defer</strong>：可选</p>
<ul>
<li><p>表示脚本在执行的时候不会改变页面的结构，即脚本会被延迟到整个页面都解析完毕之后再运行。</p>
</li>
<li><p>按顺序执行，即第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在<strong>DOMContentLoaded事件之前执行</strong></p>
</li>
<li><p>只对外部脚本文件有效。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于 XHTML 文档，指定defer属性时应该写成defer=”defer”。</p>
</blockquote>
<ul>
<li><p>integrity：可选。</p>
<ul>
<li><p>允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。</p>
</li>
<li><p>如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。</p>
</li>
<li><p>可用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。</p>
</li>
</ul>
</li>
<li><p>src：可选。表示包含要执行的代码的外部文件。</p>
</li>
<li><p>type：可选。</p>
<ul>
<li><p>表示代码块中脚本语言的内容类型（MIME类型）。</p>
</li>
<li><p>该值始终是“text/javascript”，JavaScript 文件的 MIME 类型通常是”application/x-javascript”。</p>
</li>
<li><p>如果该值是module，则代码会被当成ES6代码，而且只有这个时候代码中才能出现import和export关键字。</p>
</li>
</ul>
</li>
</ul>
<p>使用&lt;**script**&gt;的方式</p>
<ul>
<li><p>直接在网页中嵌入JS代码</p>
<ul>
<li><p>嵌入行内JS代码，直接把代码放入&lt;**script**&gt;元素中就行</p>
</li>
<li><p>包含在&lt;**script**&gt;内的代码会被从上到下依次解释</p>
</li>
<li><p>代码中不能出现字符串&lt;/**script**&gt;</p>
</li>
</ul>
</li>
<li><p>采用外部JS文件的方式</p>
<ul>
<li>必须使用scr属性——该属性的值是一个URL，指向包含JS代码的文件<ul>
<li>URL指向的资源可以跟包含它的HTML页面不再同一个域中</li>
</ul>
</li>
<li>按顺序依次解释，前提是没有使用defer和async属性</li>
</ul>
</li>
</ul>
<h4 id="2-1-1-标签位置"><a href="#2-1-1-标签位置" class="headerlink" title="2.1.1 标签位置"></a>2.1.1 标签位置</h4><p>将JavaScript引用放在&lt;**body**&gt;元素中的页面内容 <strong>后面</strong>。</p>
<h4 id="2-1-2-动态加载脚本"><a href="#2-1-2-动态加载脚本" class="headerlink" title="2.1.2 动态加载脚本"></a>2.1.2 动态加载脚本</h4><ul>
<li><p>添加&lt;**script**&gt;标签</p>
</li>
<li><p>向DOM中动态添加<strong>script</strong>元素</p>
<ul>
<li>默认情况下，该方式创建的&lt;<strong>script**&gt;元素是以</strong>异步方式加载<strong>的，相当于添加了async属性。此外，把HTMLElement元素添加到 DOM 且执行到这段代码之前</strong>不会发送请求**。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let script = document.createElement(&#x27;script&#x27;); </span><br><span class="line">script.src = &#x27;gibberish.js&#x27;; </span><br><span class="line">document.head.appendChild(script);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-2-行内代码与外部文件"><a href="#2-2-行内代码与外部文件" class="headerlink" title="2.2 行内代码与外部文件"></a>2.2 行内代码与外部文件</h3><p>尽可能将JavaScript代码放在外部文件中</p>
<ul>
<li><p>可维护性</p>
</li>
<li><p>缓存——浏览器会根据特定的设置缓存所有外部链接的JS文件，提高页面加载速度</p>
</li>
<li><p>适应未来</p>
</li>
</ul>
<h3 id="2-3-文档模式"><a href="#2-3-文档模式" class="headerlink" title="2.3 文档模式"></a>2.3 文档模式</h3><p>可以使用doctype切换文档模式</p>
<ul>
<li><p>混杂模式（quirks mode）</p>
<ul>
<li>以省略文档开头的doctype声明作为开关</li>
</ul>
</li>
<li><p>标准模式（standards mode）</p>
<ul>
<li>```html<!-- HTML 4.01 Strict --> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" 
"http://www.w3.org/TR/html4/strict.dtd"><!-- XHTML 1.0 Strict --> 
<!DOCTYPE html PUBLIC 
"-//W3C//DTD XHTML 1.0 Strict//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><!-- HTML5 --> 
<!DOCTYPE html>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 准标准模式（almost standards mode）</span><br><span class="line">  </span><br><span class="line">  - 通过过渡性文档类型（Transitional）和框架集文档类型（Frameset）来触发</span><br><span class="line"></span><br><span class="line">### 2.4 &lt; noscript &gt;元素</span><br><span class="line"></span><br><span class="line">用于给不支持 JavaScript 的浏览器提供替代内容。</span><br><span class="line">&lt;**noscript**&gt;元素可以包含任何可以出现在&lt;**body**&gt;中的 HTML 元素，&lt;**script**&gt;除外。</span><br><span class="line"></span><br><span class="line">在下列两种情况下，浏览器将显示包含在&lt;**noscript**&gt;中的内容： </span><br><span class="line"></span><br><span class="line">- 浏览器不支持脚本； </span><br><span class="line"></span><br><span class="line">- 浏览器对脚本的支持被关闭。 </span><br><span class="line"></span><br><span class="line">任何一个条件被满足，包含在&lt;**noscript**&gt;中的内容就会被渲染。</span><br><span class="line"></span><br><span class="line">### 2.5 小结</span><br><span class="line"></span><br><span class="line">- 要包含外部 JavaScript 文件，必须将src属性设置为要包含文件的 URL。</span><br><span class="line">  </span><br><span class="line">  - 文件可以与网页在同一服务器上，也可以位于完全不同的域。 </span><br><span class="line"></span><br><span class="line">- 在不使用defer和async属性的情况下，包含在&lt;**script**&gt;元素中的代码必须严格按次序解释。 </span><br><span class="line"></span><br><span class="line">- 对**不推迟执行**的脚本，浏览器**必须**解释完位于&lt;**script**&gt;元素中的代码，然后**才能继续**渲染页面的**剩余部分**。通常应该把&lt;**script**&gt;元素放到页面末尾，介于主内容之后&lt;/**body**&gt;标签之前。 </span><br><span class="line"></span><br><span class="line">- 使用**defer属性**把脚本**推迟**到**文档渲染完毕**后再执行。</span><br><span class="line">  </span><br><span class="line">  - 推迟脚本原则上按照次序执行。 </span><br><span class="line"></span><br><span class="line">- 使用**async属性**表示脚本**不需要**等待其他脚本，同时也**不阻塞文档渲染**，即**异步加载**。</span><br><span class="line">  </span><br><span class="line">  - 异步脚本**不能保证**按照出现的次序执行。 </span><br><span class="line"></span><br><span class="line">- 使用&lt;**noscript**&gt;元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则&lt;**noscript**&gt;元素中的任何内容都不会被渲染。</span><br><span class="line"></span><br><span class="line">## 三、语言基础</span><br><span class="line"></span><br><span class="line">### 3.1 语法</span><br><span class="line"></span><br><span class="line">#### 3.1.1 区分大小写</span><br><span class="line"></span><br><span class="line">ECMAScript中一起**都区分大小**写。</span><br><span class="line"></span><br><span class="line">#### 3.1.2 标识符</span><br><span class="line"></span><br><span class="line">**标识符**就是变量、函数、属性或函数参数的名称。</span><br><span class="line"></span><br><span class="line">标识符**组成**：</span><br><span class="line"></span><br><span class="line">- 第一个字符**必须**是一个字母、下划线或美元符号。</span><br><span class="line"></span><br><span class="line">- 剩下的字符可以是字母、下划线、美元符号或数字</span><br><span class="line"></span><br><span class="line">标识符使用**驼峰大小写**形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</span><br><span class="line"></span><br><span class="line">&gt; 关键字、保留字、true、false、null不能作为标识符。</span><br><span class="line"></span><br><span class="line">#### 3.1.3 注释</span><br><span class="line"></span><br><span class="line">单行注释：以两个斜杆字符开头。</span><br><span class="line"></span><br><span class="line">块注释：以一个斜杠和一个星号开头，以它们的反向组合结尾。</span><br><span class="line"></span><br><span class="line">#### 3.1.4 严格模式</span><br><span class="line"></span><br><span class="line">ES5增加严格模式，要对整个脚本启动严格模式，需要在脚本开头加上`use strict;`</span><br><span class="line"></span><br><span class="line">这是一个**预处理指令**。</span><br><span class="line"></span><br><span class="line">可以单独指定一个函数在严格模式下执行，只需将指令放在函数体开头即可。</span><br><span class="line"></span><br><span class="line">### 3.2 关键字和保留字</span><br><span class="line"></span><br><span class="line">break——do——in——typeof——case——else——instanceof——var</span><br><span class="line"></span><br><span class="line">catch——export——new——void——class——extends——return——while</span><br><span class="line"></span><br><span class="line">const——fanally——super——with——continue——for——switch——yield</span><br><span class="line"></span><br><span class="line">debugger——function——this——default——if——throw——delete——import——try</span><br><span class="line"></span><br><span class="line">### 3.3 变量</span><br><span class="line"></span><br><span class="line">变量可以用于保存**任何类型**的数据，每个变量是一个用于保存任意值的**命名占位符**。</span><br><span class="line"></span><br><span class="line">**声明**变量：var、const、let</span><br><span class="line"></span><br><span class="line">#### 3.3.1 var关键字</span><br><span class="line"></span><br><span class="line">定义变量： **var 变量名；**</span><br><span class="line"></span><br><span class="line">&gt; 在不初始化的情况下，变量会保存一个特殊值undefined。</span><br><span class="line"></span><br><span class="line">var声明的变量后续不仅可以**改变**保存的**值**，也可以改变值的**类型**。</span><br><span class="line"></span><br><span class="line">1. ##### var声明作用域</span><br><span class="line">- 范围是函数作用域。</span><br><span class="line"></span><br><span class="line">- 使用var操作符定义的变量会成为包含它的函数的**局部变量**。</span><br><span class="line">  </span><br><span class="line">  &gt; 使用var在函数内部定义一个变量 —— 变量将在函数退出时被销毁。</span><br><span class="line">  &gt; </span><br><span class="line">  &gt; 但在函数内部定义变量时省略var操作符 —— 该变量是全局变量。</span><br><span class="line"></span><br><span class="line">- 定义多个变量时，可以在一条语句中用**逗号分隔**每个变量。</span><br><span class="line">2. ##### var声明提升</span><br><span class="line">- var声明的变量会**自动提升**到函数作用域顶部。</span><br><span class="line"></span><br><span class="line">- **提升**就是把所有变量声明都拉到函数作用域的顶部。</span><br><span class="line"></span><br><span class="line">- var 可反复声明同一变量。</span><br><span class="line"></span><br><span class="line">var在全局作用域中声明的变量会成为window对象的属性。</span><br><span class="line"></span><br><span class="line">#### 3.3.2 let 关键字</span><br><span class="line"></span><br><span class="line">1. ##### let声明作用域</span><br><span class="line">- 范围是**块作用域**。</span><br><span class="line"></span><br><span class="line">- 块作用域是函数作用域的**子集**。</span><br><span class="line"></span><br><span class="line">- let**不允许**同一个块作用域中出现冗余声明。</span><br><span class="line">2. ##### 暂时性死区</span><br><span class="line">- let与var的**区别**：let声明的变量不会在作用域中被提升。</span><br><span class="line">3. ##### 全局声明</span><br><span class="line">- let与var的区别：let在全局作用域中声明的变量不会成为window对象的属性。</span><br><span class="line">  </span><br><span class="line">  &gt; let声明是在全局作用域中发生的，相应变量会在生命周期内存续，必须确保不会重复进行声明。</span><br><span class="line">4. ##### 条件声明</span><br><span class="line"></span><br><span class="line">let的作用域是块，**不能依赖**条件声明模式。</span><br><span class="line"></span><br><span class="line">5. ##### for循环中的 let 声明</span><br><span class="line">- var 进行 for 循环时，定义的迭代变量会渗透到循环体外部。</span><br><span class="line">  </span><br><span class="line">  - 会对迭代变量的奇特声明和修改。</span><br><span class="line">  </span><br><span class="line">  - 在退出循环时，迭代变量保存的是导致循环退出的值。在之后执行超时逻辑时，所有的i都是同一个变量，因而输出的都是同一个最终值。 </span><br><span class="line"></span><br><span class="line">- 使用 let 则解决渗透问题 —— 迭代变量的作用域仅限于for循环块内部。</span><br><span class="line">  </span><br><span class="line">  - 使用let声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。引用的都是不同的变量实例，所以console.log输出的就是循环执行过程中每个迭代变量的值。</span><br><span class="line"></span><br><span class="line">#### 3.3.3 const关键字</span><br><span class="line"></span><br><span class="line">const的行为与let基本相同。</span><br><span class="line"></span><br><span class="line">- 不允许重复声明。</span><br><span class="line"></span><br><span class="line">- 声明的域是块级作用域。</span><br><span class="line"></span><br><span class="line">与let的**区别**：const声明变量时**必须**同时**初始化**变量且尝试修改const声明的变量会导致运行错误。</span><br><span class="line"></span><br><span class="line">const声明的**限制**只适用于它指向的变量的有引用，即如果const变量**引用**的是一个**对象**，那么可以**修改**该对象内部的**属性**。</span><br><span class="line"></span><br><span class="line">不能用const来声明迭代变量（存在迭代变量自增问题）。</span><br><span class="line"></span><br><span class="line">### 3.4 数据类型</span><br><span class="line"></span><br><span class="line">ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是 ECMAScript 6 新增的。</span><br><span class="line"></span><br><span class="line">一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合。</span><br><span class="line"></span><br><span class="line">#### 3.4.1 typeof 操作符</span><br><span class="line"></span><br><span class="line">用于确定变量的数据类型。</span><br><span class="line"></span><br><span class="line">- &quot;undefined&quot;表示值未定义； </span><br><span class="line">  </span><br><span class="line">  &gt; 无论声明还是未声明，typeof 对于未初始化的变量返回的都是字符串“undefined”</span><br><span class="line"></span><br><span class="line">- &quot;boolean&quot;表示值为布尔值； </span><br><span class="line"></span><br><span class="line">- &quot;string&quot;表示值为字符串； </span><br><span class="line"></span><br><span class="line">- &quot;number&quot;表示值为数值； </span><br><span class="line"></span><br><span class="line">- &quot;object&quot;表示值为**对象**（而不是函数）或**null**； </span><br><span class="line"></span><br><span class="line">- &quot;function&quot;表示值为函数； </span><br><span class="line"></span><br><span class="line">- &quot;symbol&quot;表示值为符号。</span><br><span class="line"></span><br><span class="line">简单数据类型（原始类型）</span><br><span class="line"></span><br><span class="line">#### 3.4.2 Undefined 类型</span><br><span class="line"></span><br><span class="line">- 该类型只有一个值，即特殊值undefined。</span><br><span class="line"></span><br><span class="line">- 当使用var或let声明了变量但未初始化时，就相当于给变量赋予了undefined值。</span><br><span class="line"></span><br><span class="line">- undefined是一个假值。</span><br><span class="line"></span><br><span class="line">#### 3.4.3 Null 类型</span><br><span class="line"></span><br><span class="line">- 该类型只有一个值，即特殊值null，逻辑上null值表示一个**空对象指针**。</span><br><span class="line"></span><br><span class="line">- 在定义要保存对象值的变量时，用null来进行初始化。</span><br><span class="line"></span><br><span class="line">- null 是一个假值。</span><br><span class="line"></span><br><span class="line">#### 3.4.4 Boolean 类型</span><br><span class="line"></span><br><span class="line">- 有两个字面值：true 和 false 。</span><br><span class="line">- 将一个其他类型的值转换为布尔值，可以调用特定的 Boolean（）转型函数。</span><br><span class="line"></span><br><span class="line">| 数据类型      | 转换为true的值   | 转换为false的值 |</span><br><span class="line">| --------- | ----------- | ---------- |</span><br><span class="line">| Boolean   | true        | false      |</span><br><span class="line">| String    | 非空字符串       | &quot;&quot;（空字符串）   |</span><br><span class="line">| Number    | 非零数值（包括无穷值） | 0、NaN      |</span><br><span class="line">| Object    | 任意对象        | null       |</span><br><span class="line">| Undefined | N/A（不存在）    | undefined  |</span><br><span class="line"></span><br><span class="line">&gt; if 等流**控制语句**会**自动**执行其他类型值到布尔值的转换。</span><br><span class="line"></span><br><span class="line">#### 3.4.5 Number 类型</span><br><span class="line"></span><br><span class="line">- 最基本的数值字面量格式是十进制整数。</span><br><span class="line"></span><br><span class="line">- 八进制字面量，第一个数字必须是**0**；八进制字面量在严格模式下是无效的。</span><br><span class="line"></span><br><span class="line">- 十六进制字面量，前缀必须是**0x**（区分大小写）。</span><br><span class="line">1. ##### 浮点值</span><br><span class="line">- 数值中**必须**包含小数点，且小数点后面**必须至少**有一个数字。</span><br><span class="line"></span><br><span class="line">- 存储浮点值使用的内存空间是存储整数值的两倍。</span><br><span class="line"></span><br><span class="line">- 浮点值可以用科学计数法来表示。</span><br><span class="line"></span><br><span class="line">- 浮点数的精确度最高可达17位小数。</span><br><span class="line">2. ##### 值的范围</span><br><span class="line">- ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE；保存的最大数值保存在Number.MAX_VALUE。</span><br><span class="line">3. ##### NaN</span><br><span class="line">- 用来表示本来要返回数值的操作失败了。</span><br><span class="line">  </span><br><span class="line">  &gt; 在ES中，0、+0或-0相除会返回NaN。</span><br><span class="line"></span><br><span class="line">- **属性**</span><br><span class="line">  </span><br><span class="line">  - 任何涉及 NaN 的操作始终返回 NaN。</span><br><span class="line">  </span><br><span class="line">  - NaN 不等于包括 NaN 在内的任何值。</span><br><span class="line"></span><br><span class="line">- **isNaN（）** 函数，接受一个参数，可以是任意数据类型，然后判断该参数是否“**不是数值**”，该函数会尝试把参数转换成数值。</span><br><span class="line">4. ##### 数值转换</span><br><span class="line">- 将非数值转化为数值的函数 **Number（）、parseInt（）、parseFloat（）** 。</span><br><span class="line"></span><br><span class="line">- **Number（）** 可用于任何数据类型。</span><br><span class="line">  </span><br><span class="line">  - 基于以下规则执行转换</span><br><span class="line">    </span><br><span class="line">    - 布尔值，true 转化为 1，false 转换为 0。</span><br><span class="line">    </span><br><span class="line">    - 数值，直接返回。</span><br><span class="line">    </span><br><span class="line">    - null，返回0 。</span><br><span class="line">    </span><br><span class="line">    - undefined，返回 NaN。</span><br><span class="line">    </span><br><span class="line">    - 字符串</span><br><span class="line">      </span><br><span class="line">      - 如果字符串包含**数值**字符，包括数值字符前面带加减号的情况，则转换为一个十进制数值。</span><br><span class="line">      </span><br><span class="line">      - 如果字符串包含**有效的浮点值**格式，则会转换为相应的浮点值，**忽略**前面的零。</span><br><span class="line">      </span><br><span class="line">      - 如果字符串包含有效的**十六进制**格式，则会转换为与该十六进制对应的十进制整数。</span><br><span class="line">      </span><br><span class="line">      - 如果是**空字符串**（不含字符），则返回 0。</span><br><span class="line">      </span><br><span class="line">      - 如果字符串包含除上述情况之外的其他字符，则返回 NaN。</span><br><span class="line">    </span><br><span class="line">    - 对象，调用 **valueOf（）** 方法，如果转换结果是 NaN，则调用 toString（）方法，再按照转换字符串的规则转换。</span><br><span class="line"></span><br><span class="line">- **parseInt（）** 函数专注于字符串是否包含数值模式。</span><br><span class="line">  </span><br><span class="line">  - 需得到整数时通常优先考虑该函数。</span><br><span class="line">  </span><br><span class="line">  - 字符串**最前面的空格**会被**忽略**，从第一个非空字符开始转换，如果第一个字符不是数值字符、加减号，立即返回NaN。</span><br><span class="line">    </span><br><span class="line">    - 空字符串返回NaN。</span><br><span class="line">  </span><br><span class="line">  - 字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式。</span><br><span class="line">  </span><br><span class="line">  - 该函数接收第二个参数，用于**指定底数**（进制数）。</span><br><span class="line"></span><br><span class="line">- **parseFloat（）** 函数</span><br><span class="line">  </span><br><span class="line">  - 从位置0开始检测每个字符，解析到字符串末尾或解析到一个无效的浮点数值字符为止。</span><br><span class="line">  </span><br><span class="line">  - **始终忽略**字符串开头的零。</span><br><span class="line">  </span><br><span class="line">  - **只解析**十进制值。</span><br><span class="line">  </span><br><span class="line">  - 字符串表示整数（没有小数点或者小数点后面只有一个零），则parseFloat()返回**整数**。</span><br><span class="line"></span><br><span class="line">#### 3.4.6 String 类型</span><br><span class="line"></span><br><span class="line">表示零或多个16位 Unicode 字符序列。</span><br><span class="line"></span><br><span class="line">1. ##### 字符字面量</span><br><span class="line">- 字符串数据类型包含一些字符字面量，用于表示**非打印字符**或有**其他用途**的字符。</span><br><span class="line">  </span><br><span class="line">  | 字 面 量  | 含  义                                       |</span><br><span class="line">  |:------:|:------------------------------------------:|</span><br><span class="line">  | \n     | 换行                                         |</span><br><span class="line">  | \t     | 制表                                         |</span><br><span class="line">  | \b     | 退格                                         |</span><br><span class="line">  | \r     | 回车                                         |</span><br><span class="line">  | \f     | 换页                                         |</span><br><span class="line">  | \\\\   | 反斜杠（\）                                     |</span><br><span class="line">  | \&#x27;     | 单引号（&#x27;），在字符串以单引号标示时使用，例如&#x27;He said, \&#x27;hey.\&#x27;&#x27; |</span><br><span class="line">  | \&quot;     | 双引号（&quot;），在字符串以双引号标示时使用，例如&quot;He said, \&quot;hey.\&quot;&quot; |</span><br><span class="line">  | \ `    | 反引号（ `） ，在字符串以反引号标示时使用。                    |</span><br><span class="line">  | \xnn   | 以十六进制编码nn表示的字符（其中n是十六进制数字 0~F），例如\x41等于&quot;A&quot; |</span><br><span class="line">  | \unnnn | 以十六进制编码nnnn表示的 Unicode 字符（其中n是十六进制数字 0~F）。 |</span><br><span class="line"></span><br><span class="line">- 可以出现在字符串中的任意位置，且可以单个字符被解释。</span><br><span class="line">  </span><br><span class="line">  &gt; 如果字符串中包含**双字节字符**，那么**length属性**返回的值可能不是准确的字符数。</span><br><span class="line">2. ##### 字符串的特点</span><br><span class="line">- 字符串是不可变的。</span><br><span class="line">3. ##### 转换为字符串</span><br><span class="line">- 用 **toString（）** 返回当前值的字符串等价物。</span><br><span class="line">  </span><br><span class="line">  - 可用于数值、布尔值、对象、字符串值。</span><br><span class="line">    </span><br><span class="line">    &gt; null和undefined没有toString（）方法。</span><br><span class="line">  </span><br><span class="line">  - 多数情况不接受任何参数。</span><br><span class="line">    </span><br><span class="line">    &gt; 在对数值调用该方法时，toString（）可接受一个底数参数。</span><br><span class="line">  </span><br><span class="line">  - 默认返回数值的十进制字符串形式。</span><br><span class="line"></span><br><span class="line">- 若不确定某值是否为null或undefined，可用String（）转型函数。</span><br><span class="line">  </span><br><span class="line">  - String（）函数遵循规则</span><br><span class="line">    </span><br><span class="line">    - 如果值有 toString（）方法， 则调用该方法（不传参数）并返回结果。</span><br><span class="line">    </span><br><span class="line">    - 如果值是null，则返回“null”。</span><br><span class="line">    </span><br><span class="line">    - 如果值是undefined，返回“undefined”。</span><br><span class="line"></span><br><span class="line">&gt; 用加号操作符给一个值加上一个空字符串&quot;&quot;也可以将其转换为字符串。</span><br><span class="line"></span><br><span class="line">4. ##### 模板字面量(``)</span><br><span class="line">- 模板字面量 **保留** 换行字符，可以跨行定义字符串。</span><br><span class="line"></span><br><span class="line">- 模板字面量会 **保持** 反引号内部的空格。</span><br><span class="line"></span><br><span class="line">- 一种特殊的JS句法表达式。</span><br><span class="line"></span><br><span class="line">- 模板字面量在定义时立即求值并转换为字符串实例，任何 **插入的变量** 也会从它们 **最接近** 的作用域中取值。</span><br><span class="line">5. ##### 字符串插值</span><br><span class="line">- 在一个连续定义中插入一个或多个值。</span><br><span class="line"></span><br><span class="line">- 字符串插值通过在 **$&#123;&#125;** 中使用一个JS表达式实现。</span><br><span class="line">  </span><br><span class="line">  ```html</span><br><span class="line">  let value = 5;  </span><br><span class="line">  let exponent = &#x27;second&#x27;; </span><br><span class="line">  let interpolatedTemplateLiteral = </span><br><span class="line">    `$&#123; value &#125; to the $&#123; exponent &#125; power is $&#123; value * value &#125;`; </span><br><span class="line">  </span><br><span class="line">  console.log(interpolatedTemplateLiteral);  // 5 to the second power is 25</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>所有插入的值都会 <strong>使用toString()强制转型</strong> 为字符串，而且任何 JavaScript 表达式都可以用于插值。</p>
</li>
<li><p>在插值表达式中 <strong>可调用</strong> 函数和方法。</p>
</li>
<li><p>模板可以插入之前的值。</p>
</li>
</ul>
<ol start="6">
<li><h5 id="模板字面量标签函数"><a href="#模板字面量标签函数" class="headerlink" title="模板字面量标签函数"></a>模板字面量标签函数</h5></li>
</ol>
<ul>
<li><p>通过标签函数可以自定义插值行为。</p>
</li>
<li><p>标签函数会接收<strong>被插值记号分隔后的模板</strong>和每个表达式求值的结果。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let a = 6; </span><br><span class="line">let b = 9;  </span><br><span class="line">function simpleTag(strings, aValExpression, bValExpression, sumExpression) &#123; </span><br><span class="line">  console.log(strings); </span><br><span class="line">  console.log(aValExpression); </span><br><span class="line">  console.log(bValExpression); </span><br><span class="line">  console.log(sumExpression); </span><br><span class="line">  return &#x27;foobar&#x27;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">let untaggedResult = `$&#123; a &#125; + $&#123; b &#125; = $&#123; a + b &#125;`; </span><br><span class="line">let taggedResult = simpleTag`$&#123; a &#125; + $&#123; b &#125; = $&#123; a + b &#125;`; </span><br><span class="line">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] </span><br><span class="line">// 6 </span><br><span class="line">// 9 </span><br><span class="line">// 15</span><br><span class="line">console.log(untaggedResult);   // &quot;6 + 9 = 15&quot; </span><br><span class="line">console.log(taggedResult);     // &quot;foobar&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>标签函数本身是一个 <strong>常规函数</strong> ，通过 <strong>前缀</strong> 到模板字面量来应用自定义行为。</p>
</li>
</ul>
<ol start="7">
<li><h5 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h5></li>
</ol>
<ul>
<li><p>使用模板字面量可以 <strong>直接获取</strong> 原始的模板字面量内容。</p>
</li>
<li><p>默认使用 <strong>String.raw</strong> 标签函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// \u00A9 是版权符号 </span><br><span class="line">console.log(`\u00A9`);            // © </span><br><span class="line">console.log(String.raw`\u00A9`);  // \u00A9</span><br></pre></td></tr></table></figure></li>
<li><p>通过标签函数的第一个参数，即字符串数值的 <strong>.raw</strong> 属性获得每个字符串的原始内容。</p>
</li>
</ul>
<h4 id="3-4-7-Symbol-类型"><a href="#3-4-7-Symbol-类型" class="headerlink" title="3.4.7 Symbol 类型"></a>3.4.7 Symbol 类型</h4><p>符号是<strong>原始值</strong>，且符号实例是 <strong>唯一的、不可变</strong> 的。</p>
<ul>
<li><p>用于确保对象属性使用唯一标识符，不会出现属性冲突的危险。</p>
</li>
<li><p>用于创建唯一记号，进而用作非字符串形式的对象属性。</p>
</li>
</ul>
<ol>
<li><h5 id="符号的基本使用"><a href="#符号的基本使用" class="headerlink" title="符号的基本使用"></a>符号的基本使用</h5></li>
</ol>
<ul>
<li><p>用 <strong>Symbol（）</strong> 函数初始化。</p>
<blockquote>
<p>typeof 返回 symbol 。</p>
</blockquote>
</li>
<li><p>调用Symbol（）函数时，可传入一个字符串参数作为对符号的描述，但该参数与符号定义或标识完全无关。</p>
</li>
<li><p>符号没有字面量语法。</p>
</li>
<li><p>创建Symbol（）实例并将其用作对象的新属性，可以保证它 <strong>不会覆盖</strong> 已有的对象属性。</p>
</li>
<li><p>Symbol（）函数 <strong>不能与new关键字</strong> 一起 <strong>作为构造函数</strong> 使用。</p>
<blockquote>
<p>想使用符号包装对象，可以借用Object()函数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mySymbol = Symbol(); </span><br><span class="line">let myWrappedSymbol = Object(mySymbol); </span><br><span class="line">console.log(typeof myWrappedSymbol);   // &quot;object&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<ol start="2">
<li><h5 id="使用全局符号注册表"><a href="#使用全局符号注册表" class="headerlink" title="使用全局符号注册表"></a>使用全局符号注册表</h5></li>
</ol>
<ul>
<li><p>使用 <strong>Symbol.for（）</strong> 方法，用一个字符串作为键，在全局符号注册表中创建并重用符号。</p>
<ul>
<li>Symbol.for()对每个字符串键都执行幂等操作。</li>
</ul>
</li>
<li><p>全局注册表中的符号 <strong>必须</strong> 使用 <strong>字符串键</strong> 来创建。</p>
<ul>
<li><p>作为参数传给Symbol.for()的任何值都会被转换为字符串。</p>
</li>
<li><p>注册表中使用的键同时也会被用作符号描述。</p>
</li>
</ul>
</li>
<li><p>使用 <strong>Symbol.keyFor（）</strong> 来查询全局注册表，该方法接收符号，返回该全局符号对应的字符串键。</p>
<ul>
<li>查询的不是全局符号，则返回undefined。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建全局符号 </span><br><span class="line">let s = Symbol.for(&#x27;foo&#x27;); </span><br><span class="line">console.log(Symbol.keyFor(s));   // foo </span><br><span class="line"></span><br><span class="line">// 创建普通符号 </span><br><span class="line">let s2 = Symbol(&#x27;bar&#x27;); </span><br><span class="line">console.log(Symbol.keyFor(s2));  // undefined </span><br><span class="line">如果传给Symbol.keyFor()的不是符号，则该方法抛出TypeError： </span><br><span class="line">Symbol.keyFor(123); // TypeError: 123 is not a symbol </span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><h5 id="使用符号作为属性"><a href="#使用符号作为属性" class="headerlink" title="使用符号作为属性"></a>使用符号作为属性</h5></li>
</ol>
<p>凡是可以使用 <strong>字符串或数值</strong> 作为属性的地方，都可以使用符号。</p>
<ul>
<li><p>对象字面量属性、Object.defineProperty()、Object.defineProperties()定义的属性。</p>
</li>
<li><p>对象字面量 <strong>只能在计算属性</strong> 语法中使用符号作为属性。</p>
</li>
<li><p>符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但如果没有显式地保存对这些属性的引用，那么 <strong>必须遍历</strong> 对象的所有符号属性才能找$到$相应的属性键： </p>
<ul>
<li>```html<br>let o = {<br> [Symbol(‘foo’)]: ‘foo val’,<br> [Symbol(‘bar’)]: ‘bar val’<br>};<br>console.log(o);<br>// {Symbol(foo): “foo val”, Symbol(bar): “bar val”}let barSymbol = Object.getOwnPropertySymbols(o) <pre><code>            .find((symbol) =&gt; symbol.toString().match(/bar/));
</code></pre>
console.log(barSymbol);<br>// Symbol(bar)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">4. ##### 内置符号</span><br><span class="line">- 用于重新定义它们，从而改变原生结构的行为。</span><br><span class="line"></span><br><span class="line">- 所有内置符号属性都是 **不可写、不可枚举、不可配置** 的。</span><br><span class="line">  </span><br><span class="line">  &gt; 在提到 ECMAScript 规范时，经常会引用符号在规范中的名称，**前缀为@@**。比如，@@iterator指的就是Symbol.iterator。</span><br><span class="line">5. ##### Symbol.asyncIterator</span><br><span class="line">- 作为一个属性表示一个方法，该方法返回对象 **默认的AsyncIterator**。</span><br><span class="line"></span><br><span class="line">- 由for-await-of语句使用，表示实现异步迭代器API的函数。</span><br><span class="line">6. ##### Symbol.hasInstance</span><br><span class="line">- 作为一个属性表示一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。</span><br><span class="line"></span><br><span class="line">- 由instanceof操作符使用，**instanceof操作符** 可以用来确定一个对象实例的原型链上是否有原型。</span><br><span class="line">7. ##### Symbol.isConcatSpreadable</span><br><span class="line">- 作为一个属性表示一个布尔值，如果是true，则意味着对象应该用Array.prototype.concat()打平其数组元素。</span><br><span class="line">8. ##### Symbol.iterator</span><br><span class="line">- 作为一个属性表示一个方法，该方法返回对象默认的迭代器。</span><br><span class="line">  由for-of语句使用”，这个符号表示实现迭代器 API 的函数。</span><br><span class="line">9. ##### Symbol.match</span><br><span class="line">- 作为一个属性表示一个正则表达式方法，该方法用正则表达式去匹配字符串。由String.prototype.match()方法使用。</span><br><span class="line"></span><br><span class="line">- String.prototype.match()方法会使用以Symbol.match为键的函数来对正则表达式求值。</span><br><span class="line">10. ##### Symbol.replace</span><br><span class="line">- 作为一个属性表示一个正则表达式方法，该方法替换一个字符串中匹配的子串。</span><br><span class="line"></span><br><span class="line">- 由String.prototype.replace()方法使用，String.prototype.replace()方法会使用以Symbol.replace为键的函数来对正则表达式求值。</span><br><span class="line"></span><br><span class="line">- Symbol.replace函数接收两个参数，即调用replace()方法的 **字符串实例** 和 **替换字符串** ，返回的值没有限制。</span><br><span class="line">11. ##### Symbol.search</span><br><span class="line">- 作为一个属性表示一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引</span><br><span class="line"></span><br><span class="line">- 由String.prototype.search()方法使用，String.prototype.search()方法会使用以Symbol.search为键的函数来对正则表达式求值。</span><br><span class="line">12. ##### Symbol.species</span><br><span class="line">- 作为一个属性表示一个函数值，该函数作为创建派生对象的构造函数。</span><br><span class="line"></span><br><span class="line">- 在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。</span><br><span class="line"></span><br><span class="line">- 用Symbol.species定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义。</span><br><span class="line">13. ##### Symbol.split</span><br><span class="line">- 作为一个属性表示一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。</span><br><span class="line"></span><br><span class="line">- 由String.prototype.split()方法使用，String.prototype. split()方法会使用Symbol.split为键的函数来对正则表达式求值。</span><br><span class="line">14. ##### Symbol.toPrimitive</span><br><span class="line">- 作为一个属性表示一个方法，该方法将对象转换为相应的原始值。</span><br><span class="line"></span><br><span class="line">- 由ToPrimitive抽象操作使用。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。</span><br><span class="line"></span><br><span class="line">- 对于一个自定义对象实例，通过在这个实例的Symbol.toPrimitive属性上定义一个函数可以改变默认行为。</span><br><span class="line">15. ##### Symbol.toStringTag</span><br><span class="line">- 作为一个属性表示一个字符串，该字符串用于创建对象的默认字符串描述。</span><br><span class="line"></span><br><span class="line">- 由内置方法Object.prototype.toString()使用。通过toString()方法获取对象标识时，会检索由Symbol.toStringTag指定的实例标识符，默认为&quot;Object&quot;。</span><br><span class="line">16. ##### Symbol.unscopables</span><br><span class="line">- 作为一个属性表示一个对象，该对象所有的以及继承的属性，都会从关联对象的with环境绑定中排除。</span><br><span class="line"></span><br><span class="line">- 设置这个符号并让其映射对应属性的键值为true，就可以阻止该属性出现在with环境绑定中。</span><br><span class="line">  </span><br><span class="line">  &gt; 不推荐使用with，也不推荐使用Symbol.unscopables。</span><br><span class="line"></span><br><span class="line">#### 3.4.8 Object 类型</span><br><span class="line"></span><br><span class="line">对象是一种无序名值对的集合，一组数据和功能的集合。</span><br><span class="line"></span><br><span class="line">- 对象通过 **new** 操作符后跟对象类型的名称来创建。</span><br><span class="line"></span><br><span class="line">&gt; let o = new Object();</span><br><span class="line">&gt; </span><br><span class="line">&gt; 给构造函数提供参数时使用括号。</span><br><span class="line"></span><br><span class="line">- Object是派生其他对象的基类，Object类型的所有属性呵方法在派生对象上同样存在。</span><br><span class="line"></span><br><span class="line">- Object实例的属性和方法</span><br><span class="line">  </span><br><span class="line">  - **constructor**：用于创建当前对象的函数。这个属性的值就是Object() 函数。 </span><br><span class="line">  </span><br><span class="line">  - **hasOwnProperty(*propertyName*)**：用于判断当前对象实例（**不是原型**）上是否存在给定的属性。要检查的属性名必须是字符串（o.hasOwnProperty(&quot;name&quot;)）或符号。 </span><br><span class="line">  </span><br><span class="line">  - **isPrototypeOf( *object* )**：用于判断当前对象是否为另一个对象的原型。</span><br><span class="line">  </span><br><span class="line">  - **propertyIsEnumerable(*propertyName*)**：用于判断给定的属性是否可以使用**for-in语句枚举** 。与hasOwnProperty()一样，属性名 **必须** 是字符串。</span><br><span class="line">  </span><br><span class="line">  - **toLocaleString()**：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。 </span><br><span class="line">  </span><br><span class="line">  - **toString()**：返回对象的 **字符串** 表示。 </span><br><span class="line">  </span><br><span class="line">  - **valueOf()**：返回对象对应的 **字符串、数值或布尔值** 表示。通常与toString()的返回值相同。</span><br><span class="line"></span><br><span class="line">可以采用 **typeof** 操作符来确定变量的数据类型。</span><br><span class="line"></span><br><span class="line">- 注意调用 typeof null 返回的是“object”，这是因为特殊值null被认为是一个对空对象的引用。</span><br><span class="line"></span><br><span class="line">### 3.5 操作符</span><br><span class="line"></span><br><span class="line">一组可以用于操作数据值的操作符，包括数学操作符、位操作符、关系操作符、相等操作符等。</span><br><span class="line"></span><br><span class="line">&gt; 在应用给对象时，操作符通常会调用valueOf()和/或toString()方法来取得可以计算的值。</span><br><span class="line"></span><br><span class="line">#### 3.5.1 一元操作符</span><br><span class="line"></span><br><span class="line">只操作一个值得操作符叫一元操作符。</span><br><span class="line"></span><br><span class="line">1. ##### 递增/递减操作符</span><br><span class="line">- 分为前缀版和后缀版。前缀版位于要操作的变量前头，后缀版位于要操作的变量后头。</span><br><span class="line"></span><br><span class="line">- **前缀** 递增和递减在语句中的 **优先级是相等** 的。</span><br><span class="line"></span><br><span class="line">- **后缀** 递增和递减在语句 **被求值后** 才发生。</span><br><span class="line"></span><br><span class="line">- 递增和递减操作符遵循规则（用于 **任何值** ） </span><br><span class="line">  </span><br><span class="line">  - 对于 **字符串**，如果是 **有效** 的数值形式，则 **转换为数值** 再应用改变。变量 **类型** 从字符串变成数值。 </span><br><span class="line">  </span><br><span class="line">  - 对于 **字符串** ，如果是 **无效** 的数值形式，则将变量的值设置为 **NaN** 。变量 **类型** 从字符串变成数值。 </span><br><span class="line">  </span><br><span class="line">  - 对于 **布尔值** ，如果是 **false**，则转换为 **0** 再应用改变。变量 **类型** 从布尔值变成数值。 </span><br><span class="line">  </span><br><span class="line">  - 对于 **布尔值** ，如果是 **true**，则转换为 **1** 再应用改变。变量 **类型** 从布尔值变成数值。 </span><br><span class="line">  </span><br><span class="line">  - 对于 **浮点值**，加 1 或减 1。 </span><br><span class="line">  </span><br><span class="line">  - 如果是 **对象**，则 **调用其valueOf()** 方法取得可以操作的值。对得到的值应用上述规则。如果是 **NaN**，则 **调用toString()** 并再次应用其他规则。变量 **类型** 从对象变成数值。</span><br><span class="line">2. ##### 一元加和减</span><br><span class="line">- 一元加由一个加号（+）表示，放在变量前头，对数值**没有任何影响**。</span><br><span class="line">  </span><br><span class="line">  &gt; ```html</span><br><span class="line">  &gt; let num = 25; </span><br><span class="line">  &gt; num = +num; </span><br><span class="line">  &gt; console.log(num); // 25</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>将 <strong>一元加</strong> 应用到 <strong>非数值</strong>，则会执行与 <strong>使用Number()</strong> 转型函数一样得类型转换。</p>
</li>
<li><p><strong>一元减</strong> 由一个减号（-）表示，放在变量前头，主要用于把数值 <strong>变成负值</strong> 。</p>
</li>
<li><p>一元加和减操作符主要用于基本的算术，但也可以用于数据类型转换。</p>
</li>
</ul>
<h4 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h4><p>用于数值的 <strong>底层操作</strong> ，即操作内存中表示数据的比特（位）。</p>
<blockquote>
<p>ECMAScript中的所有数值都以 <strong>IEEE 754 64 位</strong> 格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。</p>
</blockquote>
<p><strong>有符号整数</strong> 使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为 <strong>符号位（sign bit）</strong> ，它的值 <strong>决定了</strong> 数值其余部分的格式。</p>
<p><strong>正值</strong> 以真正的二进制格式存储，即 31位中的每一位都代表 2 的幂。</p>
<p><strong>负值</strong> 以一种称为 <strong>二补数</strong>（或补码）的二进制编码存储。</p>
<ul>
<li>一个数值的二补数<br>(1) 确定 <strong>绝对值</strong> 的 <strong>二进制</strong> 表示（如，对于-18，先确定 18 的二进制表示）。<br>(2) <strong>找到</strong> 数值的一 <strong>补数</strong>（或反码）（就是每个 0 都变成 1，每个 1 都变成 0） 。<br>(3) 给结果 <strong>加1</strong>。</li>
</ul>
<p>默认情况下，ECMAScript中的 <strong>所有整数</strong> 都表示为 <strong>有符号数</strong>。</p>
<p>在对 ECMAScript 中的数值应用位操作符时，会导致了一个奇特的 <strong>副作用</strong> ，即特殊值 <strong>NaN和Infinity</strong> 在位操作中都会被当成 <strong>0</strong> 处理。<br>如果将位操作符应用到 <strong>非数值</strong> ，那么首先会 <strong>使用Number()</strong> 函数将该值转换为数值（这个过程是 <strong>自动的</strong>），然后再应用位操作，最终 <strong>结果是数值</strong> 。</p>
<ol>
<li><h5 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h5></li>
</ol>
<ul>
<li><p>用 <strong>~</strong> 表示，用于返回数值的一 <strong>补数</strong> 。</p>
</li>
<li><p>最终结果是对数值 <strong>取反并减1</strong> 。</p>
</li>
</ul>
<ol start="2">
<li><h5 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h5></li>
</ol>
<ul>
<li><p>用 <strong>&amp;</strong> 表示，有两个操作数。</p>
</li>
<li><p>将两个数的每一个位对齐， <strong>基于真值表</strong> 的规则，对每一位执行相应的 <strong>与操作</strong> 。</p>
<ul>
<li>按位与操作在两个位都是 1 时返回 1，在任何一位是 0 时返回 0。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><h5 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h5></li>
</ol>
<ul>
<li><p>用 <strong>|</strong> 表示，有两个操作数。</p>
</li>
<li><p>将两个数的每一个位对齐， <strong>基于真值表</strong> 的规则，对每一位执行相应的 <strong>或操作</strong> 。</p>
<ul>
<li>按位或操作在至少一位是 1 时返回 1，两位都是 0 时返回 0。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><h5 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h5></li>
</ol>
<ul>
<li><p>用 <strong>^</strong> 表示，有两个操作数。</p>
</li>
<li><p>将两个数的每一个位对齐， <strong>基于真值表</strong> 的规则，对每一位执行相应的 <strong>异或操作</strong> 。</p>
<ul>
<li>按位异或操作只在一位上是 1 的时候返回 1，两位都是 1 或 0，则返回 0。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><h5 id="有符号左移"><a href="#有符号左移" class="headerlink" title="有符号左移"></a>有符号左移</h5></li>
</ol>
<ul>
<li><p>用 <strong>&lt;&lt;</strong> 表示，按照指定位数将数值的 <strong>所有位向左移</strong> 动，空位补零。</p>
</li>
<li><p>左移会 <strong>保留</strong> 它所操作数值的 <strong>符号</strong>。</p>
</li>
</ul>
<ol start="6">
<li><h5 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h5></li>
</ol>
<ul>
<li><code>&gt;&gt;</code> 表示右移，同时 <strong>保留符号</strong>（正或负）。</li>
</ul>
<ol start="7">
<li><h5 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h5></li>
</ol>
<ul>
<li><p>用 <strong>&gt;&gt;&gt;</strong> 表示，会将数值的所有 32 位都向右移。</p>
</li>
<li><p>对于 <strong>正数</strong> ，无符号右移与有符号右移 <strong>结果相同</strong> 。</p>
</li>
<li><p>对于 <strong>负数</strong> ，无符号右移会 <strong>给空位补 0</strong>，无视符号位。</p>
</li>
</ul>
<h4 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h4><ol>
<li><h5 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h5></li>
</ol>
<ul>
<li><p><strong>！</strong> 表示，该操作符始终 <strong>返回布尔值</strong>。</p>
</li>
<li><p>操作符遵循规则</p>
<ul>
<li><p>如果操作数是 <strong>对象</strong> ，则返回 <strong>false</strong>。 </p>
</li>
<li><p>如果操作数是 <strong>空字符串</strong>，则返回 <strong>true</strong>。 </p>
</li>
<li><p>如果操作数是 <strong>非空字符串</strong>，则返回 <strong>false</strong>。 </p>
</li>
<li><p>如果操作数是数值 <strong>0</strong>，则返回 <strong>true</strong>。 </p>
</li>
<li><p>如果操作数是 <strong>非 0 数值</strong>（包括Infinity），则返回 <strong>false</strong>。 </p>
</li>
<li><p>如果操作数是 <strong>null</strong>，则返回 <strong>true</strong>。 </p>
</li>
<li><p>如果操作数是 <strong>NaN</strong>，则返回 <strong>true</strong>。 </p>
</li>
<li><p>如果操作数是 <strong>undefined</strong>，则返回 <strong>true</strong>。</p>
</li>
</ul>
<blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(!false);   // true </span><br><span class="line">console.log(!&quot;blue&quot;);  // false </span><br><span class="line">console.log(!0);       // true </span><br><span class="line">console.log(!NaN);     // true </span><br><span class="line">console.log(!&quot;&quot;);      // true </span><br><span class="line">console.log(!12345);   // false</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>可用于将任意值转换为布尔值，同时使用 <strong>！！</strong> 相当于调用了转型函数 <strong>Boolean（）</strong>。</p>
<blockquote>
<p>无论操作数是什么类型，第一个叹号总会返回布尔值，第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(!!&quot;blue&quot;); // true </span><br><span class="line">console.log(!!0);      // false </span><br><span class="line">console.log(!!NaN);    // false </span><br><span class="line">console.log(!!&quot;&quot;);     // false </span><br><span class="line">console.log(!!12345);  // true</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<ol start="2">
<li><h5 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h5></li>
</ol>
<ul>
<li><p><strong>&amp;&amp;</strong> 表示，应用到两个值。</p>
</li>
<li><p>可用于 <strong>任何类型</strong> 的操作数。</p>
</li>
<li><p>如果有操作数 <strong>不是布尔值</strong> ，遵循如下规则</p>
<ul>
<li><p>如果 <strong>第一个</strong> 操作数是 <strong>对象</strong> ，则 <strong>返回第二个</strong> 操作数。 </p>
</li>
<li><p>如果 <strong>第二个</strong> 操作数是对象，则 <strong>只有第一个</strong> 操作数求值 <strong>为true</strong> 才会 <strong>返回该对象</strong>。 </p>
</li>
<li><p>如果 <strong>两个</strong> 操作数 <strong>都是对象</strong>，则 <strong>返回第二个</strong> 操作数。 </p>
</li>
<li><p>如果 <strong>有一个</strong> 操作数是 <strong>null</strong> ，则 <strong>返回null</strong> 。 </p>
</li>
<li><p>如果 <strong>有一个</strong> 操作数是 <strong>NaN</strong> ，则返回 <strong>NaN</strong> 。 </p>
</li>
<li><p>如果 <strong>有一个</strong> 操作数是 <strong>undefined</strong> ，则 <strong>返回undefined</strong>。 </p>
</li>
<li><p>逻辑与操作符是 <strong>一种短路操作符</strong> ，就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>逻辑或</strong></li>
</ol>
<ul>
<li><p>用 <strong>||</strong> 表示。</p>
</li>
<li><p>遵循规则。</p>
<ul>
<li><p>如果 <strong>第一个</strong> 操作数是 <strong>对象</strong>，则 <strong>返回第一个</strong> 操作数。 </p>
</li>
<li><p>如果 <strong>第一个</strong> 操作数求值为 <strong>false</strong>，则 <strong>返回第二个</strong> 操作数。 </p>
</li>
<li><p>如果 <strong>两个</strong> 操作数 <strong>都是对象</strong>，则 <strong>返回第一个</strong> 操作数。 </p>
</li>
<li><p>如果 <strong>两个</strong> 操作数 <strong>都是null</strong>，则 <strong>返回null</strong>。 </p>
</li>
<li><p>如果 <strong>两个</strong> 操作数 <strong>都是NaN</strong>，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果 <strong>两个</strong> 操作数都是 <strong>undefined</strong>，则 <strong>返回undefined</strong>。 </p>
</li>
</ul>
</li>
<li><p>逻辑或操作符具有 <strong>短路</strong> 的特性，第一个操作数求值为true，第二个操作数就不会再被求值了。</p>
</li>
</ul>
<h4 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4 乘性操作符"></a>3.5.4 乘性操作符</h4><p>乘法、除法和取模。</p>
<blockquote>
<p>在处理非数值时，它们会包含一些 <strong>自动的类型转换</strong>。</p>
</blockquote>
<ol>
<li><h5 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h5></li>
</ol>
<ul>
<li>由一个 ***** 表示，用于计算两个数值的乘积。<ul>
<li><p>如果有 <strong>任一</strong>操作数是 <strong>NaN</strong>，则 <strong>返回NaN</strong>。</p>
</li>
<li><p>如果是 <strong>Infinity乘以 0</strong>，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>Infinity</strong>乘以 <strong>非 0 的 有限数值</strong>，则 <strong>根据第二个</strong> 操作数的 <strong>符号返回Infinity或-Infinity</strong> 。 </p>
</li>
<li><p>如果是 <strong>Infinity乘</strong> 以 <strong>Infinity</strong>，则 <strong>返回Infinity</strong>。 </p>
</li>
<li><p>如果 <strong>有不是数值</strong> 的操作数，则先在 <strong>后台用Number()</strong> 将其转换为数值，然后再 <strong>应用上述规则</strong>。</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><h5 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h5></li>
</ol>
<ul>
<li>由 <strong>/</strong> 表示，用于计算第一个操作数除以第二个操作数的商。<ul>
<li><p>如果操作数 <strong>都是数值</strong> ，两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity或-Infinity。 </p>
</li>
<li><p>如果有 <strong>任一</strong> 操作数是 <strong>NaN</strong> ，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>Infinity除以Infinity</strong> ，则 <strong>0</strong>。 </p>
</li>
<li><p>如果是 <strong>0 除以 0</strong>，则返回 <strong>NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>非 0 的有限值</strong> 除以 <strong>0</strong>，则根据 <strong>第一个</strong> 操作数的符号返回 <strong>Infinity或-Infinity</strong> 。 </p>
</li>
<li><p>如果是 <strong>Infinity</strong> 除以 <strong>任何数值</strong> ，则根据 <strong>第二个</strong> 操作数的符号返回 <strong>Infinity或-Infinity</strong>。 </p>
</li>
<li><p>如果 <strong>有不是数值</strong> 的操作数，则先在 <strong>后台用Number()</strong> 函数将其转换为数值，然后再应用上述规则。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><h5 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h5></li>
</ol>
<ul>
<li>由 <strong>%</strong> 表示。<ul>
<li><p>如果操作数是 <strong>数值</strong> ，则执行常规除法运算， <strong>返回余数</strong>。 </p>
</li>
<li><p>如果 <strong>被除数</strong> 是 <strong>无限值</strong> ， <strong>除数</strong> 是 <strong>有限值</strong> ，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果 <strong>被除数</strong> 是 <strong>有限值</strong> ， <strong>除数</strong> 是 <strong>0</strong>，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>Infinity除以Infinity</strong> ，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果 <strong>被除数</strong> 是 <strong>有限值</strong> ，<strong>除数</strong> 是 <strong>无限值</strong> ，则 <strong>返回被除数</strong>。 </p>
</li>
<li><p>如果 <strong>被除数</strong> 是 <strong>0</strong>，<strong>除数不是 0</strong>，则 <strong>返回 0</strong>。 </p>
</li>
<li><p>如果 <strong>有不是数值</strong> 的操作数，则先在 <strong>后台用Number()</strong> 函数将其转换为数值，然后再应用上述规则。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5 指数操作符"></a>3.5.5 指数操作符</h4><p><strong>Math.pow()</strong> 的操作符为 ****** ，指数赋值操作符为 ****=** 。</p>
<h4 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6 加性操作符"></a>3.5.6 加性操作符</h4><ol>
<li><h5 id="加法操作符（-）"><a href="#加法操作符（-）" class="headerlink" title="加法操作符（+）"></a>加法操作符（+）</h5></li>
</ol>
<p>如果 <strong>两个</strong> 操作数都是 <strong>数值</strong> ，加法操作符执行加法运算并根据如下规则返回结果： </p>
<ul>
<li><p>如果有 <strong>任一</strong> 操作数是 <strong>NaN</strong> ，则 <strong>返回NaN</strong>。</p>
</li>
<li><p>如果是 <strong>Infinity加Infinity</strong>，则 <strong>返回Infinity</strong>。</p>
</li>
<li><p>如果是 <strong>-Infinity加-Infinity</strong>，则 <strong>返回-Infinity</strong>。</p>
</li>
<li><p>如果是 <strong>Infinity加-Infinity</strong>，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>+0加+0</strong>，则 <strong>返回+0</strong>。</p>
</li>
<li><p>如果是 <strong>-0加+0</strong>，则 <strong>返回+0</strong>。</p>
</li>
<li><p>如果是 <strong>-0加-0</strong>，则 <strong>返回-0</strong>。</p>
</li>
<li><p>如果 <strong>有一个</strong> 操作数是 <strong>字符串</strong>，则应用如下规则： </p>
<ul>
<li><p>如果 <strong>两个</strong> 操作数都是 <strong>字符串</strong>，则将第二个字符串 <strong>拼接</strong> 到第一个字符串后面； </p>
</li>
<li><p>如果 <strong>只有一个</strong> 操作数是 <strong>字符串</strong>，则将 <strong>另一个</strong> 操作数 <strong>转换为字符串</strong>，再将两个字符串 <strong>拼接</strong> 在一起。 </p>
</li>
<li><p>如果有 <strong>任一</strong> 操作数是 <strong>对象、数值或布尔值</strong> ，则 <strong>调用toString()</strong> 方法以获取字符串，然后再应用前面的关于字符串的规则。</p>
</li>
<li><p>对于 <strong>undefined和null</strong> ，则 <strong>调用String()</strong> 函数，分别获取”undefined”和”null”。</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><h5 id="减法操作符（-）"><a href="#减法操作符（-）" class="headerlink" title="减法操作符（-）"></a>减法操作符（-）</h5></li>
</ol>
<p>减法操作符有一组规则用于处理 ECMAScript 中不同类型之间的转换。 </p>
<ul>
<li><p>如果 <strong>两个</strong> 操作数都是 <strong>数值</strong> ，则执行数学减法运算并返回结果。 </p>
</li>
<li><p>如果有 <strong>任一</strong>操作数是 <strong>NaN</strong>，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>Infinity减Infinity</strong>，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>-Infinity减-Infinity</strong> ，则 <strong>返回NaN</strong>。 </p>
</li>
<li><p>如果是 <strong>Infinity减-Infinity</strong> ，则 <strong>返回Infinity</strong>。 </p>
</li>
<li><p>如果是 <strong>-Infinity减Infinity</strong> ，则 <strong>返回-Infinity</strong>。 </p>
</li>
<li><p>如果是 <strong>+0减+0</strong>，则 <strong>返回+0</strong>。 </p>
</li>
<li><p>如果是 <strong>+0减-0</strong>，则 <strong>返回-0</strong>。 </p>
</li>
<li><p>如果是 <strong>-0减-0</strong>，则 <strong>返回+0</strong>。 </p>
</li>
<li><p>如果有 <strong>任一</strong>操作数是 <strong>字符串、布尔值、null或undefined</strong>，则先在后台使用 <strong>Number()</strong> 将其转换为数值，然后再根据前面的规则执行数学运算。如果 <strong>转换结果</strong>是 <strong>NaN</strong>，则减法计算的 <strong>结果是NaN</strong>。 </p>
</li>
<li><p>如果有 <strong>任一</strong>操作数是 <strong>对象</strong>，则调用其 <strong>valueOf()</strong> 方法取得表示它的数值。如果该值是<strong>NaN</strong>，则减法计算的结果是<strong>NaN</strong>。如果对象没有valueOf()方法，则调用其toString()方法，然后再将得到的字符串转换为数值。</p>
</li>
</ul>
<h4 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7 关系操作符"></a>3.5.7 关系操作符</h4><p>执行 <strong>比较两个值</strong>   的操作，包括小于、大于、小于等于、大于等于，都 <strong>返回布尔值</strong>。</p>
<p>应用到不同数据类型时会发生类型转换和其他行为。</p>
<ul>
<li><p>如果操作数 <strong>都是数值</strong> ，则执行数值比较。 </p>
</li>
<li><p>如果操作数 <strong>都是字符串</strong>，则 <strong>逐个比较</strong> 字符串中对应 <strong>字符的编码</strong>。 </p>
</li>
<li><p>如果有 <strong>任一</strong> 操作数是 <strong>数值</strong> ，则将 <strong>另一个</strong> 操作数 <strong>转换为数值</strong>，执行数值比较。 </p>
</li>
<li><p>如果有 <strong>任一</strong> 操作数是 <strong>对象</strong> ，则调用其 <strong>valueOf()</strong> 方法，取得结果后再根据前面的规则执行比较。</p>
<ul>
<li>如果没有valueOf()操作符，则 <strong>调用toString()</strong> 方法，取得结果后再根据前面的规则执行比较。 </li>
</ul>
</li>
<li><p>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</p>
</li>
</ul>
<h4 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8 相等操作符"></a>3.5.8 相等操作符</h4><p>判断两个变量是否相等。</p>
<ol>
<li><h5 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h5></li>
</ol>
<ul>
<li><p>等于操作符用两个等于号 <strong>==</strong> 表示，两个操作符都会 <strong>先进行类型转换（强制类型转换）</strong>，再确定操作数是否相等。</p>
</li>
<li><p>在转换操作数的类型时，操作符遵循规则。</p>
<ul>
<li><p>如果 <strong>任一</strong> 操作数是 <strong>布尔值</strong>，则将其 <strong>转换为数值</strong> 再比较是否相等。false转换为 0，true转换为 1。</p>
</li>
<li><p>如果 <strong>一个</strong> 操作数是 <strong>字符串</strong>，<strong>另一个</strong> 操作数是 <strong>数值</strong>，则尝试将 <strong>字符串转换为数值</strong>，再比较是否相等。</p>
</li>
<li><p>如果 <strong>一个</strong> 操作数是 <strong>对象</strong>，<strong>另一个</strong> 操作数 <strong>不是</strong>，则 <strong>调用</strong> 对象的 <strong>valueOf()</strong> 方法取得其原始值，再根据前面的规则进行比较。</p>
</li>
</ul>
</li>
<li><p>在进行比较时，这两个操作符会遵循如下规则。 </p>
<ul>
<li><p><strong>null 和 undefined</strong> 相等。 </p>
</li>
<li><p><strong>null和undefined不能转换</strong> 为其他类型的值再进行比较。 </p>
</li>
<li><p>如果有 <strong>任一</strong> 操作数是 <strong>NaN</strong>，则 <strong>相等</strong> 操作符 <strong>返回false</strong>，<strong>不相等</strong> 操作符 <strong>返回true</strong>。</p>
<blockquote>
<p>即使两个操作数都是NaN，相等操作符也返回false，因为按照规则，<strong>NaN不等于NaN</strong></p>
</blockquote>
</li>
<li><p>如果 <strong>两个</strong> 操作数都是 <strong>对象</strong>，则比较它们是不是同一个对象。如果两个操作数都 <strong>指向同一个对象</strong>，则 <strong>相等</strong> 操作符 <strong>返回true</strong>。否则，两者不相等。</p>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">结 果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">null == undefined</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“NaN” == NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">5 == NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN == NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN != NaN</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false == 0</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true == 1</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true == 2</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">undefined == 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">null == 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">“5” == 5</td>
<td align="center">true</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<ol start="2">
<li><h5 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h5></li>
</ol>
<p>比较时 <strong>不转换操作数</strong> ，全等操作符由3个等于号 <strong>===</strong> 表示，只有两个操作数在不转换的前提下相等才返回true。</p>
<p>不全等操作符用 <strong>!==</strong> 表示，只有两个操作数在不转换的前提下不相等才返回true。</p>
<h4 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9 条件操作符"></a>3.5.9 条件操作符</h4><p>variable = boolean_expression ? true_value : false_value。</p>
<h4 id="3-5-10-逗号操作符"><a href="#3-5-10-逗号操作符" class="headerlink" title="3.5.10 逗号操作符"></a>3.5.10 逗号操作符</h4><p>逗号操作符可以用来在一条语句中执行多个操作。</p>
<p>在赋值时使用逗号操作符分隔值，<strong>最终</strong> 会 <strong>返回</strong> 表达式中 <strong>最后一个值</strong> 。</p>
<h3 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h3><h4 id="3-6-1-if-语句"><a href="#3-6-1-if-语句" class="headerlink" title="3.6.1 if 语句"></a>3.6.1 if 语句</h4><p>if（condition） statement1 else statement2</p>
<p>条件（condition）可以是 <strong>任何</strong> 表达式，并且求值结果 <strong>不一定</strong> 是布尔值。</p>
<p>语句可以是一行代码也可以是一个代码块。</p>
<h4 id="3-6-2-do-while-语句"><a href="#3-6-2-do-while-语句" class="headerlink" title="3.6.2 do-while 语句"></a>3.6.2 do-while 语句</h4><p><strong>do-while</strong> 语句是一种 <strong>后测试</strong> 循环语句，即循环体中的 <strong>代码执行后</strong> 才会对退出条件进行求值。即循环体内的代码 <strong>至少执行</strong> 一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    statement  </span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure>

<h4 id="3-6-3-while-语句"><a href="#3-6-3-while-语句" class="headerlink" title="3.6.3 while 语句"></a>3.6.3 while 语句</h4><p><strong>while</strong> 语句是一种 <strong>先测试</strong> 循环语句，即先检测退出条件，再执行循环体内的代码。即while循环体内的代码有可能不会执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression)&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="3-6-4-for-语句"><a href="#3-6-4-for-语句" class="headerlink" title="3.6.4 for 语句"></a>3.6.4 for 语句</h4><p><strong>for</strong> 语句是 <strong>先测试</strong> 语句，增加了进入循环之前的 <strong>初始化代码</strong> ，以及循环执行后要执行的表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; expression; post-loop-expression) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无法通过while 循环实现的逻辑，for循环也无法实现。</p>
<p>for循环中的初始化代码可以不使用变量声明关键字的。</p>
<p>初始化、条件表达式、循环后表达式都非必须。</p>
</blockquote>
<h4 id="3-6-5-for-in-语句"><a href="#3-6-5-for-in-语句" class="headerlink" title="3.6.5 for-in 语句"></a>3.6.5 for-in 语句</h4><p><strong>for-in</strong> 语句是一种严格的 <strong>迭代语句</strong> ，用于 <strong>枚举</strong> 对象中的 <strong>非符号键属性</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="variable language_">window</span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果for-in循环要迭代的变量是null或undefined，则不执行循环体。</p>
<blockquote>
<p>ECMAScript中对象的属性是无序的，即for-in语句不能保证返回对象属性的顺序。</p>
</blockquote>
<h4 id="3-6-6-for-of-语句"><a href="#3-6-6-for-of-语句" class="headerlink" title="3.6.6 for-of 语句"></a>3.6.6 for-of 语句</h4><p><strong>for-of</strong> 语句是一种严格的 <strong>迭代语句</strong>，用于遍历 <strong>可迭代</strong> 对象的 <strong>元素</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(property <span class="keyword">of</span> expression)&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for-of</strong> 循环会按照可迭代对象的 <strong>next()</strong> 方法产生值的顺序迭代元素。</p>
<h4 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7 标签语句"></a>3.6.7 标签语句</h4><p>标签语句用于给语句 <strong>加标签</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">label</span>:statement</span><br></pre></td></tr></table></figure>

<p>标签语句的典型应用场景是嵌套循环。</p>
<h4 id="3-6-8-break和continue语句"><a href="#3-6-8-break和continue语句" class="headerlink" title="3.6.8 break和continue语句"></a>3.6.8 break和continue语句</h4><p><strong>break和continue</strong> 语句为执行循环代码提供了更严格的 <strong>控制手段</strong> 。</p>
<ul>
<li><p><strong>break</strong> 语句用于立即退出循环，<strong>强制执行</strong> 循环后的 <strong>下一条</strong> 语句。</p>
</li>
<li><p><strong>continue</strong> 语句用于立即退出循环，但会 <strong>再次</strong> 从循环 <strong>顶部</strong> 开始执行。</p>
</li>
</ul>
<h4 id="3-6-9-with语句"><a href="#3-6-9-with语句" class="headerlink" title="3.6.9 with语句"></a>3.6.9 with语句</h4><p><strong>with</strong> 语句是将代码 <strong>作用域</strong> 设置为特定的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">with</span>(<span class="params">expression</span>) &#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用with语句的主要场景是针对一个对象反复操作。</p>
<h4 id="3-6-10-switch-语句"><a href="#3-6-10-switch-语句" class="headerlink" title="3.6.10 switch 语句"></a>3.6.10 switch 语句</h4><p><strong>switch</strong> 语句是与 <strong>if</strong> 语句紧密相关的一种 <strong>流控制语句</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123; </span><br><span class="line">  <span class="keyword">case</span> <span class="attr">value1</span>:  </span><br><span class="line">    statement </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">case</span> <span class="attr">value2</span>: </span><br><span class="line">    statement </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">case</span> <span class="attr">value3</span>: </span><br><span class="line">    statement </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">case</span> <span class="attr">value4</span>: </span><br><span class="line">    statement </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="attr">default</span>: </span><br><span class="line">    statement </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case相当于条件；<strong>break</strong> 关键字会使代码跳出switch语句；default用于默认执行语句。</p>
<p>switch语句可以<strong>用于所有数据类型</strong> ，可以使用字符串甚至对象。<br>条件的值不需要是常量，也可以是变量或表达式。</p>
<blockquote>
<p>swicth语句在比较每个条件的值时会使用 <strong>全等操作符</strong>，不存在强制类型转换。</p>
</blockquote>
<h3 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h3><p>函数的基本语法： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1,...,argN</span>) &#123; </span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>函数名来调用</strong> 函数，要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）。</p>
<p>函数不需要指定是否返回值。</p>
<p>任何函数在任何时间都可以使用 <strong>return</strong> 语句来返回函数的值，用法是后跟要返回的值。</p>
<p>一个函数中可以有 <strong>多个return</strong> 语句，return语句后面的代码不会被执行。</p>
<p>return语句可以不带返回值，函数这时会立即 <strong>停止执行并返回undefined</strong> 。</p>
<blockquote>
<p>严格模式对函数也有一些限制： </p>
<ul>
<li><p>函数不能以eval或arguments作为名称。</p>
</li>
<li><p>函数的参数不能叫eval或arguments。</p>
</li>
<li><p>两个命名参数不能拥有同一个名称。<br>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>
</li>
</ul>
</blockquote>
<h3 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h3><p>JavaScript 的核心语言特性在 ECMA-262 中以伪语言 ECMAScript 的形式来定义。</p>
<ul>
<li><p>基本数据类型包括 <strong>Undefined、Null、Boolean、Number、String和Symbol</strong>。 </p>
</li>
<li><p>ECMAScript 不区分整数和浮点值，<strong>只有Number</strong> 一种数值数据类型。 </p>
</li>
<li><p>Object是一种 <strong>复杂数据类型</strong>，它是这门语言中所有对象的 <strong>基类</strong>。 </p>
</li>
<li><p><strong>严格模式</strong> 为这门语言中某些容易出错的部分施加了限制。 </p>
</li>
<li><p>常见的基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。  </p>
</li>
</ul>
<p>ECMAScript 中的函数与其他语言中的函数不一样。</p>
<ul>
<li><p>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。 </p>
</li>
<li><p>不指定返回值的函数实际上会返回特殊值undefined。</p>
</li>
</ul>
<h2 id="四、变量、作用域和内存"><a href="#四、变量、作用域和内存" class="headerlink" title="四、变量、作用域和内存"></a>四、变量、作用域和内存</h2><h3 id="4-1-原始值和引用值"><a href="#4-1-原始值和引用值" class="headerlink" title="4.1 原始值和引用值"></a>4.1 原始值和引用值</h3><p>变量可以包含两种不同类型的数据。</p>
<ul>
<li><p><strong>原始值</strong>：简单数据。</p>
</li>
<li><p><strong>引用值</strong>：由多个值构成的对象。</p>
</li>
</ul>
<p>在把一个 <strong>值赋</strong> 给变量时，js引擎 <strong>必须确定</strong> 这个值是原始值还是引用值。</p>
<p>保存 <strong>原始值</strong> 的变量是 <strong>按值访问</strong> 的。</p>
<p>保存 <strong>引用值</strong> 的变脸是 <strong>按引用访问</strong> 的。</p>
<blockquote>
<p><strong>引用值</strong> 是保存在 <strong>内存中</strong> 的对象，JS不允许直接访问内存位置。</p>
<p>在操作对象时，是对该对象的引用，而非实际的对象本身</p>
</blockquote>
<h4 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1 动态属性"></a>4.1.1 动态属性</h4><p><strong>原始值</strong> 不能有属性。</p>
<p>只有 <strong>引用值</strong> 可以动态添加可使用的属性。</p>
<p>原始类型的初始化可以只使用原始字面量形式。</p>
<p>如果使用的是 <strong>new</strong> 关键字，则JS会创建一个 <strong>Object</strong> 类型的实例，但其行为类似原始值。</p>
<h4 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2 复制值"></a>4.1.2 复制值</h4><p>在通过变量把一个 <strong>原始值</strong> 赋值到另一个变量时，原始值会被 <strong>复制</strong> 到新变量的位置。</p>
<blockquote>
<p>复制前后的变量独立使用，互不干扰。</p>
</blockquote>
<p>在把 <strong>引用值</strong> 从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置，这里复制的值实际上是一个 <strong>指针</strong> ，它指向存储在堆内存中的对象。</p>
<h4 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3 传递参数"></a>4.1.3 传递参数</h4><p>所有函数的参数都是 <strong>按值传递</strong> 的。</p>
<p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，arguments对象中的一个槽位）</p>
<p>ECMAScript中函数的参数就是局部变量。</p>
<h4 id="4-1-4-确定类型"><a href="#4-1-4-确定类型" class="headerlink" title="4.1.4 确定类型"></a>4.1.4 确定类型</h4><p><strong>typeof</strong> 操作符适合于判断一个变量是否为原始类型。</p>
<p><strong>instanceof</strong> 操作符 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure>

<ul>
<li>如果变量时给定 <strong>引用类型</strong>，则 instanceof 操作符<strong>返回true</strong> 。</li>
</ul>
<h3 id="4-2-执行上下文和作用域"><a href="#4-2-执行上下文和作用域" class="headerlink" title="4.2 执行上下文和作用域"></a>4.2 执行上下文和作用域</h3><p>每个上下文都有一个关联的 <strong>变量对象</strong> ，而这个上下文中 <strong>定义的所有</strong> 变量和函数都 <strong>存在于</strong> 这个对象上。</p>
<p><strong>全局上下文是最外层的上下文</strong> ，<strong>所有</strong> 通过 <strong>var定义</strong> 的全局变量和函数都会成为window对象的属性和方法。</p>
<blockquote>
<p>全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器。</p>
</blockquote>
<p>使用 <strong>let 和 const</strong> 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕之后会被销毁，包括定义在它上面的所有变量和函数。</p>
<p>每个 <strong>函数调用都有</strong> 自己的上下文。</p>
<p>上下文中的代码在执行的时候，会创建变量对象的一个 <strong>作用域链</strong>。这个作用域链 <strong>决定了</strong> 各级上下文中的代码在访问变量和函数时的 <strong>顺序</strong> 。如果上下文是函数，则其 <strong>活动对象</strong> 用作变量对象。活动对象最初只有一个定义变量：arguments；全局上下文的变量对象 <strong>始终</strong> 是作用域链的最后一个变量对象。</p>
<p>局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>
<h4 id="4-2-1-作用域链增强"><a href="#4-2-1-作用域链增强" class="headerlink" title="4.2.1 作用域链增强"></a>4.2.1 作用域链增强</h4><p>执行上下文主要有<strong>全文上下文和函数上下文</strong> 。</p>
<p>这两种情况下都会在作用域链前端添加一个变量对象。</p>
<ul>
<li><p><strong>try/catch</strong> 语句的 <strong>catch</strong> 块</p>
<ul>
<li>会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</li>
</ul>
</li>
<li><p><strong>with</strong> 语句</p>
<ul>
<li>向作用域链前端添加指定的对象。</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-变量声明"><a href="#4-2-2-变量声明" class="headerlink" title="4.2.2 变量声明"></a>4.2.2 变量声明</h4><ol>
<li><h5 id="var的函数作用域声明"><a href="#var的函数作用域声明" class="headerlink" title="var的函数作用域声明"></a>var的函数作用域声明</h5></li>
</ol>
<p>使用 <strong>var</strong> 声明变量时，变量会被 <strong>自动添加到最接近</strong> 的上下文。</p>
<ul>
<li><p>在函数中则是函数的局部上下文。</p>
</li>
<li><p>变量未经声明就被初始化，则为全局上下文。</p>
<blockquote>
<p>严格模式下，未经声明就初始化变量会报错。</p>
</blockquote>
</li>
</ul>
<p><strong>var</strong> 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前，这个现象叫做“<strong>提升</strong>”，提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。</p>
<p>重复的 <strong>var</strong> 声明会被忽略。</p>
<p>使用 <strong>var</strong> 声明的迭代变量会泄漏到循环外部。</p>
<ol start="2">
<li><h5 id="let的块级作用域声明"><a href="#let的块级作用域声明" class="headerlink" title="let的块级作用域声明"></a>let的块级作用域声明</h5></li>
</ol>
<p><strong>块级作用域</strong> 由最近的一对包括花括号 <strong>{ }</strong> 界定。</p>
<p><strong>let</strong> 在 <strong>同一作用域</strong> 内 <strong>不能</strong> 声明两次。</p>
<p><strong>let</strong> 适合在循环中声明迭代变量。</p>
<ol start="3">
<li><h5 id="const的常量声明"><a href="#const的常量声明" class="headerlink" title="const的常量声明"></a>const的常量声明</h5></li>
</ol>
<p>使用 <strong>const</strong> 声明的变量 <strong>必须同时初始化</strong> 为某个值。一旦声明，在其生命周期的任何时候都 <strong>不能再重新赋予</strong> 新值。</p>
<p><strong>const</strong> 声明只应用到顶级原语或对象，即赋值为对象的 <strong>const</strong> 变量不能再被重新赋值为其他的引用值，但 <strong>对象的键则不受限制</strong>。</p>
<ol start="4">
<li><h5 id="标识符查找"><a href="#标识符查找" class="headerlink" title="标识符查找"></a>标识符查找</h5></li>
</ol>
<p>作用域链中的对象也有一个原型链。</p>
<p>如果局部上下文中有一个同名的标识符，就不能在该上下文中引用父上下文中的同名标识符。</p>
<p>使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次。</p>
<h3 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3 垃圾回收"></a>4.3 垃圾回收</h3><p>通过自动内存管理实现内存分配和闲置资源回收。</p>
<p><strong>思路</strong>：确定哪个变量不再使用，然后释放它占用的内存，这个过程是 <strong>周期性</strong> 的，即垃圾回收程序每隔一定时间（或说再代码执行过程中某个预定的收集时间）就会自动运行。</p>
<h4 id="4-3-1-标记清理"><a href="#4-3-1-标记清理" class="headerlink" title="4.3.1 标记清理"></a>4.3.1 标记清理</h4><p>最常用的垃圾回收策略是 <strong>标记清理</strong> ，当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的 <strong>标记</strong> 。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。<br>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，<strong>关键是策略</strong> 。<br>垃圾回收程序运行的时候，会 <strong>标记</strong> 内存中存储的 <strong>所有变量</strong>（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<h4 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a>4.3.2 引用计数</h4><p><strong>思路</strong> 是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。</p>
<h4 id="4-3-3-内存管理"><a href="#4-3-3-内存管理" class="headerlink" title="4.3.3 内存管理"></a>4.3.3 内存管理</h4><p><strong>优化内存占用</strong> 的最佳手段就是保证在执行代码时 <strong>只保存必要</strong> 的数据。如果数据不再必要，那么把它设置为null，从而释放其引用，这也可以叫作 <strong>解除引用</strong>。</p>
<blockquote>
<p>解除对一个值的引用并不会自动导致相关内存被回收。解除引用的 <strong>关键在于</strong> 确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p>
</blockquote>
<ol>
<li><h5 id="通过const和let声明提升性能"><a href="#通过const和let声明提升性能" class="headerlink" title="通过const和let声明提升性能"></a>通过const和let声明提升性能</h5></li>
</ol>
<p><strong>const 和 let</strong> 都以块（而非函数）为作用域，相比于使用 <strong>var</strong>，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。</p>
<ol start="2">
<li><h5 id="隐藏类和删除操作"><a href="#隐藏类和删除操作" class="headerlink" title="隐藏类和删除操作"></a>隐藏类和删除操作</h5></li>
</ol>
<p>运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。</p>
<p>使用delete关键字会导致生成相同的隐藏类片段。</p>
<ol start="3">
<li><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5></li>
</ol>
<p>JavaScript 中的内存泄漏大部分是由不合理的引用导致的。 </p>
<p><strong>意外声明全局变量</strong> 是最常见但也最容易修复的内存泄漏问题。</p>
<p>定时器可能会导致内存泄漏。</p>
<p>使用 <strong>JavaScript 闭包</strong> 容易造成内存泄漏。</p>
<ol start="4">
<li><h5 id="静态分配与对象池"><a href="#静态分配与对象池" class="headerlink" title="静态分配与对象池"></a>静态分配与对象池</h5></li>
</ol>
<p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。</p>
<p>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。</p>
<h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>JavaScript 变量可以保存两种类型的值：<strong>原始值和引用值</strong>。原始值可能是以下 6 种原始数据类型之一：Undefined、Null、Boolean、Number、String和Symbol。</p>
<ul>
<li><p><strong>原始值</strong> 大小固定，因此保存在 <strong>栈内存</strong> 上。 </p>
</li>
<li><p>从一个变量到另一个变量复制原始值会创建该值的第二个副本。 </p>
</li>
<li><p><strong>引用值</strong> 是对象，存储在 <strong>堆内存</strong> 上。 </p>
</li>
<li><p>包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。 </p>
</li>
<li><p>从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。 </p>
</li>
<li><p><strong>typeof</strong> 操作符可以确定值的原始类型，而 <strong>instanceof</strong> 操作符用于确保值的引用类型。 </p>
</li>
</ul>
<p>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。</p>
<ul>
<li><p>执行上下文分 <strong>全局上下文、函数上下文和块级上下文</strong> 。 </p>
</li>
<li><p>代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。 </p>
</li>
<li><p>函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。 </p>
</li>
<li><p>全局上下文 <strong>只能</strong> 访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。 </p>
</li>
<li><p>变量的执行上下文用于确定什么时候释放内存。 </p>
</li>
</ul>
<p>JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。 </p>
<ul>
<li><p>离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。 </p>
</li>
<li><p>主流的垃圾回收算法是 <strong>标记清理</strong> ，即先给当前不使用的值加上标记，再回来回收它们的内存。</p>
</li>
<li><p><strong>引用计数</strong> 是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）。 </p>
</li>
<li><p>引用计数在代码中存在循环引用时会出现问题。 </p>
</li>
<li><p>解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</p>
</li>
</ul>
<h2 id="五、基本引用类型"><a href="#五、基本引用类型" class="headerlink" title="五、基本引用类型"></a>五、基本引用类型</h2><p>引用值（或者对象）是某个特定 <strong>引用类型</strong> 的实例。</p>
<p>对象被认为是某个特定引用类型的 <strong>实例</strong>。新对象通过使用 <strong>new</strong> 操作符后跟一个 <strong>构造函数</strong> （constructor）来创建。构造函数就是用来创建新对象的函数。</p>
<h3 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h3><p>创建 <strong>日期对象</strong>，使用 <strong>new</strong> 操作符来调用 <strong>Date</strong> 构造函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<p>在 <strong>不</strong> 给Date构造函数 <strong>传参</strong> 数的情况下，创建的对象将 <strong>保存当前日期和时间</strong>。</p>
<p>基于其他日期和时间创建日期对象，<strong>必须</strong> 传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。</p>
<p>ECMAScript提供了两个辅助方法：**Date.parse()和Date.UTC()**。 </p>
<ol>
<li><p><strong>Date.parse()</strong> 方法接收一个表示日期的字符串参数，将这个字符串转换为表示该日期的毫秒数。</p>
<p>支持下列日期格式： </p>
<ul>
<li><p>“月/日/年”，如”5/23/2019”； </p>
</li>
<li><p>“月 日, 年”，如”May 23, 2019”； </p>
</li>
<li><p>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”； </p>
</li>
<li><p>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如2019-05-23T00:00:00（只适用于兼容 ES5 的实现）。</p>
</li>
</ul>
<blockquote>
<p>若传入的字符串不表示日期，则返回NaN。</p>
</blockquote>
</li>
<li><p><strong>Date.UTC()</strong> 方法返回日期的毫秒表示。</p>
<ul>
<li>传给 <strong>Date.UTC()</strong> 的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。</li>
</ul>
</li>
</ol>
<p>与Date.parse()一样，Date.UTC()也会被Date构造函数 <strong>隐式调用</strong> ，但存在个区别：这种情况下创建的是本地日期，不是 GMT 日期。</p>
<ol start="3">
<li><strong>Date.now()</strong> 方法，返回表示方法 <strong>执行时</strong> 日期和时间的毫秒数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以方便地用在代码分析中： </span><br><span class="line"><span class="comment">// 起始时间 </span></span><br><span class="line"><span class="keyword">let</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"><span class="comment">// 调用函数 </span></span><br><span class="line"><span class="title function_">doSomething</span>(); </span><br><span class="line"><span class="comment">// 结束时间 </span></span><br><span class="line"><span class="keyword">let</span> stop = <span class="title class_">Date</span>.<span class="title function_">now</span>(), </span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-1-1-继承的方法"><a href="#5-1-1-继承的方法" class="headerlink" title="5.1.1 继承的方法"></a>5.1.1 继承的方法</h4><p><strong>Date</strong> 类型 <strong>重写了 toLocaleString()、toString() 和 valueOf()方法</strong>。</p>
<p>与其他类型不同，重写后这些方法的返回值不一样。</p>
<p><strong>Date</strong> 类型的 <strong>toLocaleString()</strong> 方法返回与浏览器运行的 <strong>本地环境</strong> 一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。</p>
<p><strong>toString()</strong> 方法通常返回 <strong>带时区信息</strong> 的日期和时间，而时间也是以 24 小时制（0~23）表示的。</p>
<p><strong>Date</strong> 类型的 <strong>valueOf()</strong> 方法根本就 <strong>不返回字符串</strong> ，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。</p>
<h4 id="5-1-2-日期格式化方法"><a href="#5-1-2-日期格式化方法" class="headerlink" title="5.1.2 日期格式化方法"></a>5.1.2 日期格式化方法</h4><p>Date类型有几个专门用于格式化日期的方法，都 <strong>返回字符串</strong>： </p>
<ul>
<li><p><strong>toDateString()</strong> 显示日期中的周几、月、日、年（格式特定于实现）； </p>
</li>
<li><p><strong>toTimeString()</strong> 显示日期中的时、分、秒和时区（格式特定于实现）； </p>
</li>
<li><p><strong>toLocaleDateString()</strong> 显示日期中的周几、月、日、年（格式特定于实现和地区）； </p>
</li>
<li><p><strong>toLocaleTimeString()</strong> 显示日期中的时、分、秒（格式特定于实现和地区）； </p>
</li>
<li><p><strong>toUTCString()</strong> 显示完整的 UTC 日期（格式特定于实现）。</p>
</li>
</ul>
<h4 id="5-1-3-日期-时间组件方法"><a href="#5-1-3-日期-时间组件方法" class="headerlink" title="5.1.3 日期/时间组件方法"></a>5.1.3 日期/时间组件方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getTime()</td>
<td align="center">返回日期的毫秒表示；与valueOf()相同</td>
</tr>
<tr>
<td align="center">setTime(milliseconds)</td>
<td align="center">设置日期的毫秒表示，从而修改整个日期</td>
</tr>
<tr>
<td align="center">getFullYear()</td>
<td align="center">返回 4 位数年（即 2019 而不是 19）</td>
</tr>
<tr>
<td align="center">getUTCFullYear()</td>
<td align="center">返回 UTC 日期的 4 位数年</td>
</tr>
<tr>
<td align="center">setFullYear(year)</td>
<td align="center">设置日期的年（year必须是 4 位数）</td>
</tr>
<tr>
<td align="center">setUTCFullYear(year)</td>
<td align="center">设置 UTC 日期的年（year必须是 4 位数）</td>
</tr>
<tr>
<td align="center">getMonth()</td>
<td align="center">返回日期的月（0 表示 1 月，11 表示 12 月）</td>
</tr>
<tr>
<td align="center">setMonth(month)</td>
<td align="center">设置日期的月（month为大于 0 的数值，大于 11 加年）</td>
</tr>
<tr>
<td align="center">getDate()</td>
<td align="center">返回日期中的日（1~31）</td>
</tr>
<tr>
<td align="center">setDate(date)</td>
<td align="center">设置日期中的日（如果date大于该月天数，则加月）</td>
</tr>
<tr>
<td align="center">getDay()</td>
<td align="center">返回日期中表示周几的数值（0 表示周日，6 表示周六）</td>
</tr>
<tr>
<td align="center">getHours()</td>
<td align="center">返回日期中的时（0~23）</td>
</tr>
<tr>
<td align="center">setHours(hours)</td>
<td align="center">设置日期中的时（如果hours大于 23，则加日）</td>
</tr>
<tr>
<td align="center">getMinutes()</td>
<td align="center">返回日期中的分（0~59）</td>
</tr>
<tr>
<td align="center">setMinutes(minutes)</td>
<td align="center">设置日期中的分（如果minutes大于 59，则加时）</td>
</tr>
<tr>
<td align="center">getSeconds()</td>
<td align="center">返回日期中的秒（0~59）</td>
</tr>
<tr>
<td align="center">setSeconds(seconds)</td>
<td align="center">设置日期中的秒（如果seconds大于 59，则加分）</td>
</tr>
<tr>
<td align="center">getMilliseconds()</td>
<td align="center">返回日期中的毫秒</td>
</tr>
<tr>
<td align="center">setMilliseconds(milliseconds)</td>
<td align="center">设置日期中的毫秒</td>
</tr>
<tr>
<td align="center">getTimezoneOffset()</td>
<td align="center">返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”</td>
</tr>
<tr>
<td align="center">返回 300，进入夏令时的地区可能有所差异）</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p>
</blockquote>
<h3 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2 RegExp"></a>5.2 RegExp</h3><p>通过 <strong>RegExp</strong> 类型支持 <strong>正则表达式</strong>。正则表达式使用类似 Perl 的简洁语法来创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression =<span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure>

<p><strong>pattern</strong>（模式）可以是 <strong>任何</strong> 简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带 <strong>零个 或 多个flags</strong> （标记），用于控制正则表达式的行为。</p>
<p>表示匹配模式的标记:</p>
<ul>
<li><p><strong>g：</strong> 全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。 </p>
</li>
<li><p><strong>i：</strong> 不区分大小写，表示在查找匹配时忽略 <strong>pattern</strong> 和字符串的大小写。 </p>
</li>
<li><p><strong>m：</strong> 多行模式，表示查找到一行文本末尾时会继续查找。 </p>
</li>
<li><p><strong>y：</strong> 粘附模式，表示只查找从 <strong>lastIndex</strong> 开始及之后的字符串。 </p>
</li>
<li><p><strong>u：</strong> Unicode 模式，启用 <strong>Unicode</strong> 匹配。 </p>
</li>
<li><p><strong>s：</strong> dotAll模式，表示元字符 <strong>.</strong> 匹配任何字符（包括\n或\r）。</p>
</li>
</ul>
<p>所有 <strong>元字符</strong> 在模式中也必须转义。</p>
<p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用 <strong>反斜杠</strong> 来转义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写 </span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/[bc]at/i</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配第一个&quot;[bc]at&quot;，忽略大小写 </span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写 </span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有&quot;.at&quot;，忽略大小写 </span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>

<p>正则表达式可以使用 <strong>RegExp</strong> 构造函数来创建，它接收两个参数：<strong>模式字符串 和（可选的）标记字符串</strong>。任何使用字面量定义的正则表达式也可以通过构造函数来创建。</p>
<p>使用 <strong>RegExp</strong> 可以基于已有的正则表达式实例，并可选择性地修改它们的标记。</p>
<h4 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1 RegExp实例属性"></a>5.2.1 RegExp实例属性</h4><p>每个RegExp实例都有下列属性，提供有关模式的各方面信息。 </p>
<ul>
<li><p><strong>global</strong>：布尔值，表示是否设置了 <strong>g</strong> 标记。 </p>
</li>
<li><p><strong>ignoreCase</strong>：布尔值，表示是否设置了 <strong>i</strong> 标记。 </p>
</li>
<li><p><strong>unicode</strong>：布尔值，表示是否设置了 <strong>u</strong> 标记。 </p>
</li>
<li><p><strong>sticky</strong>：布尔值，表示是否设置了 <strong>y</strong> 标记。 </p>
</li>
<li><p><strong>lastIndex</strong>：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。 </p>
</li>
<li><p><strong>multiline</strong>：布尔值，表示是否设置了 <strong>m</strong> 标记。 </p>
</li>
<li><p><strong>dotAll</strong>：布尔值，表示是否设置了 <strong>s</strong> 标记。 </p>
</li>
<li><p><strong>source</strong>：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。 </p>
</li>
<li><p><strong>flags</strong>：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。</p>
</li>
</ul>
<h4 id="5-2-2-RegExp-实例方法"><a href="#5-2-2-RegExp-实例方法" class="headerlink" title="5.2.2 RegExp 实例方法"></a>5.2.2 RegExp 实例方法</h4><p>RegExp实例的主要方法是 <strong>exec()</strong> ，主要用于 <strong>配合捕获组</strong> 使用。这个方法 <strong>只</strong> 接收 <strong>一个参数</strong>，即要应用模式的字符串。如果找到了匹配项，则返回包含 <strong>第一个</strong> 匹配信息的数组；如果没找到匹配项，则 <strong>返回null</strong> 。返回的 <strong>数组</strong> 虽然是 <strong>Array的实例</strong>，但 <strong>包含两个</strong> 额外的属性： <strong>index 和 input</strong>。<strong>index</strong> 是字符串中匹配模式的 <strong>起始位置</strong>，<strong>input</strong> 是要 <strong>查找的字符串</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);   <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">input</span>);   <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);      <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">1</span>]);      <span class="comment">// &quot; and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">2</span>]);      <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果模式设置了 <strong>全局标记</strong>，则 <strong>每次调用</strong>  <strong>exec()</strong> 方法会返回一个匹配的信息。如果 <strong>没有设置</strong> 全局标记，则无论对同一个字符串调用多少次exec()，也 <strong>只会返回</strong> 第一个匹配的信息。</p>
<blockquote>
<p>lastIndex在非全局模式下始终不变。</p>
</blockquote>
<p>正则表达式的另一个方法是 <strong>test()</strong> ，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 <strong>true</strong>，否则返回 <strong>false</strong>。这个方法适用于只想 <strong>测试模式是否匹配</strong> ，而不需要实际匹配内容的情况。</p>
<p>正则表达式继承的方法 <strong>toLocaleString()和toString()</strong> 都返回正则表达式的字面量表示，<strong>valueOf()</strong> 方法返回正则表达式本身。</p>
<h4 id="5-2-3-RegExp-构造函数属性"><a href="#5-2-3-RegExp-构造函数属性" class="headerlink" title="5.2.3 RegExp 构造函数属性"></a>5.2.3 RegExp 构造函数属性</h4><p>RegExp构造函数本身有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性有一个 <strong>特点</strong> ，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。</p>
<table>
<thead>
<tr>
<th align="center">全名</th>
<th align="center">简写</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">input</td>
<td align="center">$_</td>
<td align="center">最后搜索的字符串（非标准特性）</td>
</tr>
<tr>
<td align="center">lastMatch</td>
<td align="center">$&amp;</td>
<td align="center">最后匹配的文本</td>
</tr>
<tr>
<td align="center">lastParen</td>
<td align="center">$+</td>
<td align="center">最后匹配的捕获组（非标准特性）</td>
</tr>
<tr>
<td align="center">leftContext</td>
<td align="center">$`</td>
<td align="center">input字符串中出现在lastMatch前面的文本</td>
</tr>
<tr>
<td align="center">rightContext</td>
<td align="center">$’</td>
<td align="center">input字符串中出现在lastMatch后面的文本</td>
</tr>
</tbody></table>
<h3 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3 原始值包装类型"></a>5.3 原始值包装类型</h3><p>3 种特殊的引用类型：<strong>Boolean、Number和String。</strong></p>
<p>每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</p>
<p>引用类型与原始值包装类型的 <strong>主要区别</strong> 在于对象的生命周期。在通过 <strong>new</strong> 实例化引用类型后，得到的实例会在 <strong>离开作用域时被销毁</strong> ，而自动创建的原始值包装对象则 <strong>只存在</strong> 于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。</p>
<h4 id="5-3-1-Boolean"><a href="#5-3-1-Boolean" class="headerlink" title="5.3.1 Boolean"></a>5.3.1 Boolean</h4><p><strong>Boolean</strong> 是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传入 <strong>true 或 false</strong>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Boolean</strong> 的实例会重写 <strong>valueOf()</strong> 方法，返回一个原始值 <strong>true 或 false</strong>。<strong>toString()</strong> 方法被调用时也会被覆盖，返回**字符串 “true” 或 “false”**。 </p>
<p>原始值和引用值（Boolean对象）的 <strong>区别</strong>：</p>
<ul>
<li><p><strong>typeof</strong> 操作符对<strong>原始值</strong>返回 <strong>“boolean”</strong> ，但 <strong>对引用值</strong> 返回 **”object”**。</p>
</li>
<li><p>Boolean对象是Boolean类型的实例，在使用 <strong>instaceof</strong> 操作符时 <strong>返回true</strong>，但对原始值则返回 <strong>false</strong> 。</p>
</li>
</ul>
<h4 id="5-3-2-Number"><a href="#5-3-2-Number" class="headerlink" title="5.3.2 Number"></a>5.3.2 Number</h4><p><strong>Number</strong> 是对应数值的引用类型。要创建一个 <strong>Number</strong> 对象，就使用 <strong>Number</strong> 构造函数并传入一个数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>); </span><br></pre></td></tr></table></figure>

<p><strong>Number</strong> 类型重写了 <strong>valueOf()、toLocaleString()和toString()</strong> 方法。<strong>valueOf()</strong> 方法返回 <strong>Number</strong> 对象表示的 <strong>原始数值</strong>，另外两个方法返回 <strong>数值字符串</strong>。<strong>toString()</strong> 方法可选地接收一个表示 <strong>基数</strong> 的参数，并返回相应基数形式的数值字符串。</p>
<p><strong>Number</strong> 类型有几个用于将数值格式化为字符串的方法。 </p>
<ol>
<li><p><strong>toFixed()</strong> 方法返回包含指定小数点位数的数值字符串，如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。</p>
</li>
<li><p><strong>toExponential()</strong> 方法返回以科学记数法（也称为指数记数法）表示的数值字符串，接收一个参数，表示结果中小数的位数。</p>
</li>
<li><p><strong>toPrecision()</strong> 方法可以表示带 1~21 个小数位的数值，接收一个参数，表示结果中数字的总位数（不包含指数）。本质上，<strong>toPrecision()</strong> 方法会根据数值和精度来决定调用**toFixed() 还是 toExponential()**。</p>
</li>
</ol>
<p>ES6 新增了 <strong>Number.isInteger()</strong> 方法，用于辨别一个数值是否保存为整数。</p>
<h4 id="5-3-3-String"><a href="#5-3-3-String" class="headerlink" title="5.3.3 String"></a>5.3.3 String</h4><p><strong>String</strong> 是对应字符串的引用类型。要创建一个 <strong>String</strong> 对象，使用String构造函数并传入一个数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>String</strong>  象的方法可以在所有字符串原始值上调用。3 个继承的方法 <strong>valueOf()、toLocaleString() 和 toString()</strong> 都返回对象的原始字符串值。<br>每个 <strong>String</strong> 对象都有一个 <strong>length</strong> 属性，表示字符串中字符的数量。</p>
<ol>
<li><h5 id="JavaScript-字符"><a href="#JavaScript-字符" class="headerlink" title="JavaScript 字符"></a>JavaScript 字符</h5></li>
</ol>
<p>JavaScript 字符串由 <strong>16 位</strong> 码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。即字符串的 <strong>length 属性</strong>表示字符串包含多少 16 位码元。</p>
<ul>
<li><strong>charAt()</strong> 方法返回给定索引位置的字符，由传给方法的整数参数指定。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript 字符串使用了两种 Unicode 编码混合的策略：<strong>UCS-2 和 UTF-16</strong>。</li>
</ul>
<blockquote>
<p>对于可以采用 16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。</p>
</blockquote>
<ul>
<li><p><strong>charCodeAt()</strong> 方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">2</span>));  <span class="comment">// 99 </span></span><br><span class="line"><span class="comment">// 十进制 99 等于十六进制 63 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">99</span> === <span class="number">0x63</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>fromCharCode()</strong> 方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode &quot;Latin small letter A&quot;的编码是 U+0061 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter B&quot;的编码是 U+0062 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter D&quot;的编码是 U+0064 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter E&quot;的编码是 U+0065 </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>));  <span class="comment">// &quot;abcde&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x0061 === 97 </span></span><br><span class="line"><span class="comment">// 0x0062 === 98 </span></span><br><span class="line"><span class="comment">// 0x0063 === 99 </span></span><br><span class="line"><span class="comment">// 0x0064 === 100 </span></span><br><span class="line"><span class="comment">// 0x0065 === 101 </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>));          <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>16 位只能唯一表示 65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为 <strong>基本多语言平面（BMP</strong>）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为 <strong>代理对</strong>。</p>
<p>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 <strong>codePointAt()</strong> 来代替 <strong>charCodeAt()<strong>。</strong>codePointAt()</strong> 接收 16 位码元的索引并返回该索引位置上的码点（code point）。<strong>码点</strong>是 Unicode 中一个字符的完整标识。</p>
<blockquote>
<p>比如，”c”的码点是 0x0063，而”☺”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而codePointAt()方法可以从指定码元位置识别完整的码点。</p>
<p>如果传入的码元索引并非代理对的开头，就会返回错误的码点。</p>
</blockquote>
<p>与 <strong>charCodeAt()</strong> 有对应的 <strong>codePointAt()</strong> 一样，<strong>fromCharCode()</strong> 也有一个对应的 <strong>fromCodePoint()</strong> 。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串。</p>
<ol start="2">
<li><h5 id="normalize（）方法"><a href="#normalize（）方法" class="headerlink" title="normalize（）方法"></a>normalize（）方法</h5></li>
</ol>
<p>这 4 种规范化形式是：<strong>NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）</strong>。可以使用 <strong>normalize()</strong> 方法对字符串应用上述规范化形式。</p>
<ol start="3">
<li><h5 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h5></li>
</ol>
<ul>
<li><strong>concat()</strong> 用于将一个或多个字符串 <strong>拼接</strong> 成一个新字符串。<ul>
<li>可以接收任意多个参数。<blockquote>
<p>多数情况下，对于拼接多个字符串来说，使用加号更方便。 </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>ECMAScript 提供了 3 个从字符串中 <strong>提取子字符串</strong> 的方法 **slice()、substr() 和 substring()**。</p>
<ul>
<li><p>都返回调用它们的字符串的一个子字符串，而且都 <strong>接收</strong> 一或两个参数。第一个参数表示子字符串 <strong>开始的位置</strong> ，第二个参数表示子字符串 <strong>结束的位置</strong> 。</p>
</li>
<li><p>对 <strong>slice() 和 substring()</strong> 而言，第二个参数是提取结束的位置（即该位置 <strong>之前的字符</strong> 会被提取出来）。</p>
</li>
<li><p>对 <strong>substr()</strong> 而言，第二个参数表示返回的子字符串数量。</p>
</li>
<li><p>任何情况下，省略第二个参数都意味着提取到字符串末尾。</p>
</li>
<li><p>不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。</p>
</li>
<li><p>当某个参数是 <strong>负值</strong> 时，<strong>slice()</strong> 方法将所有负值参数都当成字符串长度加上负参数值；<br><strong>substr()</strong> 方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0；<strong>substring()</strong> 方法会将所有负参数值都转换为 0。</p>
</li>
</ul>
<ol start="4">
<li><h5 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h5></li>
</ol>
<p>在字符串中 <strong>定位</strong> 子字符串 ：**indexOf()和lastIndexOf()**。</p>
<ul>
<li><p>从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。</p>
</li>
<li><p><strong>区别</strong>：<strong>indexOf()</strong> 方法从字符串 <strong>开头</strong> 开始查找子字符串，而 <strong>lastIndexOf()</strong> 方法从字符串 <strong>末尾</strong> 开始查找子字符串。</p>
</li>
<li><p>可以接收可选的第二个参数，表示开始搜索的位置。</p>
<ul>
<li><p><strong>indexOf()</strong> 会从这个参数指定的位置开始向字符串末尾搜索，<strong>忽略</strong> 该位置之前的字符。</p>
</li>
<li><p><strong>lastIndexOf()</strong> 会从这个参数指定的位置开始向字符串开头搜索，<strong>忽略</strong> 该位置之后直到字符串末尾的字符。</p>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li><h5 id="字符串包含方法"><a href="#字符串包含方法" class="headerlink" title="字符串包含方法"></a>字符串包含方法</h5></li>
</ol>
<p>3 个用于判断字符串中是否包含另一个字符串的方法：**startsWith()、endsWith() 和 includes()**。</p>
<ul>
<li><p>会从字符串中搜索传入的字符串，并 <strong>返回</strong> 一个表示是否包含的 <strong>布尔值</strong>。</p>
</li>
<li><p>区别：<strong>startsWith()</strong> 检查开始于索引 0 的匹配项；<strong>endsWith()</strong> 检查开始于索<br>引( <strong>string.length - substring.length</strong> )的匹配项；<strong>includes()</strong> 检查整个字符串。</p>
</li>
<li><p><strong>startsWith() 和 includes()</strong> 方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从 <strong>指定位置</strong> 向着字符串末尾搜索，忽略该位置之前的所有字符。</p>
</li>
<li><p><strong>endsWith()</strong> 方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。</p>
</li>
</ul>
<ol start="6">
<li><h5 id="trim（）方法"><a href="#trim（）方法" class="headerlink" title="trim（）方法"></a>trim（）方法</h5></li>
</ol>
<p>创建字符串的一个副本，删除前、后所有空格符，再返回结果。</p>
<ul>
<li><p><strong>trim()</strong> 返回的是字符串的 <strong>副本</strong>，因此原始字符串不受影响。</p>
</li>
<li><p><strong>trimLeft() 和 trimRight()</strong> 方法分别用于从字符串开始和末尾清理空格符。</p>
</li>
</ul>
<ol start="7">
<li><h5 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h5></li>
</ol>
<p>接收一个整数参数，表示要将字符串 <strong>复制</strong> 多少次，然后返回拼接 <strong>所有副本</strong> 后的结果。</p>
<ol start="8">
<li><h5 id="padStart（）和-padEnd（）方法"><a href="#padStart（）和-padEnd（）方法" class="headerlink" title="padStart（）和 padEnd（）方法"></a>padStart（）和 padEnd（）方法</h5></li>
</ol>
<p><strong>padStart() 和 padEnd()</strong> 方法会 <strong>复制</strong> 字符串。</p>
<ul>
<li><p>如果小于指定长度，则在相应一边填充字符，直至满足长度条件。</p>
</li>
<li><p>第一个参数是长度，第二个参数是可选的填充字符串，默认为空格。</p>
</li>
<li><p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。</p>
</li>
<li><p>如果长度小于或等于字符串长度，则会返回原始字符串。</p>
</li>
</ul>
<ol start="9">
<li><h5 id="字符串迭代和结构"><a href="#字符串迭代和结构" class="headerlink" title="字符串迭代和结构"></a>字符串迭代和结构</h5></li>
</ol>
<p>字符串的原型上暴露了一个 <strong>@@iterator</strong> 方法，表示可以迭代字符串的每个字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">手动使用迭代器： </span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>());  <span class="comment">// &#123;value: undefined, done: true&#125; </span></span><br><span class="line">在<span class="keyword">for</span>-<span class="keyword">of</span>循环中可以通过这个迭代器按序访问每个字符： </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c); </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// a </span></span><br><span class="line"><span class="comment">// b </span></span><br><span class="line"><span class="comment">// c </span></span><br><span class="line"><span class="comment">// d </span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。</p>
</blockquote>
<ol start="10">
<li><h5 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h5></li>
</ol>
<p>**toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLocaleUpperCase</span>());  <span class="comment">// &quot;HELLO WORLD&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toUpperCase</span>());        <span class="comment">// &quot;HELLO WORLD&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLocaleLowerCase</span>());  <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">toLowerCase</span>());        <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="11">
<li><h5 id="字符串匹配模式方法"><a href="#字符串匹配模式方法" class="headerlink" title="字符串匹配模式方法"></a>字符串匹配模式方法</h5></li>
</ol>
<p>在字符串中实现模式匹配的方法。</p>
<ul>
<li><p><strong>match()</strong> 方法本质上跟RegExp对象的 <strong>exec()</strong> 方法相同。</p>
<ul>
<li><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象</p>
</li>
<li><p>返回的数组与 <strong>RegExp</strong> 对象的 <strong>exec()</strong> 方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。 </p>
</li>
</ul>
</li>
<li><p><strong>search()</strong> 方法唯一的参数与match()方法一样：正则表达式字符串或RegExp对象。</p>
<ul>
<li><p>返回模式第一个匹配的位置索引，如果没找到则返回-1。</p>
</li>
<li><p><strong>search()</strong> 始终从字符串 <strong>开头向后</strong> 匹配模式。</p>
</li>
</ul>
</li>
<li><p><strong>split()</strong> 方法会根据传入的分隔符将字符串拆 <strong>分成数组</strong>。</p>
<ul>
<li><p>作为分隔符的参数可以是字符串，也可以是 <strong>RegExp</strong> 对象。（字符串分隔符不会被这个方法当成正则表达式。）</p>
</li>
<li><p>可以传入第二个参数，即 <strong>数组大小</strong>，确保返回的数组不会超过指定大小。</p>
</li>
</ul>
</li>
</ul>
<p><strong>ECMAScript</strong> 提供了 <strong>replace()</strong> 方法子字符串 <strong>替换</strong> 操作。</p>
<ul>
<li><p>接收两个参数，第一个参数可以是一个 <strong>RegExp</strong> 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。</p>
<ul>
<li><p>如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数 <strong>必须</strong> 为正则表达式并且带全局标记。</p>
</li>
<li><p><strong>replace()</strong> 的第二个参数可以是一个函数。</p>
</li>
</ul>
</li>
<li><p>在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。</p>
</li>
<li><p>在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程。</p>
</li>
</ul>
<ol start="12">
<li><h5 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h5></li>
</ol>
<p>用于比较两个字符串，返回如下 3 个值中的一个。 </p>
<ul>
<li><p>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。） </p>
</li>
<li><p>如果字符串与字符串参数相等，则返回0。 </p>
</li>
<li><p>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是1，具体还要看与实际值相关的实现。）</p>
</li>
</ul>
<blockquote>
<p><strong>localeCompare()</strong> 的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是 ECMAScript 实现的标准语言，<strong>localeCompare()</strong> 区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。</p>
</blockquote>
<h3 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4 单例内置对象"></a>5.4 单例内置对象</h3><p>ECMA-262 对 <strong>内置对象</strong> 的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象”。</p>
<h4 id="5-4-1-Global"><a href="#5-4-1-Global" class="headerlink" title="5.4.1 Global"></a>5.4.1 Global</h4><p><strong>Global</strong> 对象是 <strong>ECMAScript</strong> 中最特别的对象，因为代码不会显式地访问它。</p>
<p>ECMA-262 规定 <strong>Global</strong> 对象为一种 <strong>兜底对象</strong>，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 <strong>Global</strong> 对象的属性。</p>
<ol>
<li><h5 id="URL编码方法"><a href="#URL编码方法" class="headerlink" title="URL编码方法"></a>URL编码方法</h5></li>
</ol>
<p><strong>encodeURI() 和 encodeURIComponent()</strong> 方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。</p>
<ul>
<li><p><strong>encodeURI()</strong> 方法用于对整个 URI 进行编码，比如”<a target="_blank" rel="noopener" href="http://www.wrox.com/illegal">www.wrox.com/illegal</a> value.js”。</p>
</li>
<li><p><strong>encodeURIComponent()</strong> 方法用于编码 URI 中单独的组件，比如前面 URL 中的”illegal value.js”。</p>
</li>
</ul>
<p>两者区别：</p>
<ul>
<li><p><strong>encodeURI()</strong> 不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、<br>井号。</p>
</li>
<li><p><strong>encodeURIComponent()</strong> 会编码它发现的所有非标准字符。</p>
</li>
</ul>
<blockquote>
<p> 一般来说，使用 <strong>encodeURIComponent()</strong> 应该比使用 <strong>encodeURI()</strong> 的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多。</p>
</blockquote>
<p><strong>decodeURI() 和 decodeURIComponent()</strong> 用于解码。</p>
<ul>
<li><p><strong>decodeURI()</strong> 只对使用 <strong>encodeURI()</strong> 编码过的字符解码。。</p>
</li>
<li><p><strong>decodeURIComponent()</strong> 解码所有被 <strong>encodeURIComponent()</strong> 编码的字符，基本上就是解码所有特殊值。</p>
</li>
</ul>
<ol start="2">
<li><h5 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a>eval() 方法</h5></li>
</ol>
<p>这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>); </span><br><span class="line">上面这行代码的功能与下一行等价： </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>通过 <strong>eval()</strong> 执行的代码属于该 <strong>调用所在上下文</strong> ，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在 <strong>eval() 调用内部被引用</strong>。</p>
<ul>
<li><p>可以在 <strong>eval()</strong> 内部定义一个函数或变量，然后在外部代码中引用。</p>
</li>
<li><p>通过 <strong>eval()</strong> 定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 <strong>eval()</strong> 执行的时候才会被创建。 </p>
</li>
<li><p>在严格模式下，在 <strong>eval()</strong> 内部创建的变量和函数无法被外部访问。</p>
</li>
</ul>
<ol start="3">
<li><h5 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h5></li>
</ol>
<p>所有全局作用域中声明的变量和函数都变成了 <strong>window</strong> 的属性。</p>
<p>当一个函数再没有明确指定 <strong>this</strong> 值得情况下执行时，<strong>this</strong> 值等于 <strong>Global</strong> 对象。</p>
<h4 id="5-4-2-Math"><a href="#5-4-2-Math" class="headerlink" title="5.4.2 Math"></a>5.4.2 Math</h4><p><strong>Math</strong> 对象用于保存数学公式、信息和计算。 </p>
<p><strong>Math</strong> 有些属性主要用于保存数学中得一些特殊值。</p>
<ol>
<li><h5 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max() 方法"></a><strong>min() 和 max()</strong> 方法</h5></li>
</ol>
<p>用于确定一组数值中的最小值和最大值。</p>
<ol start="2">
<li><h5 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h5></li>
</ol>
<ul>
<li><p><strong>Math.ceil()</strong> 方法始终向上舍入为最接近的整数。</p>
</li>
<li><p><strong>Math.floor()</strong> 方法始终向下舍入为最接近的整数。</p>
</li>
<li><p><strong>Math.round()</strong> 方法执行四舍五入。</p>
</li>
<li><p><strong>Math.fround()</strong> 方法返回数值最接近的单精度（32位）浮点值表示。</p>
</li>
</ul>
<ol start="3">
<li><h5 id="random-方法"><a href="#random-方法" class="headerlink" title="random() 方法"></a><strong>random()</strong> 方法</h5></li>
</ol>
<p>返回一个 0~1 范围内的随机数，其中包含 <strong>0</strong> 但不包含 <strong>1</strong>。</p>
<h3 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h3><p><strong>JavaScript</strong> 中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。 </p>
<ul>
<li><p>引用值与传统面向对象编程语言中的类相似，但实现不同。 </p>
</li>
<li><p><strong>Date</strong> 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。 </p>
</li>
<li><p><strong>RegExp</strong> 类型是 <strong>ECMAScript</strong> 支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。 </p>
</li>
</ul>
<p><strong>JavaScript</strong>中函数实际上是<strong>Function</strong>类型的实例，也就是说<strong>函数也是对象</strong>。因为函数也是对象，所以函数也有方法，可以用于增强其能力。 </p>
<p>由于原始值包装类型的存在，<strong>JavaScript</strong> 中的原始值可以被当成对象来使用。有 <strong>3</strong> 种原始值包装类型：<strong>Boolean、Number 和 String</strong>。</p>
<ul>
<li><p>每种包装类型都映射到同名的原始类型。 </p>
</li>
<li><p>以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。 </p>
</li>
<li><p>涉及原始值的语句执行完毕后，包装对象就会被销毁。 </p>
</li>
</ul>
<p>当代码开始执行时，全局上下文中会存在两个内置对象：<strong>Global 和 Math</strong>。其中，<strong>Global</strong> 对象在大多数 <strong>ECMAScript</strong> 实现中无法直接访问。浏览器将其实现为window对象。<strong>所有全局变量和函数都是 Global 对象的属性</strong>。</p>
<h2 id="六、集合引用类型"><a href="#六、集合引用类型" class="headerlink" title="六、集合引用类型"></a>六、集合引用类型</h2><h3 id="6-1-Object"><a href="#6-1-Object" class="headerlink" title="6.1 Object"></a>6.1 Object</h3><p><strong>Object</strong> 是 <strong>ECMAScript</strong> 中最常用的类型之一，适合存储和在应用程序间交换数据。</p>
<p>显式地创建 <strong>Object</strong> 的实例有两种方式。</p>
<ol>
<li><p>使用 <strong>new</strong> 操作符和 <strong>Object</strong> 构造函数</p>
</li>
<li><p>使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式。</p>
<p>在对象字面量表示法中，属性名可以是字符串或数值。</p>
<p>可用来定义一个只有默认属性和方法的对象。</p>
<blockquote>
<p>在使用对象字面量表示法定义对象时，并不会实际调用 <strong>Object</strong> 构造函数。</p>
<p>数值属性会自动转换为字符串。</p>
</blockquote>
</li>
</ol>
<p>属性存取方式</p>
<ol>
<li><p>使用中括号的主要优势就是可以通过变量访问属性。</p>
</li>
<li><p>点语法是首选的属性存取方式，除非访问属性时必须使用变量。</p>
</li>
</ol>
<h3 id="6-2-Array"><a href="#6-2-Array" class="headerlink" title="6.2 Array"></a>6.2 Array</h3><p><strong>ECMAScript</strong> 数组也是一组有序的数据，数组中每个槽位可以 <strong>存储任意类型</strong> 的数据。<strong>ECMAScript</strong> 数组也是动态大小的。</p>
<h4 id="6-2-1-创建数组"><a href="#6-2-1-创建数组" class="headerlink" title="6.2.1 创建数组"></a>6.2.1 创建数组</h4><ol>
<li><p>使用 <strong>Array</strong> 构造函数</p>
<ul>
<li><p>给构造函数传入一个数值。</p>
</li>
<li><p>给构造函数传入要保存的元素。</p>
</li>
</ul>
<p>使用 <strong>Array</strong> 构造函数时，也可以省略 <strong>new</strong> 操作符。</p>
</li>
<li><p>使用数组字面量（array literal）表示法</p>
</li>
</ol>
<blockquote>
<p>与对象一样，在使用数组字面量表示法创建数组不会调用 <strong>Array</strong> 构造函数。</p>
</blockquote>
<p><strong>Array</strong> 构造函数用于创建数组的静态方法：**from() 和 of()**。</p>
<ol>
<li><p><strong>from()</strong> 用于将类数组结构转换为数组实例。</p>
<p><strong>Array.from()</strong> 的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构。</p>
<ul>
<li><p>可将集合和映射转换为一个新数组。</p>
</li>
<li><p>对现有数组执行浅复制。</p>
</li>
<li><p>能转换带有必要属性的自定义对象。</p>
</li>
</ul>
<p>接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值。</p>
<p>接收第三个可选参数，用于指定映射函数中this的值。但这个重写的this值在箭头函数中不适用。</p>
</li>
<li><p><strong>of()</strong> 用于将一组参数转换为数组实例。</p>
</li>
</ol>
<h4 id="6-2-2-数组空位"><a href="#6-2-2-数组空位" class="headerlink" title="6.2.2 数组空位"></a>6.2.2 数组空位</h4><p>用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。</p>
<p><strong>ES6</strong> 新增方法普遍将这些空位当成存在的元素，只不过值为 <strong>undefined</strong>。</p>
<blockquote>
<p>map()会跳过空位置。</p>
<p>join()视空位置为空字符串。</p>
</blockquote>
<h4 id="6-2-3-数组索引"><a href="#6-2-3-数组索引" class="headerlink" title="6.2.3  数组索引"></a>6.2.3  数组索引</h4><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引。</p>
<p>数组 <strong>length</strong> 属性的独特之处在于，它不是只读的。通过修改length属性，可以从数组末尾删除或添加元素。</p>
<h4 id="6-2-4-检测数组"><a href="#6-2-4-检测数组" class="headerlink" title="6.2.4 检测数组"></a>6.2.4 检测数组</h4><ol>
<li><p>使用 <strong>instanceof</strong> 操作符</p>
</li>
<li><p><strong>Array.isArray()</strong> 方法</p>
</li>
</ol>
<h4 id="6-2-5-迭代器方法"><a href="#6-2-5-迭代器方法" class="headerlink" title="6.2.5 迭代器方法"></a>6.2.5 迭代器方法</h4><p>在 <strong>ES6</strong> 中，<strong>Array</strong> 的原型上暴露了 3 个用于检索数组内容的方法：**keys()、values() 和 entries()**。</p>
<ul>
<li><p><strong>keys()</strong> 返回数组索引的迭代器</p>
</li>
<li><p><strong>values()</strong> 返回数组元素的迭代器</p>
</li>
<li><p><strong>entries()</strong> 返回索引/值对的迭代器</p>
</li>
</ul>
<h4 id="6-2-6-复制和填充方法"><a href="#6-2-6-复制和填充方法" class="headerlink" title="6.2.6 复制和填充方法"></a>6.2.6 复制和填充方法</h4><ul>
<li><p>批量复制方法 <strong>copyWithin()</strong></p>
<ul>
<li>按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 <strong>fill()</strong> 使用同样的计算方法。</li>
</ul>
</li>
<li><p>填充数组方法 <strong>fill()</strong></p>
<ul>
<li><p>可向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。</p>
</li>
<li><p><strong>fill()</strong> 静默忽略超出数组边界、零长度及方向相反的索引范围。</p>
</li>
</ul>
</li>
</ul>
<p>需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</p>
<h4 id="6-2-7-转换方法"><a href="#6-2-7-转换方法" class="headerlink" title="6.2.7 转换方法"></a>6.2.7 转换方法</h4><p>所有对象都有 <strong>toLocaleString()、toString() 和 valueOf()</strong> 方法。</p>
<ul>
<li><p><strong>valueOf()</strong> 返回的是数组本身。</p>
</li>
<li><p><strong>toString()</strong> 返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。</p>
</li>
<li><p><strong>toLocaleString()</strong> 方法也可能返回跟 <strong>toString()</strong> 和<strong>valueOf()</strong> 相同的结果，在调用数组的 <strong>toLocaleString()</strong> 方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的 <strong>toLocaleString()</strong> 方法。</p>
</li>
</ul>
<blockquote>
<p>如果数组中某一项是null 或 undefined，则在join()、toLocaleString()、toString()和valueOf()返回的结果中会以空字符串表示。</p>
</blockquote>
<h4 id="6-2-8-栈方法"><a href="#6-2-8-栈方法" class="headerlink" title="6.2.8 栈方法"></a>6.2.8 栈方法</h4><p>栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就<br>是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了 <strong>push() 和 pop()</strong> 方法。</p>
<ul>
<li><p><strong>push()</strong> 方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。</p>
</li>
<li><p><strong>pop()</strong> 方法则用于删除数组的最后一项，同时减少数组的length值，返回被删除的项。</p>
</li>
</ul>
<h4 id="6-2-9-队列方法"><a href="#6-2-9-队列方法" class="headerlink" title="6.2.9 队列方法"></a>6.2.9 队列方法</h4><p>队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。</p>
<ul>
<li><p><strong>push()</strong> 方法在数据末尾添加数据的。</p>
</li>
<li><p><strong>shift()</strong> 方法会删除数组的第一项并返回它，然后数组长度减 1。</p>
</li>
<li><p><strong>unshift()</strong> 方法在数组开头添加任意多个值，然后返回新的数组长度。</p>
</li>
<li><p><strong>pop()</strong> 在数组末尾取得数据。</p>
</li>
</ul>
<h4 id="6-2-10-排序方法"><a href="#6-2-10-排序方法" class="headerlink" title="6.2.10 排序方法"></a>6.2.10 排序方法</h4><p>数组用来对元素重新排序：**reverse() 和 sort()**。</p>
<p>默认情况下，<strong>sort()</strong> 会按照升序重新排列数组元素。</p>
<p><strong>sort()</strong> 方法可以接收一个比较函数，用于判断哪个值应该排在前。</p>
<blockquote>
<p>reverse()和sort()都返回调用它们的数组的引用。</p>
</blockquote>
<h4 id="6-2-11-操作方法"><a href="#6-2-11-操作方法" class="headerlink" title="6.2.11 操作方法"></a>6.2.11 操作方法</h4><ol>
<li><p><strong>concat()</strong> 方法可以在现有数组全部元素基础上创建一个新数组。</p>
</li>
<li><p><strong>slice()</strong> 方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。不影响原始数组。</p>
</li>
<li><p><strong>splice()</strong> 的主要目的是在数组中间插入元素</p>
<ul>
<li><p>删除。需要给 <strong>splice()</strong> 传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素。 </p>
</li>
<li><p>插入。需要给 <strong>splice()</strong> 传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2, 0, “red”, “green”)会从数组位置 2 开始插入字符串”red”和”green”。 </p>
</li>
<li><p>替换。<strong>splice()</strong> 在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始向数组中插入”red”和”green”。</p>
</li>
</ul>
<p><strong>splice()</strong> 方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。</p>
</li>
</ol>
<h4 id="6-2-12-搜索和位置方法"><a href="#6-2-12-搜索和位置方法" class="headerlink" title="6.2.12 搜索和位置方法"></a>6.2.12 搜索和位置方法</h4><ol>
<li>严格相等</li>
</ol>
<p>ECMAScript 提供了 3 个严格相等的搜索方法：**indexOf()、lastIndexOf()和includes()**。</p>
<p>这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。<strong>indexOf() 和 includes()</strong> 方法从数组前头（第一项）开始向后搜索，而 <strong>lastIndexOf()</strong> 从数组末尾（最后一项）开始向前搜索。<br><strong>indexOf() 和 lastIndexOf()</strong> 都返回要查找的元素在数组中的位置，如果没找到则返回1。<br><strong>includes()</strong> 返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（===）比较。</p>
<ol start="2">
<li>断言函数</li>
</ol>
<p>按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。<br>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。 </p>
<p><strong>find() 和 findIndex()</strong> 方法使用了断言函数。这两个方法都从数组的最小索引开始。</p>
<p><strong>find()</strong> 返回第一个匹配的元素，<strong>findIndex()</strong> 返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部this的值。</p>
<h4 id="6-2-13-迭代方法"><a href="#6-2-13-迭代方法" class="headerlink" title="6.2.13 迭代方法"></a>6.2.13 迭代方法</h4><p>数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 <strong>this</strong> 的值）。传给每个方法的函数接收 3<br>个参数：数组元素、元素索引和数组本身。 </p>
<ul>
<li><p>**every()**：对数组每一项都运行传入的函数，如果对每一项函数都返回true，则这个方法返回true。 </p>
</li>
<li><p>**filter()**：对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回。 </p>
</li>
<li><p>**forEach()**：对数组每一项都运行传入的函数，没有返回值。 </p>
</li>
<li><p>**map()**：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。 </p>
</li>
<li><p>**some()**：对数组每一项都运行传入的函数，如果有一项函数返回 <strong>true</strong>，则这个方法返回 <strong>true</strong>。</p>
</li>
</ul>
<p>这些方法都不改变调用它们的数组。</p>
<h4 id="6-2-14-归并方法"><a href="#6-2-14-归并方法" class="headerlink" title="6.2.14 归并方法"></a>6.2.14 归并方法</h4><p>ECMAScript 为数组提供了两个归并方法：<strong>reduce()和reduceRight()</strong> 。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。</p>
<p><strong>reduce()</strong> 方法从数组第一项开始遍历到最后一项。</p>
<p><strong>reduceRight()</strong> 从最后一项开始遍历至第一项。 </p>
<p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。<br>传给 <strong>reduce() 和 reduceRight()</strong> 的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p>
<h3 id="6-3-定型函数"><a href="#6-3-定型函数" class="headerlink" title="6.3 定型函数"></a>6.3 定型函数</h3><p>定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。</p>
<h4 id="6-3-1-ArrayBuffer"><a href="#6-3-1-ArrayBuffer" class="headerlink" title="6.3.1 ArrayBuffer"></a>6.3.1 ArrayBuffer</h4><p><strong>Float32Array</strong> 实际上是一种“视图”，可以允许 <strong>JavaScript</strong> 运行时访问一块名为 <strong>ArrayBuffer</strong> 的预分配内存。<strong>ArrayBuffer</strong> 是所有定型数组及视图引用的基本单位。</p>
<p><strong>ArrayBuffer()</strong> 是一个普通的 <strong>JavaScript</strong> 构造函数，可用于在内存中分配特定数量的字节空间。</p>
<p><strong>ArrayBuffer</strong> 一经创建就不能再调整大小。可以使用<strong>slice()</strong> 复制其全部或部分到一个新实例中。</p>
<blockquote>
<p>ArrayBuffer 某种程度上类似于 C++的malloc()，但有几个明显的区别。 </p>
<ul>
<li><p>malloc()在分配失败时会返回一个null指针。ArrayBuffer在分配失败时会抛出错误。 </p>
</li>
<li><p>malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer分配的内存不能超过Number.MAX_SAFE_INTEGER（253  1）字节。 </p>
</li>
<li><p>malloc()调用成功不会初始化实际的地址。声明ArrayBuffer则会将所有二进制位初始化为 0。 </p>
</li>
<li><p>通过malloc()分配的堆内存除非调用free()或程序退出，否则系统不能再使用。而通过声明ArrayBuffer分配的堆内存可以被当成垃圾回收，不用手动释放。</p>
</li>
</ul>
</blockquote>
<p>要读取或写入 <strong>ArrayBuffer</strong>，就必须通过视图。视图有不同的类型，但引用的都是 <strong>ArrayBuffer</strong> 中存储的二进制数据。</p>
<h4 id="6-3-2-DataView"><a href="#6-3-2-DataView" class="headerlink" title="6.3.2 DataView"></a>6.3.2 DataView</h4><p>第一种允许你读写 <strong>ArrayBuffer</strong> 的视图是 <strong>DataView</strong>。这个视图专为文件 I/O 和网络 I/O 设计，其API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。<strong>DataView</strong> 对缓冲内容没有任何预设，也不能迭代。 必须在对已有的 <strong>ArrayBuffer</strong> 读取或写入时才能创建 <strong>DataView</strong> 实例。这个实例可以使用全部或部分 <strong>ArrayBuffer</strong>，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p>
<p>要通过 <strong>DataView</strong> 读取缓冲，还需要几个组件。 </p>
<ul>
<li><p>首先是要读或写的字节偏移量。可以看成 <strong>DataView</strong> 中的某种“地址”。 </p>
</li>
<li><p><strong>DataView</strong> 应该使用 <strong>ElementType</strong> 来实<strong>JavaScript</strong> 的 <strong>Number</strong> 类型到缓冲内二进制格式的转换。 </p>
</li>
<li><p>最后是内存中值的字节序。默认为大端字节序。</p>
</li>
</ul>
<ol>
<li>ElementType<strong>DataView</strong> 对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读、写时指定一个 <strong>ElementType</strong> ，然后 <strong>DataView</strong> 就会忠实地为读、写而完成相应的转换。<br>ECMAScript 6 支持 8 种不同的 <strong>ElementType</strong><img src="/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell\Documents\img\2024-02-08-17-51-05-image.png"></li>
</ol>
<p><strong>DataView</strong> 为上表中的每种类型都暴露了 <strong>get和set</strong> 方法，这些方法使用byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的。</p>
<ol start="2">
<li>字节序</li>
</ol>
<p>“字节序”指的是计算系统维护的一种字节顺序的约定。</p>
<p><strong>DataView</strong> 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。<br><strong>JavaScript</strong> 运行时所在系统的原生字节序决定了如何读取或写入字节，但 <strong>DataView</strong> 并不遵守这个约定。对一段内存而言，<strong>DataView</strong> 是一个中立接口，它会遵循你指定的字节序。<strong>DataView</strong> 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 <strong>true</strong> 即可启用小端字节序。</p>
<ol start="3">
<li>边界情形</li>
</ol>
<p><strong>DataView</strong> 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出<strong>RangeError</strong> 。</p>
<h4 id="6-3-4-定型数组"><a href="#6-3-4-定型数组" class="headerlink" title="6.3.4 定型数组"></a>6.3.4 定型数组</h4><p>定型数组是另一种形式的 <strong>ArrayBuffer</strong> 视图。虽然概念上与DataView接近，但定型数组的区别在于，它特定于一种<strong>ElementType</strong> 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API 和更高的性能。</p>
<p>设计定型数组的目的就是提高与 <strong>WebGL</strong> 等原生库交换二进制数据的效率。</p>
<p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过 <strong><code>&lt;ElementType&gt;</code>.from()和<code>&lt;ElementType&gt;</code>.of()</strong> 也可以创建定型数组。</p>
<p>定型数组的构造函数和实例都有一个 <strong>BYTES_PER_ELEMENT</strong> 属性，返回该类型数组中每个元素的大小。</p>
<p>如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充。</p>
<p>1.定性数组行为</p>
<p>定型数组支持如下操作符、方法和属性： </p>
<ul>
<li><p>[] </p>
</li>
<li><p>copyWithin() </p>
</li>
<li><p>entries()</p>
</li>
<li><p>every() </p>
</li>
<li><p>fill() </p>
</li>
<li><p>filter() </p>
</li>
<li><p>find() </p>
</li>
<li><p>findIndex() </p>
</li>
<li><p>forEach() </p>
</li>
<li><p>indexOf() </p>
</li>
<li><p>join() </p>
</li>
<li><p>keys() </p>
</li>
<li><p>lastIndexOf() </p>
</li>
<li><p>length </p>
</li>
<li><p>map() </p>
</li>
<li><p>reduce() </p>
</li>
<li><p>reduceRight() </p>
</li>
<li><p>reverse() </p>
</li>
<li><p>slice() </p>
</li>
<li><p>some() </p>
</li>
<li><p>sort() </p>
</li>
<li><p>toLocaleString() </p>
</li>
<li><p>toString()</p>
</li>
<li><p>values() </p>
<p>其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组。</p>
</li>
</ul>
<ol start="2">
<li>合并复制和修改定型数组</li>
</ol>
<p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法<strong>不适用</strong>于定型数组： concat() 、pop() 、push() 、shift() 、splice() 、unshift()。</p>
<p>定型数组提供了两个新方法，可以快速向外或向内复制数据：**set() 和 subarray()**。</p>
<p><strong>set()</strong> 从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置。</p>
<p><strong>subarray()</strong> 会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的。</p>
<ol start="3">
<li>下溢和上溢</li>
</ol>
<p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位。</p>
<blockquote>
<p>除了 8 种元素类型，还有一种“夹板”数组类型：Uint8ClampedArray，不允许任何方向溢出。超出最大值 255 的值会被向下舍入为 255，而小于最小值 0的值会被向上舍入为 0。</p>
</blockquote>
<h3 id="6-4-Map"><a href="#6-4-Map" class="headerlink" title="6.4 Map"></a>6.4 Map</h3><p><strong>Map</strong> 是一种新的集合类型，为这门语言带来了真正的键/值存储机制。</p>
<h4 id="6-4-1-基本API"><a href="#6-4-1-基本API" class="headerlink" title="6.4.1 基本API"></a>6.4.1 基本API</h4><p>使用 <strong>new</strong> 关键字和 <strong>Map</strong> 构造函数可以创建一个空映射。</p>
<p>想在创建的同时初始化实例，可以给 <strong>Map</strong> 构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例。</p>
<p>初始化之后，可以使用 <strong>set()</strong> 方法再添加键/值对。另外，可以使用 <strong>get() 和 has()</strong> 进行查询，可以通过 <strong>size</strong> 属性获取映射中的键/值对的数量，还可以使用 <strong>delete()和clear()</strong> 删除值。</p>
<p><strong>set()</strong> 方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明。</p>
<p><strong>Map</strong> 可以使用任何 <strong>JavaScript</strong> 数据类型作为键。</p>
<h4 id="6-4-2-顺序与迭代"><a href="#6-4-2-顺序与迭代" class="headerlink" title="6.4.2 顺序与迭代"></a>6.4.2 顺序与迭代</h4><p>与 <strong>Object</strong> 类型的一个主要差异是，<strong>Map</strong> 实例会维护键值对的插入顺序，可以根据插入顺序执行迭代操作。<br>映射实例可提供一个迭代器（Iterator），能以插入顺序生成 <strong>[key, value]</strong> 形式的数组。可以通过 <strong>entries()</strong> 方法（或者 <strong>Symbol.iterator</strong> 属性，它引用 <strong>entries()</strong> ）取得这个迭代器。</p>
<p><strong>entries()</strong> 是默认迭代器，可以直接对映射实例使用扩展操作，把映射转换为数组。</p>
<h4 id="6-4-3-Object-和-Map-的选择"><a href="#6-4-3-Object-和-Map-的选择" class="headerlink" title="6.4.3 Object 和 Map 的选择"></a>6.4.3 Object 和 Map 的选择</h4><ol>
<li>内存占用</li>
</ol>
<p><strong>Object 和 Map</strong> 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，<strong>Map</strong> 大约可以比 <strong>Object</strong> 多存储 <strong>50%</strong> 的键/值对。</p>
<ol start="2">
<li>插入性能</li>
</ol>
<p>插入 <strong>Map</strong> 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 <strong>Map</strong> 的性能更佳。</p>
<ol start="3">
<li>查找速度</li>
</ol>
<p>如果只包含少量键/值对，则 <strong>Object</strong> 有时候速度更快。在把 <strong>Object</strong> 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 <strong>Map</strong> 来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择 <strong>Object</strong> 更好一些。</p>
<ol start="4">
<li>删除性能</li>
</ol>
<p>对大多数浏览器引擎来说，<strong>Map 的 delete()</strong> 操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 <strong>Map</strong>。</p>
<h3 id="6-5-WeakMap"><a href="#6-5-WeakMap" class="headerlink" title="6.5 WeakMap"></a>6.5 WeakMap</h3><p>ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。WeakMap是Map的“兄弟”类型，其 API 也是Map的子集。WeakMap中的“weak”（弱），描述的是JavaScript 垃圾回收程序对待“弱映射”中键的方式。</p>
<h4 id="6-5-1-基本API"><a href="#6-5-1-基本API" class="headerlink" title="6.5.1 基本API"></a>6.5.1 基本API</h4><p>可以使用 <strong>new</strong> 关键字实例化一个空的 <strong>WeakMap</strong>。</p>
<p>弱映射中的键只能是 <strong>Object</strong> 或者继承自 <strong>Object</strong> 的类型，尝试使用非对象设置键会抛出 <strong>TypeError</strong>。值的类型没有限制。<br>如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中</p>
<p>初始化之后可以使用 <strong>set()</strong> 再添加键/值对，可以使用 <strong>get() 和 has()</strong> 查询，还可以使用 <strong>delete()</strong> 删除。</p>
<h4 id="6-5-2-弱键"><a href="#6-5-2-弱键" class="headerlink" title="6.5.2 弱键"></a>6.5.2 弱键</h4><p><strong>WeakMap</strong> 中“<strong>weak</strong>”表示这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。</p>
<h4 id="6-5-3-不可迭代键"><a href="#6-5-3-不可迭代键" class="headerlink" title="6.5.3 不可迭代键"></a>6.5.3 不可迭代键</h4><p><strong>WeakMap</strong> 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。</p>
<h4 id="6-5-4-使用弱映射"><a href="#6-5-4-使用弱映射" class="headerlink" title="6.5.4 使用弱映射"></a>6.5.4 使用弱映射</h4><ol>
<li>私有变量</li>
</ol>
<p>弱映射造就了在 <strong>JavaScript</strong> 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。</p>
<ol start="2">
<li><strong>DOM</strong> 节点元数据</li>
</ol>
<p>WeakMap 实力不会妨碍垃圾回收，适合保存关联元数据。</p>
<h3 id="6-6-Set"><a href="#6-6-Set" class="headerlink" title="6.6 Set"></a>6.6 Set</h3><p><strong>ECMAScript 6</strong> 新增的 <strong>Set</strong> 是一种新集合类型。</p>
<h4 id="6-6-1-基本API"><a href="#6-6-1-基本API" class="headerlink" title="6.6.1 基本API"></a>6.6.1 基本API</h4><p>使用 <strong>new</strong> 关键字和 <strong>Set</strong> 构造函数可以创建一个空集合。</p>
<p>初始化之后，可以使用 <strong>add()</strong> 增加值，使用 <strong>has()</strong> 查询，通过 <strong>size</strong> 取得元素数量，以及使用 <strong>delete() 和 clear()</strong> 删除元素。</p>
<p><strong>Set</strong> 可以包含任何 <strong>JavaScript</strong> 数据类型作为值。集合也使用 <strong>SameValueZero</strong> 操作。</p>
<h4 id="6-6-2-顺序与迭代"><a href="#6-6-2-顺序与迭代" class="headerlink" title="6.6.2 顺序与迭代"></a>6.6.2 顺序与迭代</h4><p><strong>Set</strong> 会维值插入时的顺序， 可以通过 <strong>values()</strong> 方法及其别名方法 **keys()**（或者 <strong>Symbol.iterator</strong> 属性，它引用 <strong>values()</strong> ）取得这个迭代器。</p>
<p><strong>values()</strong> 是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组。</p>
<p>集合的 <strong>entries()</strong> 方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现</p>
<h3 id="6-7-WeakSet"><a href="#6-7-WeakSet" class="headerlink" title="6.7 WeakSet"></a>6.7 WeakSet</h3><p><strong>ECMAScript 6</strong> 新增的“弱集合”（<strong>WeakSet</strong>）是一种新的集合类型，为这门语言带来了集合数据结构。<strong>WeakSet</strong> 是 <strong>Set</strong> 的“兄弟”类型，其 <strong>API</strong> 也是 <strong>Set</strong> 的子集 <strong>WeakSet</strong> 中的“<strong>weak</strong>”（弱），描述的是 <strong>JavaScript</strong> 垃圾回收程序对待“弱集合”中值的方式。</p>
<h4 id="6-7-1-基本API"><a href="#6-7-1-基本API" class="headerlink" title="6.7.1 基本API"></a>6.7.1 基本API</h4><p>可以使用 <strong>new</strong> 关键字实例化一个空的 <strong>WeakSet</strong>。</p>
<p>弱集合中的值只能是 <strong>Object</strong> 或者继承自 <strong>Object</strong> 的类型，尝试使用非对象设置值会抛出 <strong>TypeError</strong> 。<br>如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中。</p>
<p>初始化之后可以使用 <strong>add()</strong> 再添加新值，可以使用 <strong>has()</strong> 查询，还可以使用 <strong>delete()</strong> 删除。</p>
<h4 id="6-7-2-弱值"><a href="#6-7-2-弱值" class="headerlink" title="6.7.2 弱值"></a>6.7.2 弱值</h4><p>WeakSet中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收。</p>
<h4 id="6-7-3-不可迭代值"><a href="#6-7-3-不可迭代值" class="headerlink" title="6.7.3 不可迭代值"></a>6.7.3 不可迭代值</h4><p>因为 <strong>WeakSet</strong> 中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然，也用不着像 <strong>clear()</strong> 这样一次性销毁所有值的方法。即便代码可以访问 <strong>WeakSet</strong> 实例，也没办法看到其中的内容。<br><strong>WeakSet</strong> 之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。</p>
<h4 id="6-7-4-使用弱集合"><a href="#6-7-4-使用弱集合" class="headerlink" title="6.7.4 使用弱集合"></a>6.7.4 使用弱集合</h4><p>弱集合在给对象打标签时还是有价值的。</p>
<h3 id="6-8-迭代与扩展操作"><a href="#6-8-迭代与扩展操作" class="headerlink" title="6.8 迭代与扩展操作"></a>6.8 迭代与扩展操作</h3><p>有 4 种原生集合类型定义了默认迭代器： </p>
<ul>
<li><p>Array </p>
</li>
<li><p>所有定型数组 </p>
</li>
<li><p>Map </p>
</li>
<li><p>Set</p>
</li>
</ul>
<p>上述所有类型都支持顺序迭代，都可以传入<strong>for-of</strong> 循环。</p>
<h3 id="6-9-小结"><a href="#6-9-小结" class="headerlink" title="6.9 小结"></a>6.9 小结</h3><p><strong>JavaScript</strong> 中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。 </p>
<ul>
<li><p>引用类型与传统面向对象编程语言中的类相似，但实现不同。 </p>
</li>
<li><p><strong>Object</strong> 类型是一个基础类型，所有引用类型都从它继承了基本的行为。 </p>
</li>
<li><p><strong>Array</strong> 类型表示一组有序的值，并提供了操作和转换值的能力。 </p>
</li>
<li><p>定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。 </p>
</li>
<li><p><strong>Date</strong> 类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。 </p>
</li>
<li><p><strong>RegExp</strong> 类型是 <strong>ECMAScript</strong> 支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。 </p>
</li>
</ul>
<p><strong>JavaScript</strong> 比较独特的一点是，函数其实是 <strong>Function</strong> 类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法。<br>因为原始值包装类型的存在，所以 <strong>JavaScript</strong> 中的原始值可以拥有类似对象的行为。有 3 种原始值包装类型：<strong>Boolean、Number和String</strong>。它们都具有如下特点。</p>
<ul>
<li><p>每种包装类型都映射到同名的原始类型。 </p>
</li>
<li><p>在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。 </p>
</li>
<li><p>涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。</p>
</li>
</ul>
<p><strong>JavaScript</strong> 还有两个在一开始执行代码时就存在的内置对象：<strong>Global 和 Math</strong>。其中，<strong>Global</strong> 对象在大多数 <strong>ECMAScript</strong> 实现中无法直接访问。不过浏览器将 <strong>Global</strong> 实现为<strong>window</strong> 对象。所有全局变量和函数都是 <strong>Global</strong> 对象的属性。<strong>Math</strong> 对象包含辅助完成复杂数学计算的属性和方法。<br><strong>ECMAScript 6</strong> 新增了一批引用类型：<strong>Map、WeakMap、Set 和 WeakSet</strong>。这些类型为组织应用程序数据和简化内存管理提供了新能力。</p>
<h2 id="七、迭代器与生成器"><a href="#七、迭代器与生成器" class="headerlink" title="七、迭代器与生成器"></a>七、迭代器与生成器</h2><h3 id="7-1-迭代"><a href="#7-1-迭代" class="headerlink" title="7.1 迭代"></a>7.1 迭代</h3><p>循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。 迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）</p>
<p>数组是 <strong>JavaScript</strong> 中有序集合的最典型例子。</p>
<ul>
<li><p>迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。 </p>
</li>
<li><p>遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。</p>
</li>
</ul>
<h3 id="7-2-迭代器模式"><a href="#7-2-迭代器模式" class="headerlink" title="7.2 迭代器模式"></a>7.2 迭代器模式</h3><p>迭代器模式（特别是在 <strong>ECMAScript</strong> 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（<strong>iterable</strong>），因为它们实现了正式的 <strong>Iterable</strong> 接口，而且可以通过迭代器Iterator消费。 </p>
<p>可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。</p>
<p>可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构。</p>
<p>任何实现 <strong>Iterable</strong> 接口的数据结构都可以被实现 <strong>Iterator</strong> 接口的结构“消费”（<strong>consume</strong>）。迭代器（<strong>iterator</strong>）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 <strong>API</strong> 。</p>
<h4 id="7-2-1-可迭代协议"><a href="#7-2-1-可迭代协议" class="headerlink" title="7.2.1 可迭代协议"></a>7.2.1 可迭代协议</h4><p>实现 <strong>Iterable</strong> 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现 <strong>Iterator</strong> 接口的对象的能力。在 <strong>ECMAScript</strong> 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 <strong>Symbol.iterator</strong> 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。<br>很多内置类型都实现了 <strong>Iterable</strong> 接口</p>
<ul>
<li><p>字符串 </p>
</li>
<li><p>数组</p>
</li>
<li><p>映射 </p>
</li>
<li><p>集合 </p>
</li>
<li><p><strong>arguments</strong> 对象 </p>
</li>
<li><p><strong>NodeList</strong> 等 <strong>DOM</strong> 集合类型<br>检查是否存在默认迭代器属性可以暴露这个工厂函数。</p>
</li>
</ul>
<p>实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括： </p>
<ul>
<li><p>for-of循环 </p>
</li>
<li><p>数组解构 </p>
</li>
<li><p>扩展操作符 </p>
</li>
<li><p><strong>Array.from()</strong> </p>
</li>
<li><p>创建集合 </p>
</li>
<li><p>创建映射 </p>
</li>
<li><p><strong>Promise.all()</strong> 接收由期约组成的可迭代对象 </p>
</li>
<li><p><strong>Promise.race()</strong> 接收由期约组成的可迭代对象 </p>
</li>
<li><p><strong>yield</strong>* 操作符，在生成器中使用<br>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器。</p>
</li>
</ul>
<h4 id="7-2-2-迭代器协议"><a href="#7-2-2-迭代器协议" class="headerlink" title="7.2.2 迭代器协议"></a>7.2.2 迭代器协议</h4><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器 API 使用 <strong>next()</strong> 方法在可迭代对象中遍历数据。每次成功调用 **next()**，都会返回一个 <strong>IteratorResult</strong> 对象，其中包含迭代器返回的下一个值。若不调用 <strong>next()<strong>，则无法知道迭代器的当前位置。<br><strong>next()</strong> 方法返回的迭代器对象 <strong>IteratorResult</strong> 包含两个属性：</strong>done 和 value</strong>。</p>
<ul>
<li><p><strong>done</strong> 是一个布尔值，表示是否还可以再次调用 <strong>next()</strong> 取得下一个值。</p>
</li>
<li><p><strong>value</strong> 包含可迭代对象的下一个值（<strong>done 为 false</strong>），或者<strong>undefined（done 为 true）</strong>。<strong>done: true</strong> 状态称为“耗尽”。</p>
</li>
</ul>
<p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象。</p>
<p>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化。</p>
<blockquote>
<p>迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。</p>
</blockquote>
<h4 id="7-2-3-提前终止迭代器"><a href="#7-2-3-提前终止迭代器" class="headerlink" title="7.2.3 提前终止迭代器"></a>7.2.3 提前终止迭代器</h4><p><strong>return()</strong> 方法用于指定在迭代器提前关闭时执行的逻辑。</p>
<p>执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括： </p>
<ul>
<li><p><strong>for-of</strong> 循环通过 <strong>break、continue、return 或 throw</strong> 提前退出。</p>
</li>
<li><p>解构操作并未消费所有值。 </p>
</li>
</ul>
<p><strong>return()</strong> 方法必须返回一个有效的 <strong>IteratorResult</strong> 对象，简单情况下，可以只返回{ <strong>done: true</strong> }。因为这个返回值只会用在生成器的上下文中。</p>
<p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的。</p>
<p>因为 <strong>return()</strong> 方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 <strong>return</strong> 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 <strong>return()</strong> 不会强制迭代器进入关闭状态。即便如此，<strong>return()</strong> 方法还是会被调用。</p>
<h3 id="7-3-生成器"><a href="#7-3-生成器" class="headerlink" title="7.3 生成器"></a>7.3 生成器</h3><p>生成器是 <strong>ECMAScript 6</strong> 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。</p>
<h4 id="7-3-1-生成器基础"><a href="#7-3-1-生成器基础" class="headerlink" title="7.3.1 生成器基础"></a>7.3.1 生成器基础</h4><p>生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。</p>
<blockquote>
<p>箭头函数不能用来定义生成器函数。</p>
</blockquote>
<p>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（<strong>suspended</strong>）的状态。与迭代器相似，生成器对象也实现了 <strong>Iterator</strong> 接口，因此具有 <strong>next()</strong> 方法，调用这个方法会让生成器开始或恢复执行。</p>
<p><strong>next()</strong> 方法的返回值类似于迭代器，有一个 <strong>done</strong> 属性和一个 <strong>value</strong> 属性。函数体为空的生成器函数中间不会停留，调用一次 <strong>next()</strong> 就会让生成器到达 <strong>done: true</strong> 状态。</p>
<p><strong>value</strong> 属性是生成器函数的返回值，默认值为 <strong>undefined</strong>，可以通过生成器函数的返回值指定。</p>
<p>生成器函数只会在初次调用 <strong>next()</strong> 方法后开始执行。</p>
<p>生成器对象实现了 <strong>Iterable</strong> 接口，它们默认的迭代器是自引用的。</p>
<h4 id="7-3-2-通过-yield-中断执行"><a href="#7-3-2-通过-yield-中断执行" class="headerlink" title="7.3.2 通过 yield 中断执行"></a>7.3.2 通过 yield 中断执行</h4><p><strong>yield</strong> 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 <strong>yield</strong> 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用<strong>next()</strong> 方法来恢复执行。</p>
<ul>
<li><p>通过 <strong>yield</strong> 关键字退出的生成器函数会处在 <strong>done: false</strong> 状态。</p>
</li>
<li><p>通过 <strong>return</strong> 关键字退出的生成器函数会处于 <strong>done: true</strong> 状态。</p>
</li>
</ul>
<p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 <strong>next()</strong> 不会影响其他生成器。</p>
<p><strong>yield</strong> 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的<strong>return</strong> 关键字，<strong>yield</strong> 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误。</p>
<ol>
<li>生成器对象作为可迭代对象</li>
</ol>
<p>如果把生成器对象当成可迭代对象，那么使用起来会更方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <strong>yield</strong> 实现输入和输出</li>
</ol>
<p><strong>yield</strong> 关键字可以作为函数的中间返回语句使用，还可以作为函数的中间参数使用。上一次让生成器函数暂停的 <strong>yield</strong> 关键字会接收到传给 <strong>next()</strong> 方法的第一个值。——第一次调用 <strong>next()</strong> 传入的值不会被使用，因为这一次调用是为了开始执行生成器函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params">initial</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(initial);  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>); </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"></span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;bar&#x27;</span>);  <span class="comment">// foo </span></span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;baz&#x27;</span>);  <span class="comment">// baz </span></span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;qux&#x27;</span>);  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>

<p><strong>yield</strong> 关键字可以同时用于输入和输出。</p>
<p><strong>yield</strong> 关键字并不是只能使用一次。</p>
<ol start="3">
<li>产生可迭代对象</li>
</ol>
<p>可以使用星号增强 <strong>yield</strong> 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的 generatorFn：  </span></span><br><span class="line"><span class="comment">// function* generatorFn() &#123; </span></span><br><span class="line"><span class="comment">//   for (const x of [1, 2, 3]) &#123; </span></span><br><span class="line"><span class="comment">//     yield x; </span></span><br><span class="line"><span class="comment">//   &#125; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 <strong>yield</strong> 实现递归算法</li>
</ol>
<p><strong>yield</strong>* 最有用的地方是实现递归操作，此时生成器可以产生自身。</p>
<h4 id="7-3-3-生成器作为默认迭代器"><a href="#7-3-3-生成器作为默认迭代器" class="headerlink" title="7.3.3 生成器作为默认迭代器"></a>7.3.3 生成器作为默认迭代器</h4><p>因为生成器对象实现了Iterable接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。</p>
<h4 id="7-3-4-提前终止生成器"><a href="#7-3-4-提前终止生成器" class="headerlink" title="7.3.4 提前终止生成器"></a>7.3.4 提前终止生成器</h4><p>一个实现 <strong>Iterator</strong> 接口的对象一定有 <strong>next()</strong> 方法，还有一个可选的 <strong>return()</strong> 方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：**throw()**。</p>
<p><strong>return() 和 throw()</strong> 方法都可以用于强制生成器进入关闭状态。</p>
<ol>
<li><strong>return()</strong></li>
</ol>
<p><strong>return()</strong> 方法会强制生成器进入关闭状态。提供给 <strong>return()</strong> 方法的值，就是终止迭代器对象的值。</p>
<p>所有生成器对象都有 <strong>return()</strong> 方法，只要通过它进入关闭状态，就无法恢复了。后续调用 <strong>next()</strong> 会显示 <strong>done: true</strong> 状态，而提供的任何返回值都不会被存储或传播。</p>
<p><strong>for-of</strong> 循环等内置语言结构会忽略状态为 <strong>done: true 的 IteratorObject</strong> 内部返回的值。</p>
<ol start="2">
<li><strong>throw()</strong></li>
</ol>
<p><strong>throw()</strong> 方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭。</p>
<p>假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 <strong>yield</strong>。</p>
<blockquote>
<p>如果生成器对象还没有开始执行，那么调用 *<strong>hrow()</strong> 抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p>
</blockquote>
<h3 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h3><p>迭代是一种所有编程语言中都可以看到的模式。<strong>ECMAScript 6</strong> 正式支持迭代模式并引入了两个新的语言特性：<strong>迭代器和生成器</strong>。<br>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现 <strong>Iterable</strong> 接口的对象都有一个 <strong>Symbol.iterator</strong> 属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现 <strong>Iterator</strong> 接口的对象。<br>迭代器必须通过连续调用 <strong>next()</strong> 方法才能连续取得值，这个方法返回一个 <strong>IteratorObject</strong> 。这个对象包含一个 <strong>done</strong> 属性和一个 <strong>value</strong> 属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用 <strong>next()</strong> 方法来消费，也可以通过原生消费者，比如 <strong>for-of</strong> 循环来自动消费。<br>生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了 <strong>Iterable</strong> 接口，因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持 <strong>yield</strong> 关键字，这个关键字能够暂停执行生成器函数。使用 <strong>yield</strong> 关键字还可以通过 <strong>next()</strong> 方法接收输入和产生输出。在加上星号之后，<strong>yield</strong> 关键字可以将跟在它后面的可迭代对象序列化为一连串值。</p>
<h2 id="八、对象、类与面向对象编程"><a href="#八、对象、类与面向对象编程" class="headerlink" title="八、对象、类与面向对象编程"></a>八、对象、类与面向对象编程</h2><p><strong>ECMA-262</strong> 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。</p>
<h3 id="8-1-对象"><a href="#8-1-对象" class="headerlink" title="8.1 对象"></a>8.1 对象</h3><p>创建自定义对象的通常方式是创建 <strong>Object</strong> 的一个新实例，然后再给它添加属性和方法。</p>
<h4 id="8-1-1-属性类型"><a href="#8-1-1-属性类型" class="headerlink" title="8.1.1 属性类型"></a>8.1.1 属性类型</h4><p><strong>ECMA-262</strong> 使用一些内部特性来描述属性的特征。这些特性是由为 <strong>JavaScript</strong> 实现引擎的规范定义的。因此，开发者不能在 <strong>JavaScript</strong> 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[<strong>Enumerable</strong>]]。</p>
<p>属性分为：数据属性和访问器属性</p>
<ol>
<li>数据属性</li>
</ol>
<p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。</p>
<ul>
<li><p>[[<strong>Configurable</strong>]]：表示属性是否可以通过 <strong>delete</strong> 删除并重新定义，是否可以修改它的性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 <strong>true</strong>。</p>
</li>
<li><p>[[<strong>Enumerable</strong>]]：表示属性是否可以通过 <strong>for-in</strong> 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 <strong>true</strong>。 </p>
</li>
<li><p>[[<strong>Writable</strong>]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 <strong>true</strong>。 </p>
</li>
<li><p>[[<strong>Value</strong>]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 <strong>undefined</strong>。</p>
</li>
</ul>
<p>要修改属性的默认特性，就必须使用 <strong>Object.defineProperty()</strong> 方法。这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：<strong>configurable、enumerable、writable 和 value</strong>，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;  </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>, </span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>

<p>一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 <strong>Object.defineProperty()</strong> 并修改任何非 <strong>writable</strong> 属性会导致错误。</p>
<p>在调用 <strong>Object.defineProperty()</strong> 时，<strong>configurable、enumerable 和 writable</strong> 的值如果不指定，则都默认为 <strong>false</strong>。</p>
<ol start="2">
<li>访问器属性</li>
</ol>
<p>访问器属性不包含数据值。它们包含一个获取（<strong>getter</strong>）函数和一个设置（<strong>setter</strong>）函数，这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。</p>
<ul>
<li><p>[[<strong>Configurable</strong>]]：表示属性是否可以通过 <strong>delete</strong> 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 <strong>true</strong>。 </p>
</li>
<li><p>[[<strong>Enumerable</strong>]]：表示属性是否可以通过 <strong>for-in</strong> 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 <strong>true</strong>。 </p>
</li>
<li><p>[[<strong>Get</strong>]]：获取函数，在读取属性时调用。默认值为 <strong>undefined</strong>。 </p>
</li>
<li><p>[[<strong>Set</strong>]]：设置函数，在写入属性时调用。默认值为 <strong>undefined</strong>。</p>
</li>
</ul>
<p>访问器属性是不能直接定义的，必须使用 **Object.defineProperty()**。</p>
<p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 <strong>undefined</strong> ，严格模式下会抛出错误。</p>
<h4 id="8-1-2-定义多个属性"><a href="#8-1-2-定义多个属性" class="headerlink" title="8.1.2 定义多个属性"></a>8.1.2 定义多个属性</h4><p><strong>ECMAScript</strong> 提供了 <strong>Object.defineProperties()</strong> 方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。</p>
<h4 id="8-1-3-读取属性的特性"><a href="#8-1-3-读取属性的特性" class="headerlink" title="8.1.3 读取属性的特性"></a>8.1.3 读取属性的特性</h4><p>使用 <strong>Object.getOwnPropertyDescriptor()</strong> 方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 <strong>configurable、enumerable、get 和 set</strong> 属性，对于数据属性包含 <strong>configurable、enumerable、writable 和 value</strong> 属性。</p>
<p><strong>ECMAScript 2017</strong> 新增了 <strong>Object.getOwnPropertyDescriptors()</strong> 静态方法。这个方法实际上会在每个自有属性上调用 <strong>Object.getOwnPropertyDescriptor()</strong> 并在一个新对象中返回它们。</p>
<h4 id="8-1-4-合并对象"><a href="#8-1-4-合并对象" class="headerlink" title="8.1.4 合并对象"></a>8.1.4 合并对象</h4><p><strong>ECMAScript 6</strong> 专门为合并对象提供了 <strong>Object.assign()</strong> 方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（<strong>Object.propertyIsEnumerable() 返回 true</strong>）和自有（<strong>Object.hasOwnProperty() 返回 true</strong>）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[<strong>Get</strong>]]取得属性的值，然后使用目标对象上的[[<strong>Set</strong>]]设置属性的值。</p>
<p><strong>Object.assign()</strong> 实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</p>
<h4 id="8-1-5-对象标识及相等判定"><a href="#8-1-5-对象标识及相等判定" class="headerlink" title="8.1.5 对象标识及相等判定"></a>8.1.5 对象标识及相等判定</h4><p><strong>ECMAScript 6</strong> 规范新增了 **Object.is()**，这个方法与===很像，但同时也考虑<br>到了边界情形，这个方法必须接收两个参数。</p>
<h4 id="8-1-6-增强的对象语法"><a href="#8-1-6-增强的对象语法" class="headerlink" title="8.1.6 增强的对象语法"></a>8.1.6 增强的对象语法</h4><ol>
<li>属性值简写</li>
</ol>
<p>简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 <strong>ReferenceError</strong>。</p>
<p>代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。</p>
<ol start="2">
<li>可计算属性</li>
</ol>
<p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性</p>
<p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 <strong>JavaScript</strong> 表达式而不是字符串来求值。</p>
<blockquote>
<p>可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。</p>
</blockquote>
<ol start="3">
<li>简写方法名</li>
</ol>
<p>在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式。</p>
<p>新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名。相应地，这样也可以明显缩短方法声明。</p>
<p>简写方法名与可计算属性键相互兼容。</p>
<h4 id="8-1-7-对象解构"><a href="#8-1-7-对象解构" class="headerlink" title="8.1.7 对象解构"></a>8.1.7 对象解构</h4><p><strong>ECMAScript 6</strong> 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p>
<p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法。</p>
<p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 <strong>undefined</strong>。</p>
<p>可以在解构赋值的同时定义默认值，这适用于引用的属性不存在于源对象中的情况。</p>
<p>解构在内部使用函数 <strong>ToObject()<strong>（不能在运行时环境中直接访问）把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 <strong>ToObject()</strong> 的定义），</strong>null 和 undefined</strong> 不能被解构，否则会抛出错误。</p>
<p>解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中。</p>
<ol>
<li>嵌套解构</li>
</ol>
<p>解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性。</p>
<p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样。</p>
<ol start="2">
<li>部分解构</li>
</ol>
<p>涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及<br>多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分。</p>
<ol start="3">
<li>参数上下文匹配</li>
</ol>
<p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 <strong>arguments</strong> 对象，但可以在函数签名中声明在函数体内使用局部变量。</p>
<h3 id="8-2-创建对象"><a href="#8-2-创建对象" class="headerlink" title="8.2 创建对象"></a>8.2 创建对象</h3><h4 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1 概述"></a>8.2.1 概述</h4><p><strong>ECMAScript 6</strong> 开始正式支持类和继承。<strong>ES6</strong> 的类旨在完全涵盖之前规范设计的基于原型的继承模式。</p>
<h4 id="8-2-2-工厂模式"><a href="#8-2-2-工厂模式" class="headerlink" title="8.2.2 工厂模式"></a>8.2.2 工厂模式</h4><p>工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();  </span><br><span class="line">  o.<span class="property">name</span> = name; </span><br><span class="line">  o.<span class="property">age</span> = age; </span><br><span class="line">  o.<span class="property">job</span> = job; </span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-构造函数模式"><a href="#8-2-3-构造函数模式" class="headerlink" title="8.2.3 构造函数模式"></a>8.2.3 构造函数模式</h4><p><strong>ECMAScript</strong> 中的构造函数是用于创建特定类型对象的。像 <strong>Object 和 Array</strong> 这<br>样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayName</span>();  <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>();  <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure>

<p>与工厂模式的 <strong>区别</strong>：</p>
<ul>
<li><p>没有显式地创建对象。 </p>
</li>
<li><p>属性和方法直接赋值给了this。 </p>
</li>
<li><p>没有return。</p>
</li>
</ul>
<p>按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。</p>
<p>使用new操作符调用构造函数会执行如下操作。<br>(1) 在内存中创建一个新对象。<br>(2) 这个新对象内部的[[<strong>Prototype</strong>]]特性被赋值为构造函数的 <strong>prototype</strong> 属性。(3) 构造函数内部的this被赋值为这个新对象（即this指向新对象）。<br>(4) 执行构造函数内部的代码（给新对象添加属性）。<br>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p>
<p><strong>constructor</strong> 本来是用于标识对象类型的。不过，一般认为 <strong>instanceo</strong> f操作符是确定对象类型更可靠的方式。</p>
<p>构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数。</p>
<ol>
<li>构造函数也是函数</li>
</ol>
<p>构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。</p>
<p>任何函数只要使用 <strong>new</strong> 操作符调用就是构造函数，而不使用 <strong>new</strong> 操作符调用的函数就是普通函数。</p>
<p>在调用一个函数而没有明确设置 <strong>this</strong> 值的情况下（即没有作为对象的方法调用，或者没有使用 <strong>call()/apply()</strong> 调用），<strong>this</strong> 始终指向 <strong>Global</strong> 对象（在浏览器中就是 <strong>window</strong> 对象）。</p>
<ol start="2">
<li>构造函数的问题</li>
</ol>
<p>主要问题在于，其定义的方法会在每个实例上都创建一遍。</p>
<h4 id="8-2-4-原型模式"><a href="#8-2-4-原型模式" class="headerlink" title="8.2.4 原型模式"></a>8.2.4 原型模式</h4><p>每个函数都会创建一个 <strong>prototype</strong> 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。</p>
<ol>
<li>原型</li>
</ol>
<p>只要创建一个函数，就会按照特定的规则为这个函数创建一个 <strong>prototype</strong> 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 <strong>constructor</strong> 的属性，指回与之关联的构造函数。</p>
<p>在自定义构造函数时，原型对象默认只会获得 <strong>constructor</strong> 属性，其他的所有方法都继承自 <strong>Object</strong>。每次调用构造函数创建一个新实例，这个实例的内部[[<strong>Prototype</strong>]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[<strong>Prototype</strong>]]特性的标准方式，但 <strong>Firefox、Safari 和 Chrome</strong> 会在每个对象上暴露 <strong><strong>proto</strong></strong> 属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性<br>完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<p>实例与构造函数没有直接联系，与原型对象有直接联系。</p>
<p><strong>ECMAScript</strong> 的 <strong>Object</strong> 类型有一个方法叫 **Object.getPrototypeOf()**，返回参数的内部特性[[<strong>Prototype</strong>]]的值。</p>
<p><strong>Object</strong> 类型还有一个 <strong>setPrototypeOf()</strong> 方法，可以向实例的私有特特[[<strong>Prototype</strong>]]写入一个新值。</p>
<p>为避免使用 <strong>Object.setPrototypeOf()</strong> 可能造成的性能下降，可以通过 <strong>Object.create()</strong> 来创建一个新对象，同时为其指定原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;  </span><br><span class="line">  <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(biped); </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);                              <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">numLegs</span>);                           <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === biped);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原型层级</li>
</ol>
<p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。</p>
<blockquote>
<p><strong>constructor</strong> 属性只存在于原型对象，因此通过实例对象也是可以访问到的。</p>
</blockquote>
<p><strong>hasOwnProperty()</strong> 方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 <strong>Object</strong> 的，会在属性存在于调用它的对象实例上时返回 <strong>true</strong>。</p>
<ol start="3">
<li>原型和 in 操作符</li>
</ol>
<p>有两种方式使用 <strong>in</strong> 操作符：单独使用和在 <strong>for-in</strong> 循环中使用。在单独使用时，<strong>in</strong> 操作符会在可以通过对象访问指定属性时返回 <strong>true</strong> ，无论该属性是在实例上还是在原型上。</p>
<p>如果要确定某个属性是否存在于原型上，则可以同时使用 <strong>hasOwnProperty()和 in</strong> 操作符。</p>
<p>在 <strong>for-in</strong> 循环中使用 <strong>in</strong> 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（[[<strong>Enumerable]</strong>]特性被设置为 <strong>false</strong>）属性的实例属性也会在 <strong>for-in</strong> 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p>
<p>获得对象上所有可枚举的实例属性，可以使用 <strong>Object.keys()</strong> 方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。</p>
<p>如果想列出所有实例属性，无论是否可以枚举，都可以使用 **Object.getOwnPropertyNames()**。</p>
<blockquote>
<p>返回的结果中包含了一个不可枚举的属性 <strong>constructor</strong>。<strong>Object.keys() 和 Object. getOwnPropertyNames()</strong> 在适当的时候都可用来代替 <strong>for-in</strong> 循环。</p>
</blockquote>
<p>在 <strong>ECMAScript 6</strong> 新增符号类型之后，相应地出现了增加一个 <strong>Object.getOwnPropertyNames()</strong> 的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，<strong>Object.getOwnProperty- Symbols()</strong> 方法就出现了，这个方法与 <strong>Object.getOwnPropertyNames()</strong> 类似，只是针对符号而已。</p>
<ol start="4">
<li>属性枚举顺序</li>
</ol>
<p><strong>for-in</strong> 循环、<strong>Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols() 以及 Object.assign()</strong> 在属性枚举顺序方面有很大区别。<strong>for-in</strong> 循环和 <strong>Object.keys()</strong> 的枚举顺序是不确定的，取决于 <strong>JavaScript</strong> 引擎，可能因浏览器而异。<br><strong>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols() 和 Object.assign()</strong> 的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p>
<h4 id="8-2-5-对象迭代"><a href="#8-2-5-对象迭代" class="headerlink" title="8.2.5 对象迭代"></a>8.2.5 对象迭代</h4><p><strong>ECMAScript 2017</strong> 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法 <strong>Object.values()和Object.entries()</strong> 接收一个对象，返回它们内容的数组。<strong>Object.values()</strong> 返回对象值的数组，<strong>Object.entries()</strong> 返回键/值对的数组。</p>
<blockquote>
<p>非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制。</p>
</blockquote>
<ol>
<li>其他原型语法</li>
</ol>
<p>为了减少代码冗余，也为了从视觉上更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原型的动态性</li>
</ol>
<p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。</p>
<p>实例的[[<strong>Prototype</strong>]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。</p>
<p>重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。</p>
<ol start="3">
<li>原生对象原型</li>
</ol>
<p>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括 <strong>Object、Array、String</strong> 等）都在原型上定义了实例方法。</p>
<p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。</p>
<ol start="4">
<li>原型的问题</li>
</ol>
<p>首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。原型的最主要问题源自它的共享特性。</p>
<h3 id="8-3-继承"><a href="#8-3-继承" class="headerlink" title="8.3 继承"></a>8.3 继承</h3><p>实现继承是 <strong>ECMAScript</strong> 唯一支持的继承方式，而这主要是通过原型链实现的。</p>
<h4 id="8-3-1-原型链"><a href="#8-3-1-原型链" class="headerlink" title="8.3.1 原型链"></a>8.3.1 原型链</h4><p><strong>ECMA-262</strong> 把原型链定义为 <strong>ECMAScript</strong> 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。</p>
<p>构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p>
<ol>
<li>默认原型</li>
</ol>
<p>默认情况下，所有引用类型都继承自 <strong>Object</strong>，这也是通过原型链实现的。任何函数的默认原型都是一个 <strong>Object</strong> 的实例，这意味着这个实例有一个内部指针指向 <strong>Object.prototype</strong>。</p>
<ol start="2">
<li>原型与继承关系</li>
</ol>
<p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用 <strong>instanceof</strong> 操作符，如果一个实例的原型链中出现过相应的构造函数，则 <strong>instanceof</strong> 返回 <strong>true</strong>。</p>
<p>第二种方式是使用 <strong>isPrototypeOf()</strong> 方法。原型链中的每个原型都可以调用这个<br>方法，只要原型链中包含这个原型，这个方法就返回 <strong>true</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance));     <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance));  <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance));    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>方法</li>
</ol>
<p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。</p>
<p>以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。</p>
<ol start="4">
<li>原型链问题</li>
</ol>
<p>主要问题出现在原型中包含引用值的时候。原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。</p>
<p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。</p>
<h4 id="8-3-2-盗用构造函数"><a href="#8-3-2-盗用构造函数" class="headerlink" title="8.3.2 盗用构造函数"></a>8.3.2 盗用构造函数</h4><p>为了解决原型包含引用值导致的继承问题，“盗用构造函数”（<strong>constructor stealing</strong>）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 <strong>apply()和call()</strong> 方法以新创建的对象为上下文执行构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 继承 SuperType </span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>传递参数</li>
</ol>
<p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p>
<ol start="2">
<li>盗用构造函数的问题</li>
</ol>
<p>主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。</p>
<h4 id="8-3-3-组合继承"><a href="#8-3-3-组合继承" class="headerlink" title="8.3.3 组合继承"></a>8.3.3 组合继承</h4><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123; </span><br><span class="line">  <span class="comment">// 继承属性 </span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法 </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>);  <span class="comment">// &quot;red,blue,green,black&quot; </span></span><br><span class="line">instance1.<span class="title function_">sayName</span>();            <span class="comment">// &quot;Nicholas&quot;; </span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>();             <span class="comment">// 29 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>);  <span class="comment">// &quot;red,blue,green&quot; </span></span><br><span class="line">instance2.<span class="title function_">sayName</span>();            <span class="comment">// &quot;Greg&quot;; </span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>();             <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<p>组合继承弥补了原型链和盗用构造函数的不足，是 <strong>JavaScript</strong> 中使用最多的继承模式。而且组合继承也保留了 <strong>instanceof</strong> 操作符和 <strong>isPrototypeOf()</strong> 方法识别合成对象的能力。</p>
<blockquote>
<p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
</blockquote>
<h4 id="8-3-4-原型式继承"><a href="#8-3-4-原型式继承" class="headerlink" title="8.3.4 原型式继承"></a>8.3.4 原型式继承</h4><p>原型式继承（“<strong>Prototypal Inheritance in JavaScript</strong>”）。一种不涉及严格意义上构造函数的继承方法。出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123; </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;  </span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上，<strong>object()</strong> 是对传入的对象执行了一次浅复制。</p>
<p>原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。<br>你需要把这个对象先传给 **object()**，然后再对返回的对象进行适当修改。</p>
<p><strong>ECMAScript 5</strong> 通过增加 <strong>Object.create()</strong> 方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，<strong>Object.create()</strong> 与这里的 <strong>object()</strong> 方法效果相同。</p>
<p><strong>Object.create()</strong> 的第二个参数与 <strong>Object.defineProperties()</strong> 的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。</p>
<p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p>
<h4 id="8-3-5-寄生式继承"><a href="#8-3-5-寄生式继承" class="headerlink" title="8.3.5 寄生式继承"></a>8.3.5 寄生式继承</h4><p>寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;  </span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">object</span>(original);  <span class="comment">// 通过调用函数创建一个新对象 </span></span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;     <span class="comment">// 以某种方式增强这个对象 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">return</span> clone;           <span class="comment">// 返回这个对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。<strong>object()</strong> 函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。</p>
<blockquote>
<p>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
</blockquote>
<h4 id="8-3-6-寄生式组合继承"><a href="#8-3-6-寄生式组合继承" class="headerlink" title="8.3.6 寄生式组合继承"></a>8.3.6 寄生式组合继承</h4><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// 创建对象 </span></span><br><span class="line">  prototype.<span class="property">constructor</span> = subType;              <span class="comment">// 增强对象  </span></span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;                <span class="comment">// 赋值对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原型链仍然保持不变，因此 <strong>instanceof</strong> 操作符和 <strong>isPrototypeOf()</strong> 方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p>
<h3 id="8-4-类"><a href="#8-4-类" class="headerlink" title="8.4 类"></a>8.4 类</h3><p><strong>ECMAScript 6</strong> 新引入的 <strong>class</strong> 关键字具有正式定义类的能力。类（<strong>class</strong>）是<strong>ECMAScript</strong> 中新的基础性语法糖结构。</p>
<h4 id="8-4-1-类定义"><a href="#8-4-1-类定义" class="headerlink" title="8.4.1 类定义"></a>8.4.1 类定义</h4><p>定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 <strong>class</strong> 关键字加大括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; </span><br><span class="line"><span class="comment">// 类表达式 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = <span class="keyword">class</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>类表达式在它们被求值前也不能引用。不过，与函数定义不同的是，虽然函数<br>声明可以提升，但类定义不能。</p>
<p>另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制。</p>
<ol>
<li>类的构成</li>
</ol>
<p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。</p>
<p>类名的首字母要大写，以区别于通过它创建的实例。</p>
<p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 <strong>name</strong> 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p>
<h4 id="8-4-2-类构造函数"><a href="#8-4-2-类构造函数" class="headerlink" title="8.4.2 类构造函数"></a>8.4.2 类构造函数</h4><p><strong>constructor</strong> 关键字用于在类定义块内部创建类的构造函数。方法名 <strong>constructor</strong> 会告诉解释器在使用 <strong>new</strong> 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p>
<ol>
<li>实例化</li>
</ol>
<p>使用 <strong>new</strong> 操作符实例化 <strong>Person</strong> 的操作等于使用 <strong>new</strong> 调用其构造函数。唯一可感知的不同之处就是，<strong>JavaScript</strong> 解释器知道使用 <strong>new</strong> 和类意味着应该使用<strong>constructor</strong> 函数进行实例化。<br>使用 <strong>new</strong> 调用类的构造函数会执行如下操作。<br>(1) 在内存中创建一个新对象。<br>(2) 这个新对象内部的[[<strong>Prototype</strong>]]指针被赋值为构造函数的 <strong>prototype</strong> 属性。<br>(3) 构造函数内部的 <strong>this</strong> 被赋值为这个新对象（即 <strong>this</strong> 指向新对象）。<br>(4) 执行构造函数内部的代码（给新对象添加属性）。<br>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p>
<p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的。</p>
<p>默认情况下，类构造函数会在执行之后返回 <strong>this</strong> 对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 <strong>this</strong> 对象，那么这个对象会被销毁。不过，如果返回的不是 <strong>this</strong> 对象，而是其他对象，那么这个对象不会通过 <strong>instanceof</strong> 操作符检测出跟类有关联。</p>
<p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 <strong>new</strong> 操作符。而普通构造函数如果不使用 <strong>new</strong> 调用，那么就会以全局的 <strong>this</strong>（通常是 <strong>window</strong>）作为内部对象。调用类构造函数时如果忘了使用 <strong>new</strong> 则会抛出错误。</p>
<ol start="2">
<li>类是特殊函数</li>
</ol>
<p><strong>ECMAScript</strong> 类就是一种特殊函数。声明一个类之后，通过 <strong>typeof</strong> 操作符检测类标识符，表明它是一个函数。</p>
<p>类标识符有 <strong>prototype</strong> 属性，而这个原型也有一个 <strong>constructor</strong> 属性指向类自身。</p>
<p>与普通构造函数一样，可以使用 <strong>instanceof</strong> 操作符检查构造函数原型是否存在于实例的原型链中。</p>
<p>在类的上下文中，类本身在使用 <strong>new</strong> 调用时就会被当成构造函数。重点在于，类中定义的 <strong>constructor</strong> 方法不会被当成构造函数，在对它使用 <strong>instanceof</strong> 操作符时会返回 <strong>false</strong>。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么 <strong>instanceof</strong> 操作符的返回值会反转。</p>
<p>类是 <strong>JavaScript</strong> 的一等公民，因此可以像其他对象或函数引用一样把类作为参数传递。</p>
<p>与立即调用函数表达式相似，类也可以立即实例化。</p>
<h4 id="8-4-3-实例、原型和类成员"><a href="#8-4-3-实例、原型和类成员" class="headerlink" title="8.4.3 实例、原型和类成员"></a>8.4.3 实例、原型和类成员</h4><ol>
<li>实例成员</li>
</ol>
<p>每次通过 <strong>new</strong> 调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（<strong>this</strong>）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。 </p>
<p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享。</p>
<ol start="2">
<li>原型方法与访问器</li>
</ol>
<p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>); </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 在类块中定义的所有内容都会定义在类的原型上 </span></span><br><span class="line">  <span class="title function_">locate</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prototype&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">p.<span class="title function_">locate</span>();                 <span class="comment">// instance </span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>();  <span class="comment">// prototype</span></span><br></pre></td></tr></table></figure>

<p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据。</p>
<p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键。</p>
<p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样。</p>
<ol start="3">
<li>静态类方法</li>
</ol>
<p>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。</p>
<p>静态成员每个类上只能有一个。<br>静态类成员在类定义中使用 <strong>static</strong> 关键字作为前缀。在静态成员中，<strong>this</strong> 引用类自身。其他所有约定跟原型成员一样。</p>
<p>静态类方法非常适合作为实例工厂。</p>
<ol start="4">
<li>非函数原型和类成员</li>
</ol>
<p>类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加。</p>
<blockquote>
<p>类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 <strong>this</strong> 引用的数据。</p>
</blockquote>
<ol start="5">
<li>迭代器与生成器方法</li>
</ol>
<p>类定义语法支持在原型和类本身上定义生成器方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">  <span class="comment">// 在原型上定义生成器方法 </span></span><br><span class="line">  *<span class="title function_">createNicknameIterator</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;J-Dog&#x27;</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类上定义生成器方法 </span></span><br><span class="line">  <span class="keyword">static</span> *<span class="title function_">createJobIterator</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Butcher&#x27;</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Baker&#x27;</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Candlestick maker&#x27;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jobIter = <span class="title class_">Person</span>.<span class="title function_">createJobIterator</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// Butcher </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// Baker </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// Candlestick maker </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.<span class="title function_">createNicknameIterator</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// Jack </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// Jake </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>

<p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象。</p>
<h4 id="8-4-4-继承"><a href="#8-4-4-继承" class="headerlink" title="8.4.4 继承"></a>8.4.4 继承</h4><ol>
<li>基础</li>
</ol>
<p><strong>ES6</strong> 类支持单继承。使用 <strong>extends</strong> 关键字，就可以继承任何拥有[[<strong>Construct</strong>]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bus</span>);      <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>);  <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承普通构造函数 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> <span class="title class_">Engineer</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">Engineer</span>);  <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">Person</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>派生类都会通过原型链访问到类和原型上定义的方法。<strong>this</strong> 的值会反映调用相应方法的实例或者类。</p>
<blockquote>
<p><strong>extends</strong> 关键字也可以在类表达式中使用，因此 <strong>let Bar = class extends Foo {}</strong> 是有效的语法。</p>
</blockquote>
<ol start="2">
<li>构造函数、HomeObject 和 super()</li>
</ol>
<p>派生类的方法可以通过 <strong>super</strong> 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 <strong>super</strong> 可以调用父类构造函数。</p>
<blockquote>
<p>不要在调用 <strong>super()</strong> 之前引用 <strong>this</strong>，否则会抛出 <strong>ReferenceError</strong> 。</p>
<p><strong>ES6</strong> 给类构造函数和静态方法添加了内部特性[[<strong>HomeObject</strong>]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 <strong>JavaScript</strong> 引擎内部访问。<strong>super</strong> 始终会定义为[[<strong>HomeObject</strong>]]的原型。</p>
</blockquote>
<p>使用 <strong>super</strong> 时要注意：</p>
<ul>
<li><p><strong>super</strong> 只能在派生类构造函数和静态方法中使用。</p>
</li>
<li><p>不能单独引用 <strong>super</strong> 关键字，要么用它调用构造函数，要么用它引用静态方法。</p>
</li>
<li><p>调用 <strong>super()</strong> 会调用父类构造函数，并将返回的实例赋值给 <strong>this</strong>。</p>
</li>
<li><p><strong>super()</strong> 的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</p>
</li>
<li><p>如果没有定义类构造函数，在实例化派生类时会调用 **super()**，而且会传入所有传给派生类的参数。</p>
</li>
<li><p>在类构造函数中，不能在调用 <strong>super()</strong> 之前引用 <strong>this</strong>。</p>
</li>
<li><p>如果在派生类中显式定义了构造函数，则要么必须在其中调用 **super()**，要么必须在其中返回一个对象。</p>
</li>
</ul>
<ol start="3">
<li>抽象基类</li>
</ol>
<p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 <strong>ECMAScript</strong> 没有专门支持这种类的语法 ，但通过 <strong>new.target</strong> 也很容易实现。<strong>new.target</strong> 保存通过 <strong>new</strong> 关键字调用的类或函数。通过在实例化时检测 <strong>new.target</strong> 是不是抽象基类，可以阻止对抽象基类的实例化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>); </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();       <span class="comment">// class Bus &#123;&#125; </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vehicle</span>();   <span class="comment">// class Vehicle &#123;&#125; </span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure>

<p>通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 <strong>this</strong> 关键字来检查相应的方法。</p>
<ol start="4">
<li>继承内置类型</li>
</ol>
<p><strong>ES6</strong> 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;  </span><br><span class="line">  <span class="title function_">shuffle</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 洗牌算法 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line">      <span class="keyword">const</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>)); </span><br><span class="line">      [<span class="variable language_">this</span>[i], <span class="variable language_">this</span>[j]] = [<span class="variable language_">this</span>[j], <span class="variable language_">this</span>[i]]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>);       <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// [1, 2, 3, 4, 5] </span></span><br><span class="line">a.<span class="title function_">shuffle</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// [3, 1, 4, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的。</p>
<p>如果想覆盖这个默认行为，则可以覆盖 <strong>Symbol.species</strong> 访问器，这个访问器决定在创建返回的实例时使用的类。</p>
<ol start="5">
<li>类混入</li>
</ol>
<p>把不同类的行为集中到一个类是一种常见的 JavaScript 模式。</p>
<blockquote>
<p><strong>Object.assign()</strong> 方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用 <strong>Object.assign()</strong> 就可以了。</p>
</blockquote>
<p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。</p>
<p>一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123; </span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123; </span><br><span class="line">  <span class="title function_">bar</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123; </span><br><span class="line">  <span class="title function_">baz</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FooMixin</span>(<span class="title class_">BarMixin</span>(<span class="title class_">BazMixin</span>(<span class="title class_">Vehicle</span>))) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>(); </span><br><span class="line">b.<span class="title function_">foo</span>();  <span class="comment">// foo </span></span><br><span class="line">b.<span class="title function_">bar</span>();  <span class="comment">// bar </span></span><br><span class="line">b.<span class="title function_">baz</span>();  <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<h4 id="8-5-小结"><a href="#8-5-小结" class="headerlink" title="8.5 小结"></a>8.5 小结</h4><p>对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。</p>
<ul>
<li><p>工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。 </p>
</li>
<li><p>使用构造函数模式可以自定义引用类型，可以使用new关键字像创建内置类型实例一样创建自定义类型的实例。不过，构造函数模式也有不足，主要是其成员无法重用，包括函数。考虑到函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享。 </p>
</li>
<li><p>原型模式解决了成员共享的问题，只要是添加到构造函数 <strong>prototype</strong> 上的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。</p>
</li>
</ul>
<p><strong>JavaScript</strong> 的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。</p>
<p>除上述模式之外，还有以下几种继承模式。</p>
<ul>
<li><p>原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。 </p>
</li>
<li><p>与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。 </p>
</li>
<li><p>寄生组合继承被认为是实现基于类型继承的最有效方式。</p>
</li>
</ul>
<p><strong>ECMAScript 6</strong> 新增的类很大程度上是基于既有原型机制的语法糖。类的语法让开发者可以优雅地定义向后兼容的类，既可以继承内置类型，也可以继承自定义类型。类有效地跨越了对象实例、对象原型和对象类之间的鸿沟。</p>
<h2 id="九、代理与反射"><a href="#九、代理与反射" class="headerlink" title="九、代理与反射"></a>九、代理与反射</h2><p><strong>ECMAScript 6</strong> 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</p>
<h3 id="9-1-代理基础"><a href="#9-1-代理基础" class="headerlink" title="9.1 代理基础"></a>9.1 代理基础</h3><p>代理是目标对象的抽象。</p>
<h4 id="9-1-1-创建空代理"><a href="#9-1-1-创建空代理" class="headerlink" title="9.1.1 创建空代理"></a>9.1.1 创建空代理</h4><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。<br>代理是使用 <strong>Proxy</strong> 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 <strong>TypeError</strong>。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;  </span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// Proxy.prototype 是 undefined </span></span><br><span class="line"><span class="comment">// 因此不能使用 instanceof 操作符</span></span><br></pre></td></tr></table></figure>

<h4 id="9-1-2-定义捕获器"><a href="#9-1-2-定义捕获器" class="headerlink" title="9.1.2 定义捕获器"></a>9.1.2 定义捕获器</h4><p>使用代理的主要目的是可以定义捕获器（<strong>trap</strong>）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;  </span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> handler = &#123; </span><br><span class="line">  <span class="comment">// 捕获器在处理程序对象中以方法名为键 </span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p><strong>proxy[property]、proxy.property 或 Object.create(proxy)[property]</strong> 等操作都会触发基本的 <strong>get()</strong> 操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 <strong>get()</strong> 捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p>
<h4 id="9-1-3-捕获器参数和反射-API"><a href="#9-1-3-捕获器参数和反射-API" class="headerlink" title="9.1.3 捕获器参数和反射 API"></a>9.1.3 捕获器参数和反射 API</h4><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，<strong>get()</strong> 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<p>所有捕获器都可以基于自己的参数重建原始操作，实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 <strong>Reflect</strong> 对象上（封装了原始行为）的同名方法来轻松重建。<br>处理程序对象中所有可以捕获的方法都有对应的反射（<strong>Reflect</strong>）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。</p>
<p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; </span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, <span class="title class_">Reflect</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>);   <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>);  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>反射 <strong>API</strong> 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。</p>
<h4 id="9-1-4-捕获器不定式"><a href="#9-1-4-捕获器不定式" class="headerlink" title="9.1.4 捕获器不定式"></a>9.1.4 捕获器不定式</h4><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 <strong>ECMAScript</strong> 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。 </p>
<blockquote>
<p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 <strong>TypeError</strong>。</p>
</blockquote>
<h4 id="9-1-5-可撤销代理"><a href="#9-1-5-可撤销代理" class="headerlink" title="9.1.5 可撤销代理"></a>9.1.5 可撤销代理</h4><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 <strong>new Proxy()</strong> 创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。<br><strong>Proxy</strong> 也暴露了 <strong>revocable()</strong> 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（**revoke()**）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 <strong>TypeError</strong>。 撤销函数和代理对象是在实例化时同时生成的。</p>
<h4 id="9-1-6-使用反射API"><a href="#9-1-6-使用反射API" class="headerlink" title="9.1.6 使用反射API"></a>9.1.6 使用反射API</h4><p>某些情况下应该优先使用反射 <strong>API</strong>。</p>
<ol>
<li>反射 <strong>API</strong> 与对象 <strong>API</strong></li>
</ol>
<p>(1) 反射 <strong>API</strong> 并不限于捕获处理程序；<br>(2) 大多数反射 <strong>API</strong> 方法在 <strong>Object</strong> 类型上有对应的方法。<br>通常，<strong>Object</strong> 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p>
<ol start="2">
<li>状态标记</li>
</ol>
<p>很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 <strong>API</strong> 方法更有用。</p>
<p>以下反射方法都会提供状态标记： </p>
<ul>
<li><p><strong>Reflect.defineProperty()</strong></p>
</li>
<li><p><strong>Reflect.preventExtensions()</strong></p>
</li>
<li><p><strong>Reflect.setPrototypeOf()</strong></p>
</li>
<li><p><strong>Reflect.set()</strong></p>
</li>
<li><p><strong>Reflect.deleteProperty()</strong></p>
</li>
</ul>
<ol start="3">
<li>用一等函数替代操作符</li>
</ol>
<p>以下反射方法提供只有通过操作符才能完成的操作。 </p>
<ul>
<li><p>**Reflect.get()**：可以替代对象属性访问操作符。 </p>
</li>
<li><p>**Reflect.set()**：可以替代 <strong>=</strong> 赋值操作符。 </p>
</li>
<li><p>**Reflect.has()**：可以替代 <strong>in</strong> 操作符或 **with()**。 </p>
</li>
<li><p>**Reflect.deleteProperty()**：可以替代 <strong>delete</strong> 操作符。 </p>
</li>
<li><p>**Reflect.construct()**：可以替代 <strong>new</strong> 操作符。</p>
</li>
</ul>
<ol start="4">
<li>安全地应用函数</li>
</ol>
<p>在通过 <strong>apply</strong> 方法调用函数时，被调用的函数可能也定义了自己的apply属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 <strong>Function</strong> 原型上的 <strong>apply</strong> 方法。</p>
<h4 id="9-1-7-代理另一个代理"><a href="#9-1-7-代理另一个代理" class="headerlink" title="9.1.7 代理另一个代理"></a>9.1.7 代理另一个代理</h4><p>代理可以拦截反射 <strong>API</strong> 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。</p>
<h4 id="9-1-8-代理的问题与不足"><a href="#9-1-8-代理的问题与不足" class="headerlink" title="9.1.8 代理的问题与不足"></a>9.1.8 代理的问题与不足</h4><p>很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 <strong>ECMAScript</strong> 机制很好地协同。</p>
<ol>
<li>代理中的 <strong>this</strong></li>
</ol>
<p>代理潜在的一个问题来源是<strong>this</strong>值。方法中的 <strong>this</strong> 通常指向调用这个方法的对象。</p>
<ol start="2">
<li>代理与内部槽位</li>
</ol>
<p>代理与内置引用类型（比如 <strong>Array</strong>）的实例通常可以很好地协同，但有些 <strong>ECMAScript <strong>内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。<br>一个典型的例子就是 <strong>Date</strong> 类型。根据 <strong>ECMAScript</strong> 规范，</strong>Date</strong> 类型方法的执行依赖 <strong>this</strong> 值上的内部槽位[[<strong>NumberDate</strong>]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 <strong>get()</strong> 和 <strong>set()</strong> 操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 <strong>TypeError</strong>。</p>
<h3 id="9-2-代理捕获器与反射方法"><a href="#9-2-代理捕获器与反射方法" class="headerlink" title="9.2 代理捕获器与反射方法"></a>9.2 代理捕获器与反射方法</h3><p>代理可以捕获 <strong>13</strong> 种不同的基本操作。这些操作有各自不同的反射 <strong>API</strong> 方法、参数、关联 <strong>ECMAScript</strong> 操作和不变式。</p>
<p>只要在代理上调用，所有捕获器都会拦截它们对应的反射 <strong>API</strong> 操作。</p>
<h4 id="9-2-1-get"><a href="#9-2-1-get" class="headerlink" title="9.2.1 get()"></a>9.2.1 get()</h4><p><strong>get()</strong> 捕获器会在获取属性值的操作中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.get()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span>; </span><br><span class="line"><span class="comment">// get()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br>返回值无限制。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>proxy.property</strong></p>
</li>
<li><p><strong>proxy[property]</strong></p>
</li>
<li><p><strong>Object.create(proxy)[property]</strong></p>
</li>
<li><p><strong>Reflect.get(proxy, property, receiver)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>property</strong>：引用的目标对象上的字符串键属性。 </p>
</li>
<li><p><strong>receiver</strong>：代理对象或继承代理对象的对象。 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br>如果 <strong>target.property</strong> 不可写且不可配置，则处理程序返回的值必须与 <strong>target.property</strong> 匹配。<br>如果 <strong>target.property</strong> 不可配置且[[<strong>Get</strong>]]特性为 <strong>undefined</strong>，处理程序的返回值也必须是 <strong>undefined</strong>。</p>
</li>
</ol>
<h4 id="9-2-2-set"><a href="#9-2-2-set" class="headerlink" title="9.2.2 set()"></a>9.2.2 set()</h4><p><strong>set()</strong> 捕获器会在设置属性值的操作中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.set()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="comment">// set()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br>返回 <strong>true</strong> 表示成功；返回 <strong>false</strong> 表示失败，严格模式下会抛出 <strong>TypeError</strong>。</p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>proxy.property = value</strong></p>
</li>
<li><p><strong>proxy[property] = value</strong></p>
</li>
<li><p><strong>Object.create(proxy)[property] = value</strong></p>
</li>
<li><p><strong>Reflect.set(proxy, property, value, receiver)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>property</strong>：引用的目标对象上的字符串键属性。 </p>
</li>
<li><p><strong>value</strong>：要赋给属性的值。 </p>
</li>
<li><p><strong>receiver</strong>：接收最初赋值的对象。 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br>如果 <strong>target.property</strong> 不可写且不可配置，则不能修改目标属性的值。<br>如果 <strong>target.property</strong> 不可配置且[[<strong>Set</strong>]]特性为 <strong>undefined</strong>，则不能修改目标属性的值。 在严格模式下，处理程序中返回false会抛出 <strong>TypeError</strong>。</p>
</li>
</ol>
<h4 id="9-2-3-has"><a href="#9-2-3-has" class="headerlink" title="9.2.3 has()"></a>9.2.3 has()</h4><p><strong>has()</strong> 捕获器会在 <strong>in</strong> 操作符中被调用。对应的反射 <strong>API</strong> 方法 **Reflect.has()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;has()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy; </span><br><span class="line"><span class="comment">// has()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>has()</strong> 必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>property in proxy</strong></p>
</li>
<li><p><strong>property in Object.create(proxy)</strong></p>
</li>
<li><p><strong>with(proxy) {(property);}</strong></p>
</li>
<li><p><strong>Reflect.has(proxy, property)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>property</strong>：引用的目标对象上的字符串键属性。 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br>如果 <strong>target.property</strong> 存在且不可配置，则处理程序必须返回 <strong>true</strong>。<br>如果 <strong>target.property</strong> 存在且目标对象不可扩展，则处理程序必须返回 <strong>true</strong>。</p>
</li>
</ol>
<h4 id="9-2-4-defineProperty"><a href="#9-2-4-defineProperty" class="headerlink" title="9.2.4 defineProperty()"></a>9.2.4 defineProperty()</h4><p><strong>defineProperty()</strong> 捕获器会在 <strong>Object.defineProperty()</strong> 中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.defineProperty()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, property, descriptor</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proxy, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// defineProperty()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>defineProperty()</strong> 必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>Object.defineProperty(proxy, property, descriptor)</strong></p>
</li>
<li><p><strong>Reflect.defineProperty(proxy, property, descriptor)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>property</strong>：引用的目标对象上的字符串键属性。 </p>
</li>
<li><p><strong>descriptor</strong>：包含可选的 <strong>enumerable、configurable、 writable、value、get 和 set</strong> 定义的对象。 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br>如果目标对象不可扩展，则无法定义属性。<br>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。<br>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</p>
</li>
</ol>
<h4 id="9-2-5-getOwnPropertyDescriptor"><a href="#9-2-5-getOwnPropertyDescriptor" class="headerlink" title="9.2.5 getOwnPropertyDescriptor()"></a>9.2.5 getOwnPropertyDescriptor()</h4><p><strong>getOwnPropertyDescriptor()</strong> 捕获器会在 <strong>Object.getOwnPropertyDescriptor()</strong> 中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.getOwnPropertyDescriptor()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getOwnPropertyDescriptor()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>getOwnPropertyDescriptor()</strong> 必须返回对象，或者在属性不存在时返回 <strong>undefined</strong>。</p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>Object.getOwnPropertyDescriptor(proxy, property)</strong></p>
</li>
<li><p><strong>Reflect.getOwnPropertyDescriptor(proxy, property)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>property</strong>：引用的目标对象上的字符串键属性。 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br>如果自有的 <strong>target.property</strong> 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。<br>如果自有的 <strong>target.property</strong> 存在且可配置，则处理程序必须返回表示该属性可配置的对象。<br>如果自有的 <strong>target.property</strong> 存在且 <strong>target</strong> 不可扩展，则处理程序必须返回一个表示该属性存在的对象。<br>如果 <strong>target.property</strong> 不存在且 <strong>target</strong> 不可扩展，则处理程序必须返回 <strong>undefined</strong> 表示该属性不存在。<br>如果 <strong>target.property</strong> 不存在，则处理程序不能返回表示该属性可配置的对象。</p>
</li>
</ol>
<h4 id="9-2-6-deleteProperty"><a href="#9-2-6-deleteProperty" class="headerlink" title="9.2.6 deleteProperty()"></a>9.2.6 deleteProperty()</h4><p><strong>deleteProperty()</strong> 捕获器会在 <strong>delete</strong> 操作符中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect. deleteProperty()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;deleteProperty()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">foo</span> </span><br><span class="line"><span class="comment">// deleteProperty()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>deleteProperty()</strong> 必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>delete proxy.property</strong></p>
</li>
<li><p><strong>delete proxy[property]</strong></p>
</li>
<li><p><strong>Reflect.deleteProperty(proxy, property)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>property</strong>：引用的目标对象上的字符串键属性。 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br>如果自有的 <strong>target.property</strong> 存在且不可配置，则处理程序不能删除这个属性。</p>
</li>
</ol>
<h4 id="9-2-7-ownKeys"><a href="#9-2-7-ownKeys" class="headerlink" title="9.2.7 ownKeys()"></a>9.2.7 ownKeys()</h4><p><strong>ownKeys()</strong> 捕获器会在 <strong>Object.keys()</strong> 及类似方法中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.ownKeys()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ownKeys()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy); </span><br><span class="line"><span class="comment">// ownKeys()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>ownKeys()</strong> 必须返回包含字符串或符号的可枚举对象。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>Object.getOwnPropertyNames(proxy)</strong></p>
</li>
<li><p><strong>Object.getOwnPropertySymbols(proxy)</strong></p>
</li>
<li><p><strong>Object.keys(proxy)</strong></p>
</li>
<li><p><strong>Reflect.ownKeys(proxy)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><strong>target</strong>：目标对象。 </li>
</ul>
</li>
<li><p>捕获器不变式<br>返回的可枚举对象必须包含 <strong>target</strong> 的所有不可配置的自有属性。<br>如果 <strong>target</strong> 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</p>
</li>
</ol>
<h4 id="9-2-8-getPrototypeOf"><a href="#9-2-8-getPrototypeOf" class="headerlink" title="9.2.8 getPrototypeOf()"></a>9.2.8 getPrototypeOf()</h4><p><strong>getPrototypeOf()</strong> 捕获器会在 <strong>Object.getPrototypeOf()</strong> 中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.getPrototypeOf()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getPrototypeOf()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy); </span><br><span class="line"><span class="comment">// getPrototypeOf()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>getPrototypeOf()</strong> 必须返回对象或 <strong>null</strong>。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>Object.getPrototypeOf(proxy)</strong></p>
</li>
<li><p><strong>Reflect.getPrototypeOf(proxy)</strong></p>
</li>
<li><p><strong>proxy.__proto __</strong></p>
</li>
<li><p><strong>Object.prototype.isPrototypeOf(proxy)</strong></p>
</li>
<li><p><strong>proxy instanceof Object</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><strong>target</strong>：目标对象。 </li>
</ul>
</li>
<li><p>捕获器不变式<br>如果<strong>target</strong>不可扩展，则<strong>Object.getPrototypeOf(proxy)</strong> 唯一有效的返回值就是 <strong>Object.getPrototypeOf(target)</strong> 的返回值。</p>
</li>
</ol>
<h4 id="9-2-9-setPrototypeOf"><a href="#9-2-9-setPrototypeOf" class="headerlink" title="9.2.9 setPrototypeOf()"></a>9.2.9 setPrototypeOf()</h4><p><strong>setPrototypeOf()</strong> 捕获器会在 <strong>Object.setPrototypeOf()</strong> 中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.setPrototypeOf()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">setPrototypeOf</span>(<span class="params">target, prototype</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setPrototypeOf()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, <span class="title class_">Object</span>); </span><br><span class="line"><span class="comment">// setPrototypeOf()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>setPrototypeOf()</strong> 必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>Object.setPrototypeOf(proxy)</strong></p>
</li>
<li><p><strong>Reflect.setPrototypeOf(proxy)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>prototype</strong>：<strong>target</strong> 的替代原型，如果是顶级原型则为 <strong>null</strong>。 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br>如果 <strong>target</strong> 不可扩展，则唯一有效的 <strong>prototype</strong> 参数就是 <strong>Object.getPrototypeOf(target)</strong> 的返回值。</p>
</li>
</ol>
<h4 id="9-2-10-isExtensible"><a href="#9-2-10-isExtensible" class="headerlink" title="9.2.10 isExtensible()"></a>9.2.10 isExtensible()</h4><p><strong>isExtensible()</strong> 捕获器会在 <strong>Object.isExtensible()</strong> 中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.isExtensible()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">isExtensible</span>(<span class="params">target</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isExtensible()&#x27;</span>); </span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy); </span><br><span class="line"><span class="comment">// isExtensible()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>isExtensible()</strong> 必须返回布尔值，表示 <strong>target</strong> 是否可扩展。返回非布尔值会被转型为布尔值。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>Object.isExtensible(proxy)</strong></p>
</li>
<li><p><strong>Reflect.isExtensible(proxy)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><strong>target</strong>：目标对象。 </li>
</ul>
</li>
<li><p>捕获器不变式<br>如果 <strong>target</strong> 可扩展，则处理程序必须返回 <strong>true</strong>。<br>如果 <strong>target</strong> 不可扩展，则处理程序必须返回 <strong>false</strong>。</p>
</li>
</ol>
<h4 id="9-2-11-preventExtensions"><a href="#9-2-11-preventExtensions" class="headerlink" title="9.2.11 preventExtensions()"></a>9.2.11 preventExtensions()</h4><p><strong>preventExtensions()</strong> 捕获器会在 <strong>Object.preventExtensions()</strong> 中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.preventExtensions()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;preventExtensions()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy); </span><br><span class="line"><span class="comment">// preventExtensions()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>preventExtensions()</strong> 必须返回布尔值，表示 <strong>target</strong> 是否已经不可扩展。返回非布尔值会被转型为布尔值。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>Object.preventExtensions(proxy)</strong></p>
</li>
<li><p><strong>Reflect.preventExtensions(proxy)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><strong>target</strong>：目标对象。 </li>
</ul>
</li>
<li><p>捕获器不变式<br>如果 <strong>Object.isExtensible(proxy)</strong> 是 <strong>false</strong>，则处理程序必须返回 <strong>true</strong>。</p>
</li>
</ol>
<h4 id="9-2-12-apply"><a href="#9-2-12-apply" class="headerlink" title="9.2.12 apply()"></a>9.2.12 apply()</h4><p><strong>apply()</strong> 捕获器会在调用函数时中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.apply()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;  </span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;apply()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title function_">proxy</span>(); </span><br><span class="line"><span class="comment">// apply()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br>返回值无限制。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>proxy(…argumentsList)</strong></p>
</li>
<li><p><strong>Function.prototype.apply(thisArg, argumentsList)</strong></p>
</li>
<li><p><strong>Function.prototype.call(thisArg, …argumentsList)</strong></p>
</li>
<li><p><strong>Reflect.apply(target, thisArgument, argumentsList)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标对象。 </p>
</li>
<li><p><strong>thisArg</strong>：调用函数时的this参数。 </p>
</li>
<li><p><strong>argumentsList</strong>：调用函数时的参数列表 </p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br><strong>target</strong> 必须是一个函数对象。</p>
</li>
</ol>
<h4 id="9-2-13-construct"><a href="#9-2-13-construct" class="headerlink" title="9.2.13 construct()"></a>9.2.13 construct()</h4><p><strong>construct()</strong> 捕获器会在 <strong>new</strong> 操作符中被调用。对应的反射 <strong>API</strong> 方法为 **Reflect.construct()**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line">  <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123; </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;construct()&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> proxy; </span><br><span class="line"><span class="comment">// construct()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>返回值<br><strong>construct()</strong> 必须返回一个对象。 </p>
</li>
<li><p>拦截的操作 </p>
<ul>
<li><p><strong>new proxy(…argumentsList)</strong></p>
</li>
<li><p><strong>Reflect.construct(target, argumentsList, newTarget)</strong></p>
</li>
</ul>
</li>
<li><p>捕获器处理程序参数 </p>
<ul>
<li><p><strong>target</strong>：目标构造函数。</p>
</li>
<li><p><strong>argumentsList</strong>：传给目标构造函数的参数列表。 </p>
</li>
<li><p><strong>newTarget</strong>：最初被调用的构造函数。</p>
</li>
</ul>
</li>
<li><p>捕获器不变式<br><strong>target</strong> 必须可以用作构造函数。</p>
</li>
</ol>
<h3 id="9-3-代理模式"><a href="#9-3-代理模式" class="headerlink" title="9.3 代理模式"></a>9.3 代理模式</h3><p>使用代理可以在代码中实现一些有用的编程模式。</p>
<h4 id="9-3-1-跟踪属性访问"><a href="#9-3-1-跟踪属性访问" class="headerlink" title="9.3.1 跟踪属性访问"></a>9.3.1 跟踪属性访问</h4><p>通过捕获 <strong>get、set 和 has</strong> 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。</p>
<h4 id="9-3-2-隐藏属性"><a href="#9-3-2-隐藏属性" class="headerlink" title="9.3.2 隐藏属性"></a>9.3.2 隐藏属性</h4><p>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。</p>
<h4 id="9-3-3-属性验证"><a href="#9-3-3-属性验证" class="headerlink" title="9.3.3 属性验证"></a>9.3.3 属性验证</h4><p>因为所有赋值操作都会触发 <strong>set()</strong> 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。</p>
<h4 id="9-3-4-函数与构造参数验证"><a href="#9-3-4-函数与构造参数验证" class="headerlink" title="9.3.4 函数与构造参数验证"></a>9.3.4 函数与构造参数验证</h4><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值。</p>
<h4 id="9-3-5-数据绑定与可观察对象"><a href="#9-3-5-数据绑定与可观察对象" class="headerlink" title="9.3.5 数据绑定与可观察对象"></a>9.3.5 数据绑定与可观察对象</h4><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。<br>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中。还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息。</p>
<h3 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h3><p>代理是 <strong>ECMAScript 6</strong> 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的 <strong>JavaScript</strong> 元编程及抽象的新天地。<br>从宏观上看，代理是真实 <strong>JavaScript</strong> 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分<strong>JavaScript</strong> 的基本操作和方法。在这个捕获器处理程序中，可以修改任<br>何基本操作的行为，当然前提是遵从捕获器不变式。<br>与代理如影随形的反射 <strong>API</strong>，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 <strong>API</strong> 看作一套基本操作，这些操作是绝大部分 <strong>JavaScript</strong> 对象 <strong>API</strong> 的基础。<br>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p>
<h2 id="十、函数"><a href="#十、函数" class="headerlink" title="十、函数"></a>十、函数</h2><p>函数实际上是对象。每个函数都是 <strong>Function</strong> 类型的实例，而 <strong>Function</strong> 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。</p>
<ol>
<li>函数通常以函数声明的方式定义。</li>
</ol>
<blockquote>
<p>注意函数定义最后没有加分号。</p>
</blockquote>
<ol start="2">
<li>函数表达式。函数表达式与函数声明几乎是等价的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 <strong>function</strong> 关键字后面没有名称，<br>注意这里的函数末尾是有分号的，与任何变量初始化语句一样。</p>
</blockquote>
<ol start="3">
<li>定义函数:“箭头函数”（arrow function）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用Function构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。</li>
</ol>
<h3 id="10-1-箭头函数"><a href="#10-1-箭头函数" class="headerlink" title="10.1 箭头函数"></a>10.1 箭头函数</h3><p><strong>ECMAScript 6</strong> 新增了使用胖箭头（**=&gt;**）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数。</p>
<p>箭头函数简洁的语法非常适合嵌入函数的场景。</p>
<p>如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号。</p>
<p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码。</p>
<p>箭头函数不能使用 <strong>arguments、super和new.target</strong> ，也不能用作构造函数。此外，箭头函数也没有 <strong>prototype</strong> 属性。</p>
<h3 id="10-2-函数名"><a href="#10-2-函数名" class="headerlink" title="10.2 函数名"></a>10.2 函数名</h3><p>函数名就是指向函数的指针，这意味着一个函数可以有多个名称。</p>
<blockquote>
<p>使用不带括号的函数名会访问函数指针，而不会执行函数。</p>
</blockquote>
<p><strong>ECMAScript 6</strong> 的所有函数对象都会暴露一个只读的 <strong>name</strong> 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 <strong>Function</strong> 构造函数创建的，则会标识成”<strong>anonymous</strong>“。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; &#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>);               <span class="comment">// foo </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>);               <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">name</span>);               <span class="comment">// baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>);        <span class="comment">//（空字符串） </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span>);  <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure>

<p>如果函数是一个获取函数、设置函数，或者使用 <strong>bind()</strong> 实例化，那么标识符前面会加上一个前缀。</p>
<h3 id="10-3-理解参数"><a href="#10-3-理解参数" class="headerlink" title="10.3 理解参数"></a>10.3 理解参数</h3><p><strong>ECMAScript</strong> 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错 —— 因为 <strong>ECMAScript</strong> 函数的参数在内部表现为一个数组。</p>
<p>事实上，在使用 <strong>function</strong> 关键字定义（非箭头）函数时，可以在函数内部访问 <strong>arguments</strong> 对象，从中取得传进来的每个参数值。<br><strong>arguments</strong> 对象是一个类数组对象（但不是 <strong>Array</strong> 的实例），因此可以使用中括号语法访问其中的元素（第一个参数是 **arguments[0]**，第二个参数是 **arguments[1]**）。而要确定传进来多少个参数，可以访问 <strong>arguments.length</strong> 属性。</p>
<p><strong>ECMAScript</strong> 函数的参数只是为了方便才写出来的，并不是必须写出来的。</p>
<p><strong>arguments</strong> 对象可以跟命名参数一起使用。</p>
<p>arguments对象的值始终会与对应的命名参数同步。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。如果只传了一个参数，然后把 <strong>arguments[1]</strong> 设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为 <strong>arguments</strong> 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。</p>
<p>对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 <strong>undefined</strong>。</p>
<blockquote>
<p>严格模式下，arguments会有一些变化。首先，像前面那样arguments[1]赋值不会再影响num2的值。就算把arguments[1]设置为 10，num2的值仍然还是传入的值。次，在函数中尝试重写arguments对象会导致语法错误。（代码也不会执行。）</p>
</blockquote>
<ol>
<li>箭头函数中的参数</li>
</ol>
<p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 <strong>arguments</strong> 关键字访问，而只能通过定义的命名参数访问。</p>
<p>虽然箭头函数中没有 <strong>arguments</strong> 对象，但可以在包装函数中把它提供给箭头函数。</p>
<blockquote>
<p><strong>ECMAScript</strong> 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</p>
</blockquote>
<h3 id="10-4-没有重载"><a href="#10-4-没有重载" class="headerlink" title="10.4 没有重载"></a>10.4 没有重载</h3><p><strong>ECMAScript</strong> 函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。<br>如果在 <strong>ECMAScript</strong> 中定义了两个同名函数，则后定义的会覆盖先定义的。</p>
<h3 id="10-5-默认参数值"><a href="#10-5-默认参数值" class="headerlink" title="10.5 默认参数值"></a>10.5 默认参数值</h3><p><strong>ECMAScript 6</strong> 之后支持显式定义默认参数。</p>
<p>在使用默认参数时，<strong>arguments</strong> 对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟 ES5 严格模式一样，修改命名参数也不会影响 <strong>arguments</strong> 对象，它始终以调用函数时传入的值为准。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) &#123; </span><br><span class="line">  name = <span class="string">&#x27;Louis&#x27;</span>;  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;<span class="variable language_">arguments</span>[<span class="number">0</span>]&#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>());         <span class="comment">// &#x27;King undefined&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>));  <span class="comment">// &#x27;King Louis&#x27;</span></span><br></pre></td></tr></table></figure>

<p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值</p>
<p>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。<br>箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了。</p>
<ol>
<li>默认参数作用域与暂时性死区</li>
</ol>
<p>因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。<br>给多个参数定义默认值实际上跟使用 <strong>let</strong> 关键字顺序声明变量一样。</p>
<p>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。</p>
<p>参数也存在于自己的作用域中，它们不能引用函数体的作用域。</p>
<h3 id="10-6-参数扩展与收集"><a href="#10-6-参数扩展与收集" class="headerlink" title="10.6 参数扩展与收集"></a>10.6 参数扩展与收集</h3><p>扩展操作符最有用的场景就是函数定义中的参数列表，<br>扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p>
<h4 id="10-6-1-扩展参数"><a href="#10-6-1-扩展参数" class="headerlink" title="10.6.1 扩展参数"></a>10.6.1 扩展参数</h4><p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。</p>
<p>对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。</p>
<p><strong>arguments</strong> 对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数。</p>
<h4 id="10-6-2-收集参数"><a href="#10-6-2-收集参数" class="headerlink" title="10.6.2 收集参数"></a>10.6.2 收集参数</h4><p>在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似 <strong>arguments</strong> 对象的构造机制，只不过收集参数的结果会得到一个 <strong>Array</strong> 实例。</p>
<p>箭头函数虽然不支持 <strong>arguments</strong> 对象，但支持收集参数的定义方式，因此也可以实现与使用 <strong>arguments</strong> 一样的逻辑。</p>
<p>使用收集参数并不影响 <strong>arguments</strong> 对象，它仍然反映调用时传给函数的参数。</p>
<h3 id="10-7-函数声明与函数表达式"><a href="#10-7-函数声明与函数表达式" class="headerlink" title="10.7 函数声明与函数表达式"></a>10.7 函数声明与函数表达式</h3><p><strong>JavaScript</strong> 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p>
<p>函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个<br>过程叫作函数声明提升（<strong>function declaration hoisting</strong>）。</p>
<h3 id="10-8-函数作为值"><a href="#10-8-函数作为值" class="headerlink" title="10.8 函数作为值"></a>10.8 函数作为值</h3><p>因为函数名在 <strong>ECMAScript</strong> 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p>
<blockquote>
<p>要注意的是，如果是访问函数而不是调用函数，那就必须不带括号。</p>
</blockquote>
<h3 id="10-9-函数内部"><a href="#10-9-函数内部" class="headerlink" title="10.9 函数内部"></a>10.9 函数内部</h3><p>在 <strong>ECMAScript 5</strong> 中，函数内部存在两个特殊的对象：<strong>arguments 和 this</strong>。<strong>ECMAScript 6</strong> 又新增了 <strong>new.target</strong> 属性。</p>
<h4 id="10-9-1-arguments"><a href="#10-9-1-arguments" class="headerlink" title="10.9.1 arguments"></a>10.9.1 arguments</h4><p><strong>arguments</strong> 对象前面讨论过多次了，它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以 <strong>function</strong> 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 <strong>arguments</strong> 对象其实还有一个 <strong>callee</strong> 属性，是一个指向 <strong>arguments</strong> 对象所在函数的指针。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 这个重写之后的factorial()函数已经用arguments.callee代替了之前硬编码的factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。</span></span><br></pre></td></tr></table></figure>

<h4 id="10-9-2-this"><a href="#10-9-2-this" class="headerlink" title="10.9.2 this"></a>10.9.2 this</h4><p>在标准函数中，<strong>this</strong> 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 <strong>this</strong> 值（在网页的全局上下文中调用函数时，<strong>this</strong> 指向 <strong>windows</strong>）。</p>
<p>在箭头函数中，<strong>this</strong> 引用的是定义箭头函数的上下文。</p>
<blockquote>
<p>注意 函数名只是保存指针的变量。</p>
</blockquote>
<h4 id="10-9-3-caller"><a href="#10-9-3-caller" class="headerlink" title="10.9.3 caller"></a>10.9.3 caller</h4><p><strong>ECMAScript 5</strong> 也会给函数对象上添加一个属性：<strong>caller</strong>。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 <strong>null</strong>。</p>
<p>在严格模式下访问 <strong>arguments.callee</strong> 会报错。<strong>ECMAScript 5</strong> 也定义了 <strong>arguments.caller</strong>，但在严格模式下访问它会报错，在非严格模式下则始终是 <strong>undefined</strong>。</p>
<p>严格模式下还有一个限制，就是不能给函数的 <strong>caller</strong> 属性赋值，否则会导致错误。</p>
<h4 id="10-9-4-new-target"><a href="#10-9-4-new-target" class="headerlink" title="10.9.4 new.target"></a>10.9.4 new.target</h4><p><strong>ECMAScript</strong> 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。<strong>ECMAScript 6</strong> 新增了检测函数是否使用 <strong>new</strong> 关键字调用的 <strong>new.target</strong> 属性。如果函数是正常调用的，则 <strong>new.target</strong> 的值是 <strong>undefined</strong>；如果是使用 <strong>new</strong> 关键字调用的，则 <strong>new.target</strong> 将引用被调用的构造函数。</p>
<h3 id="10-10-函数属性与方法"><a href="#10-10-函数属性与方法" class="headerlink" title="10.10 函数属性与方法"></a>10.10 函数属性与方法</h3><p><strong>ECMAScript</strong> 中的函数是对象，因此有属性和方法。每个函数都有两个属性：<strong>length 和 prototype</strong>。其中，<strong>length</strong> 属性保存函数定义的命名参数的个数。</p>
<p><strong>prototype</strong> 是保存引用类型所有实例方法的地方，这意味着 <strong>toString()、valueOf()</strong> 等方法实际上都保存在 <strong>prototype</strong> 上，进而由所有实例共享。这个属性在自定义类型时特别重要。在 <strong>ECMAScript 5</strong><br>中，<strong>prototype</strong> 属性是不可枚举的，因此使用 <strong>for-in</strong> 循环不会返回这个属性。<br>函数还有两个方法：**apply() 和 call()**。这两个方法都会以指定的 <strong>this</strong> 值来调用函数，即会设置调用函数时函数体内 <strong>this</strong> 对象的值 —— 控制函数调用上下文即函数体内 <strong>this</strong> 值的能力。</p>
<p><strong>apply()</strong> 方法接收两个参数：函数内 <strong>this</strong> 的值和一个参数数组。第二个参数可以是 <strong>Array</strong> 的实例，但也可以是 <strong>arguments</strong> 对象。</p>
<blockquote>
<p>在严格模式下，调用函数时如果没有指定上下文对象，则 <strong>this</strong> 值不会指向 <strong>window</strong>。除非使用 <strong>apply() 或 call()</strong> 把函数指定给一个对象，否则 <strong>this</strong> 的值会变成 <strong>undefined</strong>。</p>
</blockquote>
<p><strong>call()</strong> 方法与 <strong>apply()</strong> 的作用一样，只是传参的形式不同。第一个参数是 <strong>this</strong> 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 <strong>call()</strong> 向函数传参时，必须将参数一个一个地列出来。</p>
<p>使用 <strong>call() 或 apply()</strong> 的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。</p>
<p><strong>ECMAScript 5</strong> 出于同样的目的定义了一个新方法：<strong>bind()<strong>。</strong>bind()</strong> 方法会创建一个新的函数实例，其 <strong>this</strong> 值会被绑定到传给 <strong>bind()</strong> 的对象。</p>
<p>对函数而言，继承的方法 <strong>toLocaleString() 和 toString()</strong> 始终返回函数的代码。继承的方法 <strong>valueOf()</strong> 返回函数本身。</p>
<h3 id="10-11-函数表达式"><a href="#10-11-函数表达式" class="headerlink" title="10.11 函数表达式"></a>10.11 函数表达式</h3><p>定义函数有两种方式：函数声明和函数表达式。</p>
<p>函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。这意味着函数声明可以出现在调用它的代码之后。</p>
<p>第二种创建函数的方式就是函数表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) &#123; </span><br><span class="line">  <span class="comment">// 函数体  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 <strong>functionName</strong>。这样创建的函数叫作匿名函数（<strong>anonymous funtion</strong>），因为function关键字后面没有标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 <strong>name</strong> 属性是空字符串。</p>
<p>创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回。</p>
<h3 id="10-12-递归"><a href="#10-12-递归" class="headerlink" title="10.12 递归"></a>10.12 递归</h3><p>递归函数通常的形式是一个函数通过名称调用自己。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num - <span class="number">1</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 这是经典的递归阶乘函数。</span></span><br></pre></td></tr></table></figure>

<p><strong>arguments.callee</strong> 是一个指向正在执行的函数的指针，因此可以在函数内部递归调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//在编写递归函数时，arguments.callee是引用当前函数的首选.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在严格模式下运行的代码是不能访问 <strong>arguments.callee</strong> 的，因为访问会出错。</p>
</blockquote>
<h3 id="10-13-尾调用优化"><a href="#10-13-尾调用优化" class="headerlink" title="10.13 尾调用优化"></a>10.13 尾调用优化</h3><p><strong>ECMAScript 6</strong> 规范新增了一项内存管理优化机制，让 <strong>JavaScript</strong> 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">innerFunction</span>(); <span class="comment">// 尾调用 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>ES6</strong> 优化之前，执行这个例子会在内存中发生如下操作。<br>(1) 执行到outerFunction函数体，第一个栈帧被推到栈上。<br>(2) 执行outerFunction函数体，到return语句。计算返回值必须先计算innerFunction。<br>(3) 执行到innerFunction函数体，第二个栈帧被推到栈上。<br>(4) 执行innerFunction函数体，计算其返回值。<br>(5) 将返回值传回outerFunction，然后outerFunction再返回值。<br>(6) 将栈帧弹出栈外。</p>
<p>在 <strong>ES6</strong> 优化之后，执行这个例子会在内存中发生如下操作。<br>(1) 执行到outerFunction函数体，第一个栈帧被推到栈上。<br>(2) 执行outerFunction函数体，到达return语句。为求值返回语句，必须先求值innerFunction。<br>(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为innerFunction的返回值也是outerFunction的返回值。<br>(4) 弹出outerFunction的栈帧。<br>(5) 执行到innerFunction函数体，栈帧被推到栈上。<br>(6) 执行innerFunction函数体，计算其返回值。<br>(7) 将innerFunction的栈帧弹出栈外。<br>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p>
<h4 id="10-13-1-尾调用优化的条件"><a href="#10-13-1-尾调用优化的条件" class="headerlink" title="10.13.1 尾调用优化的条件"></a>10.13.1 尾调用优化的条件</h4><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了。</p>
<ul>
<li><p>代码在严格模式下执行。</p>
</li>
<li><p>外部函数的返回值是对尾调用函数的调用。</p>
</li>
<li><p>尾调用函数返回后不需要执行额外的逻辑。</p>
</li>
<li><p>尾调用函数不是引用外部函数作用域中自由变量的闭包。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是几个符合尾调用优化条件的例子： </span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">innerFunction</span>(a + b); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) &#123; </span><br><span class="line">    <span class="keyword">return</span> a; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">innerFunction</span>(a + b); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">condition</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> condition ? <span class="title function_">innerFunctionA</span>() : <span class="title function_">innerFunctionB</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-14-闭包"><a href="#10-14-闭包" class="headerlink" title="10.14 闭包"></a>10.14 闭包</h3><p>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。</p>
<p>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。</p>
<blockquote>
<p>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。V8 等优化的 JavaScript 引擎会努力回收被闭包困住的内存，不过我们还是建议在使用闭包时要谨慎。</p>
</blockquote>
<h4 id="10-14-1-this对象"><a href="#10-14-1-this对象" class="headerlink" title="10.14.1 this对象"></a>10.14.1 this对象</h4><p>在闭包中使用 <strong>this</strong> 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 <strong>this</strong> 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则 <strong>this</strong> 在非严格模式下等于 <strong>window</strong>，在严格模式下等于 <strong>undefined</strong>。如果作为某个对象的方法调用，则 <strong>this</strong> 等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着 <strong>this</strong> 会指向 <strong>window</strong>，除非在严格模式下 <strong>this</strong> 是<strong>undefined</strong>。</p>
<p>每个函数在被调用时都会自动创建两个特殊变量：<strong>this 和 arguments</strong>。内部函数永远不可能直接访问外部函数的这两个变量。</p>
<blockquote>
<p><strong>this</strong> 和 <strong>arguments</strong> 都是不能直接在内部函数中访问的。如果想访问包含作用域中的 <strong>arguments</strong> 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。</p>
</blockquote>
<h3 id="10-15-立即调用的函数表达式"><a href="#10-15-立即调用的函数表达式" class="headerlink" title="10.15 立即调用的函数表达式"></a>10.15 立即调用的函数表达式</h3><p>立即调用的匿名函数又被称作立即调用的函数表达式（<strong>IIFE，Immediately Invoked Function Expression</strong>）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。</p>
<p>使用 <strong>IIFE</strong> 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。</p>
<h3 id="10-16-私有变量"><a href="#10-16-私有变量" class="headerlink" title="10.16 私有变量"></a>10.16 私有变量</h3><p>严格来讲，<strong>JavaScript</strong> 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。</p>
<p>特权方法（<strong>privileged method</strong>）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="comment">// 私有变量和私有函数  </span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 特权方法 </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">publicMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    privateVariable++; </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">privateFunction</span>(); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-16-1-静态私有变量"><a href="#10-16-1-静态私有变量" class="headerlink" title="10.16.1 静态私有变量"></a>10.16.1 静态私有变量</h4><p>特权方法也可以通过使用私有作用域定义私有变量和函数来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="comment">// 私有变量和私有函数 </span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 </span></span><br><span class="line">  <span class="title class_">MyObject</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有和特权方法 </span></span><br><span class="line">  <span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">publicMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    privateVariable++; </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">privateFunction</span>(); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>特权方法作为一个闭包，始终引用着包含它的作用域。</p>
<h4 id="10-16-2-模块模式"><a href="#10-16-2-模块模式" class="headerlink" title="10.16.2 模块模式"></a>10.16.2 模块模式</h4><p>模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（<strong>singleton</strong>）就是只有一个实例的对象。按照惯例，<strong>JavaScript</strong> 是通过对象字面量来创建单例对象的。</p>
<p>模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 样板代码如下： </span></span><br><span class="line"><span class="keyword">let</span> singleton = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="comment">// 私有变量和私有函数 </span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 特权/公有方法和属性 </span></span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">publicProperty</span>: <span class="literal">true</span>, </span><br><span class="line"></span><br><span class="line">    <span class="title function_">publicMethod</span>(<span class="params"></span>) &#123; </span><br><span class="line">      privateVariable++; </span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">privateFunction</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式。</p>
<p>在模块模式中，单例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以通过其暴露的公共方法来访问。以这种方式创建的每个单例对象都是 <strong>Object</strong> 的实例，因为最终单例都由一个对象字面量来表示。</p>
<h4 id="10-16-3-模块增强模式"><a href="#10-16-3-模块增强模式" class="headerlink" title="10.16.3 模块增强模式"></a>10.16.3 模块增强模式</h4><p>利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。</p>
<h3 id="10-17-小结"><a href="#10-17-小结" class="headerlink" title="10.17 小结"></a>10.17 小结</h3><p>函数是 <strong>JavaScript</strong> 编程中最有用也最通用的工具。</p>
<ul>
<li><p>函数表达式与函数声明是不一样的。函数声明要求写出函数名称，而函数表达式并不需要。没有名称的函数表达式也被称为匿名函数。 </p>
</li>
<li><p><strong>ES6</strong> 新增了类似于函数表达式的箭头函数语法，但两者也有一些重要区别。 </p>
</li>
<li><p><strong>JavaScript</strong> 中函数定义与调用时的参数极其灵活。<strong>arguments</strong> 对象，以及 <strong>ES6</strong> 新增的扩展操作符，可以实现函数定义和调用的完全动态化。 </p>
</li>
<li><p>函数内部也暴露了很多对象和引用，涵盖了函数被谁调用、使用什么调用，以及调用时传入了什么参数等信息。 </p>
</li>
<li><p><strong>JavaScript</strong> 引擎可以优化符合尾调用条件的函数，以节省栈空间。 </p>
</li>
<li><p>闭包的作用域链中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象。 </p>
</li>
<li><p>通常，函数作用域及其中的所有变量在函数执行完毕后都会被销毁。 </p>
</li>
<li><p>闭包在被函数返回之后，其作用域会一直保存在内存中，直到闭包被销毁。 </p>
</li>
<li><p>函数可以在创建之后立即调用，执行其中代码之后却不留下对函数的引用。 </p>
</li>
<li><p>立即调用的函数表达式如果不在包含作用域中将返回值赋给一个变量，则其包含的所有变量都会被销毁。 </p>
</li>
<li><p>虽然 <strong>JavaScript</strong> 没有私有对象属性的概念，但可以使用闭包实现公共方法，访问位于包含作用域中定义的变量。 </p>
</li>
<li><p>可以访问私有变量的公共方法叫作特权方法。 </p>
</li>
<li><p>特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。</p>
</li>
</ul>
<h2 id="十一、期约与异步函数"><a href="#十一、期约与异步函数" class="headerlink" title="十一、期约与异步函数"></a>十一、期约与异步函数</h2><p><strong>ECMAScript 6</strong> 新增了正式的 <strong>Promise</strong>（期约）引用类型，支持优雅地定义和组织异步逻辑。</p>
<h3 id="11-1-异步编程"><a href="#11-1-异步编程" class="headerlink" title="11.1 异步编程"></a>11.1 异步编程</h3><p><strong>JavaScript</strong> 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。</p>
<h4 id="11-1-1-同步与异步"><a href="#11-1-1-同步与异步" class="headerlink" title="11.1.1 同步与异步"></a>11.1.1 同步与异步</h4><p>同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。</p>
<p>异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。</p>
<h4 id="11-1-2-以往的异步编程模式"><a href="#11-1-2-以往的异步编程模式" class="headerlink" title="11.1.2 以往的异步编程模式"></a>11.1.2 以往的异步编程模式</h4><p>异步行为是 <strong>JavaScript</strong> 的基础，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。</p>
<ol>
<li>异步返回值</li>
</ol>
<p>给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。</p>
<ol start="2">
<li>失败处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value, success, failure</span>) &#123;  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="title function_">success</span>(<span class="number">2</span> * value); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">      <span class="title function_">failure</span>(e); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, <span class="number">1000</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">successCallback</span> = (<span class="params">x</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Success: <span class="subst">$&#123;x&#125;</span>`</span>); </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">failureCallback</span> = (<span class="params">e</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>); </span><br><span class="line"></span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>, successCallback, failureCallback); </span><br><span class="line"><span class="title function_">double</span>(<span class="string">&#x27;b&#x27;</span>, successCallback, failureCallback); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Success: 6（大约 1000 毫秒之后） </span></span><br><span class="line"><span class="comment">// Failure: Must provide number as first argument（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>嵌套异步回调</li>
</ol>
<h3 id="11-2-期约"><a href="#11-2-期约" class="headerlink" title="11.2 期约"></a>11.2 期约</h3><p>期约是对尚不存在结果的一个替身。期约（promise）描述的是一种异步程序执行的机制。</p>
<h4 id="11-2-1-期约基础"><a href="#11-2-1-期约基础" class="headerlink" title="11.2.1 期约基础"></a>11.2.1 期约基础</h4><p><strong>ECMAScript 6</strong> 新增的引用类型 <strong>Promise</strong>，可以通过 <strong>new</strong> 操作符来实例化。创建新期约时需要传入执行器（<strong>executor</strong>）函数作为参数。</p>
<ol>
<li>期约状态机</li>
</ol>
<p>期约是一个有状态的对象，可能处于如下 3 种状态之一：</p>
<ul>
<li><p>待定（<strong>pending</strong>） </p>
</li>
<li><p>兑现（<strong>fulfilled</strong>，有时候也称为“解决”，<strong>resolved</strong>） </p>
</li>
<li><p>拒绝（<strong>rejected</strong>）</p>
</li>
</ul>
<p>待定（<strong>pending</strong>）是期约的最初始状态。在待定状态下，期约可以落定（<strong>settled</strong>）为代表成功的兑现（<strong>fulfilled</strong>）状态，或者代表失败的拒绝（<strong>rejected</strong>）状态。无论落定为哪种状态都是不可逆的。只要从待<br>定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（<strong>resolve</strong>）还是拒绝（<strong>reject</strong>），甚至永远处于待定（<strong>pending</strong>）状态，都应该<br>具有恰当的行为。<br>重要的是，期约的状态是私有的，不能直接通过 <strong>JavaScript</strong> 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 <strong>JavaScript</strong> 代码修改。</p>
<ol start="2">
<li>解决值、拒绝理由及期约用例</li>
</ol>
<p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。</p>
<p>在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。</p>
<p>为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（<strong>value</strong>）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（<strong>reason</strong>）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 <strong>undefined</strong>。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</p>
<ol start="3">
<li>通过执行函数控制期约状态</li>
</ol>
<p>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 **resolve() 和 reject()**。调用 <strong>resolve()</strong> 会把状态切换为兑现，调用 <strong>reject()</strong> 会把状态切换为拒绝。另外，调用 <strong>reject()</strong> 也会抛出错误。</p>
<ol start="4">
<li>Promise.resolve()</li>
</ol>
<p>通过调用 <strong>Promise.resolve()</strong> 静态方法，可以实例化一个解决的期约。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>()); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br></pre></td></tr></table></figure>

<p>对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，<strong>Promise.resolve()</strong> 可以说是一个幂等方法。</p>
<blockquote>
<p>这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。</p>
</blockquote>
<ol start="5">
<li>Promise.reject()</li>
</ol>
<p><strong>Promise.reject()</strong> 会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 <strong>try/catch</strong> 捕获，而只能通过拒绝处理程序捕获）。</p>
<p><strong>Promise.reject()</strong> 并没有照搬 <strong>Promise.resolve()</strong> 的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由。</p>
<ol start="6">
<li>同步/异步执行的二元性</li>
</ol>
<p>期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。</p>
<h4 id="11-2-3-期约的实例方法"><a href="#11-2-3-期约的实例方法" class="headerlink" title="11.2.3 期约的实例方法"></a>11.2.3 期约的实例方法</h4><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p>
<ol>
<li>实现 <strong>Thenable</strong> 接口</li>
</ol>
<p>在 <strong>ECMAScript</strong> 暴露的异步结构中，任何对象都有一个 <strong>then()</strong> 方法。这个方法被认为实现了 <strong>Thenable</strong> 接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThenable</span> &#123; </span><br><span class="line">  <span class="title function_">then</span>(<span class="params"></span>) &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promise.prototype.then()</li>
</ol>
<p><strong>Promise.prototype.then()</strong> 是为期约实例添加处理程序的主要方法。这个 <strong>then()</strong> 方法接收最多两个参数：<strong>onResolved</strong> 处理程序和 <strong>onRejected</strong> 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。</p>
<p>传给 <strong>then()</strong> 的任何非函数类型的参数都会被静默忽略。如果想只提供 <strong>onRejected</strong> 参数，那就要在 <strong>onResolved</strong> 参数的位置上传入 <strong>undefined</strong>。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。</p>
<p><strong>onRejected</strong> 处理程序也与之类似：<strong>onRejected</strong> 处理程序返回的值也会被 <strong>Promise.resolve()</strong> 包装。</p>
<ol start="3">
<li>Promise.prototype.catch()</li>
</ol>
<p><strong>Promise.prototype.catch()</strong> 方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：<strong>onRejected</strong> 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 **Promise.prototype. then(null,onRejected)**。</p>
<p>在返回新期约实例方面，<strong>Promise.prototype.catch()</strong> 的行为与 <strong>Promise.prototype.then()</strong> 的 <strong>onRejected</strong> 处理程序是一样的。</p>
<ol start="4">
<li>Promise.prototype.finally()</li>
</ol>
<p><strong>Promise.prototype.finally()</strong> 方法用于给期约添加 <strong>onFinally</strong> 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 <strong>onResolved</strong> 和 <strong>onRejected</strong> 处理程序中出现冗余代码。但 <strong>onFinally</strong> 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。</p>
<p><strong>onFinally</strong> 被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。</p>
<p>如果返回的是一个待定的期约，或者 <strong>onFinally</strong> 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）。</p>
<ol start="5">
<li>非重入期约方法</li>
</ol>
<p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 <strong>JavaScript</strong> 运行时保证，被称为“非重入”（<strong>non-reentrancy</strong>）特性。</p>
<p>非重入适用于 <strong>onResolved/onRejected</strong> 处理程序、<strong>catch()</strong> 处理程序和 <strong>finally()</strong> 处理程序。</p>
<ol start="6">
<li>邻近处理程序的执行顺序</li>
</ol>
<p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 <strong>then()、catch() 还是 finally()</strong> 添加的处理程序都是如此。</p>
<ol start="7">
<li>传递解决值和拒绝理由</li>
</ol>
<p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。</p>
<p>在执行函数中，解决的值和拒绝的理由是分别作为 <strong>resolve() 和 reject()</strong> 的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 <strong>onResolved 或 onRejected</strong> 处理程序的唯一参数。</p>
<p><strong>Promise.resolve() 和 Promise.reject()</strong> 在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给 <strong>onResolved 或 onRejected</strong> 处理程序。</p>
<ol start="8">
<li>拒绝期约与拒绝错误处理</li>
</ol>
<p>拒绝期约类似于 <strong>throw()</strong> 表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝。</p>
<p>期约可以以任何理由拒绝，包括 <strong>undefined</strong>，但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。</p>
<p>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：<strong>Promise.resolve().then()</strong> 的错误最后才出现，这是因为它需要在运行时消息队列中添加处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。</p>
<p>正常情况下，在通过 <strong>throw()</strong> 关键字抛出错误时，<strong>JavaScript</strong> 运行时的错误处理机制会停止执行抛出错误之后的任何指令。</p>
<p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令。</p>
<p>异步错误只能通过异步的 <strong>onRejected</strong> 处理程序捕获。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确  </span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不正确 </span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 <strong>try/catch</strong> 在执行函数中捕获错误。</p>
<p><strong>then() 和 catch() 的 onRejected</strong> 处理程序在语义上相当于 <strong>try/catch</strong>。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，<strong>onRejected</strong> 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。</p>
<h4 id="11-2-4-期约连锁与期约合成"><a href="#11-2-4-期约连锁与期约合成" class="headerlink" title="11.2.4 期约连锁与期约合成"></a>11.2.4 期约连锁与期约合成</h4><p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</p>
<ol>
<li>期约连锁</li>
</ol>
<p>把期约逐个地串联起来是一种非常有用的编程模式。</p>
<p>要真正执行异步任务，可以让每个执行器都返回一个期约实例。这样就可以让每个后续期约都等待之前的期约，也就是串行化异步任务。</p>
<ol start="2">
<li>期约图</li>
</ol>
<p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。</p>
<p>树只是期约图的一种形式。考虑到根节点不一定唯一，且多个期约也可以组合成一个期约，所以有向非循环图是体现期约连锁可能性的最准确表达。</p>
<ol start="3">
<li>Promise.all()和Promise.race()</li>
</ol>
<p><strong>Promise</strong> 类提供两个将多个期约实例组合成一个期约的静态方法：**Promise.all() 和 Promise.race()**。而合成后期约的行为取决于内部期约的行为。</p>
<ul>
<li>Promise.all()</li>
</ul>
<p><strong>Promise.all()</strong> 静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约。</p>
<p>合成的期约只会在每个包含的期约都解决之后才解决。</p>
<p>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝。</p>
<p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序。</p>
<p>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作。</p>
<ul>
<li>Promise.race()</li>
</ul>
<p><strong>Promise.race()</strong> 静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约。</p>
<p><strong>Promise.race()</strong> 不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，<strong>Promise.race()</strong> 就会包装其解决值或拒绝理由并返回新期约。</p>
<p>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 <strong>Promise.all()</strong> 类似，合成的期约会静默处理所有包含期约的拒绝操作。</p>
<p>基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。</p>
<h4 id="11-2-5-期约扩展"><a href="#11-2-5-期约扩展" class="headerlink" title="11.2.5 期约扩展"></a>11.2.5 期约扩展</h4><ol>
<li>期约取消</li>
</ol>
<p>实际上，可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。这可以用到 <strong>Kevin Smith</strong> 提到的“取消令牌”（<strong>cancel token</strong>）。生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CancelToken</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">cancelFn</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="title function_">cancelFn</span>(resolve); </span><br><span class="line">    &#125;); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>期约进度通知</li>
</ol>
<p><strong>ECMAScript 6</strong> 期约并不支持进度追踪，但是可以通过扩展来实现。<br>一种实现方式是扩展 <strong>Promise</strong> 类，为它添加 <strong>notify()</strong> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrackablePromise</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Promise</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;  </span><br><span class="line">    <span class="keyword">const</span> notifyHandlers = []; </span><br><span class="line"></span><br><span class="line">      <span class="variable language_">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">executor</span>(resolve, reject, <span class="function">(<span class="params">status</span>) =&gt;</span> &#123; </span><br><span class="line">        notifyHandlers.<span class="title function_">map</span>(<span class="function">(<span class="params">handler</span>) =&gt;</span> <span class="title function_">handler</span>(status)); </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">notifyHandlers</span> = notifyHandlers; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">notifyHandler</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">notifyHandlers</span>.<span class="title function_">push</span>(notifyHandler); </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//可以像下面这样使用这个函数来实例化一个期约： </span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">TrackablePromise</span>(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">x</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="title function_">notify</span>(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>); </span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(x - <span class="number">1</span>), <span class="number">1000</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="title function_">resolve</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="title function_">countdown</span>(<span class="number">5</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>notify()</strong> 函数会返回期约，所以可以连缀调用，连续添加处理程序。多个处理程序会针对收到的每条消息分别执行一遍。</p>
<h3 id="11-3-异步函数"><a href="#11-3-异步函数" class="headerlink" title="11.3 异步函数"></a>11.3 异步函数</h3><p>异步函数，也称为“<strong>async/await</strong>”（语法关键字），是 <strong>ES6</strong> 期约模式在 <strong>ECMAScript</strong> 函数中的应用。<br><strong>async/await</strong> 是 <strong>ES8</strong> 规范新增的。</p>
<h4 id="11-3-1-异步函数"><a href="#11-3-1-异步函数" class="headerlink" title="11.3.1 异步函数"></a>11.3.1 异步函数</h4><p><strong>ES8</strong> 的 <strong>async/await</strong> 旨在解决利用异步结构组织代码的问题。为此，<strong>ECMAScript</strong> 对函数进行了扩展，为其增加了两个新关键字：<strong>async和await</strong>。</p>
<ol>
<li>async </li>
</ol>
<p><strong>async</strong> 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。</p>
<p>使用 <strong>async</strong> 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通 <strong>JavaScript</strong> 函数的正常行为。</p>
<p>不过，异步函数如果使用 <strong>return</strong> 关键字返回了值（如果没有 <strong>return</strong> 则会返回 <strong>undefined</strong>），这个值会被<strong>Promise.resolve()</strong> 包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约。</p>
<p>异步函数的返回值期待（但实际上并不要求）一个实现 <strong>thenable</strong> 接口的对象，但常规的值也可以。如果返回的是实现 <strong>thenable</strong> 接口的对象，则这个对象可以由提供给 <strong>then()</strong> 的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值  </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个没有实现 thenable 接口的对象 </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">bar</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个实现了 thenable 接口的非期约对象 </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> thenable = &#123; </span><br><span class="line">    <span class="title function_">then</span>(<span class="params">callback</span>) &#123; <span class="title function_">callback</span>(<span class="string">&#x27;baz&#x27;</span>); &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">return</span> thenable; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">baz</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"><span class="comment">// baz </span></span><br><span class="line"><span class="comment">// 返回一个期约 </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">qux</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure>

<p>与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约。不过，拒绝期约的错误不会被异步函数捕获。</p>
<ol start="2">
<li>await</li>
</ol>
<p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 <strong>await</strong> 关键字可以暂停异步函数代码的执行，等待期约解决。</p>
<p><strong>await</strong> 关键字会暂停执行异步函数后面的代码，让出 <strong>JavaScript</strong> 运行时的执行线程。这个行为与生成器函数中的 <strong>yield</strong> 关键字是一样的。<strong>await</strong> 关键字同样是尝试“解包”对象的值，然后将这<br>个值传给表达式，再异步恢复异步函数的执行。<br><strong>await</strong> 关键字的用法与 <strong>JavaScript</strong> 的一元操作一样。它可以单独使用，也可以在表达式中使用。</p>
<p><strong>await</strong> 关键字期待（但实际上并不要求）一个实现 <strong>thenable</strong> 接口的对象，但常规的值也可以。如果是实现 <strong>thenable</strong> 接口的对象，则这个对象可以由 <strong>await</strong> 来“解包”。如果不是，则这个值就被当作已经解决的期约。</p>
<p>等待会抛出错误的同步操作，会返回拒绝的期约。</p>
<p>单独的 <strong>Promise.reject()</strong> 不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用 <strong>await</strong> 则会释放（<strong>unwrap</strong>）错误值（将拒绝期约返回）。</p>
<ol start="3">
<li>await的限制</li>
</ol>
<p><strong>await</strong> 关键字必须在异步函数中使用，不能在顶级上下文如 &lt;**script**&gt; 标签或模块中使用。不过，定义并立即调用异步函数是没问题的。</p>
<p>异步函数的特质不会扩展到嵌套函数。因此，<strong>await</strong> 关键字也只能直接出现在异步函数的定义中。在同步函数内部使用 <strong>await</strong> 会抛出 <strong>SyntaxError</strong>。</p>
<h4 id="11-3-2-停止和恢复执行"><a href="#11-3-2-停止和恢复执行" class="headerlink" title="11.3.2 停止和恢复执行"></a>11.3.2 停止和恢复执行</h4><p>异步函数如果不包含 <strong>await</strong> 关键字，其执行基本上跟普通函数没有什么区别。</p>
<p><strong>JavaScript</strong> 运行时在碰到 <strong>await</strong> 关键字时，会记录在哪里暂停执行。等到 <strong>await</strong> 的值可用了，<strong>JavaScript</strong> 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。 因此，即使 <strong>await</strong> 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。</p>
<h4 id="11-3-3-异步函数策略"><a href="#11-3-3-异步函数策略" class="headerlink" title="11.3.3 异步函数策略"></a>11.3.3 异步函数策略</h4><ol>
<li>实现 sleep()</li>
</ol>
<p>在程序中加入非阻塞的暂停。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>); <span class="comment">// 暂停约 1500 毫秒 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="comment">// 1502</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>串行执行期约</li>
</ol>
<p>使用 async/await，期约连锁会变得很简单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123; </span><br><span class="line">    x = <span class="keyword">await</span> <span class="title function_">fn</span>(x); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>栈追踪与内存管理</li>
</ol>
<p>栈追踪信息应该相当直接地表现 <strong>JavaScript</strong> 引擎当前栈内存中函数调用之间的嵌套关系。在超时处理程序执行时和拒绝期约时，我们看到的错误信息包含嵌套函数的标识符，那是被调用以创建最初期约实例的函数。可是，我们知道这些函数已经返回了，因此栈追踪信息中不应该看到它们。<br>答案很简单，这是因为 <strong>JavaScript</strong> 引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。</p>
<h3 id="11-4-小结"><a href="#11-4-小结" class="headerlink" title="11.4 小结"></a>11.4 小结</h3><p>长期以来，掌握单线程 <strong>JavaScript</strong> 运行时的异步行为一直都是个艰巨的任务。随着 <strong>ES6</strong> 新增了期约和 <strong>ES8</strong> 新增了异步函数，<strong>ECMAScript</strong> 的异步编程特性有了长足的进步。通过期约和 <strong>async/await</strong>，不仅可以实现之前难以实现或不可能实现的任务，而且也能写出更清晰、简洁，并且容易理解、调试的代码。<br>期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。<br>异步函数是将期约应用于 <strong>JavaScript</strong> 函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代 <strong>JavaScript</strong> 工具箱中最重要的工具之一。</p>
<h2 id="十二、-BOM"><a href="#十二、-BOM" class="headerlink" title="十二、 BOM"></a>十二、 BOM</h2><p>浏览器对象模型（<strong>BOM，Browser Object Model</strong>）描述为 <strong>JavaScript</strong> 的核心，但实际上 <strong>BOM</strong> 是使用 <strong>JavaScript</strong> 开发 <strong>Web</strong> 应用程序的核心。<strong>BOM</strong> 提供了与网页无关的浏览器功能对象。</p>
<h3 id="12-1-window对象"><a href="#12-1-window对象" class="headerlink" title="12.1 window对象"></a>12.1 window对象</h3><p><strong>BOM</strong> 的核心是 <strong>window</strong> 对象，表示浏览器的实例。<strong>window</strong>对象在浏览器中有两重身份，一个是 <strong>ECMAScript</strong> 中的 <strong>Global</strong> 对象，另一个就是浏览器窗口的 <strong>JavaScript</strong> 接口。这意味着网页中定义的所有对象、变量和函数都以 <strong>window</strong> 作为其 <strong>Global</strong> 对象，都可以访问其上定义的 <strong>parseInt()</strong> 等全局方法。</p>
<blockquote>
<p><strong>window</strong> 对象的属性在全局作用域中有效。</p>
</blockquote>
<h4 id="12-1-1-Global作用域"><a href="#12-1-1-Global作用域" class="headerlink" title="12.1.1 Global作用域"></a>12.1.1 Global作用域</h4><p><strong>window</strong> 对象被复用为 <strong>ECMAScript</strong> 的 <strong>Global</strong> 对象，所以通过 <strong>var</strong> 声明的所有全局变量和函数都会变成 <strong>window</strong> 对象的属性和方法。</p>
<p>如果使用 <strong>let</strong> 或 <strong>const</strong> 替代 <strong>var</strong>，则不会把变量添加给全局对象。</p>
<p>另外，访问未声明的变量会抛出错误，但是可以在 <strong>window</strong> 对象上查询是否存在可能未声明的变量。</p>
<h4 id="12-1-2-窗口关系"><a href="#12-1-2-窗口关系" class="headerlink" title="12.1.2 窗口关系"></a>12.1.2 窗口关系</h4><p><strong>top</strong> 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 <strong>parent</strong> 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 <strong>parent</strong> 等于 <strong>top</strong>（都等于 <strong>window</strong>）。最上层的 <strong>window</strong>如果不是通过 <strong>window.open()</strong> 打开的，那么其 <strong>name</strong> 属性就不会包含值。 还有一个 <strong>self</strong> 对象，它是终极 <strong>window</strong> 属性，始终会指向 <strong>window</strong>。实际上，<strong>self</strong> 和 <strong>window</strong> 就是同一个对象。之所以还要暴露 <strong>self</strong>，就是为了和 <strong>top、parent</strong> 保持一致。</p>
<h4 id="12-1-3-窗口位置与像素比"><a href="#12-1-3-窗口位置与像素比" class="headerlink" title="12.1.3 窗口位置与像素比"></a>12.1.3 窗口位置与像素比</h4><p><strong>window</strong> 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 <strong>screenLeft</strong> 和 <strong>screenTop</strong> 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 <strong>CSS</strong> 像素。<br>可以使用 <strong>moveTo()</strong> 和 <strong>moveBy()</strong> 方法移动窗口。这两个方法都接收两个参数，其中 <strong>moveTo()</strong> 接收要移动到的新位置的绝对坐标 <strong>x</strong> 和 <strong>y</strong>；而 <strong>moveBy()</strong> 则接收相对当前位置在两个方向上移动的像素数。</p>
<p><strong>CSS</strong> 像素是 <strong>Web</strong> 开发中使用的统一像素单位。这个单位的背后其实是一个角度：<strong>0.0213°</strong>。</p>
<p><strong>window.devicePixelRatio</strong> 实际上与每英寸像素数（<strong>DPI，dots per inch</strong>）是对应的。<strong>DPI</strong> 表示单位像素密度，而 <strong>window.devicePixelRatio</strong> 表示物理像素与逻辑像素之间的缩放系数。</p>
<h4 id="12-1-4-窗口大小"><a href="#12-1-4-窗口大小" class="headerlink" title="12.1.4 窗口大小"></a>12.1.4 窗口大小</h4><p>所有现代浏览器都支持 4 个属性：<strong>innerWidth、innerHeight、outerWidth和outerHeight。outerWidth 和 outerHeight</strong> 返回浏览器窗口自身的大小（不管是在最外层 <strong>window</strong> 上使用，还是在窗格 <strong><frame></strong> 中使用）。<strong>innerWidth</strong> 和 <strong>innerHeight</strong> 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。<br><strong>document.documentElement.clientWidth 和 document.documentElement.clientHeight</strong> 返回页面视口的宽度和高度。</p>
<p>在移动设备上，<strong>window.innerWidth 和 window.innerHeight</strong> 返回视口的大小，也就是屏幕上页面可视区域的大小。</p>
<p>在其他移动浏览器中，<strong>document.documentElement.clientWidth 和 document.documentElement. clientHeight</strong> 返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的概念，可 见 视 口 只 能 显 示 整 个 页 面 的 一 小 部 分 。 <strong>Mobile Internet Explorer</strong> 把 布 局 视 口 的 信 息 保 存 在<strong>document.body.clientWidth 和 document.body.clientHeight</strong> 中。</p>
<p>可以使用 <strong>resizeTo() 和 resizeBy()</strong> 方法调整窗口大小。这两个方法都接收两个参数，<strong>resizeTo()</strong> 接收新的宽度和高度值，而 <strong>resizeBy()</strong> 接收宽度和高度各要缩放多少。</p>
<h4 id="12-1-5-视口位置"><a href="#12-1-5-视口位置" class="headerlink" title="12.1.5 视口位置"></a>12.1.5 视口位置</h4><p>度量文档相对于视口滚动距离的属性有两对，返回相等的值: <strong>window.pageXoffset/window. scrollX 和 window.pageYoffset/window.scrollY</strong>。<br>可以使用 <strong>scroll()、scrollTo() 和 scrollBy()</strong> 方法滚动页面。这 3 个方法都接收表示相对视口距离的 <strong>x</strong> 和 <strong>y</strong> 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</p>
<p>这几个方法也都接收一个 <strong>ScrollToOptions</strong> 字典，除了提供偏移值，还可以通过 <strong>behavior</strong> 属性告诉浏览器是否平滑滚动。</p>
<h4 id="12-1-6-导航与打开新窗口"><a href="#12-1-6-导航与打开新窗口" class="headerlink" title="12.1.6 导航与打开新窗口"></a>12.1.6 导航与打开新窗口</h4><p><strong>window.open()</strong> 方法可以用于导航到指定 <strong>URL</strong>，也可以用于打开新浏览器窗口。这个方法接收 <strong>4</strong> 个参数：要加载的 <strong>URL</strong>、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前 <strong>3</strong> 个参数，最后一个参数只有在不打开新窗口时才会使用。 </p>
<p>如果 <strong>window.open()</strong> 的第二个参数是一个已经存在的窗口或窗格（<strong>frame</strong>）的名字，则会在对应的窗口或窗格中打开 <strong>URL</strong>。</p>
<ol>
<li>弹出窗口</li>
</ol>
<p>如果 <strong>window.open()</strong> 的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）。如果打开的不是新窗口，则忽略第三个参数。</p>
<p>特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。</p>
<table>
<thead>
<tr>
<th align="center">设 置</th>
<th align="center">值</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fullscreen</td>
<td align="center">“yes”或”no”</td>
<td align="center">表示新窗口是否最大化。仅限 IE 支持</td>
</tr>
<tr>
<td align="center">height</td>
<td align="center">数值</td>
<td align="center">新窗口高度。这个值不能小于 100</td>
</tr>
<tr>
<td align="center">left</td>
<td align="center">数值</td>
<td align="center">新窗口的 x 轴坐标。这个值不能是负值。</td>
</tr>
<tr>
<td align="center">location</td>
<td align="center">“yes”或”no”</td>
<td align="center">表示是否显示地址栏。不同浏览器的默认值也不一样。在设置为”no”时，地址栏可能隐藏或禁用（取决于浏览器）</td>
</tr>
<tr>
<td align="center">Menubar</td>
<td align="center">“yes”或”no”</td>
<td align="center">表示是否显示菜单栏。默认为”no”</td>
</tr>
</tbody></table>
<p>这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接。（特性字符串中不能包含空格。）</p>
<p><strong>window.open()</strong> 方法返回一个对新建窗口的引用。</p>
<p>新创建窗口的 <strong>window</strong> 对象有一个属性 <strong>opener</strong>，指向打开它的窗口。这个属性只在弹出窗口的最上层 <strong>window</strong> 对象（<strong>top</strong>）有定义，是指向调用 <strong>window.open()</strong> 打开它的窗口或窗格的指针。</p>
<p>在浏览器中，可以将新打开的标签页的 <strong>opener</strong> 属性设置为 <strong>null</strong>，表示新打开的标签页可以运行在独立的进程中。</p>
<p>把 <strong>opener</strong> 设置为 <strong>null</strong> 表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。这个连接一旦切断，就无法恢复了。</p>
<ol start="2">
<li>安全限制</li>
</ol>
<p>无论 <strong>window.open()</strong> 的特性字符串是什么，都不会隐藏弹窗的状态栏。</p>
<blockquote>
<p>IE 对打开本地网页的窗口再弹窗解除了某些限制。同样的代码如果来自服务器，则会施加弹窗限制。</p>
</blockquote>
<ol start="3">
<li>弹窗屏蔽程序</li>
</ol>
<p>所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。</p>
<p>在浏览器扩展或其他程序屏蔽弹窗时，<strong>window.open()</strong> 通常会抛出错误。因此要准确检测弹窗是否被屏蔽，除了检测 <strong>window.open()</strong> 的返回值，还要把它用 <strong>try/catch</strong> 包装起来。</p>
<h4 id="12-1-7-定时器"><a href="#12-1-7-定时器" class="headerlink" title="12.1.7 定时器"></a>12.1.7 定时器</h4><p><strong>JavaScript</strong> 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。<strong>setTimeout()</strong> 用于指定在一定时间后执行某些代码，而 <strong>setInterval()</strong> 用于指定每隔一段时间执行某些代码。<br><strong>setTimeout()</strong> 方法通常接收两个参数：要执行的代码和在执行回调函数前等待的时间（毫秒）。第一个参数可以是包含 <strong>JavaScript</strong> 代码的字符串（类似于传给 <strong>eval()</strong> 的字符串）或者一个函数。第二个参数是要等待的毫秒数。</p>
<p><strong>setTimeout()</strong> 的第二个参数只是告诉 <strong>JavaScript</strong> 引擎在指定的毫秒数过后把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待前面的任务执行完才能执行。<br>调用 <strong>setTimeout()</strong> 时，会返回一个表示该超时排期的数值 <strong>ID</strong>。这个超时 <strong>ID</strong> 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 <strong>clearTimeout()</strong> 方法并传入超时 <strong>ID</strong>。</p>
<blockquote>
<p>所有超时执行的代码（函数）都会在全局作用域中的一个匿名函数中运行，因此函数中的 <strong>this</strong> 值在非严格模式下始终指向 <strong>window</strong>，而在严格模式下是 <strong>undefined</strong>。如果给 <strong>setTimeout()</strong> 提供了一个箭头函数，那么 <strong>this</strong> 会保留为定义它时所在的词汇作用域。</p>
</blockquote>
<p><strong>setInterval()</strong> 指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。<strong>setInterval()</strong> 同样可以接收两个参数：要执行的代码（字符串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）。</p>
<blockquote>
<p>执行时间短、非阻塞的回调函数比较适合 **setInterval()**。</p>
</blockquote>
<p><strong>setInterval()</strong> 方法也会返回一个循环定时 <strong>ID</strong>，可以用于在未来某个时间点上取消循环定时。要取消循环定时，可以调用 <strong>clearInterval()</strong> 并传入定时 <strong>ID</strong>。</p>
<h4 id="12-1-8-系统对话框"><a href="#12-1-8-系统对话框" class="headerlink" title="12.1.8 系统对话框"></a>12.1.8 系统对话框</h4><p>使用 <strong>alert()、confirm() 和 prompt()</strong> 方法，可以让浏览器调用系统对话框向用户显示消息。</p>
<p>这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。</p>
<p>1.<strong>alert()</strong> 方法接收一个要显示给用户的字符串。与 <strong>console.log</strong> 可以接收任意数量的参数且能一次性打印这些参数不同，<strong>alert()</strong> 只接收一个参数。调用 <strong>alert()</strong> 时，传入的字符串会显示在一个系统对话框中。对话框只有一个“<strong>OK</strong>”（确定）按钮。如果传给 <strong>alert()</strong> 的参数不是一个原始字符串，则会调用这个值的 <strong>toString()</strong> 方法将其转换为字符串。<br>警告框（<strong>alert</strong>）通常用于向用户显示一些他们无法控制的消息，比如报错。</p>
<p>2.第二种对话框叫确认框，通过调用 <strong>confirm()</strong> 来显示。确认框跟警告框类似，都会向用户显示消息。但不同之处在于，确认框有两个按钮：“<strong>Cancel</strong>”（取消）和“<strong>OK</strong>”（确定）。用户通过单击不同的按钮表明希望接下来执行什么操作。</p>
<p>3.最后一种对话框是提示框，通过调用 <strong>prompt()</strong> 方法来显示。提示框的用途是提示用户输入消息。除了 <strong>OK</strong> 和 <strong>Cancel</strong> 按钮，提示框还会显示一个文本框，让用户输入内容。<strong>prompt()</strong> 方法接收两个参数：要显示给用户的文本，以及文本框的默认值（可以是空字符串）。</p>
<p><strong>JavaScript</strong> 还可以显示另外两种对话框：<strong>find() 和 print()<strong>。这两种对话框都是异步显示的，即控制权会立即返回给脚本。用户在浏览器菜单上选择“查找”（</strong>find</strong>）和“打印”（<strong>print</strong>）时显示的就是这两种对话框。通过在 <strong>window</strong> 对象上调用 <strong>find() 和 print()</strong> 可以显示它们。这两个方法不会返回任何有关用户在对话框中执行了什么操作的信息。</p>
<h3 id="12-2-location对象"><a href="#12-2-location对象" class="headerlink" title="12.2 location对象"></a>12.2 location对象</h3><p><strong>location</strong> 是最有用的 <strong>BOM</strong> 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这 个 对 象 独 特 的 地 方 在 于 ， 它 既 是 <strong>window</strong> 的 属 性 ， 也 是 <strong>document</strong> 的 属 性 。 也 就 是 说 ，<br> <strong>window.location 和 document.location</strong> 指向同一个对象。<strong>location</strong> 对象不仅保存着当前加载文档的信息，也保存着把 <strong>URL</strong> 解析为离散片段后能够通过属性访问的信息。</p>
<p>假 设 浏 览 器 当 前 加 载 的 <strong>URL</strong> 是 <a target="_blank" rel="noopener" href="http://foouser:barpassword@www.wrox.com/WileyCDA/?q=">http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=</a><br>javascript#contents，<strong>location</strong> 对象的内容如下表所示。</p>
<p><img src="/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell\Documents\img\2024-02-19-11-20-55-image.png"></p>
<h4 id="12-2-1-查询字符串"><a href="#12-2-1-查询字符串" class="headerlink" title="12.2.1 查询字符串"></a>12.2.1 查询字符串</h4><p><strong>location.search</strong> 返回了从问号开始直到 <strong>URL</strong> 末尾的所有内容，但没有办法逐个访问每个查询参数。</p>
<p><strong>URLSearchParams</strong> 提供了一组标准 <strong>API</strong> 方法，通过它们可以检查和修改查询字符串。给 <strong>URLSearchParams</strong> 构造函数传入一个查询字符串，就可以创建一个实例。这个实例上暴露了 <strong>get()、set() 和 delete()</strong> 等方法，可以对查询字符串执行相应操作。</p>
<p>大多数支持 <strong>URLSearchParams</strong> 的浏览器也支持将 <strong>URLSearchParams</strong> 的实例用作可迭代对象。</p>
<h4 id="12-2-2-操作地址"><a href="#12-2-2-操作地址" class="headerlink" title="12.2.2 操作地址"></a>12.2.2 操作地址</h4><p>可以通过修改 <strong>location</strong> 对象修改浏览器的地址。首先，最常见的是使用 <strong>assign()</strong> 方法并传入一个 <strong>URL</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.<span class="title function_">assign</span>(<span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>下面两行代码都会执行与显式调用 <strong>assign()</strong> 一样的操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;http://www.wrox.com&quot;</span>; </span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这 <strong>3</strong> 种修改浏览器地址的方法中，设置 <strong>location.href</strong> 是最常见的。<br>修改 <strong>location</strong> 对象的属性也会修改当前加载的页面。其中，<strong>hash、search、hostname、pathname 和 port</strong> 属性被设置为新值之后都会修改当前 <strong>URL</strong>。</p>
<p>除了 <strong>hash</strong> 之外，只要修改 <strong>location</strong> 的一个属性，就会导致页面重新加载新 <strong>URL</strong>。</p>
<p>在以前面提到的方式修改 <strong>URL</strong> 之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退”按钮时，就会导航到前一个页面。如果不希望增加历史记录，可以使用 <strong>replace()</strong> 方法。这个方法接收一个 <strong>URL</strong> 参数，但重新加载后不会增加历史记录。调用 <strong>replace()</strong> 之后，用户不能回到前一页。</p>
<p>最后一个修改地址的方法是 **reload()**，它能重新加载当前显示的页面。调用 <strong>reload()</strong> 而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给 <strong>reload()</strong> 传个 <strong>true</strong>。</p>
<h3 id="12-3-navigator对象"><a href="#12-3-navigator对象" class="headerlink" title="12.3 navigator对象"></a>12.3 navigator对象</h3><p>只要浏览器启用 <strong>JavaScript</strong>，<strong>navigator</strong> 对象就一定存在。</p>
<p><strong>navigator</strong> 对 象 实 现 了 <strong>NavigatorID、NavigatorLanguage、NavigatorOnLine、NavigatorContentUtils、NavigatorStorage、NavigatorStorageUtils、NavigatorConcurrentHardware、NavigatorPlugins 和 NavigatorUserMedia</strong> 接口定义的属性和方法。</p>
<p><strong>navigator</strong> 对象的属性通常用于确定浏览器的类型。</p>
<h4 id="12-3-1-检测插件"><a href="#12-3-1-检测插件" class="headerlink" title="12.3.1 检测插件"></a>12.3.1 检测插件</h4><p>检测浏览器是否安装了某个插件是开发中常见的需求。除 <strong>IE10</strong> 及更低版本外的浏览器，都可以通过 <strong>plugins</strong> 数组来确定。这个数组中的每一项都包含如下属性。</p>
<ul>
<li><p><strong>name</strong>：插件名称。 </p>
</li>
<li><p><strong>description</strong>：插件介绍。 </p>
</li>
<li><p><strong>filename</strong>：插件的文件名。 </p>
</li>
<li><p><strong>length</strong>：由当前插件处理的 <strong>MIME</strong> 类型数量。</p>
</li>
</ul>
<p>通常，<strong>name</strong> 属性包含识别插件所需的必要信息。</p>
<p><strong>IE11</strong> 的 <strong>window.navigator</strong> 对象开始支持 <strong>plugins 和 mimeTypes</strong> 属性。这意味着前面定义的函数可以适用于所有较新版本的浏览器。而且，<strong>IE11</strong> 中的 <strong>ActiveXObject</strong> 也从 <strong>DOM</strong> 中隐身了，意味着不能再用它来作为检测特性的手段。</p>
<h4 id="12-3-2-注册处理程序"><a href="#12-3-2-注册处理程序" class="headerlink" title="12.3.2 注册处理程序"></a>12.3.2 注册处理程序</h4><p>现代浏览器支持 <strong>navigator</strong> 上的（在 <strong>HTML5</strong> 中定义的） <strong>registerProtocolHandler()</strong> 方法。这个方法可以把一个网站注册为处理某种特定类型信息应用程序。</p>
<p>要使用 <strong>registerProtocolHandler()</strong> 方法，必须传入 <strong>3</strong> 个参数：要处理的协议（如”<strong>mailto</strong>“或”<strong>ftp</strong>“）、处理该协议的 <strong>URL</strong>，以及应用名称。</p>
<h3 id="12-4-screen对象"><a href="#12-4-screen对象" class="headerlink" title="12.4 screen对象"></a>12.4 screen对象</h3><p><strong>window</strong> 的另一个属性 <strong>screen</strong> 对象，这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息。</p>
<p><img src="/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell\Documents\img\2024-02-19-11-32-19-image.png"></p>
<h3 id="12-5-history对象"><a href="#12-5-history对象" class="headerlink" title="12.5 history对象"></a>12.5 history对象</h3><p><strong>history</strong> 对象表示当前窗口首次使用以来用户的导航历史记录。因为 <strong>history</strong> 是 <strong>window</strong> 的属性，所以每个 <strong>window</strong> 都有自己的 <strong>history</strong> 对象。</p>
<h4 id="12-5-1-导航"><a href="#12-5-1-导航" class="headerlink" title="12.5.1 导航"></a>12.5.1 导航</h4><p><strong>go()</strong> 方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。负值表示在历史记录中后退（类似点击浏览器的“后退”按钮），而正值表示在历史记录中前进（类似点击浏览器的“前进”按钮）。</p>
<p><strong>go()</strong> 有两个简写方法：**back() 和 forward()**。</p>
<p><strong>history</strong> 对象还有一个 <strong>length</strong> 属性，表示历史记录中有多个条目。这个属性反映了历史记录的数量，包括可以前进和后退的页面。</p>
<p>对于窗口或标签页中加载的第一个页面，<strong>history.length</strong> 等于 <strong>1</strong>。通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面</p>
<p><strong>history</strong> 对象通常被用于创建“后退”和“前进”按钮，以及确定页面是不是用户历史记录中的第一条记录。</p>
<h4 id="12-5-2-历史状态管理"><a href="#12-5-2-历史状态管理" class="headerlink" title="12.5.2 历史状态管理"></a>12.5.2 历史状态管理</h4><p><strong>hashchange</strong> 会在页面 <strong>URL</strong> 的散列变化时被触发，开发者可以在此时执行某些操作。而状态管理 <strong>API</strong> 则可以让开发者改变浏览器 <strong>URL</strong> 而不会加载新页面。为此，可以使用 <strong>history.pushState()</strong> 方法。这个方法接收 <strong>3</strong> 个参数：一个 <strong>state</strong> 对象、一个新状态的标题和一个（可选的）相对 <strong>URL</strong>。</p>
<p><strong>pushState()</strong> 方法执行后，状态信息就会被推到历史记录中，浏览器地址栏也会改变以反映新的相对 <strong>URL</strong>。除了这些变化之外，即使<strong>location.href</strong> 返回的是地址栏中的内容，浏览器页不会向服务器发送请求。第二个参数并未被当前实现所使用，因此既可以传一个空字符串也可以传一个短标题。第一个参数应该包含正确初始化页面状态所必需的信息。为防止滥用，这个状态的对象大小是有限制的，通常在 <strong>500KB～1MB</strong> 以内。</p>
<p>因为 <strong>pushState()</strong> 会创建新的历史记录，所以也会相应地启用“后退”按钮。此时单击“后退”按钮，就会触发 <strong>window</strong>  对象上的 <strong>popstate</strong>事件。<strong>popstate</strong> 事件的事件对象有一个 <strong>state</strong> 属性，其中包含通过 <strong>pushState()</strong> 第一个参数传入的 <strong>state</strong> 对象。</p>
<p>基于这个状态，应该把页面重置为状态对象所表示的状态（因为浏览器不会自动为你做这些）。记住，页面初次加载时没有状态。因此点击“后退”按钮直到返回最初页面时，<strong>event.state</strong> 会为 <strong>null</strong>。<br>可以通过 <strong>history.state</strong> 获取当前的状态对象，也可以使用 <strong>replaceState()</strong> 并传入与 <strong>pushState()</strong> 同样的前两个参数来更新状态。更新状态不会创建新历史记录，只会覆盖当前状态。</p>
<h3 id="12-6-小结"><a href="#12-6-小结" class="headerlink" title="12.6 小结"></a>12.6 小结</h3><p>浏览器对象模型（<strong>BOM，Browser Object Model</strong>）是以 <strong>window</strong> 对象为基础的，这个对象代表了浏览器窗口和页面可见的区域。<strong>window</strong> 对象也被复用为 <strong>ECMAScript</strong> 的 <strong>Global</strong> 对象，因此所有全局变量和函数都是它的属性，而且所有原生类型的构造函数和普通函数也都从一开始就存在于这个对象之上。 </p>
<ul>
<li><p>要引用其他 <strong>window</strong> 对象，可以使用几个不同的窗口指针。 </p>
</li>
<li><p>通过 <strong>location</strong> 对象可以以编程方式操纵浏览器的导航系统。通过设置这个对象上的属性，可以改变浏览器 <strong>URL</strong> 中的某一部分或全部。 </p>
</li>
<li><p>使用 <strong>replace()</strong> 方法可以替换浏览器历史记录中当前显示的页面，并导航到新 <strong>URL</strong>。 </p>
</li>
<li><p><strong>navigator</strong> 对象提供关于浏览器的信息。提供的信息类型取决于浏览器，不过有些属性如 <strong>userAgent</strong> 是所有浏览器都支持的。</p>
</li>
</ul>
<p><strong>BOM</strong> 中的另外两个对象也提供了一些功能。<strong>screen</strong> 对象中保存着客户端显示器的信息。这些信息通常用于评估浏览网站的设备信息。<strong>history</strong> 对象提供了操纵浏览器历史记录的能力，开发者可以确定历史记录中包含多少个条目，并以编程方式实现在历史记录中导航，而且也可以修改历史记录。</p>
<h2 id="十三、客户端检测"><a href="#十三、客户端检测" class="headerlink" title="十三、客户端检测"></a>十三、客户端检测</h2><h3 id="13-1-能力检测"><a href="#13-1-能力检测" class="headerlink" title="13.1 能力检测"></a>13.1 能力检测</h3><p>能力检测（又称特性检测）即在 <strong>JavaScript</strong> 运行时中使用一套简单的检测逻辑，测试浏览器是否支持某种特性。</p>
<p>能力检测的基本模式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.<span class="property">propertyInQuestion</span>) &#123;  </span><br><span class="line">  <span class="comment">// 使用 object.propertyInQuestion </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能力检测的关键是理解两个重要概念。首先，如前所述，应该先检测最常用的方式。其次是必须检测切实需要的特性。</p>
<h4 id="13-1-1-安全能力检测"><a href="#13-1-1-安全能力检测" class="headerlink" title="13.1.1 安全能力检测"></a>13.1.1 安全能力检测</h4><p>能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为。</p>
<p>进行能力检测时应该尽量使用 <strong>typeof</strong> 操作符，但光有它还不够。尤其是某些宿主对象并不保证对 <strong>typeof</strong> 测试返回合理的值。最有名的例子就是 <strong>Internet Explorer（IE）</strong>。在多数浏览器中，下面的代码都会在 <strong>document.createElement()</strong> 存在时返回 <strong>true</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不适用于 IE8 及更低版本 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasCreateElement</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="variable language_">document</span>.<span class="property">createElement</span> == <span class="string">&quot;function&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DOM</strong> 对象是宿主对象，而宿主对象在 <strong>IE8</strong> 及更低版本中是通过 <strong>COM</strong> 而非 <strong>JScript</strong> 实现的。因此，<strong>document.createElement()</strong> 函数被实现为 <strong>COM</strong> 对象，<strong>typeof</strong> 返回”<strong>object</strong>“。<strong>IE9</strong> 对 <strong>DOM</strong> 方法会返回”<strong>function</strong>“。</p>
<h4 id="13-1-2-基于能力检测进行浏览器分析"><a href="#13-1-2-基于能力检测进行浏览器分析" class="headerlink" title="13.1.2 基于能力检测进行浏览器分析"></a>13.1.2 基于能力检测进行浏览器分析</h4><p>恰当地使用能力检测可以精准地分析运行代码的浏览器。使用能力检测而非用户代理检测的优点在于，伪造用户代理字符串很简单，而伪造能够欺骗能力检测的浏览器特性却很难。</p>
<ol>
<li>检测特性</li>
</ol>
<p>可以按照能力将浏览器归类。如果你的应用程序需要使用特定的浏览器能力，那么最好集中检测所有能力，而不是等到用的时候再重复检测。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 检测浏览器是否支持 Netscape 式的插件 </span></span><br><span class="line"><span class="keyword">let</span> hasNSPlugins = !!(navigator.<span class="property">plugins</span> &amp;&amp; navigator.<span class="property">plugins</span>.<span class="property">length</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测浏览器是否具有 DOM Level 1 能力 </span></span><br><span class="line"><span class="keyword">let</span> hasDOM1 = !!(<span class="variable language_">document</span>.<span class="property">getElementById</span> &amp;&amp; <span class="variable language_">document</span>.<span class="property">createElement</span> &amp;&amp; </span><br><span class="line">         <span class="variable language_">document</span>.<span class="property">getElementsByTagName</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检测浏览器</li>
</ol>
<p>可以根据对浏览器特性的检测并与已知特性对比，确认用户使用的是什么浏览器。这样可以获得比用户代码嗅探（稍后讨论）更准确的结果。</p>
<ol start="3">
<li>能力检测的局限</li>
</ol>
<p>通过检测一种或一组能力，并不总能确定使用的是哪种浏览器。</p>
<h3 id="13-2-用户代理检测"><a href="#13-2-用户代理检测" class="headerlink" title="13.2 用户代理检测"></a>13.2 用户代理检测</h3><p>用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。用户代理字符串包含在每个 <strong>HTTP</strong> 请求的头部，在 <strong>JavaScript</strong> 中可以通过 <strong>navigator.userAgent</strong> 访问。在服务器端，常见的做法是根据接收到的用户代理字符串确定浏览器并执行相应操作。而在客户端，用户代理检测被认为是不可靠的，只应该在没有其他选项时再考虑。</p>
<h4 id="13-2-1-用户代理的历史"><a href="#13-2-1-用户代理的历史" class="headerlink" title="13.2.1 用户代理的历史"></a>13.2.1 用户代理的历史</h4><p><strong>HTTP</strong> 规范（<strong>1.0</strong> 和 <strong>1.1</strong>）要求浏览器应该向服务器发送包含浏览器名称和版本信息的简短字符串。</p>
<h4 id="13-2-2-浏览器分析"><a href="#13-2-2-浏览器分析" class="headerlink" title="13.2.2 浏览器分析"></a>13.2.2 浏览器分析</h4><p>想要知道自己代码运行在什么浏览器上，大部分开发者会分析 <strong>window.navigator.userAgent</strong> 返回的字符串值。所有浏览器都会提供这个值，如果相信这些返回值并基于给定的一组浏览器检测这个字符串，最终会得到关于浏览器和操作系统的比较精确的结果。</p>
<p>能力检测可以保证脚本不必理会浏览器而正常执行。现代浏览器用户代理字符串的过去、现在和未来格式都是有章可循的，我们能够利用它们准确识别浏览器。</p>
<ol>
<li>伪造用户代理</li>
</ol>
<p>通过检测用户代理来识别浏览器并不是完美的方式，毕竟这个字符串是可以造假的。只不过实现 <strong>window.navigator</strong> 对象的浏览器（即所有现代浏览器）都会提供 <strong>userAgent</strong> 这个只读属性。因此，简单地给这个属性设置其他值不会有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span> </span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span> = <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span></span><br></pre></td></tr></table></figure>

<p>有些浏览器提供伪私有的  __ defineGetter __  方法，利用它可以篡改用户代理字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) </span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span> </span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="title function_">__defineGetter__</span>(<span class="string">&#x27;userAgent&#x27;</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>); </span><br><span class="line"><span class="comment">// foobar</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>分析浏览器</li>
</ol>
<p>通过解析浏览器返回的用户代理字符串，可以极其准确地推断出下列相关的环境信息： </p>
<ul>
<li><p>浏览器 </p>
</li>
<li><p>浏览器版本 </p>
</li>
<li><p>浏览器渲染引擎 </p>
</li>
<li><p>设备类型（桌面/移动） </p>
</li>
<li><p>设备生产商 </p>
</li>
<li><p>设备型号 </p>
</li>
<li><p>操作系统 </p>
</li>
<li><p>操作系统版本</p>
</li>
</ul>
<p>这里推荐一些 <strong>GitHub</strong> 上维护比较频繁的第三方用户代理解析程序：</p>
<ul>
<li><p>Bowser </p>
</li>
<li><p>UAParser.js </p>
</li>
<li><p>Platform.js </p>
</li>
<li><p>CURRENT-DEVICE </p>
</li>
<li><p>Google Closure </p>
</li>
<li><p>Mootools</p>
</li>
</ul>
<h3 id="13-3-软件与硬件检测"><a href="#13-3-软件与硬件检测" class="headerlink" title="13.3 软件与硬件检测"></a>13.3 软件与硬件检测</h3><p>现代浏览器提供了一组与页面执行环境相关的信息，包括浏览器、操作系统、硬件和周边设备信息。这些属性可以通过暴露在 <strong>window.navigator</strong> 上的一组 <strong>API</strong> 获得。不过，这些 <strong>API</strong> 的跨浏览器支持还不够好，远未达到标准化的程度。</p>
<h4 id="13-3-1-识别浏览器与操作系统"><a href="#13-3-1-识别浏览器与操作系统" class="headerlink" title="13.3.1 识别浏览器与操作系统"></a>13.3.1 识别浏览器与操作系统</h4><p>特性检测和用户代理字符串解析是当前常用的两种识别浏览器的方式。而 <strong>navigator</strong> 和 <strong>screen</strong> 对象也提供了关于页面所在软件环境的信息。</p>
<ol>
<li>navigator.oscpu</li>
</ol>
<p><strong>navigator.oscpu</strong> 属性是一个字符串，通常对应用户代理字符串中操作系统/系统架构相关信息。根据 <strong>HTML</strong> 实时标准：<strong>oscpu</strong> 属性的获取方法必须返回空字符串或者表示浏览器所在平台的字符串，比如”<strong>Windows NT 10.0; Win64; x64”或”Linux x86_64</strong>“。</p>
<ol start="2">
<li>navigator.vendor</li>
</ol>
<p><strong>navigator.vendor</strong> 属性是一个字符串，通常包含浏览器开发商信息。返回这个字符串是浏览器 <strong>navigator</strong> 兼容模式的一个功能。根据 <strong>HTML</strong> 实时标准：<strong>navigator.vendor</strong> 返回一个空字符串，也可能返回字符串”<strong>Apple Computer, Inc.</strong>“或字符串”<strong>Google Inc.</strong>“。</p>
<ol start="3">
<li>navigator.platform</li>
</ol>
<p><strong>navigator.platform</strong> 属性是一个字符串，通常表示浏览器所在的操作系统。根据 <strong>HTML</strong> 实时标准：<strong>navigator.platform</strong> 必须返回一个字符串或表示浏览器所在平台的字符串，例如”<strong>MacIntel”、”Win32”、”FreeBSD i386”或”WebTV OS</strong>“</p>
<ol start="4">
<li>screen.colorDepth和screen.pixelDepth</li>
</ol>
<p><strong>screen.colorDepth和screen.pixelDepth</strong> 返回一样的值，即显示器每像素颜色的位深。根据 <strong>CSS</strong> 对象模型（<strong>CSSOM</strong>）规范：<br><strong>screen.colorDepth 和 screen.pixelDepth</strong>属性应该返回输出设备中每像素用于显示颜色的位数，不包含 <strong>alpha</strong> 通道。</p>
<ol start="5">
<li>screen.orientation</li>
</ol>
<p><strong>screen.orientation</strong> 属性返回一个 <strong>ScreenOrientation</strong> 对象，其中包含 <strong>Screen Orientation API</strong> 定义的屏幕信息。这里面最有意思的属性是 <strong>angle 和 type</strong>，前者返回相对于默认状态下屏幕的角度，后者返回以下 <strong>4</strong> 种枚举值之一：</p>
<ul>
<li><p>portrait-primary </p>
</li>
<li><p>portrait-secondary </p>
</li>
<li><p>landscape-primary </p>
</li>
<li><p>landscape-secondary</p>
</li>
</ul>
<h4 id="13-3-2-浏览器元数据"><a href="#13-3-2-浏览器元数据" class="headerlink" title="13.3.2 浏览器元数据"></a>13.3.2 浏览器元数据</h4><p><strong>navigator</strong> 对象暴露出一些 <strong>API</strong>，可以提供浏览器和操作系统的状态信息。</p>
<ol>
<li>Geolocation API</li>
</ol>
<p><strong>navigator.geolocation</strong>属性暴露了 <strong>Geolocation API</strong>，可以让浏览器脚本感知当前设备的地理位置。这个 <strong>API</strong> 只在安全执行环境（通过 <strong>HTTPS</strong> 获取的脚本）中可用。<br>这个 <strong>API</strong> 可以查询宿主系统并尽可能精确地返回设备的位置信息。</p>
<p>根据 <strong>Geolocation API</strong> 规范： 地理位置信息的主要来源是 <strong>GPS</strong> 和 <strong>IP</strong> 地址、射频识别（<strong>RFID</strong>）、<strong>Wi-Fi</strong> 及蓝牙 <strong>Mac</strong> 地址、<strong>GSM/CDMA</strong> 蜂窝 <strong>ID</strong> 以及用户输入等信息。</p>
<p>要获取浏览 器当前的位置，可以使用 <strong>getCurrentPosition()</strong> 方法。这个方法返回一个 <strong>Coordinates</strong> 对象，其中包含的信息不一定完全依赖宿主系统的能力。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getCurrentPosition()会以 position 对象为参数调用传入的回调函数 </span></span><br><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> p = position);</span><br></pre></td></tr></table></figure>

<p>这个 <strong>position</strong> 对象中有一个表示查询时间的时间戳，以及包含坐标信息的 <strong>Coordinates</strong>n 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">timestamp</span>);  <span class="comment">// 1525364883361 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">coords</span>);     <span class="comment">// Coordinates &#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Coordinates</strong> 对象中包含标准格式的经度和纬度，以及以米为单位的精度。精度同样以确定设备位置的机制来判定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">coords</span>.<span class="property">latitude</span>, p.<span class="property">coords</span>.<span class="property">longitude</span>);   <span class="comment">// 37.4854409, -122.2325506 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">coords</span>.<span class="property">accuracy</span>);                       <span class="comment">// 58</span></span><br></pre></td></tr></table></figure>

<p><strong>Coordinates</strong> 对象包含一个 <strong>altitude</strong>（海拔高度）属性，是相对于 <strong>1984</strong> 世界大地坐标系（<strong>World Geodetic System，1984</strong>）地球表面的以米为单位的距离。此外也有一个 <strong>altitudeAccuracy</strong> 属性，这个精度值单位也是米。为了取得 <strong>Coordinates</strong> 中包含的这些信息，当前设备必须具备相应的能力（比如 <strong>GPS</strong> 或高度计）。很多设备因为没有能力测量高度，所以这两个值经常有一个或两个是空的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">coords</span>.<span class="property">altitude</span>);          <span class="comment">// -8.800000190734863 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">coords</span>.<span class="property">altitudeAccuracy</span>);  <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<p><strong>Coordinates</strong> 对象包含一个 <strong>speed</strong> 属性，表示设备每秒移动的速度。还有一个 <strong>heading</strong>（朝向）属性，表示相对于正北方向移动的角度（<strong>0 ≤ heading &lt; 360</strong>）。为获取这些信息，当前设备必须具备相应的能力（比如加速计或指南针）。很多设备因为没有能力测量高度，所以这两个值经常有一个是空的，或者两个都是空的。</p>
<p><strong>getCurrentPosition()</strong> 方法也接收失败回调函数作为第二个参数，这个函数会收到一个 <strong>PositionError</strong> 对象。在失败的情况下，<strong>PositionError</strong> 对象中会包含一个 <strong>code</strong> 属性和一个 <strong>message</strong> 属性，后者包含对错误的简短描述。<strong>code</strong> 属性是一个整数，表示以下 <strong>3</strong> 种错误。</p>
<ul>
<li><p><strong>PERMISSION_DENIED</strong>：浏览器未被允许访问设备位置。页面第一次尝试访问 <strong>Geolocation API</strong> 时，浏览器会弹出确认对话框取得用户授权（每个域分别获取）。如果返回了这个错误码，则要么是用户不同意授权，要么是在不安全的环境下访问了 <strong>Geolocation API</strong>。<strong>message</strong>属性还会提供额外信息。 </p>
</li>
<li><p><strong>POSITION_UNAVAILABLE</strong>：系统无法返回任何位置信息。这个错误码可能代表各种失败原因，但相对来说并不常见，因为只要设备能上网，就至少可以根据 <strong>IP</strong> 地址返回一个低精度的坐标。 </p>
</li>
<li><p><strong>TIMEOUT</strong>：系统不能在超时时间内返回位置信息。</p>
</li>
</ul>
<p><strong>Geolocation API</strong> 位置请求可以使用 <strong>PositionOptions</strong> 对象来配置，作为第三个参数提供。这个对象支持以下 3 个属性。</p>
<ul>
<li><p><strong>enableHighAccuracy</strong>：布尔值，<strong>true</strong> 表示返回的值应该尽量精确，默认值为 <strong>false</strong>。默认情况下，设备通常会选择最快、最省电的方式返回坐标。这通常意味着返回的是不够精确的坐标。比如，在移动设备上，默认位置查询通常只会采用 <strong>Wi-Fi</strong> 和蜂窝网络的定位信息。而在 <strong>enableHighAccuracy</strong> 为 <strong>true</strong> 的情况下，则会使用设备的 <strong>GPS</strong> 确定设备位置，并返回这些值的混合结果。使用 <strong>GPS</strong> 会更耗时、耗电，因此在使用 <strong>enableHighAccuracy</strong> 配置时要仔细权衡一下。 </p>
</li>
<li><p><strong>timeout</strong>：毫秒，表示在以TIMEOUT状态调用错误回调函数之前等待的最长时间。默认值是 <strong>0xFFFFFFFF（232 – 1）</strong>。<strong>0</strong> 表示完全跳过系统调用而立即以 <strong>TIMEOUT</strong> 调用错误回调函数。 </p>
</li>
<li><p><strong>maximumAge</strong>：毫秒，表示返回坐标的最长有效期，默认值为 <strong>0</strong>。因为查询设备位置会消耗资源，所以系统通常会缓存坐标并在下次返回缓存的值（遵从位置缓存失效策略）。系统会计算缓存期，如果 <strong>Geolocation API</strong> 请求的配置要求比缓存的结果更新，则系统会重新查询并返回值。<strong>0</strong> 表示强制系统忽略缓存的值，每次都重新查询。而 <strong>Infinity</strong> 会阻止系统重新查询，只会返回缓存的值。<strong>JavaScript</strong> 可以通过检查 <strong>Position</strong> 对象的 <strong>timestamp</strong> 属性值是否重复来判断返回的是不是缓存值。</p>
</li>
</ul>
<ol start="2">
<li>Connection State 和 NetworkInformation API</li>
</ol>
<p>浏览器会跟踪网络连接状态并以两种方式暴露这些信息：连接事件和<strong>navigator.onLine</strong> 属性。在设备连接到网络时，浏览器会记录这个事实并在 <strong>window</strong> 对象上触发 <strong>online</strong> 事件。相应地，当设备断开网络连接后，浏览器会在 <strong>window</strong> 对象上触发 <strong>offline</strong> 事件。任何时候，都可以通过 <strong>navigator. onLine</strong> 属性来确定浏览器的联网状态。这个属性返回一个布尔值，表示浏览器是否联网。</p>
<p><strong>navigator</strong> 对象还暴露了 <strong>NetworkInformation API</strong>，可以通过 <strong>navigator.connection</strong> 属性使用。这个 <strong>API</strong> 提供了一些只读属性，并为连接属性变化事件处理程序定义了一个事件对象。</p>
<h4 id="13-3-3-硬件"><a href="#13-3-3-硬件" class="headerlink" title="13.3.3 硬件"></a>13.3.3 硬件</h4><p><strong>navigator</strong> 对象通过一些属性提供了基本信息。</p>
<ol>
<li><p>处理器核心数 </p>
<p><strong>navigator.hardwareConcurrency</strong> 属性返回浏览器支持的逻辑处理器核心数量，包含表示核心数的一个整数值（如果核心数无法确定，这个值就是 <strong>1</strong>）。关键在于，这个值表示浏览器可以并行执行的最大工作线程数量，不一定是实际的 <strong>CPU</strong> 核心数。</p>
</li>
<li><p>设备内存大小<br><strong>navigator.deviceMemory</strong> 属性返回设备大致的系统内存大小，包含单位为 <strong>GB</strong> 的浮点数（舍入为最接近的 <strong>2</strong> 的幂：<strong>512MB</strong> 返回 <strong>0.5</strong>，<strong>4GB</strong> 返回 <strong>4</strong>）。 </p>
</li>
<li><p>最大触点数<br><strong>navigator.maxTouchPoints</strong> 属性返回触摸屏支持的最大关联触点数量，包含一个整数值。</p>
</li>
</ol>
<h3 id="13-4-小结"><a href="#13-4-小结" class="headerlink" title="13.4 小结"></a>13.4 小结</h3><p>客户端检测是 <strong>JavaScript</strong> 中争议最多的话题之一。因为不同浏览器之间存在差异，所以经常需要根据浏览器的能力来编写不同的代码。客户端检测有不少方式，但下面两种用得最多。</p>
<ul>
<li><p><strong>能力检测</strong>，在使用之前先测试浏览器的特定能力。例如，脚本可以在调用某个函数之前先检查它是否存在。这种客户端检测方式可以让开发者不必考虑特定的浏览器或版本，而只需关注某些能力是否存在。能力检测不能精确地反映特定的浏览器或版本。 </p>
</li>
<li><p><strong>用户代理检测</strong>，通过用户代理字符串确定浏览器。用户代理字符串包含关于浏览器的很多信息，通常包括浏览器、平台、操作系统和浏览器版本。用户代理字符串有一个相当长的发展史，很多浏览器都试图欺骗网站相信自己是别的浏览器。用户代理检测也比较麻烦，特别是涉及 <strong>Opera</strong> 会在代理字符串中隐藏自己信息的时候。即使如此，用户代理字符串也可以用来确定浏览器使用的渲染引擎以及平台，包括移动设备和游戏机。</p>
</li>
</ul>
<p>在选择客户端检测方法时，首选是使用能力检测。特殊能力检测要放在次要位置，作为决定代码逻辑的参考。用户代理检测是最后一个选择，因为它过于依赖用户代理字符串。<br>浏览器也提供了一些软件和硬件相关的信息。这些信息通过 <strong>screen</strong> 和 <strong>navigator</strong> 对象暴露出来。利用这些 <strong>API</strong>，可以获取关于操作系统、浏览器、硬件、设备位置、电池状态等方面的准确信息。</p>
<h2 id="十四、DOM"><a href="#十四、DOM" class="headerlink" title="十四、DOM"></a>十四、DOM</h2><p>文档对象模型（<strong>DOM，Document Object Model</strong>）是 <strong>HTML</strong> 和 <strong>XML</strong> 文档的编程接口。<strong>DOM</strong> 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。</p>
<h3 id="14-1-节点层级"><a href="#14-1-节点层级" class="headerlink" title="14.1 节点层级"></a>14.1 节点层级</h3><p>任何 <strong>HTML</strong> 或 <strong>XML</strong> 文档都可以用 <strong>DOM</strong> 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。</p>
<p><strong>document</strong> 节点表示每个文档的根节点。在这里，根节点的唯一子节点是 <strong><html></html></strong> 元素，我们称之为文档元素（<strong>documentElement</strong>）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 <strong>HTML</strong> 页面中，文档元素始终是 <strong><html></html></strong> 元素。在 <strong>XML</strong> 文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。<br><strong>HTML</strong> 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 <strong>HTML</strong> 元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。<strong>DOM</strong> 中总共有 <strong>12</strong> 种节点类型，这些类型都继承一种基本类型。</p>
<h4 id="14-1-1-Node类型"><a href="#14-1-1-Node类型" class="headerlink" title="14.1.1 Node类型"></a>14.1.1 Node类型</h4><p><strong>DOM Level 1</strong> 描述了名为 <strong>Node</strong> 的接口，这个接口是所有 <strong>DOM</strong> 节点类型都必须实现的。<strong>Node</strong> 接口在 <strong>JavaScript</strong> 中被实现为 <strong>Node</strong> 类型，在除 <strong>IE</strong> 之外的所有浏览器中都可以直接访问这个类型。在 <strong>JavaScript</strong> 中，所有节点类型都继承 <strong>Node</strong> 类型，因此所有类型都共享相同的基本属性和方法。<br>每个节点都有 <strong>nodeType</strong> 属性，表示该节点的类型。节点类型由定义在 <strong>Node</strong> 类型上的 <strong>12</strong> 个数值常量表示：</p>
<ul>
<li><p>Node.ELEMENT_NODE（1）</p>
</li>
<li><p>Node.ATTRIBUTE_NODE（2）</p>
</li>
<li><p>Node.TEXT_NODE（3）</p>
</li>
<li><p>Node.CDATA_SECTION_NODE（4）</p>
</li>
<li><p>Node.ENTITY_REFERENCE_NODE（5）</p>
</li>
<li><p>Node.ENTITY_NODE（6）</p>
</li>
<li><p>Node.PROCESSING_INSTRUCTION_NODE（7）</p>
</li>
<li><p>Node.COMMENT_NODE（8）</p>
</li>
<li><p>Node.DOCUMENT_NODE（9）</p>
</li>
<li><p>Node.DOCUMENT_TYPE_NODE（10）</p>
</li>
<li><p>Node.DOCUMENT_FRAGMENT_NODE（11）</p>
</li>
<li><p>Node.NOTATION_NODE（12）</p>
</li>
</ul>
<p>节点类型可通过与这些常量比较来确定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="title class_">Node</span>.<span class="property">ELEMENT_NODE</span>)&#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Node is an element.&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol>
<li>nodeName与nodeValue</li>
</ol>
<p><strong>nodeName</strong> 与 <strong>nodeValue</strong> 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>)&#123; </span><br><span class="line">  value = someNode.<span class="property">nodeName</span>; <span class="comment">// 会显示元素的标签名 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对元素而言，<strong>nodeName</strong> 始终等于元素的标签名，而 <strong>nodeValue</strong> 则始终为 <strong>null</strong>。</p>
<ol start="2">
<li>节点关系</li>
</ol>
<p>文档中的所有节点都与其他节点有关系。</p>
<p>每个节点都有一个 <strong>childNodes</strong> 属性，其中包含一个 <strong>NodeList</strong> 的实例。<strong>NodeList</strong> 是一个类数组对象，用于存储可以按位置存取的有序节点。注意，<strong>NodeList</strong> 并不是 <strong>Array</strong> 的实例，但可以使用中括号访问它的值，而且它也有 <strong>length</strong> 属性。<strong>NodeList</strong> 对象独特的地方在于，它其实是一个对 <strong>DOM</strong> 结构的查询，因此 <strong>DOM</strong> 结构的变化会自动地在 <strong>NodeList</strong> 中反映出来。我们通常说 <strong>NodeList</strong> 是实时的活动对象，而不是第一次访问时所获得内容的快照。</p>
<blockquote>
<p><strong>length</strong> 属性表示那一时刻 <strong>NodeList</strong> 中节点的数量。使用 <strong>Array.prototype. slice()</strong> 可以像 <strong>arguments</strong> 时一样把 <strong>NodeList</strong> 对象转换为数组。</p>
</blockquote>
<p>每个节点都有一个 <strong>parentNode</strong> 属性，指向其 <strong>DOM</strong> 树中的父元素。<strong>childNodes</strong> 中的所有节点都有同一个父元素，因此它们的 <strong>parentNode</strong> 属性都指向同一个节点。此外，<strong>childNodes</strong> 列表中的每个节点都是同一列表中其他节点的同胞节点。而使用 <strong>previousSibling</strong> 和 <strong>nextSibling</strong> 可以在这个列表的节点间导航。这个列表中第一个节点的 <strong>previousSibling</strong> 属性是 <strong>null</strong>，最后一个节点的 <strong>nextSibling</strong> 属性也是 <strong>null</strong>。</p>
<blockquote>
<p>如果 <strong>childNodes</strong> 中只有一个节点，则它的 <strong>previousSibling</strong> 和 <strong>nextSibling</strong> 属性都是 <strong>null</strong>。</p>
</blockquote>
<p>父节点和它的第一个及最后一个子节点也有专门属性：<strong>firstChild</strong> 和 <strong>lastChild</strong> 分别指向 <strong>childNodes</strong> 中的第一个和最后一个子节点。</p>
<p>如果只有一个子节点，则 <strong>firstChild</strong> 和 <strong>lastChild</strong> 指向同一个节点。如果没有子节点，则 <strong>firstChild</strong> 和 <strong>lastChild</strong> 都是 <strong>null</strong>。</p>
<p><img src="/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/dell\Documents\img\2024-02-20-15-19-02-image.png"></p>
<p><strong>hasChildNodes()</strong> 方法如果返回 <strong>true</strong> 则说明节点有一个或多个子节点。</p>
<p>所有节点都共享的关系 —— <strong>ownerDocument</strong> 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。</p>
<blockquote>
<p>虽然所有节点类型都继承了<strong>Node</strong>，但并非所有节点都有子节点。</p>
</blockquote>
<ol start="3">
<li>操纵节点</li>
</ol>
<p>因为所有关系指针都是只读的，所以 <strong>DOM</strong> 又提供了一些操纵节点的方法。最常用的方法是 <strong>appendChild()<strong>，用于在 <strong>childNodes</strong> 列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。</strong>appendChild()</strong> 方法返回新添加的节点。</p>
<p>如果把文档中已经存在的节点传给 **appendChild()**，则这个节点会从之前的位置被转移到新位置。即使 <strong>DOM</strong> 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此，如果调用 <strong>appendChild()</strong> 传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点。</p>
<p>如果想把节点放到 <strong>childNodes</strong> 中的特定位置而不是末尾，则可以使用 <strong>insertBefore()</strong> 方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是 <strong>null</strong>，则 <strong>insertBefore() 与 appendChild()</strong> 效果相同。</p>
<p><strong>appendChild()</strong> 和 <strong>insertBefore()</strong> 在插入节点时不会删除任何已有节点 。相对地 ，<strong>replaceChild()</strong> 方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。</p>
<p>使用 <strong>replaceChild()</strong> 插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p>
<p>要移除节点而不是替换节点，可以使用 <strong>removeChild()</strong> 方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回。</p>
<p>与 <strong>replaceChild()</strong> 方法一样，通过 <strong>removeChild()</strong> 被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p>
<p>上面 <strong>4</strong> 个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。</p>
<ol start="4">
<li>其他方法</li>
</ol>
<p>所有节点类型还共享了两个方法。第一个是 <strong>cloneNode()<strong>，会返回与调用它的节点一模一样的节点。</strong>cloneNode()</strong> 方法接收一个布尔值参数，表示是否深复制。在传入 <strong>true</strong> 参数时，会进行深复制，即复制节点及其整个子 <strong>DOM</strong> 树。如果传入 <strong>false</strong>，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（<strong>orphan</strong>）。可以通过 <strong>appendChild()、insertBefore() 或 replaceChild()</strong> 方法把孤儿节点添加到文档中。</p>
<blockquote>
<p><strong>cloneNode()</strong> 方法不会复制添加到 <strong>DOM</strong> 节点的 <strong>JavaScript</strong> 属性，比如事件处理程序。这个方法只复制 <strong>HTML</strong> 属性，以及可选地复制子节点。除此之外则一概不会复制。<strong>IE</strong> 在很长时间内会复制事件处理程序，这是一个 <strong>bug</strong>，所以推荐在复制前先删除事件处理程序。</p>
</blockquote>
<p><strong>normalize()</strong> 方法唯一的任务就是处理文档子树中的文本节点。在节点上调用 <strong>normalize()</strong> 方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。</p>
<h4 id="14-1-2-Document类型"><a href="#14-1-2-Document类型" class="headerlink" title="14.1.2 Document类型"></a>14.1.2 Document类型</h4><p><strong>Document</strong> 类型是 <strong>JavaScript</strong> 中表示文档节点的类型。在浏览器中，文档对象 <strong>document</strong> 是 <strong>HTMLDocument</strong> 的实例（<strong>HTMLDocument</strong> 继承 <strong>Document</strong>），表示整个 <strong>HTML</strong> 页面。<strong>document</strong> 是 <strong>window</strong> 对象的属性，因此是一个全局对象。<strong>Document</strong> 类型的节点有以下特征：</p>
<ul>
<li><p><strong>nodeType</strong> 等于 9； </p>
</li>
<li><p><strong>nodeName</strong> 值为”#document”； </p>
</li>
<li><p><strong>nodeValue</strong> 值为null； </p>
</li>
<li><p><strong>parentNode</strong> 值为null； </p>
</li>
<li><p><strong>ownerDocument</strong> 值为null； </p>
</li>
<li><p>子节点可以是 <strong>DocumentType</strong>（最多一个）、<strong>Element</strong>（最多一个）、<strong>ProcessingInstruction</strong> 或 <strong>Comment</strong> 类型。</p>
</li>
</ul>
<p><strong>Document</strong> 类型可以表示 <strong>HTML</strong> 页面或其他 <strong>XML</strong> 文档，但最常用的还是通过 <strong>HTMLDocument</strong> 的实例取得 <strong>document</strong> 对象。<strong>document</strong> 对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p>
<ol>
<li>文档子节点</li>
</ol>
<p>两个访问子节点的快捷方式。第一个是 <strong>documentElement</strong> 属性，始终指向 <strong>HTML</strong> 页面中的 <strong><html></html></strong> 元素。</p>
<p>作为 <strong>HTMLDocument</strong> 的实例，<strong>document</strong> 对象还有一个 <strong>body</strong> 属性，直接指向 <strong><body></body></strong> 元素。</p>
<p>所有主流浏览器都支持 <strong>document.documentElement 和 document.body</strong>。</p>
<p><strong>Document</strong> 类型另一种可能的子节点是 <strong>DocumentType</strong>。**&lt;!doctype&gt;** 标签是文档中独立的部分，其信息可以通过 <strong>doctype</strong> 属性（在浏览器中是 <strong>document.doctype</strong>）来访问。</p>
<p>另外，严格来讲出现在 <strong><html></html></strong> 元素外面的注释也是文档的子节点，它们的类型是 <strong>Comment</strong>。</p>
<p>一般来说，<strong>appendChild()、removeChild()和replaceChild()</strong> 方法不会用在 <strong>document</strong> 对象上。这是因为文档类型（如果存在）是只读的，而且只能有一个 <strong>Element</strong> 类型的子节点（即 **<html>**，已经存在了）。</html></p>
<ol start="2">
<li>文档信息</li>
</ol>
<p><strong>document</strong> 作为 <strong>HTMLDocument</strong> 的实例，还有一些标准  <strong>Document</strong> 对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是 <strong>title</strong>，包含 <strong><title></title></strong> 元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改 <strong>title</strong> 属性并不会改变 <strong><title></title></strong> 元素。</p>
<p><strong>URL</strong> 包含当前页面的完整 <strong>URL</strong>（地址栏中的 <strong>URL</strong>），<strong>domain</strong> 包含页面的域名，而 <strong>referrer</strong> 包含链接到当前页面的那个页面的 <strong>URL</strong>。如果当前页面没有来源，则 <strong>referrer</strong> 属性包含空字符串。所有这些信息都可以在请求的   <strong>HTTP</strong> 头部信息中获取，只是在 <strong>JavaScript</strong> 中通过这几个属性暴露出来而已。</p>
<p>在这些属性中，只有 <strong>domain</strong> 属性是可以设置的。出于安全考虑，给 <strong>domain</strong> 属性设置的值是有限制的。不能给这个属性设置 <strong>URL</strong> 中不包含的值。</p>
<p>当页面中包含来自某个不同子域的窗格（**<frame><strong>）或内嵌窗格（</strong><iframe>**）时，设置 <strong>document.domain</strong> 是有用的。</iframe></p>
<p>浏览器对 <strong>domain</strong> 属性还有一个限制 ，即这个属性一旦放松就不能再收紧 。比如，把 <strong>document.domain</strong> 设置为”<strong>wrox.com</strong>“之后，就不能再将其设置回”<strong>p2p.wrox.com</strong>“，后者会导致错误。</p>
<ol start="3">
<li>定位元素</li>
</ol>
<p>使用 <strong>DOM</strong> 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。<strong>document</strong> 对象上暴露了一些方法，可以实现这些操作。<strong>getElementById() 和 getElementsByTagName()</strong> 就是 <strong>Document</strong> 类型提供的两个方法。<br><strong>getElementById()</strong> 方法接收一个参数，即要获取元素的 <strong>ID</strong>，如果找到了则返回这个元素，如果没找到则返回 <strong>null</strong>。参数 <strong>ID</strong> 必须跟元素在页面中的 <strong>id</strong> 属性值完全匹配，包括大小写。</p>
<p>如果页面中存在多个具有相同 <strong>ID</strong> 的元素，则 <strong>getElementById()</strong> 返回在文档中出现的第一个元素。 </p>
<p><strong>getElementsByTagName()</strong> 是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的 <strong>NodeList</strong>。在 HTML 文档中，这个方法返回一个 <strong>HTMLCollection</strong> 对象。</p>
<p><strong>HTMLCollection</strong> 对象还有一个额外的方法 **namedItem()**，可通过标签的 <strong>name</strong> 属性取得某一项的引用。对于 <strong>name</strong> 属性的元素，还可以直接使用中括号来获取。</p>
<p>对 <strong>HTMLCollection</strong> 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用 **item()**，字符串索引会调用 **namedItem()**。 </p>
<p>要取得文档中的所有元素，可以给 <strong>getElementsByTagName()</strong> 传入 <em><strong><strong>。在 <strong>JavaScript</strong> 和</strong> CSS</strong> 中，</em>**** 一般被认为是匹配一切的字符。</p>
<p><strong>HTMLDocument</strong> 类型上定义的获取元素的第三个方法是 <strong>getElementsByName()<strong>。这个方法会返回具有给定 <strong>name</strong> 属性的所有元素。</strong>getElementsByName()</strong> 方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的 <strong>name</strong> 属性才能确保把正确的值发送给服务器。</p>
<p>与 <strong>getElementsByTagName()</strong> 一样，<strong>getElementsByName()</strong> 方法也返回 <strong>HTMLCollection</strong>。不过在这种情况下，<strong>namedItem()</strong> 方法只会取得第一项（因为所有项的 <strong>name</strong> 属性都一样）。</p>
<ol start="4">
<li>特殊集合</li>
</ol>
<p><strong>document</strong> 对象上还暴露了几个特殊集合，这些集合也都是 <strong>HTMLCollection</strong> 的实例。这些集合是访问文档中公共部分的快捷方式。</p>
<ul>
<li><p><strong>document.anchors</strong> 包含文档中所有带 <strong>name</strong> 属性的 <strong><a></a></strong> 元素。 </p>
</li>
<li><p><strong>document.forms</strong> 包含文档中所有 <strong><form></form></strong> 元素。</p>
</li>
<li><p><strong>document.images</strong>包含文档中所有 <strong>img</strong> 元素。</p>
</li>
<li><p><strong>document.links</strong> 包含文档中所有带 <strong>href</strong> 属性的 <strong><a></a></strong> 元素。</p>
</li>
</ul>
<ol start="5">
<li><strong>DOM</strong> 兼容性检测</li>
</ol>
<p><strong>document.implementation</strong> 属性是一个对象，其中提供了与浏览器 <strong>DOM</strong> 实现相关的信息和能力。</p>
<p><strong>DOM Level 1</strong> 在 <strong>document.implementation</strong> 上只定义了一个方法，即 **hasFeature()**。这个方法接收两个参数：特性名称和 <strong>DOM</strong> 版本。如果浏览器支持指定的特性和版本，则 <strong>hasFeature()</strong> 方法返回 <strong>true</strong>。</p>
<ol start="6">
<li>文档写入</li>
</ol>
<p><strong>document</strong> 对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法：<strong>write()、writeln()、open()和close()<strong>。其中，</strong>write() 和 writeln()</strong> 方法都接收一个字符串参数，可以将这个字符串写入网页中。<strong>write()</strong> 简单地写入文本，而 <strong>writeln()</strong> 还会在字符串末尾追加一个换行符 <strong>（\n）</strong>。这两个方法可以用来在页面加载期间向页面中动态添加内容。</p>
<p><strong>write()和writeln()</strong> 方法经常用于动态包含外部资源，如 <strong>JavaScript</strong> 文件。在包含 <strong>JavaScript</strong> 文件时，记住不能像下面的例子中这样直接包含字符串”<strong>&lt;/**script**&gt;</strong>“，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行。</p>
<p>如果是在页面加载完之后再调用 **document.write()**，则输出的内容会重写整个页面。</p>
<p><strong>open()和close()</strong> 方法分别用于打开和关闭网页输出流。在调用 <strong>write()和writeln()</strong> 时，这两个方法都不是必需的。</p>
<h4 id="14-1-3-Element类型"><a href="#14-1-3-Element类型" class="headerlink" title="14.1.3 Element类型"></a>14.1.3 Element类型</h4><p><strong>Element</strong> 表示 <strong>XML</strong> 或 <strong>HTML</strong> 元素，对外暴露出访问元素标签名、子节点和属性的能力。<strong>Element</strong> 类型的节点具有以下特征：</p>
<ul>
<li><p><strong>nodeType</strong> 等于 1；</p>
</li>
<li><p><strong>nodeName</strong> 值为元素的标签名； </p>
</li>
<li><p><strong>nodeValue</strong> 值为 <strong>null</strong>； </p>
</li>
<li><p><strong>parentNode</strong> 值为 <strong>Document</strong> 或 <strong>Element</strong> 对象； </p>
</li>
<li><p>子节点可以是 <strong>Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference</strong> 类型。</p>
</li>
</ul>
<p>可以通过 <strong>nodeName</strong> 或 <strong>tagName</strong> 属性来获取元素的标签名。这两个属性返回同样的值。</p>
<p>在 <strong>HTML</strong> 中，元素标签名始终以全大写表示；在 <strong>XML</strong>（包括 <strong>XHTML</strong>）中，标签名始终与源代码中的大小写一致。如果不确定脚本是在 <strong>HTML</strong> 文档还是 <strong>XML</strong> 文档中运行，最好将标签名转换为小写形式，以便于比较。</p>
<ol>
<li>HTML 元素</li>
</ol>
<p>所有 <strong>HTML</strong> 元素都通过 <strong>HTMLElement</strong> 类型表示，包括其直接实例和间接实例。另外，<strong>HTMLElement</strong> 直接继承 <strong>Element</strong> 并增加了一些属性。每个属性都对应下列属性之一，它们是所有 <strong>HTML</strong> 元素上都有的标准属性：</p>
<ul>
<li><p><strong>id</strong>，元素在文档中的唯一标识符； </p>
</li>
<li><p><strong>title</strong>，包含元素的额外信息，通常以提示条形式展示； </p>
</li>
<li><p><strong>lang</strong>，元素内容的语言代码（很少用）； </p>
</li>
<li><p><strong>dir</strong>，语言的书写方向（”<strong>ltr</strong>“表示从左到右，”<strong>rtl</strong>“表示从右到左，同样很少用）； </p>
</li>
<li><p><strong>className</strong>，相当于 <strong>class</strong> 属性，用于指定元素的 <strong>CSS</strong> 类（因为 <strong>class</strong> 是 <strong>ECMAScript</strong> 关键字，所以不能直接用这个名字）。</p>
</li>
</ul>
<ol start="2">
<li>取得属性</li>
</ol>
<p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 <strong>DOM</strong> 方法主要有 <strong>3</strong> 个：**getAttribute()、setAttribute()和removeAttribute()**。这些方法主要用于操纵属性，包括在 <strong>HTMLElement</strong> 类型上定义的属性。</p>
<p>如果给定的属性不存在，则 <strong>getAttribute()</strong> 返回 <strong>null</strong>。</p>
<p><strong>getAttribute()</strong> 方法也能取得不是 <strong>HTML</strong> 语言正式属性的自定义属性的值。</p>
<blockquote>
<p>属性名不区分大小写，因此”ID”和”id”被认为是同一个属性。另外，根据 HTML5 规范的要求，自定义属性名应该前缀 <strong>data-</strong> 以方便验证。</p>
</blockquote>
<p>元素的所有属性也可以通过相应 <strong>DOM</strong> 元素对象的属性来取得。当然，这包括 <strong>HTMLElement</strong> 上定义的直接映射对应属性的 <strong>5</strong> 个属性，还有所有公认（非自定义）的属性也会被添加为 <strong>DOM</strong> 对象的属性。</p>
<p>通过 <strong>DOM</strong> 对象访问的属性中有两个返回的值跟使用 <strong>getAttribute()</strong> 取得的值不一样。首先是 <strong>style</strong> 属性，这个属性用于为元素设定 <strong>CSS</strong> 样式。在使用 <strong>getAttribute()</strong> 访问 <strong>style</strong> 属性时，返回的是 <strong>CSS</strong> 字符串。而在通过 <strong>DOM</strong> 对象的属性访问时，<strong>style</strong> 属性返回的是一个（<strong>CSSStyleDeclaration</strong>）对象。 <strong>DOM</strong> 对象的 <strong>style</strong> 属性用于以编程方式读写元素样式，因此不会直接映射为元素中 <strong>style</strong> 属性的字符串值。</p>
<p>第二个属性其实是一类，即事件处理程序（或者事件属性），比如<strong>onclick</strong>。在元素上使用事件属性时（比如<strong>onclick</strong>），属性的值是一段 <strong>JavaScript</strong> 代码。如果使用 <strong>getAttribute()</strong> 访问事件属性，则返回的是字符串形式的源代码。而通过 <strong>DOM</strong> 对象的属性访问事件属性时返回的则是一个 <strong>JavaScript</strong> 函数（未指定该属性则返回 <em>null<strong>）。这是因为 <strong>onclick</strong> 及其他事件属性是可以接受函数作为值的。<br>考虑到以上差异，开发者在进行 <strong>DOM</strong> 编程时通常会放弃使用 <strong>getAttribute()</strong> 而只使用对象属性。</strong>getAttribute()*</em> 主要用于取得自定义属性的值。</p>
<ol start="3">
<li>设置属性</li>
</ol>
<p>与 <strong>getAttribute()</strong> 配套的方法是 **setAttribute()**，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则 <strong>setAttribute()</strong> 会以指定的值替换原来的值；如果属性不存在，则 <strong>setAttribute()</strong> 会以指定的值创建该属性。</p>
<p><strong>setAttribute()</strong> 适用于 <strong>HTML</strong> 属性，也适用于自定义属性。另外，使用 <strong>setAttribute()</strong> 方法设置的属性名会规范为小写形式，因此”<strong>ID</strong>“会变成”<strong>id</strong>“。<br>因为元素属性也是 <strong>DOM</strong> 对象属性，所以直接给 <strong>DOM</strong> 对象的属性赋值也可以设置元素属性的值。</p>
<blockquote>
<p>在 <strong>DOM</strong> 对象上添加自定义属性，不会自动让它变成元素的属性。</p>
</blockquote>
<p>最后一个方法 <strong>removeAttribute()</strong> 用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉。</p>
<ol start="4">
<li>attributes属性</li>
</ol>
<p><strong>Element</strong> 类型是唯一使用 <strong>attributes</strong> 属性的 <strong>DOM</strong> 节点类型。<strong>attributes</strong> 属性包含一个 <strong>NamedNodeMap</strong> 实例，是一个类似 <strong>NodeList</strong> 的“实时”集合。元素的每个属性都表示为一个 <strong>Attr</strong> 节点，并保存在这个 <strong>NamedNodeMap</strong> 对象中。</p>
<p><strong>NamedNodeMap</strong> 对象包含下列方法： </p>
<ul>
<li><p>**getNamedItem(name)**，返回 <strong>nodeName</strong> 属性等于 <strong>name</strong> 的节点； </p>
</li>
<li><p>**removeNamedItem(name)**，删除 <strong>nodeName</strong> 属性等于 <strong>name</strong> 的节点； </p>
</li>
<li><p>**setNamedItem(node)**，向列表中添加 <strong>node</strong> 节点，以 <strong>nodeName</strong> 为索引； </p>
</li>
<li><p>**item(pos)**，返回索引位置 <strong>pos</strong> 处的节点。</p>
</li>
</ul>
<p><strong>attributes</strong> 属性中的每个节点的 <strong>nodeName</strong> 是对应属性的名字，<strong>nodeValue</strong> 是属性的值。</p>
<p><strong>removeNamedItem()</strong> 方法与元素上的 <strong>removeAttribute()</strong> 方法类似，也是删除指定名字的属性。不同之处，就是 <strong>removeNamedItem()</strong> 返回表示被删除属性的 <strong>Attr</strong> 节点。</p>
<p><strong>setNamedItem()</strong> 方法接收一个属性节点，然后给元素添加一个新属性。</p>
<p><strong>attributes</strong> 属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把 <strong>DOM</strong> 结构序列化为 <strong>XML</strong> 或 <strong>HTML</strong> 字符串。</p>
<ol start="5">
<li>创建元素</li>
</ol>
<p>可以使用 <strong>document.createElement()</strong> 方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在 <strong>HTML</strong> 文档中，标签名是不区分大小写的，而 <strong>XML</strong> 文档（包括 <strong>XHTML</strong>）是区分大小写的。</p>
<p>使用 <strong>createElement()</strong> 方法创建新元素的同时也会将 <strong>ownerDocument</strong> 属性设置为 <strong>document</strong>。此时，可以再为其添加属性、添加更多子元素。</p>
<p>在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用 **appendChild()、insertBefore()或replaceChild()**。</p>
<p>元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。</p>
<ol start="6">
<li>元素后代</li>
</ol>
<p>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。<strong>childNodes</strong> 属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。</p>
<h4 id="14-1-4-Text类型"><a href="#14-1-4-Text类型" class="headerlink" title="14.1.4 Text类型"></a>14.1.4 Text类型</h4><p><strong>Text</strong> 节点由 <strong>Text</strong> 类型表示，包含按字面解释的纯文本，也可能包含转义后的 <strong>HTML</strong> 字符，但不含 <strong>HTML</strong> 代码。</p>
<p><strong>Text</strong> 类型的节点具有以下特征： </p>
<ul>
<li><p><strong>nodeType</strong> 等于 <strong>3</strong>； </p>
</li>
<li><p><strong>nodeName</strong> 值为”#text”； </p>
</li>
<li><p><strong>nodeValue</strong> 值为节点中包含的文本； </p>
</li>
<li><p><strong>parentNode</strong> 值为 <strong>Element</strong> 对象； </p>
</li>
<li><p>不支持子节点。</p>
</li>
</ul>
<p><strong>Text</strong> 节点中包含的文本可以通过 <strong>nodeValue</strong> 属性访问，也可以通过 <strong>data</strong> 属性访问，这两个属性包含相同的值。修改 <strong>nodeValue</strong> 或 <strong>data</strong> 的值，也会在另一个属性反映出来。</p>
<p>文本节点暴露了以下操作文本的方法：</p>
<ul>
<li><p>appendData(text)，向节点末尾添加文本text； </p>
</li>
<li><p>deleteData(offset, count)，从位置offset开始删除count个字符； </p>
</li>
<li><p>insertData(offset, text)，在位置offset插入text； </p>
</li>
<li><p>replaceData(offset, count, text)，用text替换从位置offset到offset + count的文本； </p>
</li>
<li><p>splitText(offset)，在位置offset将当前文本节点拆分为两个文本节点； </p>
</li>
<li><p>substringData(offset, count)，提取从位置offset到offset + count的文本。</p>
</li>
</ul>
<p>还可以通过 <strong>length</strong> 属性获取文本节点中包含的字符数量。这个值等于 <strong>nodeValue.length和data.length</strong>。<br>默认情况下，包含文本内容的每个元素最多只能有一个文本节点。</p>
<p>只要开始标签和结束标签之间有内容，就会创建一个文本节点。</p>
<p>修改文本节点还有一点要注意，就是 <strong>HTML</strong> 或 <strong>XML</strong> 代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义。</p>
<ol>
<li>创建文本节点</li>
</ol>
<p><strong>document.createTextNode()</strong> 可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。跟设置已有文本节点的值一样，这些要插入的文本也会应用 <strong>HTML</strong> 或 <strong>XML</strong> 编码。</p>
<p>一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点。</p>
<ol start="2">
<li>规范化文本节点</li>
</ol>
<p>有一个方法可以合并相邻的文本节点。这个方法叫 **normalize()**，是在 <strong>Node</strong> 类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用 <strong>normalize()</strong> 时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的 <strong>nodeValue</strong> 就等于之前所有同胞节点 <strong>nodeValue</strong> 拼接在一起得到的字符串。</p>
<p>浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 <strong>DOM</strong> 脚本生成的文档树中。</p>
<ol start="3">
<li>拆分文本节点</li>
</ol>
<p><strong>Text</strong> 类型定义了一个与 <strong>normalize()</strong> 相反的方法—— **splitText()**。这个方法可以在指定的偏移位置拆分 <strong>nodeValue</strong>，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点相同的 <strong>parentNode</strong>。</p>
<h4 id="14-1-5-Comment类型"><a href="#14-1-5-Comment类型" class="headerlink" title="14.1.5 Comment类型"></a>14.1.5 Comment类型</h4><p><strong>DOM</strong> 中的注释通过 <strong>Comment</strong> 类型表示。</p>
<p><strong>Comment</strong> 类型的节点具有以下特征： </p>
<ul>
<li><p><strong>nodeType</strong> 等于 8； </p>
</li>
<li><p><strong>nodeName</strong> 值为”#comment”； </p>
</li>
<li><p><strong>nodeValue</strong> 值为注释的内容； </p>
</li>
<li><p><strong>parentNode</strong> 值为 <strong>Document</strong> 或 <strong>Element</strong> 对象； </p>
</li>
<li><p>不支持子节点。</p>
</li>
</ul>
<p><strong>Comment</strong> 类型与 <strong>Text</strong> 类型继承同一个基类（<strong>CharacterData</strong>），因此拥有除 <strong>splitText()</strong> 之外 <strong>Text</strong> 节点所有的字符串操作方法。与 <strong>Text</strong> 类型相似，注释的实际内容可以通过 <strong>nodeValue</strong> 或 <strong>data</strong> 属性获得。<br>注释节点可以作为父节点的子节点来访问。</p>
<p>可以使用 <strong>document.createComment()</strong> 方法创建注释节点，参数为注释文本。</p>
<h4 id="14-1-6-CDATASection类型"><a href="#14-1-6-CDATASection类型" class="headerlink" title="14.1.6 CDATASection类型"></a>14.1.6 CDATASection类型</h4><p><strong>CDATASection</strong> 类型表示 <strong>XML</strong> 中特有的 <strong>CDATA</strong> 区块 <strong>CDATASection</strong> 类型继承 <strong>Text</strong> 类型，因此拥有包括 <strong>splitText()</strong> 在内的所有字符串操作方法。<strong>CDATASection</strong> 类型的节点具有以下特征：</p>
<ul>
<li><p><strong>nodeType</strong> 等于 <strong>4</strong>； </p>
</li>
<li><p><strong>nodeName</strong> 值为”#cdata-section”； </p>
</li>
<li><p><strong>nodeValue</strong> 值为 CDATA 区块的内容； </p>
</li>
<li><p><strong>parentNode</strong> 值为Document或Element对象； </p>
</li>
<li><p>不支持子节点。</p>
</li>
</ul>
<p><strong>CDATA</strong> 区块只在 <strong>XML</strong> 文档中有效，因此某些浏览器比较陈旧的版本会错误地将 <strong>CDATA</strong> 区块解析为 <strong>Comment 或 Element</strong>。</p>
<p>在真正的 <strong>XML</strong> 文档中，可以使用 <strong>document.createCDataSection()</strong> 并传入节点内容来创建 <strong>CDATA</strong> 区块。</p>
<h4 id="14-1-7-DocumentType类型"><a href="#14-1-7-DocumentType类型" class="headerlink" title="14.1.7 DocumentType类型"></a>14.1.7 DocumentType类型</h4><p><strong>DocumentType</strong> 类型的节点包含文档的文档类型（<strong>doctype</strong>）信息，具有以下特征： </p>
<ul>
<li><p><strong>nodeType</strong> 等于 <strong>10</strong>； </p>
</li>
<li><p><strong>nodeName</strong> 值为文档类型的名称； </p>
</li>
<li><p><strong>nodeValue</strong> 值为 <strong>null</strong>； </p>
</li>
<li><p><strong>parentNode</strong> 值为 <strong>Document</strong> 对象； </p>
</li>
<li><p>不支持子节点。</p>
</li>
</ul>
<p><strong>DocumentType</strong> 对象在 <strong>DOM Level 1</strong> 中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器，<strong>DocumentType</strong> 对象保存在 <strong>document.doctype</strong> 属性中。<strong>DOM Level 1</strong> 规定了 <strong>DocumentType</strong> 对象的 <strong>3</strong> 个属性：<strong>name、entities和notations</strong>。其中，<strong>name</strong> 是文档类型的名称，<strong>entities</strong> 是这个文档类型描述的实体的 <strong>NamedNodeMap</strong>，而 <strong>notations</strong> 是这个文档类型描述的表示法的 <strong>NamedNodeMap</strong>。因为浏览器中的文档通常是 <strong>HTML</strong> 或 <strong>XHTML</strong> 文档类型，所以 <strong>entities</strong> 和 <strong>notations</strong> 列表为空。（这个对象只包含行内声明的文档类型。）无论如何，只有 <strong>name</strong> 属性是有用的。这个属性包含文档类型的名称，即紧跟在&lt;!DOCTYPE后面的那串文本。</p>
<h4 id="14-1-8-DocumentFragment类型"><a href="#14-1-8-DocumentFragment类型" class="headerlink" title="14.1.8 DocumentFragment类型"></a>14.1.8 DocumentFragment类型</h4><p>在所有节点类型中，<strong>DocumentFragment</strong> 类型是唯一一个在标记中没有对应表示的类型。<strong>DOM</strong> 将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。</p>
<p><strong>DocumentFragment</strong>节点具有以下特征：</p>
<ul>
<li><p><strong>nodeType</strong> 等于 11； </p>
</li>
<li><p><strong>nodeName</strong> 值为”#document-fragment”； </p>
</li>
<li><p><strong>nodeValue</strong> 值为null； </p>
</li>
<li><p><strong>parentNode</strong> 值为null； </p>
</li>
<li><p>子节点可以是 <strong>Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference</strong>。</p>
</li>
</ul>
<p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。</p>
<p>文档片段从 <strong>Node</strong> 类型继承了所有文档类型具备的可以执行 <strong>DOM</strong> 操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过 <strong>appendChild()或insertBefore()</strong> 方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。</p>
<h4 id="14-1-9-Attr类型"><a href="#14-1-9-Attr类型" class="headerlink" title="14.1.9 Attr类型"></a>14.1.9 Attr类型</h4><p>元素数据在 <strong>DOM</strong> 中通过 <strong>Attr</strong> 类型表示。<strong>Attr</strong> 类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素 <strong>attributes</strong> 属性中的节点。<strong>Attr</strong> 节点具有以下特征：</p>
<ul>
<li><p><strong>nodeType</strong> 等于 2； </p>
</li>
<li><p><strong>nodeName</strong> 值为属性名； </p>
</li>
<li><p><strong>nodeValue</strong> 值为属性值； </p>
</li>
<li><p><strong>parentNode</strong> 值为 <strong>null</strong>； </p>
</li>
<li><p>在 <strong>HTML</strong> 中不支持子节点； </p>
</li>
<li><p>在 <strong>XML</strong> 中子节点可以是 <strong>Text</strong> 或 <strong>EntityReference</strong>。</p>
</li>
</ul>
<p>属性节点尽管是节点，却不被认为是 <strong>DOM</strong> 文档树的一部分。<strong>Attr</strong> 节点很少直接被引用，通常开发者更喜欢使用 <strong>getAttribute()、removeAttribute()和setAttribute()</strong> 方法操作属性。<br><strong>Attr</strong> 对象上有 <strong>3</strong> 个属性：<strong>name、value和specified</strong>。其中，<strong>name</strong> 包含属性名（与 <strong>nodeName</strong> 一样），<strong>value</strong> 包含属性值（与 <strong>nodeValue</strong> 一样），而* <em>specified</em>* 是一个布尔值，表示属性使用的是默认值还是被指定的值。<br>可以使用 <strong>document.createAttribute()</strong> 方法创建新的 <strong>Attr</strong> 节点，参数为属性名。</p>
<h3 id="14-2-DOM-编程"><a href="#14-2-DOM-编程" class="headerlink" title="14.2 DOM 编程"></a>14.2 DOM 编程</h3><h4 id="14-2-1-动态脚本"><a href="#14-2-1-动态脚本" class="headerlink" title="14.2.1 动态脚本"></a>14.2.1 动态脚本</h4><p>&lt;**script**&gt; 元素用于向网页中插入 <strong>JavaScript</strong> 代码，可以是 <strong>src</strong> 属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过 <strong>DOM</strong> 包含的脚本。</p>
<p>与对应的HTML 元素一样，有两种方式通过 &lt;**script**&gt; 动态为网页添加脚本：引入外部文件和直接插入源代码。</p>
<blockquote>
<p>通过 <strong>innerHTML</strong> 属性创建的 &lt;**script**&gt; 元素永远不会执行。浏览器会尽责地创建 &lt;**script**&gt; 元素，以及其中的脚本文本，但解析器会给这个 &lt;**script**&gt; 元素打上永不执行的标签。只要是使用 <strong>innerHTML</strong> 创建的 &lt;**script**&gt; 元素，以后也没有办法强制其执行。</p>
</blockquote>
<h4 id="14-2-2-动态样式"><a href="#14-2-2-动态样式" class="headerlink" title="14.2.2 动态样式"></a>14.2.2 动态样式</h4><p><strong>CSS</strong> 样式在 HTML 页面中可以通过两个元素加载。**&lt; link &gt;** 元素用于包含 <strong>CSS</strong> 外部文件，而 <strong>&lt; style &gt;</strong> 元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。 </p>
<blockquote>
<p>应该把 <strong><link></strong> 元素添加到 <strong><head></head></strong> 元素而不是 <strong><body></body></strong> 元素，这样才能保证所有浏览器都能正常运行。</p>
</blockquote>
<p>另一种定义样式的方式是使用<style>元素包含嵌入的 CSS 规则。</p>
<h4 id="14-2-3-操作表格"><a href="#14-2-3-操作表格" class="headerlink" title="14.2.3 操作表格"></a>14.2.3 操作表格</h4><p>通过 DOM 编程创建 <strong>&lt; table &gt;</strong> 元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过 <strong>DOM</strong> 编程创建和修改表格时可能要写很多代码。</p>
<p>为了方便创建表格，<strong>HTML DOM</strong> 给&lt; **table** &gt;、&lt;**tbody**&gt;和&lt;**tr**&gt;<br>元素添加了一些属性和方法。 </p>
<p>&lt; **table** &gt;元素添加了以下属性和方法：</p>
<ul>
<li><p>caption，指向<caption>元素的指针（如果存在）； </p>
</li>
<li><p>tBodies，包含<tbody>元素的HTMLCollection； </p>
</li>
<li><p>tFoot，指向<tfoot>元素（如果存在）；</p>
</li>
<li><p>tHead，指向<thead>元素（如果存在）；</p>
</li>
<li><p>rows，包含表示所有行的HTMLCollection；</p>
</li>
<li><p>createTHead()，创建<thead>元素，放到表格中，返回引用；</p>
</li>
<li><p>createTFoot()，创建<tfoot>元素，放到表格中，返回引用；</p>
</li>
<li><p>createCaption()，创建<caption>元素，放到表格中，返回引用；</p>
</li>
<li><p>deleteTHead()，删除<thead>元素； </p>
</li>
<li><p>deleteTFoot()，删除<tfoot>元素； </p>
</li>
<li><p>deleteCaption()，删除<caption>元素； </p>
</li>
<li><p>deleteRow(pos)，删除给定位置的行； </p>
</li>
<li><p>insertRow(pos)，在行集合中给定位置插入一行。 </p>
</li>
<li><p>deleteRow(pos)，删除给定位置的行； </p>
</li>
<li><p>insertRow(pos)，在行集合中给定位置插入一行，返回该行的引用。</p>
</li>
</ul>
<p>&lt; **tr** &gt;元素添加了以下属性和方法： </p>
<ul>
<li><p>cells，包含<tr>元素所有表元的HTMLCollection； </p>
</li>
<li><p>deleteCell(pos)，删除给定位置的表元； </p>
</li>
<li><p>insertCell(pos)，在表元集合给定位置插入一个表元，返回该表元的引用。</p>
</li>
</ul>
<h4 id="14-2-4-使用NodeList"><a href="#14-2-4-使用NodeList" class="headerlink" title="14.2.4 使用NodeList"></a>14.2.4 使用NodeList</h4><p>理解 <strong>NodeList</strong> 对象和相关的 <strong>NamedNodeMap、HTMLCollection</strong> ，是理解 <strong>DOM</strong> 编程的关键。这 <strong>3</strong> 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，<strong>NodeList</strong> 就是基于 <strong>DOM</strong> 文档的实时查询。</p>
<p>任何时候要迭代 <strong>NodeList</strong>，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较。</p>
<p>一般来说，最好限制操作 <strong>NodeList</strong> 的次数。因为每次查询都会搜索整个文档，所以最好把查询到的 <strong>NodeList</strong> 缓存起来。</p>
<h3 id="14-3-MutationObserver接口"><a href="#14-3-MutationObserver接口" class="headerlink" title="14.3 MutationObserver接口"></a>14.3 MutationObserver接口</h3><p><strong>MutationObserver</strong> 接口，可以在 <strong>DOM</strong> 被修改时异步执行回调。使<br>用 <strong>MutationObserver</strong> 可以观察整个文档、<strong>DOM</strong> 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p>
<h4 id="14-3-1-基本用法"><a href="#14-3-1-基本用法" class="headerlink" title="14.3.1 基本用法"></a>14.3.1 基本用法</h4><p><strong>MutationObserver</strong> 的实例要通过调用 <strong>MutationObserver</strong> 构造函数并传入一个回调函数来创建。</p>
<ol>
<li>observe()方法</li>
</ol>
<p>新创建的 <strong>MutationObserver</strong> 实例不会关联 <strong>DOM</strong> 的任何部分。要把这个 <strong>observer</strong> 与 <strong>DOM</strong> 关联起来，需要使用 <strong>observe()</strong> 方法。这个方法接收两个必需的参数：要观察其变化的 <strong>DOM</strong> 节点，以及一个<strong>MutationObserverInit</strong> 对象。<br><strong>MutationObserverInit</strong> 对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。例如，下面的代码会创建一个观察者（<strong>observer</strong>）并配置它观察&lt;**body**&gt;元素上的属性变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>执行以上代码后，&lt;**body**&gt;元素上任何属性发生变化都会被这个 <strong>MutationObserver</strong> 实例发现，然后就会异步执行注册的回调函数。&lt;**body**&gt;元素后代的修改或其他非属性修改都不会触发回调进入任务队列。</p>
<ol start="2">
<li>回调与MutationRecord</li>
</ol>
<p>每个回调都会收到一个 <strong>MutationRecord</strong> 实例的数组。<strong>MutationRecord</strong> 实例包含的信息包括发生了什么变化，以及 <strong>DOM</strong> 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 <strong>MutationRecord</strong> 实例的数组。</p>
<p>传给回调函数的第二个参数是观察变化的 <strong>MutationObserver</strong> 的实例。</p>
<ol start="3">
<li>disconnect()方法</li>
</ol>
<p>默认情况下，只要被观察的元素不被垃圾回收，<strong>MutationObserver</strong> 的回调就会响应 <strong>DOM</strong> 变化事件，从而被执行。要提前终止执行回调，可以调用 <strong>disconnect()</strong> 方法。</p>
<ol start="4">
<li>复用MutationObserver</li>
</ol>
<p>多次调用 <strong>observe()</strong> 方法，可以复用一个 <strong>MutationObserver</strong> 对象观察多个不同的目标节点。此时，<strong>MutationRecord</strong> 的 <strong>target</strong> 属性可以标识发生变化事件的目标节点。</p>
<p><strong>disconnect()</strong> 方法是一个“一刀切”的方案，调用它会停止观察所有目标。</p>
<ol start="5">
<li>重用MutationObserver</li>
</ol>
<p>调用 <strong>disconnect()</strong> 并不会结束 <strong>MutationObserver</strong> 的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。</p>
<h4 id="14-3-2-MutationObserverInit与观察范围"><a href="#14-3-2-MutationObserverInit与观察范围" class="headerlink" title="14.3.2 MutationObserverInit与观察范围"></a>14.3.2 MutationObserverInit与观察范围</h4><p><strong>MutationObserverInit</strong> 对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">subtree</td>
<td>布尔值，表示除了目标节点，是否观察目标节点的子树（后代） <br/>如果是false，则只观察目标节点的变化；如果是true，则观察目标节点及其整个子树<br/>默认为false</td>
</tr>
<tr>
<td align="center">attributes</td>
<td>布尔值，表示是否观察目标节点的属性变化</td>
</tr>
<tr>
<td align="center"><br/>默认为false</td>
<td></td>
</tr>
<tr>
<td align="center">attributeFilter</td>
<td>字符串数组，表示要观察哪些属性的变化</td>
</tr>
<tr>
<td align="center"><br/>把这个值设置为true也会将attributes的值转换为true</td>
<td></td>
</tr>
<tr>
<td align="center"><br/>默认为观察所有属性</td>
<td></td>
</tr>
<tr>
<td align="center">attributeOldValue</td>
<td>布尔值，表示MutationRecord是否记录变化之前的属性值</td>
</tr>
<tr>
<td align="center"><br/>把这个值设置为true也会将attributes的值转换为true</td>
<td></td>
</tr>
<tr>
<td align="center"><br/>默认为false</td>
<td></td>
</tr>
<tr>
<td align="center">characterData</td>
<td>布尔值，表示修改字符数据是否触发变化事件</td>
</tr>
<tr>
<td align="center"><br/>默认为false</td>
<td></td>
</tr>
<tr>
<td align="center">characterDataOldValue</td>
<td>布尔值，表示MutationRecord是否记录变化之前的字符数据</td>
</tr>
<tr>
<td align="center"><br/>把这个值设置为true也会将characterData的值转换为true</td>
<td></td>
</tr>
<tr>
<td align="center"><br/>默认为false</td>
<td></td>
</tr>
<tr>
<td align="center">childList</td>
<td>布尔值，表示修改目标节点的子节点是否触发变化事件</td>
</tr>
<tr>
<td align="center"><br/>默认为false</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>观察属性</li>
</ol>
<p><strong>MutationObserver</strong> 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在 <strong>MutationObserverInit</strong> 对象中将 <strong>attributes</strong> 属性设置为 <strong>true</strong>。</p>
<p>把 <strong>attributes</strong> 设置为 <strong>true</strong> 的默认行为是观察所有属性，但不会在 <strong>MutationRecord</strong> 对象中记录原来的属性值。如果想观察某个或某几个属性，可以使用 <strong>attributeFilter</strong> 属性来设置白名单，即一个属性名字符串数组。</p>
<p>如果想在变化记录中保存属性原来的值，可以将 <strong>attributeOldValue</strong> 属性设置为 <strong>true</strong>。</p>
<ol start="2">
<li>观察字符数据</li>
</ol>
<p><strong>MutationObserver</strong> 可以观察文本节点（如 <strong>Text、Comment或ProcessingInstruction</strong> 节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在 <strong>MutationObserverInit</strong> 对象中将 <strong>characterData</strong> 属性设置为 <strong>true</strong>。</p>
<p>将 <strong>characterData</strong> 属性设置为 <strong>true</strong> 的默认行为不会在 <strong>MutationRecord</strong> 对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据，可以将 <strong>characterDataOldValue</strong> 属性设置为 <strong>true</strong>。</p>
<ol start="3">
<li>观察子节点</li>
</ol>
<p><strong>MutationObserver</strong> 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 <strong>MutationObserverInit</strong> 对象中将 <strong>childList</strong> 属性设置为 <strong>true</strong>。</p>
<p>对子节点重新排序（尽管调用一个方法即可实现）会报告两次变化事件。</p>
<ol start="4">
<li>观察子树</li>
</ol>
<p>默认情况下，<strong>MutationObserver</strong> 将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点），这需要在 <strong>MutationObserverInit</strong> 对象中将 <strong>subtree</strong> 属性设置为 <strong>true</strong>。</p>
<p>被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。</p>
<h4 id="14-3-3-异步回调与记录队列"><a href="#14-3-3-异步回调与记录队列" class="headerlink" title="14.3.3 异步回调与记录队列"></a>14.3.3 异步回调与记录队列</h4><p><strong>MutationObserver</strong> 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 <strong>MutationRecord</strong> 实例中，然后添加到记录队列。这个队列对每个 <strong>MutationObserver</strong> 实例都是唯一的，是所有 <strong>DOM</strong> 变化事件的有序列表。</p>
<ol>
<li>记录队列</li>
</ol>
<p>每次 <strong>MutationRecord</strong> 被添加到 <strong>MutationObserver</strong> 的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 <strong>0</strong>），才会将观察者注册的回调（在初始化 <strong>MutationObserver</strong> 时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。 </p>
<p>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个 <strong>MutationRecord</strong> 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 <strong>MutationRecord</strong> 就用不着了，因此记录队列会被清空，其内容会被丢弃。</p>
<ol start="2">
<li>takeRecords()方法</li>
</ol>
<p>调用 <strong>MutationObserver</strong> 实例的 <strong>takeRecords()</strong> 方法可以清空记录队列，取出并返回其中的所有 <strong>MutationRecord</strong> 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">et observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(  </span><br><span class="line">    <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord] </span></span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="14-3-4-性能、内存与垃圾回收"><a href="#14-3-4-性能、内存与垃圾回收" class="headerlink" title="14.3.4 性能、内存与垃圾回收"></a>14.3.4 性能、内存与垃圾回收</h4><p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 <strong>MutationObserver</strong> 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p>
<ol>
<li>MutationObserver的引用</li>
</ol>
<p><strong>MutationObserver</strong> 实例与目标节点之间的引用关系是非对称的。<strong>MutationObserver</strong> 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。 </p>
<p>然而，目标节点却拥有对 <strong>MutationObserver</strong> 的强引用。如果目标节点从 <strong>DOM</strong> 中被移除，随后被垃圾回收，则关联的 <strong>MutationObserver</strong> 也会被垃圾回收。</p>
<ol start="2">
<li>MutationRecord的引用</li>
</ol>
<p>记录队列中的每个 <strong>MutationRecord</strong> 实例至少包含对已有 <strong>DOM</strong> 节点的一个引用。如果变化是 <strong>childList</strong> 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个 <strong>MutationRecord</strong> ，然后让它们超出作用域并被垃圾回收。<br>有时候可能需要保存某个观察者的完整变化记录。保存这些 <strong>MutationRecord</strong> 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 <strong>MutationRecord</strong> 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 <strong>MutationRecord</strong>。</p>
<h3 id="14-4-小结"><a href="#14-4-小结" class="headerlink" title="14.4 小结"></a>14.4 小结</h3><p>文档对象模型（<strong>DOM，Document Object Model</strong>）是语言中立的 <strong>HTML</strong> 和 <strong>XML</strong> 文档的 <strong>API</strong>。<strong>DOM Level 1</strong> 将 <strong>HTML</strong> 和 <strong>XML</strong> 文档定义为一个节点的多层级结构，并暴露出 <strong>JavaScript</strong> 接口以操作文档的底层结构和外观。</p>
<p><strong>DOM</strong> 由一系列节点类型构成，主要包括以下几种。</p>
<ul>
<li><p><strong>Node</strong> 是基准节点类型，是文档一个部分的抽象表示，所有其他类型都继承 <strong>Node</strong>。 </p>
</li>
<li><p><strong>Document</strong> 类型表示整个文档，对应树形结构的根节点。在 <strong>JavaScript</strong> 中，<strong>document</strong> 对象是 <strong>Document</strong> 的实例，拥有查询和获取节点的很多方法。 </p>
</li>
<li><p><strong>Element</strong> 节点表示文档中所有 <strong>HTML</strong> 或 <strong>XML</strong> 元素，可以用来操作它们的内容和属性。 </p>
</li>
<li><p>其他节点类型分别表示文本内容、注释、文档类型、<strong>CDATA</strong> 区块和文档片段。</p>
</li>
</ul>
<p><strong>DOM</strong> 编程在多数情况下没什么问题，在涉及&lt;<strong>script**&gt;和&lt;**style**&gt;元素时会有一点兼容性问题。因为这些元素分别包含脚本和样式信息，所以浏览器会将它们与其他元素区别对待。<br>要理解 <strong>DOM</strong>，最关键的一点是知道影响其性能的问题所在。</strong>DOM** 操作在 <strong>JavaScript</strong> 代码中是代价比较高的，<strong>NodeList</strong> 对象尤其需要注意。<strong>NodeList</strong> 对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少 <strong>DOM</strong> 操作的数量。<br><strong>MutationObserver</strong> 是为代替性能不好的 <strong>MutationEvent</strong> 而问世的。使用它可以有效精准地监控 <strong>DOM</strong> 变化，而且 <strong>API</strong> 也相对简单。</p>
<h2 id="十五、DOM-扩展"><a href="#十五、DOM-扩展" class="headerlink" title="十五、DOM 扩展"></a>十五、DOM 扩展</h2><h3 id="15-1-Selectors-API"><a href="#15-1-Selectors-API" class="headerlink" title="15.1 Selectors API"></a>15.1 Selectors API</h3><p><strong>JavaScript</strong> 库中最流行的一种能力就是根据 <strong>CSS</strong> 选择符的模式匹配 <strong>DOM</strong> 元素。</p>
<p><strong>Selectors API</strong> 是 W3C 推荐标准，规定了浏览器原生支持的 <strong>CSS</strong> 查询 <strong>API</strong>。支持这一特性的所有 JavaScript 库都会实现一个基本的 <strong>CSS</strong> 解析器，然后使用已有的 <strong>DOM</strong> 方法搜索文档并匹配目标节点。</p>
<p><strong>Selectors API Level 1</strong> 的核心是两个方法：<strong>querySelector()和querySelectorAll()<strong>。在兼容浏览器中，</strong>Document</strong> 类型和 <strong>Element</strong> 类型的实例上都会暴露这两个方法。<br><strong>Selectors API Level 2</strong> 规范在 <strong>Element</strong> 类型上新增了更多方法，比如 **matches()、find()和findAll()**。</p>
<h4 id="15-1-1-querySelector"><a href="#15-1-1-querySelector" class="headerlink" title="15.1.1 querySelector()"></a>15.1.1 querySelector()</h4><p><strong>querySelector()</strong> 方法接收 <strong>CSS</strong> 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 <strong>null</strong>。</p>
<p>在 <strong>Document</strong> 上使用 <strong>querySelector()</strong> 方法时，会从文档元素开始搜索；在 <strong>Element</strong> 上使用 <strong>querySelector()</strong> 方法时，则只会从当前元素的后代中查询。</p>
<h4 id="15-1-2-querySelectorAll"><a href="#15-1-2-querySelectorAll" class="headerlink" title="15.1.2 querySelectorAll()"></a>15.1.2 querySelectorAll()</h4><p><strong>querySelectorAll()</strong> 方法跟 <strong>querySelector()</strong> 一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 <strong>NodeList</strong> 的静态实例。</p>
<p><strong>querySelectorAll()</strong> 返回的 <strong>NodeList</strong> 实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。</p>
<p>以有效 <strong>CSS</strong> 选择符调用 <strong>querySelectorAll()</strong> 都会返回 <strong>NodeList</strong>，无论匹配多少个元素都可以。如果没有匹配项，则返回空的 <strong>NodeList</strong> 实例。</p>
<p><strong>querySelectorAll()</strong> 也可以在 <strong>Document、DocumentFragment</strong>和 <strong>Element</strong> 类型上使用。</p>
<p>返回的 <strong>NodeList</strong> 对象可以通过 <strong>for-of</strong> 循环、<strong>item()</strong> 方法或中括号语法取得个别元素。</p>
<h4 id="15-1-3-matches"><a href="#15-1-3-matches" class="headerlink" title="15.1.3 matches()"></a>15.1.3 matches()</h4><p><strong>matches()</strong> 方法（在规范草案中称为 **matchesSelector()**）接收一个 <strong>CSS</strong> 选择符参数，如果元素匹配则该选择符返回 <strong>true</strong>，否则返回 <strong>false</strong>。</p>
<p>使用这个方法可以方便地检测某个元素会不会被 <strong>querySelector()或querySelectorAll()</strong> 方法返回。 </p>
<h3 id="15-2-元素遍历"><a href="#15-2-元素遍历" class="headerlink" title="15.2 元素遍历"></a>15.2 元素遍历</h3><p><strong>Element Traversal API</strong> 为 <strong>DOM</strong> 元素添加了 <strong>5</strong> 个属性： </p>
<ul>
<li><p><strong>childElementCount</strong>，返回子元素数量（不包含文本节点和注释）； </p>
</li>
<li><p><strong>firstElementChild</strong>，指向第一个 <strong>Element</strong> 类型的子元素（<strong>Element</strong> 版 <strong>firstChild</strong>）； </p>
</li>
<li><p><strong>lastElementChild</strong>，指向最后一个<strong>Element</strong> 类型的子元素（<strong>Element</strong>版 <strong>lastChild</strong>）； </p>
</li>
<li><p><strong>previousElementSibling</strong>， 指 向 前 一 个 <strong>Element</strong> 类 型 的 同 胞 元 素 （<strong>Element</strong> 版 <strong>previousSibling</strong>）； </p>
</li>
<li><p><strong>nextElementSibling</strong>，指向后一个 <strong>Element</strong> 类型的同胞元素（<strong>Element</strong> 版 <strong>nextSibling</strong>）。</p>
</li>
</ul>
<h3 id="15-3-HTML5"><a href="#15-3-HTML5" class="headerlink" title="15.3 HTML5"></a>15.3 HTML5</h3><h4 id="15-3-1-CSS-类扩展"><a href="#15-3-1-CSS-类扩展" class="headerlink" title="15.3.1 CSS 类扩展"></a>15.3.1 CSS 类扩展</h4><ol>
<li>getElementsByClassName()</li>
</ol>
<p><strong>getElementsByClassName()</strong> 方法接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的 <strong>NodeList</strong>。如果提供了多个类名，则顺序无关紧要。</p>
<p>这个方法只会返回以调用它的对象为根元素的子树中所有匹配的元素。在 <strong>document</strong> 上调用 <strong>getElementsByClassName()</strong> 返回文档中所有匹配的元素，而在特定元素上调用 <strong>getElementsByClassName()</strong> 则返回该元素后代中匹配的元素。</p>
<ol start="2">
<li>classList属性</li>
</ol>
<p>要操作类名，可以通过 <strong>className</strong> 属性实现添加、删除和替换。但 <strong>className</strong> 是一个字符串，所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。</p>
<p><strong>classList</strong> 是一个新的集合类型 <strong>DOMTokenList</strong> 的实例。与其他 <strong>DOM</strong> 集合类型一样，<strong>DOMTokenList</strong> 也有 <strong>length</strong> 属性表示自己包含多少项，也可以通过 <strong>item()</strong> 或中括号取得个别的元素。此外， <strong>DOMTokenList</strong> 还增加了以下方法。</p>
<ul>
<li><p>**add(value)**，向类名列表中添加指定的字符串值 <strong>value</strong>。如果这个值已经存在，则什么也不做。 </p>
</li>
<li><p>**contains(value)**，返回布尔值，表示给定的 <strong>value</strong> 是否存在。 </p>
</li>
<li><p>**remove(value)**，从类名列表中删除指定的字符串值 <strong>value</strong>。 </p>
</li>
<li><p>**toggle(value)**，如果类名列表中已经存在指定的 <strong>value</strong>，则删除；如果不存在，则添加。</p>
</li>
</ul>
<p>添加了 <strong>classList</strong> 属性之后，除非是完全删除或完全重写元素的 <strong>class</strong> 属性，否则 <strong>className</strong> 属性就用不到了。</p>
<h4 id="15-3-2-焦点管理"><a href="#15-3-2-焦点管理" class="headerlink" title="15.3.2 焦点管理"></a>15.3.2 焦点管理</h4><p><strong>HTML5</strong> 增加了辅助 <strong>DOM</strong> 焦点管理的功能。首先是 <strong>document.activeElement</strong>，始终包含当前拥有焦点的 <strong>DOM</strong> 元素。页面加载时，可以通过用户输入（按 <strong>Tab</strong> 键或代码中使用 <strong>focus()</strong> 方法）让某个元素自动获得焦点。</p>
<p>默认情况下，<strong>document.activeElement</strong> 在页面刚加载完之后会设置为 <strong>document.body</strong>。而在页面完全加载之前， <strong>document.activeElement</strong> 的值为 <strong>null</strong>。<br>其次是 <strong>document.hasFocus()</strong> 方法，该方法返回布尔值，表示文档是否拥有焦点。</p>
<p>第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点，而这对于保证 <strong>Web</strong> 应用程序的无障碍使用是非常重要的。</p>
<h4 id="15-3-3-HTMLDocument扩展"><a href="#15-3-3-HTMLDocument扩展" class="headerlink" title="15.3.3 HTMLDocument扩展"></a>15.3.3 HTMLDocument扩展</h4><ol>
<li>readyState属性</li>
</ol>
<p><strong>readyState</strong> 是 <strong>IE4</strong> 最早添加到 <strong>document</strong> 对象上的属性，<strong>HTML5</strong> 将这个属性写进了标准。<strong>document.readyState</strong> 属性有两个可能的值：</p>
<ul>
<li><p><strong>loading</strong>，表示文档正在加载； </p>
</li>
<li><p><strong>complete</strong>，表示文档加载完成。</p>
</li>
</ul>
<p>实际开发中，最好是把 <strong>document.readState</strong> 当成一个指示器，以判断文档是否加载完毕。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>)&#123; </span><br><span class="line">  <span class="comment">// 执行操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>compatMode属性</li>
</ol>
<p>自从 <strong>IE6</strong> 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。</p>
<p><strong>compatMode</strong>属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。标准模式下 <strong>document.compatMode</strong> 的值是”<strong>CSS1Compat</strong>“，而在混杂模式下，<strong>document.compatMode</strong> 的值是”<strong>BackCompat</strong>“。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>)&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Standards mode&quot;</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Quirks mode&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>head属性</li>
</ol>
<p><strong>HTML5</strong> 增加了 <strong>document.head</strong> 属性，指向文档的&lt;**head**&gt;元素。可以像下面这样直接取得&lt;**head**&gt;元素。</p>
<h4 id="15-3-4-字符集属性"><a href="#15-3-4-字符集属性" class="headerlink" title="15.3.4 字符集属性"></a>15.3.4 字符集属性</h4><p><strong>HTML5</strong> 增加了几个与文档字符集有关的新属性。其中，<strong>characterSet</strong> 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是”<strong>UTF-16</strong>“，但可以通过&lt;**meta**&gt;元素或响应头，以及新增的 <strong>characterSeet</strong> 属性来修改。</p>
<h4 id="15-3-5-自定义数据属性"><a href="#15-3-5-自定义数据属性" class="headerlink" title="15.3.5 自定义数据属性"></a>15.3.5 自定义数据属性</h4><p><strong>HTML5</strong> 允许给元素指定非标准的属性，但要使用前缀 <strong>data-</strong> 以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，<strong>data-</strong> 后面跟什么都可以。</p>
<p>定义了自定义数据属性后，可以通过元素的 <strong>dataset</strong> 属性来访问。<strong>dataset</strong> 属性是一个 <strong>DOMStringMap</strong> 的实例，包含一组键/值对映射。元素的每个 <strong>data-name</strong> 属性在 <strong>dataset</strong> 中都可以通过 <strong>data-</strong> 后面的字符串作为键来访问。</p>
<h4 id="15-3-6-插入标记"><a href="#15-3-6-插入标记" class="headerlink" title="15.3.6 插入标记"></a>15.3.6 插入标记</h4><ol>
<li>innerHTML属性</li>
</ol>
<p>在读取 <strong>innerHTML</strong> 属性时，会返回元素所有后代的 <strong>HTML</strong> 字符串，包括元素、注释和文本节点。而在写入 <strong>innerHTML</strong> 时，则会根据提供的字符串值以新的 <strong>DOM</strong> 子树替代元素中原来包含的所有节点。</p>
<p>在写入模式下，赋给 <strong>innerHTML</strong> 属性的值会被解析为 <strong>DOM</strong> 子树，并替代元素之前的所有节点。因为所赋的值默认为 <strong>HTML</strong>，所以其中的所有标签都会以浏览器处理 <strong>HTML</strong> 的方式转换为元素（同样，转换结果也会因浏览器不同而不同）。如果赋值中不包含任何 HTML 标签，则直接生成一个文本节点。</p>
<blockquote>
<p>设置 <strong>innerHTML</strong> 会导致浏览器将 <strong>HTML</strong> 字符串解析为相应的 <strong>DOM</strong> 树。这意味着设置 <strong>innerHTML</strong> 属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的 <strong>DOM</strong> 子树序列化之后的结果。</p>
</blockquote>
<ol start="2">
<li>旧 IE 中的innerHTML</li>
</ol>
<p>在所有现代浏览器中，通过 <strong>innerHTML</strong> 插入的&lt;<strong>script**&gt;标签是不会执行的。而在 <strong>IE8</strong> 及之前的版本中，只要这样插入的&lt;**script**&gt;元素指定了 <strong>defer</strong> 属性，且&lt;**script**&gt;之前是“受控元素”（</strong>scoped element<strong>），那就是可以执行的。&lt;**script**&gt;元素与&lt;**style**&gt;或注释一样，都是“非受控元素”（</strong>NoScope element**），也就是在页面上看不到它们。</p>
<ol start="3">
<li>outerHTML属性</li>
</ol>
<p>读取 <strong>outerHTML</strong> 属性时，会返回调用它的元素（及所有后代元素）的 <strong>HTML</strong> 字符串。在写入 <strong>outerHTML</strong> 属性时，调用它的元素会被传入的 <strong>HTML</strong> 字符串经解释之后生成的 <strong>DOM</strong> 子树取代。</p>
<ol start="4">
<li>insertAdjacentHTML()与insertAdjacentText()</li>
</ol>
<p>关于插入标签的最后两个新增方法是 **insertAdjacentHTML() 和 insertAdjacentText()**。接收两个参数：要插入标记的位置和要插入的 <strong>HTML</strong> 或文本。第一个参数必须是下列值中的一个：</p>
<ul>
<li><p>“<strong>beforebegin</strong>“，插入当前元素前面，作为前一个同胞节点； </p>
</li>
<li><p>“<strong>afterbegin</strong>“，插入当前元素内部，作为新的子节点或放在第一个子节点前面； </p>
</li>
<li><p>“<strong>beforeend</strong>“，插入当前元素内部，作为新的子节点或放在最后一个子节点后面； </p>
</li>
<li><p>“<strong>afterend</strong>“，插入当前元素后面，作为下一个同胞节点。</p>
</li>
</ul>
<p>注意这几个值是不区分大小写的。第二个参数会作为 <strong>HTML</strong> 字符串解析（与 <strong>innerHTML和outerHTML</strong> 相同）或者作为纯文本解析（与 <strong>innerText和outerText</strong> 相同）。如果是 <strong>HTML</strong>，则会在解析出错时抛出错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同胞节点插入 </span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为第一个子节点插入 </span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为最后一个子节点插入 </span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为下一个同胞节点插入 </span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); element. </span><br><span class="line"><span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>内存与性能问题</li>
</ol>
<p>在使用 <strong>innerHTML、outerHTML和insertAdjacentHTML()</strong> 之前，最好手动删除要被替换的元素上关联的事件处理程序和<strong>JavaScript</strong> 对象。</p>
<ol start="6">
<li>跨站点脚本</li>
</ol>
<p>如果页面中要使用用户提供的信息，则不建议使用 <strong>innerHTML</strong>。</p>
<h4 id="15-3-7-scrollIntoView"><a href="#15-3-7-scrollIntoView" class="headerlink" title="15.3.7 scrollIntoView()"></a>15.3.7 scrollIntoView()</h4><p><strong>HTML5</strong> 选择了标准化 **scrollIntoView()**。</p>
<p><strong>scrollIntoView()</strong> 方法存在于所有 <strong>HTML</strong> 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下：</p>
<ul>
<li><p><strong>alignToTop</strong> 是一个布尔值。 </p>
<ul>
<li><p><strong>true</strong>：窗口滚动后元素的顶部与视口顶部对齐。 </p>
</li>
<li><p><strong>false</strong>：窗口滚动后元素的底部与视口底部对齐。</p>
</li>
</ul>
</li>
<li><p><strong>scrollIntoViewOptions</strong> 是一个选项对象。 </p>
<ul>
<li><p><strong>behavior</strong>：定义过渡动画，可取的为”smooth”和”auto”，默认为”auto”。 </p>
</li>
<li><p><strong>block</strong>：定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默认为 “start”。 </p>
</li>
<li><p><strong>inline</strong>：定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默认为 “nearest”。 </p>
</li>
</ul>
</li>
<li><p>不传参数等同于 <strong>alignToTop</strong> 为 <strong>true</strong>。</p>
</li>
</ul>
<h3 id="15-4-专有扩展"><a href="#15-4-专有扩展" class="headerlink" title="15.4 专有扩展"></a>15.4 专有扩展</h3><h4 id="15-4-1-children属性"><a href="#15-4-1-children属性" class="headerlink" title="15.4.1 children属性"></a>15.4.1 children属性</h4><p><strong>children</strong> 属性是一个 <strong>HTMLCollection</strong>，只包含元素的 <strong>Element</strong> 类型的子节点。如果元素的子节点类型全部是元素类型，那 <strong>children</strong> 和 <strong>childNodes</strong> 中包含的节点应该是一样的。</p>
<h4 id="15-4-2-contains-方法"><a href="#15-4-2-contains-方法" class="headerlink" title="15.4.2 contains()方法"></a>15.4.2 contains()方法</h4><p>确定一个元素是不是另一个元素的后代，<strong>contains()</strong> 方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。<br>如果目标节点是被搜索节点的后代，<strong>contains()</strong> 返回 <strong>true</strong>，否则返回 <strong>false</strong>。</p>
<p>另外，使用 <strong>DOM Level 3</strong> 的 <strong>compareDocumentPosition()</strong> 方法也可以确定节点间的关系。这个方法会返回表示两个节点关系的位掩码。</p>
<table>
<thead>
<tr>
<th align="center">掩  码</th>
<th>节点关系</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x1</td>
<td>断开（传入的节点不在文档中）</td>
</tr>
<tr>
<td align="center">0x2</td>
<td>领先（传入的节点在 DOM 树中位于参考节点之前）</td>
</tr>
<tr>
<td align="center">0x4</td>
<td>随后（传入的节点在 DOM 树中位于参考节点之后）</td>
</tr>
<tr>
<td align="center">0x8</td>
<td>包含（传入的节点是参考节点的祖先）</td>
</tr>
<tr>
<td align="center">0x10</td>
<td>被包含（传入的节点是参考节点的后代）</td>
</tr>
</tbody></table>
<p>要模仿 <strong>contains()</strong> 方法，就需要用到掩码 <strong>16（0x10）</strong>。<strong>compareDocumentPosition()</strong> 方法的结果可以通过按位与来确定参考节点是否包含传入的节点。</p>
<h4 id="15-4-3-插入标记"><a href="#15-4-3-插入标记" class="headerlink" title="15.4.3 插入标记"></a>15.4.3 插入标记</h4><ol>
<li>innerText属性</li>
</ol>
<p><strong>innerText</strong> 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时，<strong>innerText</strong> 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，<strong>innerText</strong> 会移除元素的所有后代并插入一个包含该值的文本节点。</p>
<p>设置 <strong>innerText</strong> 会移除元素之前所有的后代节点，完全改变 <strong>DOM</strong> 子树。此外，设置 <strong>innerText</strong> 也会编码出现在字符串中的 <strong>HTML</strong> 语法字符（小于号、大于号、引号及和号）。</p>
<ol start="2">
<li>outerText属性</li>
</ol>
<p><strong>outerText</strong> 与 <strong>innerText</strong> 是类似的，只不过作用范围包含调用它的节点。要读取文本值时，<strong>outerText</strong> 与 <strong>innerText</strong> 实际上会返回同样的内容。但在写入文本值时，<strong>outerText</strong> 就大不相同了。写入文本值时，<strong>outerText</strong> 不止会移除所有后代节点，而且会替换整个元素。</p>
<h4 id="15-4-4-滚动"><a href="#15-4-4-滚动" class="headerlink" title="15.4.4 滚动"></a>15.4.4 滚动</h4><p><strong>scrollIntoViewIfNeeded()</strong> 作为 <strong>HTMLElement</strong> 类型的扩展可以在所有元素上调用。<strong>scrollIntoViewIfNeeded</strong>(<strong>alingCenter</strong>) 会在元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见；如果已经在视口中可见，则这个方法什么也不做。如果将可选的参数 <strong>alingCenter</strong> 设置为 <strong>true</strong>，则浏览器会尝试将其放在视口中央。</p>
<h3 id="15-5-小结"><a href="#15-5-小结" class="headerlink" title="15.5 小结"></a>15.5 小结</h3><p>虽然 <strong>DOM</strong> 规定了与 <strong>XML</strong> 和 <strong>HTML</strong> 文档交互的核心 <strong>API</strong>，但其他几个规范也定义了对 <strong>DOM</strong> 的扩展。很多扩展都基于之前的已成为事实标准的专有特性标准化而来。本章主要介绍了以下 <strong>3</strong> 个规范。</p>
<ul>
<li><p><strong>Selectors API</strong> 为基于 <strong>CSS</strong> 选择符获取 <strong>DOM</strong> 元素定义了几个方法：**querySelector()、querySelectorAll()和matches()**。</p>
</li>
<li><p><strong>Element Traversal</strong> 在 <strong>DOM</strong> 元素上定义了额外的属性，以方便对 <strong>DOM</strong> 元素进行遍历。这个需求是因浏览器处理元素间空格的差异而产生的。</p>
</li>
<li><p><strong>HTML5</strong> 为标准 <strong>DOM</strong> 提供了大量扩展。其中包括对 <strong>innerHTML</strong> 属性等事实标准进行了标准化，还有焦点管理、字符集、滚动等特性。</p>
</li>
</ul>
<p><strong>DOM</strong> 扩展的数量总体还不大，但随着 <strong>Web</strong> 技术的发展一定会越来越多。浏览器仍然没有停止对专有扩展的探索，如果出现成功的扩展，那么就可能成为事实标准，或者最终被整合到未来的标准中。</p>
<h2 id="十六、DOM2-和-DOM3"><a href="#十六、DOM2-和-DOM3" class="headerlink" title="十六、DOM2 和 DOM3"></a>十六、DOM2 和 DOM3</h2><p><strong>DOM1</strong>（<strong>DOM Level 1</strong>）主要定义了 <strong>HTML</strong> 和 <strong>XML</strong> 文档的底层结构。<strong>DOM2</strong>（<strong>DOM Level 2</strong>）和 <strong>DOM3</strong>（<strong>DOM Level 3</strong>）在这些结构之上加入更多交互能力，提供了更高级的 <strong>XML</strong> 特性。实际上，<strong>DOM2</strong> 和 <strong>DOM3</strong> 是按照模块化的思路来制定标准的，每个模块之间有一定关联，但分别针对某个 <strong>DOM</strong> 子集。这些模式如下所示。</p>
<ul>
<li><p>DOM Core：在 DOM1 核心部分的基础上，为节点增加方法和属性。 </p>
</li>
<li><p>DOM Views：定义基于样式信息的不同视图。 </p>
</li>
<li><p>DOM Events：定义通过事件实现 DOM 文档交互。 </p>
</li>
<li><p>DOM Style：定义以编程方式访问和修改 CSS 样式的接口。 </p>
</li>
<li><p>DOM Traversal and Range：新增遍历 DOM 文档及选择文档内容的接口。 </p>
</li>
<li><p>DOM HTML：在 DOM1 HTML 部分的基础上，增加属性、方法和新接口。 </p>
</li>
<li><p>DOM Mutation Observers：定义基于 DOM 变化触发回调的接口。这个模块是 DOM4 级模块，用于取代 Mutation Events。</p>
</li>
</ul>
<h3 id="16-1-DOM-的演进"><a href="#16-1-DOM-的演进" class="headerlink" title="16.1 DOM 的演进"></a>16.1 DOM 的演进</h3><p>DOM2 和 DOM3 Core 模块的目标是扩展 DOM API，满足 XML 的所有需求并提供更好的错误处理和特性检测。</p>
<h4 id="16-1-1-XML-命名空间"><a href="#16-1-1-XML-命名空间" class="headerlink" title="16.1.1 XML 命名空间"></a>16.1.1 XML 命名空间</h4><p>XML 命名空间可以实现在一个格式规范的文档中混用不同的 XML 语言，而不必担心元素命名冲突。严格来讲，XML 命名空间在 XHTML 中才支持，HTML 并不支持。</p>
<p>命名空间是使用xmlns指定的。XHTML 的命名空间是”<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xhtml&quot;%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E5%9C%A8%E4%BB%BB%E4%BD%95%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%E7%9A%84">http://www.w3.org/1999/xhtml&quot;，应该包含在任何格式规范的</a> XHTML 页面的<html>元素中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    Hello world!  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用xmlns给命名空间创建一个前缀，格式为“xmlns: 前缀”。为<br>避免混淆，属性也可以加上命名空间前缀。</p>
<p>如果文档中只使用一种 XML 语言，那么命名空间前缀其实是多余的，只有一个文档混合使用多种 XML 语言时才有必要。</p>
<ol>
<li>Node的变化</li>
</ol>
<p>在 DOM2 中，Node类型包含以下特定于命名空间的属性： </p>
<ul>
<li><p>localName，不包含命名空间前缀的节点名； </p>
</li>
<li><p>namespaceURI，节点的命名空间 URL，如果未指定则为null； </p>
</li>
<li><p>prefix，命名空间前缀，如果未指定则为null。</p>
</li>
</ul>
<p>在节点使用命名空间前缀的情况下，nodeName等于prefix + “:” + localName。</p>
<p>DOM3 进一步增加了如下与命名空间相关的方法：</p>
<ul>
<li><p>isDefaultNamespace(namespaceURI)，返回布尔值，表示namespaceURI是否为节点的默认命名空间； </p>
</li>
<li><p>lookupNamespaceURI(prefix)，返回给定prefix的命名空间 URI； </p>
</li>
<li><p>lookupPrefix(namespaceURI)，返回给定namespaceURI的前缀。</p>
</li>
</ul>
<ol start="2">
<li>Document的变化</li>
</ol>
<p>DOM2 在Document类型上新增了如下命名空间特定的方法：</p>
<ul>
<li><p>createElementNS(namespaceURI, tagName)，以给定的标签名tagName创建指定命名空间namespaceURI的一个新元素； </p>
</li>
<li><p>createAttributeNS(namespaceURI, attributeName)，以给定的属性名 attributeName 创建指定命名空间namespaceURI的一个新属性；</p>
</li>
<li><p>getElementsByTagNameNS(namespaceURI, tagName)，返回指定命名空间 namespaceURI 中所有标签名为tagName的元素的NodeList。</p>
</li>
</ul>
<p>使用这些方法都需要传入相应的命名空间 URI（不是命名空间前缀）。</p>
<p>这些命名空间特定的方法只在文档中包含两个或两个以上命名空间时才有用。</p>
<ol start="3">
<li>Element的变化</li>
</ol>
<p>DOM2 Core 对Element类型的更新主要集中在对属性的操作上。</p>
<ul>
<li><p>getAttributeNS(namespaceURI, localName)，取得指定命名空间namespaceURI中名为 localName的属性； </p>
</li>
<li><p>getAttributeNodeNS(namespaceURI, localName)，取得指定命名空间namespaceURI中名为localName的属性节点； </p>
</li>
<li><p>getElementsByTagNameNS(namespaceURI, tagName)，取得指定命名空间namespaceURI中标签名为tagName的元素的NodeList； </p>
</li>
<li><p>hasAttributeNS(namespaceURI, localName)，返回布尔值，表示元素中是否有命名空间 namespaceURI 下名为localName的属性（注意，DOM2 Core 也添加不带命名空间的 hasAttribute()方法）； </p>
</li>
<li><p>removeAttributeNS(namespaceURI, localName)，删除指定命名空间namespaceURI中名为localName的属性； </p>
</li>
<li><p>setAttributeNS(namespaceURI, qualifiedName, value)，设置指定命名空间namespaceURI中名为qualifiedName的属性为value； </p>
</li>
<li><p>setAttributeNodeNS(attNode)，为元素设置（添加）包含命名空间信息的属性节点attNode。</p>
</li>
</ul>
<p>这些方法与 DOM1 中对应的方法行为相同，除setAttributeNodeNS()之外都只是多了一个命名空间参数。</p>
<ol start="4">
<li>NamedNodeMap的变化</li>
</ol>
<p>NamedNodeMap也增加了以下处理命名空间的方法。因为NamedNodeMap主要表示属性，所以这些方法大都适用于属性：</p>
<ul>
<li><p>getNamedItemNS(namespaceURI, localName)，取得指定命名空间namespaceURI中名为localName的项； </p>
</li>
<li><p>removeNamedItemNS(namespaceURI, localName)，删除指定命名空间namespaceURI中名为localName的项； </p>
</li>
<li><p>setNamedItemNS(node)，为元素设置（添加）包含命名空间信息的节点。</p>
</li>
</ul>
<h4 id="16-1-2-其他变化"><a href="#16-1-2-其他变化" class="headerlink" title="16.1.2 其他变化"></a>16.1.2 其他变化</h4><ol>
<li>DocumentType的变化</li>
</ol>
<p>DocumentType新增了 3 个属性：publicId、systemId和internalSubset。publicId、systemId属性表示文档类型声明中有效但无法使用 DOM1 API 访问的数据。</p>
<p>internalSubset用于访问文档类型声明中可能包含的额外定义。</p>
<ol start="2">
<li>Document的变化</li>
</ol>
<p><strong>Document</strong> 类型的更新中唯一跟命名空间无关的方法是importNode()。这个方法的目的是从其他文档获取一个节点并导入到新文档，以便将其插入新文档。每个节点都有一个ownerDocument属性，表示所属文档。如果调用appendChild()方法时传入节点的ownerDocument不是指向当前文档，则会发生错误。而调用importNode()导入其他文档的节点会返回一个新节点，这个新节点的ownerDocument属性是正确的。<br>importNode()方法跟cloneNode()方法类似，同样接收两个参数：要复制的节点和表示是否同时复制子树的布尔值，返回结果是适合在当前文档中使用的新节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newNode = <span class="variable language_">document</span>.importNode(oldNode, <span class="literal">true</span>);   <span class="comment">// 导入节点及所有后代 </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newNode);</span><br></pre></td></tr></table></figure>

<p>DOM2 View 给Document类型增加了新属性defaultView，是一个指向拥有当前文档的窗口（或窗格<frame>）的指针。</p>
<p>DOM2 Core 还针对document.implementation对象增加了两个新方法：createDocumentType()和createDocument()。前者用于创建DocumentType类型的新节点，接收 3 个参数：文档类型名称、publicId和systemId。</p>
<p>已有文档的文档类型不可更改，因此createDocumentType()只在创建新文档时才会用到，而创建新文档要使用createDocument()方 法 。createDocument()接收3个参数 ：文档元素的namespaceURI、文档元素的标签名和文档类型。</p>
<p>DOM2 HTML 模块也为document.implamentation对象添加了createHTMLDocument()方法。使用这个方法可以创建一个完整的 HTML 文档，包含<html>、<head>、<title>和<body>元素。这个方法只接收一个参数，即新创建文档的标题（放到<title>元素中），返回一个新的 HTML 文档。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> htmldoc = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createHTMLDocument</span>(<span class="string">&quot;New Doc&quot;</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(htmldoc.<span class="property">title</span>);        <span class="comment">// &quot;New Doc&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> htmldoc.<span class="property">body</span>);  <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>createHTMLDocument()方法创建的对象是HTMLDocument类型的实例，因此包括该类型所有相关的方法和属性，包括title和body属性。</p>
<ol start="3">
<li>Node的变化</li>
</ol>
<p>DOM3 新增了两个用于比较节点的方法：isSameNode()和isEqualNode()。这两个方法都接收一个节点参数，如果这个节点与参考节点相同或相等，则返回true。节点相同，意味着引用同一个对象；节点相等，意味着节点类型相同，拥有相等的属性（nodeName、nodeValue等），而且 attributes 和childNodes也相等（即同样的位置包含相等的值）。</p>
<p>DOM3 也增加了给 DOM 节点附加额外数据的方法。setUserData()方法接收 3 个参数：键、值、处理函数，用于给节点追加数据。</p>
<p>setUserData()的处理函数会在包含数据的节点被复制、删除、重命名或导入其他文档的时候执行，可以在这时候决定如何处理用户数据。处理函数接收 5 个参数：表示操作类型的数值（1代表复制，2代表导入，3代表删除，4代表重命名）、数据的键、数据的值、源节点和目标节点。删除节点时，源节点为null；除复制外，目标节点都为null。</p>
<ol start="4">
<li>内嵌窗格的变化</li>
</ol>
<p>DOM2 HTML 给HTMLIFrameElement（即<iframe>，内嵌窗格）类型新增了一个属性，叫 contentDocument。这个属性包含代表子内嵌窗格中内容的document对象的指针。</p>
<p>还有一个属性contentWindow，返回相应窗格的window对象，这个对象上有一个document属性。所有现代浏览器都支持contentDocument和contentWindow属性。</p>
<blockquote>
<p>跨源访问子内嵌窗格的 document 对象会受到安全限制。如果内嵌窗格中加载了不同域名（或子域名）的页面，或者该页面使用了不同协议，则访问其document对象会抛出错误。</p>
</blockquote>
<h3 id="16-2-样式"><a href="#16-2-样式" class="headerlink" title="16.2 样式"></a>16.2 样式</h3><p>HTML 中的样式有 3 种定义方式：外部样式表（通过<link>元素）、文档样式表（使用<style>元素）和元素特定样式（使用style属性）。</p>
<h4 id="16-2-1-存取元素样式"><a href="#16-2-1-存取元素样式" class="headerlink" title="16.2.1 存取元素样式"></a>16.2.1 存取元素样式</h4><p>任何支持style属性的 HTML 元素在 JavaScript 中都会有一个对应的style属性。这个style属性是CSSStyleDeclaration类型的实例，其中包含通过 HTML style属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式。HTML style属性中的 CSS 属性在 JavaScript style对象中都有对应的属性。因为 CSS 属性名使用连字符表示法（用连字符分隔两个单词，如background-image），所以在 JavaScript 中这些属性必须转换为驼峰大小写形式（如backgroundImage）。</p>
<p>大多数属性名会这样直接转换过来。但有一个 CSS 属性名不能直接转换，它就是float。因为float是 JavaScript 的保留字，所以不能用作属性名。DOM2 Style 规定它在style对象中对应的属性应该是cssFloat。<br>任何时候，只要获得了有效 DOM 元素的引用，就可以通过 JavaScript 来设置样式。</p>
<blockquote>
<p>在标准模式下，所有尺寸都必须包含单位。在混杂模式下，可以把style.width设置为”20”，相当于”20px”。如果是在标准模式下，把style.width设置为”20”会被忽略，因为没有单位。实践中，最好一直加上单位。</p>
</blockquote>
<p>如果元素上没有style属性，则style对象包含所有可能的 CSS 属性的空值。</p>
<ol>
<li>DOM 样式属性和方法</li>
</ol>
<p>DOM2 Style 规范也在style对象上定义了一些属性和方法。这些属性和方法提供了元素style属性的信息并支持修改。</p>
<ul>
<li><p>cssText，包含style属性中的 CSS 代码。 </p>
</li>
<li><p>length，应用给元素的 CSS 属性数量。 </p>
</li>
<li><p>parentRule，表示 CSS 信息的CSSRule对象。 </p>
</li>
<li><p>getPropertyCSSValue(propertyName)，返回包含 CSS 属性propertyName值的CSSValue对象（已废弃）。 </p>
</li>
<li><p>getPropertyPriority(propertyName)，如果 CSS 属性propertyName使用了!important则返回”important”，否则返回空字符串。 </p>
</li>
<li><p>getPropertyValue(propertyName)，返回属性propertyName的字符串值。 </p>
</li>
<li><p>item(index)，返回索引为index的 CSS 属性名。 </p>
</li>
<li><p>removeProperty(propertyName)，从样式中删除 CSS 属性propertyName。 </p>
</li>
<li><p>setProperty(propertyName, value, priority)，设置 CSS 属性propertyName的值为value，priority是”important”或空字符串。</p>
</li>
</ul>
<p>通过cssText属性可以存取样式的 CSS 代码。在读模式下，cssText返回style属性 CSS 代码在浏览器内部的表示。在写模式下，给cssText赋值会重写整个style属性的值，意味着之前通过style属性设置的属性都会丢失。</p>
<p>设置cssText是一次性修改元素多个样式最快捷的方式，因为所有变化会同时生效。<br>length属性是跟item()方法一起配套迭代 CSS 属性用的。此时，style对象实际上变成了一个集合，也可以用中括号代替item()取得相应位置的 CSS 属性名。</p>
<p>如果需要更多信息，则可以通过getPropertyCSSValue()获取CSSValue对象。这个对象有两个属性：cssText和cssValueType。前者的值与getPropertyValue()方法返回的值一样；后者是一个数值常量，表示当前值的类型（0代表继承的值，1代表原始值，2代表列表，3代表自定义值）。</p>
<p>removeProperty()方法用于从元素样式中删除指定的 CSS 属性。使用这个方法删除属性意味着会应用该属性的默认（从其他样式表层叠继承的）样式。</p>
<p>在不确定给定 CSS 属性的默认值是什么的时候，可以使用这个方法。只要从style属性中删除，就可以使用默认值。</p>
<ol start="2">
<li>计算样式</li>
</ol>
<p>style对象中包含支持style属性的元素为这个属性设置的样式信息，但不包含从其他样式表层叠继承的同样影响该元素的样式信息。DOM2 Style在document.defaultView上增加了getComputedStyle()方法。这个方法接收两个参数：要取得计算样式的元素和伪元素字符串（如”:after”）。如果不需要查询伪元素，则第二个参数可以传null。getComputedStyle()方法返回一个CSSStyleDeclaration对象（与style属性的类型一样），包含元素的计算样式。</p>
<blockquote>
<p>浏览器虽然会返回样式值，但返回值的格式不一定相同。比如，Firefox 和 Safari 会把所有颜色值转换为 RGB 格式（如红色会变成rgb(255,0,0)），而 Opera 把所有颜色转换为十六进制表示法（如红色会变成#ff0000）。因此在使用getComputedStyle()时一定要多测试几个浏览器。</p>
</blockquote>
<p>关于计算样式要记住一点，在所有浏览器中计算样式都是只读的，不能修改getComputedStyle()方法返回的对象。</p>
<h4 id="16-2-2-操作样式表"><a href="#16-2-2-操作样式表" class="headerlink" title="16.2.2 操作样式表"></a>16.2.2 操作样式表</h4><p>CSSStyleSheet类型表示 CSS 样式表，包括使用<link>元素和通过<style>元素定义的样式表。注意，这两个元素本身分别是HTMLLinkElement和HTMLStyleElement。CSSStyleSheet类型是一个通用样式表类型，可以表示以任何方式在 HTML 中定义的样式表。另外，元素特定的类型允许修改HTML 属性，而CSSStyleSheet类型的实例则是一个只读对象（只有一个属性例外）。</p>
<p>CSSStyleSheet类型继承StyleSheet，后者可用作非CSS样式表的基类。以下是CSSStyleSheet从StyleSheet继承的属性。</p>
<ul>
<li><p>disabled，布尔值，表示样式表是否被禁用了（这个属性是可读写的，因此将它设置为true会禁用样式表）。 </p>
</li>
<li><p>href，如果是使用<link>包含的样式表，则返回样式表的 URL，否则返回null。 </p>
</li>
<li><p>media，样式表支持的媒体类型集合，这个集合有一个length属性和一个item()方法，跟所有 DOM 集合一样。同样跟所有 DOM 集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表。 </p>
</li>
<li><p>ownerNode，指向拥有当前样式表的节点，在 HTML 中要么是<link>元素要么是<style>元素（在 XML 中可以是处理指令）。如果当前样式表是通过@import被包含在另一个样式表中，则这个属性值为null。</p>
</li>
<li><p>parentStyleSheet，如果当前样式表是通过@import被包含在另一个样式表中，则这个属性指向导入它的样式表。 </p>
</li>
<li><p>title，ownerNode的title属性。 </p>
</li>
<li><p>type，字符串，表示样式表的类型。对 CSS 样式表来说，就是”text/css”。</p>
</li>
</ul>
<p>上述属性里除了disabled，其他属性都是只读的。除了上面继承的属性，CSSStyleSheet类型还支持以下属性和方法。</p>
<ul>
<li><p>cssRules，当前样式表包含的样式规则的集合。 </p>
</li>
<li><p>ownerRule，如果样式表是使用@import导入的，则指向导入规则；否则为null。 </p>
</li>
<li><p>deleteRule(index)，在指定位置删除cssRules中的规则。 </p>
</li>
<li><p>insertRule(rule, index)，在指定位置向cssRules中插入规则。</p>
</li>
</ul>
<p>document.styleSheets表示文档中可用的样式表集合。这个集合的length属性保存着文档中样式表的数量，而每个样式表都可以使用中括号或item()方法获取。</p>
<p>通过<link>或<style>元素也可以直接获取CSSStyleSheet对象。DOM 在这两个元素上暴露了sheet属性，其中包含对应的CSSStyleSheet对象。</p>
<ol>
<li>CSS 规则</li>
</ol>
<p>CSSRule类型表示样式表中的一条规则。这个类型也是一个通用基类，很多类型都继承它，但其中最常用的是表示样式信息的CSSStyleRule:</p>
<ul>
<li><p>cssText，返回整条规则的文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。Safari 始终会把所有字母都转换为小写。 </p>
</li>
<li><p>parentRule，如果这条规则被其他规则（如@media）包含，则指向包含规则，否则就是null。 </p>
</li>
<li><p>parentStyleSheet，包含当前规则的样式表。 </p>
</li>
<li><p>selectorText，返回规则的选择符文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。这个属性在 Firefox、Safari、Chrome 和 IE 中是只读的，在 Opera 中是可以修改的。 </p>
</li>
<li><p>style，返回CSSStyleDeclaration对象，可以设置和获取当前规则中的样式。 </p>
</li>
<li><p>type，数值常量，表示规则类型。对于样式规则，它始终为1。</p>
</li>
</ul>
<p>在这些属性中，使用最多的是cssText、selectorText和style。cssText属性与style.cssText类似，不过并不完全一样。前者包含选择符文本和环绕样式声明的大括号，而后者则只包含样式声明（类似于元素上的style.cssText）。此外，cssText是只读的，而style.cssText可以被重写。</p>
<ol start="2">
<li>创建规则</li>
</ol>
<p>DOM 规定，可以使用insertRule()方法向样式表中添加新规则。这个方法接收两个参数：规则的文本和表示插入位置的索引值。</p>
<ol start="3">
<li>删除规则</li>
</ol>
<p>支持从样式表中删除规则的 DOM 方法是deleteRule()，它接收一个参数：要删除规则的索引。要删除样式表中的第一条规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheet.<span class="title function_">deleteRule</span>(<span class="number">0</span>);  <span class="comment">// 使用 DOM 方法</span></span><br></pre></td></tr></table></figure>

<h4 id="16-2-3-元素尺寸"><a href="#16-2-3-元素尺寸" class="headerlink" title="16.2.3 元素尺寸"></a>16.2.3 元素尺寸</h4><ol>
<li>偏移尺寸</li>
</ol>
<p>第一组属性涉及偏移尺寸（offset dimensions），包含元素在屏幕上占用的所有视觉空间。元素在页面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框（但不包含外边距）。以下 4 个属性用于取得元素的偏移尺寸。</p>
<ul>
<li><p>offsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度（如果可见）和上、下边框的高度。 </p>
</li>
<li><p>offsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数。 </p>
</li>
<li><p>offsetTop，元素上边框外侧距离包含元素上边框内侧的像素数。 </p>
</li>
<li><p>offsetWidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度（如果可见）和左、右边框的宽度。</p>
</li>
</ul>
<p>其中，offsetLeft和offsetTop是相对于包含元素的，包含元素保存在offsetParent属性中。offsetParent不一定是parentNode。</p>
<p><img src="D:\dell\Documents\img\2024-02-21-17-06-17-image.png"></p>
<p>要确定一个元素在页面中的偏移量，可以把它的offsetLeft和offsetTop属性分别与offsetParent的相同属性相加，一直加到根元素。</p>
<blockquote>
<p>所有这些偏移尺寸属性都是只读的，每次访问都会重新计算。因此，应该尽量减少查询它们的次数。比如把查询的值保存在局量中，就可以避免影响性能。</p>
</blockquote>
<ol start="2">
<li>客户端尺寸</li>
</ol>
<p>元素的客户端尺寸（client dimensions）包含元素内容及其内边距所占用的空间。客户端尺寸只有两个相关属性：clientWidth和clientHeight。其中，clientWidth是内容区宽度加左、右内边距宽度，clientHeight是内容区高度加上、下内边距高度。</p>
<p><img src="D:\dell\Documents\img\2024-02-21-17-07-22-image.png"></p>
<p>客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间。这两个属性最常用于确定浏览器视口尺寸，即检测document.documentElement的clientWidth和clientHeight。这两个属性表示视口（<html>或<body>元素）的尺寸。</p>
<blockquote>
<p>与偏移尺寸一样，客户端尺寸也是只读的，而且每次访问都会重新计算。</p>
</blockquote>
<ol start="3">
<li>滚动尺寸</li>
</ol>
<p>最后一组尺寸是滚动尺寸（scroll dimensions），提供了元素内容滚动距离的信息。有些元素，比如<html>无须任何代码就可以自动滚动，而其他元素则需要使用 CSS 的overflow属性令其滚动。滚动尺寸相关的属性有如下 4 个。</p>
<ul>
<li><p>scrollHeight，没有滚动条出现时，元素内容的总高度。 </p>
</li>
<li><p>scrollLeft，内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。 </p>
</li>
<li><p>scrollTop，内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。 </p>
</li>
<li><p>scrollWidth，没有滚动条出现时，元素内容的总宽度。</p>
</li>
</ul>
<p><img src="D:\dell\Documents\img\2024-02-21-17-08-37-image.png"></p>
<p>scrollWidth和scrollHeight可以用来确定给定元素内容的实际尺寸。</p>
<p>如果文档尺寸超过视口尺寸，则在所有主流浏览器中这两对属性都不相等，scrollWidth和scollHeight等于文档内容的宽度，而clientWidth和clientHeight等于视口的大小。</p>
<p>scrollLeft和scrollTop属性可以用于确定当前元素滚动的位置，或者用于设置它们的滚动位置。元素在未滚动时，这两个属性都等于0。</p>
<ol start="4">
<li>确定元素尺寸</li>
</ol>
<p>浏览器在每个元素上都暴露了getBoundingClientRect()方法，返回一个DOMRect对象，包含6 个属性：left、top、right、bottom、height和width。这些属性给出了元素在页面中相对于视口的位置。</p>
<h3 id="16-3-遍历"><a href="#16-3-遍历" class="headerlink" title="16.3 遍历"></a>16.3 遍历</h3><p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型—— NodeIterator和TreeWalker——从某个起点开始执行对 DOM 结构的深度优先遍历。<br>DOM 遍历是对 DOM 结构的深度优先遍历，至少允许朝两个方向移动（取决于类型）。遍历以给定节点为根，不能在 DOM 中向上超越这个根节点。</p>
<h4 id="16-3-1-NodeIterator"><a href="#16-3-1-NodeIterator" class="headerlink" title="16.3.1 NodeIterator"></a>16.3.1 NodeIterator</h4><p>NodeIterator类型是两个类型中比较简单的，可以通过document.createNodeIterator()方法创建其实例。这个方法接收以下 4 个参数。</p>
<ul>
<li><p>root，作为遍历根节点的节点。 </p>
</li>
<li><p>whatToShow，数值代码，表示应该访问哪些节点。 </p>
</li>
<li><p>filter，NodeFilter对象或函数，表示是否接收或跳过特定节点。 </p>
</li>
<li><p>entityReferenceExpansion，布尔值，表示是否扩展实体引用。这个参数在 HTML 文档中没有效果，因为实体引用永远不扩展。</p>
</li>
</ul>
<p>whatToShow参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在NodeFilter类型中定义的。</p>
<ul>
<li><p>NodeFilter.SHOW_ALL，所有节点。 </p>
</li>
<li><p>NodeFilter.SHOW_ELEMENT，元素节点。 </p>
</li>
<li><p>NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上。 </p>
</li>
<li><p>NodeFilter.SHOW_TEXT，文本节点。 </p>
</li>
<li><p>NodeFilter.SHOW_CDATA_SECTION，CData 区块节点。不是在 HTML 页面中使用的。 </p>
</li>
<li><p>NodeFilter.SHOW_ENTITY_REFERENCE，实体引用节点。不是在 HTML 页面中使用的。 </p>
</li>
<li><p>NodeFilter.SHOW_ENTITY，实体节点。不是在 HTML 页面中使用的。 </p>
</li>
<li><p>NodeFilter.SHOW_PROCESSING_INSTRUCTION，处理指令节点。不是在 HTML 页面中使用的。 </p>
</li>
<li><p>NodeFilter.SHOW_COMMENT，注释节点。 </p>
</li>
<li><p>NodeFilter.SHOW_DOCUMENT，文档节点。 </p>
</li>
<li><p>NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。 </p>
</li>
<li><p>NodeFilter.SHOW_DOCUMENT_FRAGMENT，文档片段节点。不是在 HTML 页面中使用的。 </p>
</li>
<li><p>NodeFilter.SHOW_NOTATION，记号节点。不是在 HTML 页面中使用的。</p>
</li>
</ul>
<p>这些值除了NodeFilter.SHOW_ALL之外，都可以组合使用。</p>
<p>createNodeIterator()方法的filter参数可以用来指定自定义NodeFilter对象，或者一个作为节点过滤器的函数。NodeFilter对象只有一个方法acceptNode()，如果给定节点应该访问就返回NodeFilter.FILTER_ACCEPT，否则返回NodeFilter.FILTER_SKIP。因为NodeFilter是一个抽象类型，所以不可能创建它的实例。只要创建一个包含acceptNode()的对象，然后把它传给createNodeIterator()就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码定义了只接收&lt;p&gt;元素的节点过滤器对象</span></span><br><span class="line"><span class="keyword">let</span> filter = &#123; </span><br><span class="line">  <span class="title function_">acceptNode</span>(<span class="params">node</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;p&quot;</span> ? </span><br><span class="line">         <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line">         <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(root, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>,   </span><br><span class="line">                                           filter, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>filter参数还可以是一个函数，与acceptNode()的形式一样.</p>
<p>如果不需要指定过滤器，则可以给这个参数传入null。</p>
<p>NodeIterator的两个主要方法是nextNode()和previousNode()。nextNode()方法在 DOM子树中以深度优先方式进前一步，而previousNode()则是在遍历中后退一步。创建NodeIterator对象的时候，会有一个内部指针指向根节点，因此第一次调用nextNode()返回的是根节点。当遍历到达 DOM 树最后一个节点时，nextNode()返回null。previousNode()方法也是类似的。当遍历到达DOM 树最后一个节点时，调用previousNode()返回遍历的根节点后，再次调用也会返回null。</p>
<h4 id="16-3-2-TreeWalker"><a href="#16-3-2-TreeWalker" class="headerlink" title="16.3.2 TreeWalker"></a>16.3.2 TreeWalker</h4><p>TreeWalker是NodeIterator的高级版。除了包含同样的nextNode()、previousNode()方法，TreeWalker还添加了如下在 DOM 结构中向不同方向遍历的方法。</p>
<ul>
<li><p>parentNode()，遍历到当前节点的父节点。 </p>
</li>
<li><p>firstChild()，遍历到当前节点的第一个子节点。 </p>
</li>
<li><p>lastChild()，遍历到当前节点的最后一个子节点。 </p>
</li>
<li><p>nextSibling()，遍历到当前节点的下一个同胞节点。 </p>
</li>
<li><p>previousSibling()，遍历到当前节点的上一个同胞节点。</p>
</li>
</ul>
<p>TreeWalker对象要调 用document.createTreeWalker()方法来 创建，这 个 方法接收 与document.createNodeIterator()同样的参数：作为遍历起点的根节点、要查看的节点类型、节点过滤器和一个表示是否扩展实体引用的布尔值。因为两者很类似，所以TreeWalker通常可以取代NodeIterator。</p>
<p>不同的是，节点过滤器（filter）除了可以返回NodeFilter.FILTER_ACCEPT和NodeFilter. FILTER_SKIP，还可以返回NodeFilter.FILTER_REJECT。在使用NodeIterator时，NodeFilter. FILTER_SKIP和NodeFilter.FILTER_REJECT是一样的。但在使用TreeWalker时，NodeFilter. FILTER_SKIP表示跳过节点，访问子树中的下一个节点，而NodeFilter.FILTER_REJECT则表示跳过该节点以及该节点的整个子树。</p>
<p>TreeWalker类型也有一个名为currentNode的属性，表示遍历过程中上一次返回的节点（无论使用的是哪个遍历方法）。可以通过修改这个属性来影响接下来遍历的起点。</p>
<h3 id="16-4-范围"><a href="#16-4-范围" class="headerlink" title="16.4 范围"></a>16.4 范围</h3><h4 id="16-4-1-DOM-范围"><a href="#16-4-1-DOM-范围" class="headerlink" title="16.4.1 DOM 范围"></a>16.4.1 DOM 范围</h4><p>DOM2 在Document类型上定义了一个createRange()方法，暴露在document对象上。使用这个方法可以创建一个 DOM 范围对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br></pre></td></tr></table></figure>

<p>与节点类似，这个新创建的范围对象是与创建它的文档关联的，不能在其他文档中使用。然后可以使用这个范围在后台选择文档特定的部分。创建范围并指定它的位置之后，可以对范围的内容执行一些操作，从而实现对底层 DOM 树更精细的控制。<br>每个范围都是Range类型的实例，拥有相应的属性和方法。</p>
<ul>
<li><p>startContainer，范围起点所在的节点（选区中第一个子节点的父节点）。 </p>
</li>
<li><p>startOffset，范围起点在startContainer中的偏移量。如果startContainer是文本节点、注释节点或 CData 区块节点，则startOffset指范围起点之前跳过的字符数；否则，表示范围中第一个节点的索引。 </p>
</li>
<li><p>endContainer，范围终点所在的节点（选区中最后一个子节点的父节点）。 </p>
</li>
<li><p>endOffset，范围起点在startContainer中的偏移量（与startOffset中偏移量的含义相同）。 </p>
</li>
<li><p>commonAncestorContainer，文档中以startContainer和endContainer为后代的最深的节点。 这些属性会在范围被放到文档中特定位置时获得相应的值。</p>
</li>
</ul>
<h4 id="16-4-2-简单选择"><a href="#16-4-2-简单选择" class="headerlink" title="16.4.2 简单选择"></a>16.4.2 简单选择</h4><p>通过范围选择文档中某个部分最简单的方式，就是使用selectNode()或selectNodeContents()方法。这两个方法都接收一个节点作为参数，并将该节点的信息添加到调用它的范围。selectNode()方法选择整个节点，包括其后代节点，而selectNodeContents()只选择节点的后代。</p>
<p>调用selectNode()时，startContainer、endContainer和commonAncestorContainer都等于传入节点的父节点。</p>
<p>在调用selectNodeContents()时，startContainer、endContainer和commonAncestor Container属性就是传入的节点。</p>
<p>选定节点或节点后代之后，还可以在范围上调用相应的方法，实现对范围中选区的更精细控制。</p>
<ul>
<li><p>setStartBefore(refNode)，把范围的起点设置到refNode之前，从而让refNode成为选区的第一个子节点。startContainer属性被设置为refNode.parentNode，而startOffset属性被设置为refNode在其父节点childNodes集合中的索引。 </p>
</li>
<li><p>setStartAfter(refNode)，把范围的起点设置到refNode之后，从而将refNode排除在选区之外，让其下一个同胞节点成为选区的第一个子节点。startContainer属性被设置为refNode.parentNode，startOffset属性被设置为refNode在其父节点childNodes集合中的索引加1。 </p>
</li>
<li><p>setEndBefore(refNode)，把范围的终点设置到refNode之前，从而将refNode排除在选区之外、让其上一个同胞节点成为选区的最后一个子节点。endContainer属性被设置为refNode.parentNode，endOffset属性被设置为refNode在其父节点childNodes集合中的索引。 </p>
</li>
<li><p>setEndAfter(refNode)，把范围的终点设置到refNode之后，从而让refNode成为选区的最后一个子节点。endContainer属性被设置为refNode.parentNode，endOffset属性被设置为refNode在其父节点childNodes集合中的索引加1。</p>
</li>
</ul>
<p>调用这些方法时，所有属性都会自动重新赋值。不过，为了实现复杂的选区，也可以直接修改这些属性的值。</p>
<h4 id="16-4-3-复杂选择"><a href="#16-4-3-复杂选择" class="headerlink" title="16.4.3 复杂选择"></a>16.4.3 复杂选择</h4><p>要创建复杂的范围，需要使用setStart()和setEnd()方法。这两个方法都接收两个参数：参照节点和偏移量。对setStart()来说，参照节点会成为startContainer，而偏移量会赋值给startOffset。对setEnd()而言，参照节点会成为endContainer，而偏移量会赋值给endOffset。</p>
<h4 id="16-4-4-操作范围"><a href="#16-4-4-操作范围" class="headerlink" title="16.4.4 操作范围"></a>16.4.4 操作范围</h4><p>创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。为操作范围的内容，选区中的内容必须格式完好。</p>
<p>第一个方法最容易理解和使用：deleteContents()。顾名思义，这个方法会从文档中删除范围包含的节点。</p>
<p>另一个方法extractContents()跟deleteContents()类似，也会从文档中移除范围选区。但不同的是，extractContents()方法返回范围对应的文档片段。这样，就可以把范围选中的内容插入文档中其他地方。</p>
<p>如果不想把范围从文档中移除，也可以使用cloneContents()创建一个副本，然后把这个副本插入到文档其他地方。</p>
<p>这个方法跟extractContents()很相似，因为它们都返回文档片段。主要区别是cloneContents()返回的文档片段包含范围中节点的副本，而非实际的节点。</p>
<h4 id="16-4-5-范围插入"><a href="#16-4-5-范围插入" class="headerlink" title="16.4.5 范围插入"></a>16.4.5 范围插入</h4><p>使用insertNode()方法可以在范围选区的开始位置插入一个节点。</p>
<p>除了向范围中插入内容，还可以使用surroundContents()方法插入包含范围的内容。这个方法接收一个参数，即包含范围内容的节点。调用这个方法时，后台会执行如下操作：<br>(1) 提取出范围的内容；<br>(2) 在原始文档中范围之前所在的位置插入给定的节点；<br>(3) 将范围对应文档片段的内容添加到给定节点。<br>这种功能适合在网页中高亮显示某些关键词，</p>
<p>为了插入&lt;**span**&gt;元素，范围中必须包含完整的 DOM 结构。如果范围中包含部分选择的非文节点，这个操作会失败并报错。另外，如果给定的节点是Document、DocumentType或DocumentFragment类型，也会导致抛出错误。</p>
<h4 id="16-4-6-范围折叠"><a href="#16-4-6-范围折叠" class="headerlink" title="16.4.6 范围折叠"></a>16.4.6 范围折叠</h4><p>如果范围并没有选择文档的任何部分，则称为折叠（collapsed）。</p>
<p>折叠范围可以使用collapse()方法，这个方法接收一个参数：布尔值，表示折叠到范围哪一端。true表示折叠到起点，false表示折叠到终点。要确定范围是否已经被折叠，可以检测范围的collapsed属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>);          <span class="comment">// 折叠到起点 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range.<span class="property">collapsed</span>);  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p>测试范围是否被折叠，能够帮助确定范围中的两个节点是否相邻。</p>
<h4 id="16-4-7-范围比较"><a href="#16-4-7-范围比较" class="headerlink" title="16.4.7 范围比较"></a>16.4.7 范围比较</h4><p>如果有多个范围，则可以使用compareBoundaryPoints()方法确定范围之间是否存在公共的边界（起点或终点）。这个方法接收两个参数：要比较的范围和一个常量值，表示比较的方式。这个常量参数包括： </p>
<ul>
<li><p>Range.START_TO_START（0），比较两个范围的起点； </p>
</li>
<li><p>Range.START_TO_END（1），比较第一个范围的起点和第二个范围的终点； </p>
</li>
<li><p>Range.END_TO_END（2），比较两个范围的终点； </p>
</li>
<li><p>Range.END_TO_START（3），比较第一个范围的终点和第二个范围的起点。</p>
</li>
</ul>
<p>compareBoundaryPoints()方法在第一个范围的边界点位于第二个范围的边界点之前时返回-1，在两个范围的边界点相等时返回0，在第一个范围的边界点位于第二个范围的边界点之后时返回1。</p>
<h4 id="16-4-8-复制范围"><a href="#16-4-8-复制范围" class="headerlink" title="16.4.8 复制范围"></a>16.4.8 复制范围</h4><p>调用范围的cloneRange()方法可以复制范围。这个方法会创建调用它的范围的副本： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newRange = range.<span class="title function_">cloneRange</span>();</span><br></pre></td></tr></table></figure>

<p>新范围包含与原始范围一样的属性，修改其边界点不会影响原始范围。</p>
<h4 id="16-4-9-清理"><a href="#16-4-9-清理" class="headerlink" title="16.4.9 清理"></a>16.4.9 清理</h4><p>在使用完范围之后，最好调用detach()方法把范围从创建它的文档中剥离。调用detach()之后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存。</p>
<h3 id="16-5-小结"><a href="#16-5-小结" class="headerlink" title="16.5 小结"></a>16.5 小结</h3><p>DOM2 规范定义了一些模块，用来丰富 DOM1 的功能。DOM2 Core 在一些类型上增加了与 XML命名空间有关的新方法。这些变化只有在使用 XML 或 XHTML 文档时才会用到，在 HTML 文档中则没有用处。DOM2 增加的与 XML 命名空间无关的方法涉及以编程方式创建Document和DocumentType类型的新实例。</p>
<p>DOM2 Style 模块定义了如何操作元素的样式信息。</p>
<ul>
<li><p>每个元素都有一个关联的style对象，可用于确定和修改元素特定的样式。 </p>
</li>
<li><p>要确定元素的计算样式，包括应用到元素身上的所有 CSS规则，可以使用getComputedStyle()方法。 </p>
</li>
<li><p>通过document.styleSheets集合可以访问文档上所有的样式表。 DOM2 Traversal and Range 模块定义了与 DOM 结构交互的不同方式。 </p>
</li>
<li><p>NodeIterator和TreeWalker可以对 DOM 树执行深度优先的遍历。 </p>
</li>
<li><p>NodeIterator接口很简单，每次只能向前和向后移动一步。TreeWalker除了支持同样的行为，还支持在 DOM 结构的所有方向移动，包括父节点、同胞节点和子节点。 </p>
</li>
<li><p>范围是选择 DOM 结构中特定部分并进行操作的一种方式。 </p>
</li>
<li><p>通过范围的选区可以在保持文档结构完好的同时从文档中移除内容，也可复制文档中相应的部分。</p>
</li>
</ul>
<h2 id="十七、事件"><a href="#十七、事件" class="headerlink" title="十七、事件"></a>十七、事件</h2><p><strong>JavaScript</strong> 与 <strong>HTML</strong> 的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫“观察者模式”，其能够做到页面行为（在 <strong>JavaScript</strong> 中定义）与页面展示（在 <strong>HTML</strong> 和 <strong>CSS</strong> 中定义）的分离。</p>
<h3 id="17-1-事件流"><a href="#17-1-事件流" class="headerlink" title="17.1 事件流"></a>17.1 事件流</h3><p>事件流描述了页面接收事件的顺序。IE 将支持事件冒泡流，而 Netscape Communicator 将支持事件捕获流。</p>
<h4 id="17-1-1-事件冒泡"><a href="#17-1-1-事件冒泡" class="headerlink" title="17.1.1 事件冒泡"></a>17.1.1 事件冒泡</h4><p><strong>IE</strong> 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。</p>
<p>所有现代浏览器都支持事件冒泡，只是在实现方式上会有一些变化。</p>
<h4 id="17-1-2-事件捕获"><a href="#17-1-2-事件捕获" class="headerlink" title="17.1.2 事件捕获"></a>17.1.2 事件捕获</h4><p>事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。</p>
<p>实际上，所有浏览器都是从 <strong>window</strong> 对象开始捕获事件，而 <strong>DOM2 Events</strong> 规范规定的是从 <strong>document</strong> 开始。</p>
<p>通常建议使用事件冒泡，特殊情况下可以使用事件捕获。</p>
<h4 id="17-1-3-DOM-事件流"><a href="#17-1-3-DOM-事件流" class="headerlink" title="17.1.3 DOM 事件流"></a>17.1.3 DOM 事件流</h4><p><strong>DOM2 Events</strong> 规范规定事件流分为 <strong>3</strong> 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。</p>
<p>在 <strong>DOM</strong> 事件流中，实际的目标在捕获阶段不会接收到事件。这是因为捕获阶段从 <strong>document</strong> 到&lt;**html**&gt;再到&lt;**body**&gt;就结束了。下一阶段，即会在&lt;**div**&gt;元素上触发事件的“到达目标”阶段，通常在事件处理时被认为是冒泡阶段的一部分。然后，冒泡阶段开始，事件反向传播至文档。</p>
<p>虽然 <strong>DOM2 Events</strong> 规范明确捕获阶段不命中事件目标，但现代浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。</p>
<blockquote>
<p>所有现代浏览器都支持 <strong>DOM</strong> 事件流，只有 <strong>IE8</strong> 及更早版本不支持。</p>
</blockquote>
<h3 id="17-2-事件处理程序"><a href="#17-2-事件处理程序" class="headerlink" title="17.2 事件处理程序"></a>17.2 事件处理程序</h3><p>事件意味着用户或浏览器执行的某种动作。比如，单击（<strong>click</strong>）、加载（<strong>load</strong>）、鼠标悬停（<strong>mouseover</strong>）。为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字以”<strong>on</strong>“开头，因此 <strong>click</strong> 事件的处理程序叫作 <strong>onclick</strong>，而 <strong>load</strong> 事件的处理程序叫 <strong>onload</strong>。</p>
<h4 id="17-2-1-HTML-事件处理程序"><a href="#17-2-1-HTML-事件处理程序" class="headerlink" title="17.2.1 HTML 事件处理程序"></a>17.2.1 HTML 事件处理程序</h4><p>特定元素支持的每个事件都可以使用事件处理程序的名字以 <strong>HTML</strong> 属性的形式来指定。此时属性的值必须是能够执行的 <strong>JavaScript</strong> 代码。</p>
<p>在 HTML 中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本。</p>
<p>作为事件处理程序执行的代码可以访问全局作用域中的一切。</p>
<p>在 <strong>HTML</strong> 中指定事件处理程序有一些问题。第一个问题是时机问题。有可能 <strong>HTML</strong> 元素已经显示在页面上，用户都与其交互了，而事件处理程序的代码还无法执行。大多数 HTML 事件处理程序会封装在try/catch块中，以便在这种情况下静默失败。</p>
<p>另一个问题是对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同 <strong>JavaScript</strong> 引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。<br>使用 <strong>HTML</strong> 指定事件处理程序的最后一个问题是 <strong>HTML</strong> 与 <strong>JavaScript</strong> 强耦合。如果需要修改事件处理程序，则必须在两个地方，即 <strong>HTML</strong> 和 <strong>JavaScript</strong> 中，修改代码。</p>
<h4 id="17-2-2-DOM0-事件处理程序"><a href="#17-2-2-DOM0-事件处理程序" class="headerlink" title="17.2.2 DOM0 事件处理程序"></a>17.2.2 DOM0 事件处理程序</h4><p>在 JavaScript 中指定事件处理程序的传统方式是把一个函数赋值给（DOM 元素的）一个事件处理程序属性。</p>
<p>使用 JavaScript 指定事件处理程序，必须先取得要操作对象的引用。</p>
<p>每个元素（包括window和document）都有通常小写的事件处理程序属性，比如onclick。只要把这个属性赋值为一个函数即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>像这样使用 <strong>DOM0</strong> 方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即 this 等于元素。</p>
<p>以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。<br>通过将事件处理程序属性的值设置为 null，可以移除通过 DOM0 方式添加的事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>;  <span class="comment">// 移除事件处理程序</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果事件处理程序是在 HTML 中指定的，则onclick属性的值是一个包装相应 HTML 事件处理程序属性值的函数。这些事件处理程序也可以通过在 JavaScript 中将相应属性设置为null来移除。</p>
</blockquote>
<h4 id="17-2-3-DOM2-事件处理程序"><a href="#17-2-3-DOM2-事件处理程序" class="headerlink" title="17.2.3 DOM2 事件处理程序"></a>17.2.3 DOM2 事件处理程序</h4><p>DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：addEventListener()和removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，true表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>使用 DOM2 方式的主要优势是可以为同一个事件添加多个事件处理程序。</p>
<p>通过addEventListener()添加的事件处理程序只能使用removeEventListener()并传入与添加时同样的参数来移除。这意味着使用addEventListener()添加的匿名函数无法移除。</p>
<p>大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。</p>
<h4 id="17-2-4-IE-事件处理程序"><a href="#17-2-4-IE-事件处理程序" class="headerlink" title="17.2.4 IE 事件处理程序"></a>17.2.4 IE 事件处理程序</h4><p>IE 实现了与 DOM 类似的方法，即attachEvent()和detachEvent()。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用attachEvent()添加的事件处理程序会添加到冒泡阶段。<br>要使用attachEvent()给按钮添加click事件处理程序，可以使用以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);  </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 IE 中使用attachEvent()与使用 DOM0 方式的主要区别是事件处理程序的作用域。使用 DOM0方式时，事件处理程序中的this值等于目标元素。而使用attachEvent()时，事件处理程序是在全局作用域中运行的，因此this等于window。</p>
<p>与使用addEventListener()一样，使用attachEvent()方法也可以给一个元素添加多个事件处理程序。</p>
<p>与 DOM 方法不同，这里的事件处理程序会以添加它们的顺序反向触发。</p>
<p>使用attachEvent()添加的事件处理程序将使用detachEvent()来移除，只要提供相同的参数。与使用 DOM 方法类似，作为事件处理程序添加的匿名函数也无法移除。但只要传给detachEvent()方法相同的函数引用，就可以移除。</p>
<h4 id="17-2-5-跨浏览器事件处理程序"><a href="#17-2-5-跨浏览器事件处理程序" class="headerlink" title="17.2.5 跨浏览器事件处理程序"></a>17.2.5 跨浏览器事件处理程序</h4><p>为了以跨浏览器兼容的方式处理事件，要确保事件处理代码具有最大兼容性，只需要让代码在冒泡阶段运行即可。</p>
<p>需要先创建一个addHandler()方法。这个方法的任务是根据需要分别使用 DOM0 方式、DOM2 方式或 IE 方式来添加事件处理程序。这个方法会在EventUtil对象（本章示例使用的对象）上添加一个方法，以实现跨浏览器事件处理。添加的这个addHandler()方法接收 3 个参数：目标元素、事件名和事件处理函数。</p>
<p>有了addHandler()，还要写一个也接收同样的 3 个参数的removeHandler()。这个方法的任务是移除之前添加的事件处理程序，不管是通过何种方式添加的，默认为 DOM0 方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123; </span><br><span class="line">  <span class="attr">addHandler</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123; </span><br><span class="line">      element.<span class="title function_">addEventListener</span>(type, handler, <span class="literal">false</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;  </span><br><span class="line">      element.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line"></span><br><span class="line">  <span class="attr">removeHandler</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">removeEventListener</span>) &#123;  </span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(type, handler, <span class="literal">false</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">detachEvent</span>) &#123;  </span><br><span class="line">      element.<span class="title function_">detachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>; </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>DOM0 只支持给一个事件添加一个处理程序。</p>
<h3 id="17-3-事件对象"><a href="#17-3-事件对象" class="headerlink" title="17.3 事件对象"></a>17.3 事件对象</h3><p>在 DOM 合规的浏览器中，event对象是传给事件处理程序的唯一参数。不管以哪种方式（DOM0 或 DOM2）指定事件处理程序，都会传入这个event对象。</p>
<p>在通过 HTML 属性指定的事件处理程序中，同样可以使用变量event引用事件对象。</p>
<p>事件对象包含与特定事件相关的属性和方法。不同的事件生成的事件对象也会包含不同的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。</p>
<table>
<thead>
<tr>
<th align="center">属性/方法</th>
<th align="center">类型</th>
<th align="center">读/写</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bubbles</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td>表示事件是否冒泡</td>
</tr>
<tr>
<td align="center">cancelable</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td>表示是否可以取消事件的默认行为</td>
</tr>
<tr>
<td align="center">currentTarget</td>
<td align="center">元素</td>
<td align="center">只读</td>
<td>当前事件处理程序所在的元素</td>
</tr>
<tr>
<td align="center">defaultPrevented</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td>true表示已经调用preventDefault()方法（DOM3 Events 中新增）</td>
</tr>
<tr>
<td align="center">detail</td>
<td align="center">整数</td>
<td align="center">只读</td>
<td>事件相关的其他信息</td>
</tr>
<tr>
<td align="center">eventPhase</td>
<td align="center">整数</td>
<td align="center">只读</td>
<td>表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段</td>
</tr>
<tr>
<td align="center">preventDefault()</td>
<td align="center">函数</td>
<td align="center">只读</td>
<td>用于取消事件的默认行为。只有cancelable为true才可以调用这个方法</td>
</tr>
<tr>
<td align="center">stopImmediatePropagation()</td>
<td align="center">函数</td>
<td align="center">只读</td>
<td>用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events 中新增）</td>
</tr>
<tr>
<td align="center">stopPropagation()</td>
<td align="center">函数</td>
<td align="center">只读</td>
<td>用于取消所有后续事件捕获或事件冒泡。只有bubbles为true才可以调用这个方法</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">元素</td>
<td align="center">只读</td>
<td>事件目标</td>
</tr>
<tr>
<td align="center">trusted</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td>true表示事件是由浏览器生成的。false表示事件是开发者通过 JavaScript 创建的（DOM3 Events 中新增）</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">字符串</td>
<td align="center">只读</td>
<td>被触发的事件类型</td>
</tr>
<tr>
<td align="center">View</td>
<td align="center">AbstractView</td>
<td align="center">只读</td>
<td>与事件相关的抽象视图。等于事件所发生的window对象</td>
</tr>
</tbody></table>
<p>在事件处理程序内部，this对象始终等于currentTarget的值，而target只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标，则this、currentTarget和target的值是一样的。</p>
<p>type属性在一个处理程序处理多个事件时很有用。</p>
<p>preventDefault()方法用于阻止特定事件的默认动作。</p>
<p>任何可以通过preventDefault()取消默认行为的事件，其事件对象的cancelable属性都会设置为true。</p>
<p>stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。</p>
<p>eventPhase属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则eventPhase等于 1；如果事件处理程序在目标上被调用，则eventPhase等于 2；如果事件处理程序在冒泡阶段被调用，则eventPhase等于 3。不过要注意的是，虽然“到达目标”是在冒泡阶段发生的，但其eventPhase仍然等于 2。</p>
<blockquote>
<p>event对象只在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。</p>
</blockquote>
<h4 id="17-3-2-IE-事件对象"><a href="#17-3-2-IE-事件对象" class="headerlink" title="17.3.2 IE 事件对象"></a>17.3.2 IE 事件对象</h4><p>与 DOM 事件对象不同， IE 事件对象可以基于事件处理程序被指定的方式以不同方式来访问。如果事件处理程序是使用 DOM0 方式指定的，则event对象只是window对象的一个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> event = <span class="variable language_">window</span>.<span class="property">event</span>; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>);  <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果事件处理程序是使用attachEvent()指定的，则event对象会作为唯一的参数传给处理函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>);  <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果是使用 HTML 属性方式指定的事件处理程序，则event对象同样可以通过变量event访问（与 DOM 模型一样）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;Click Me&quot;</span> onclick=<span class="string">&quot;console.log(event.type)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>所有 IE 事件对象都会包含下表所列的公共属性和方法。</p>
<table>
<thead>
<tr>
<th align="center">属性/方法</th>
<th align="center">类型</th>
<th align="center">读/写</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cancelBubble</td>
<td align="center">布尔值</td>
<td align="center">读/写</td>
<td>默认为false，设置为true可以取消冒泡（与 DOM 的</td>
</tr>
<tr>
<td align="center">stopPropagation()方法相同）</td>
<td align="center"></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td align="center">returnValue</td>
<td align="center">布尔值</td>
<td align="center">读/写</td>
<td>默认为true，设置为false可以取消事件默认行为 （与 DOM 的preventDefault()方法相同）</td>
</tr>
<tr>
<td align="center">srcElement</td>
<td align="center">元素</td>
<td align="center">只读</td>
<td>事件目标（与 DOM 的target属性相同）</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">字符串</td>
<td align="center">只读</td>
<td>触发的事件类型</td>
</tr>
</tbody></table>
<p>由于事件处理程序的作用域取决于指定它的方式，因此this值并不总是等于事件目标。为此，更好的方式是使用事件对象的srcElement属性代替this。下面的例子表明，不同事件对象上的srcElement属性中保存的都是事件目标:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">event</span>.<span class="property">srcElement</span> === <span class="variable language_">this</span>);  <span class="comment">// true </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">srcElement</span> === <span class="variable language_">this</span>);         <span class="comment">// false </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>returnValue属性等价于 DOM 的preventDefault()方法，都是用于取消给定事件默认的行为。只不过在这里要把returnValue设置为false才是阻止默认动作。</p>
<p>与 DOM 不同，没有办法通过 JavaScript 确定事件是否可以被取消。<br>cancelBubble属性与 DOMstopPropagation()方法用途一样，都可以阻止事件冒泡。stopPropagation()则既取消捕获也取消冒泡。</p>
<h4 id="17-3-3-跨浏览器事件对象"><a href="#17-3-3-跨浏览器事件对象" class="headerlink" title="17.3.3 跨浏览器事件对象"></a>17.3.3 跨浏览器事件对象</h4><p>DOM 事件对象中包含 IE 事件对象的所有信息和能力，只是形式不同。这些共性可让两种事件模型之间的映射成为可能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123; </span><br><span class="line">  <span class="attr">addHandler</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123; </span><br><span class="line">     <span class="comment">//  </span></span><br><span class="line">  &#125;,  </span><br><span class="line"></span><br><span class="line">  <span class="attr">getEvent</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="variable language_">window</span>.<span class="property">event</span>; </span><br><span class="line">  &#125;, </span><br><span class="line"></span><br><span class="line">  <span class="attr">getTarget</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> event.<span class="property">target</span> || event.<span class="property">srcElement</span>; </span><br><span class="line"></span><br><span class="line">  &#125;, </span><br><span class="line"></span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">preventDefault</span>) &#123; </span><br><span class="line">      event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      event.<span class="property">returnValue</span> = <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, </span><br><span class="line"></span><br><span class="line">  <span class="attr">removeHandler</span>: <span class="keyword">function</span>(<span class="params">element, type, handler</span>) &#123;  </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">  &#125;,  </span><br><span class="line"></span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">stopPropagation</span>) &#123; </span><br><span class="line">      event.<span class="title function_">stopPropagation</span>(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      event.<span class="property">cancelBubble</span> = <span class="literal">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先是getEvent()，其返回对event对象的引用。IE 中事件对象的位置不同，而使用这个方法可以不用管事件处理程序是如何指定的，都可以获取到event对象。使用这个方法的前提是，事件处理程序必须接收event对象，并把它传给这个方法。</p>
<p>下面是使用EventUtil中这个方法统一获取event对象的一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line">  event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>在 DOM 合规的浏览器中，event对象会直接传入并返回。而在 IE 中，event对象可能并没有被定义（因为使用了attachEvent()），因此返回window.event。这样就可以确保无论使用什么浏览器，都可以获取到事件对象。<br>第二个方法是getTarget()，其返回事件目标。在这个方法中，首先检测event对象是否存在target属性。如果存在就返回这个值；否则，就返回event.srcElement属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line">  <span class="keyword">let</span> target = <span class="title class_">EventUtil</span>.<span class="title function_">getTarget</span>(event); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>第三个方法是preventDefault()，其用于阻止事件的默认行为。在传入的event对象上，如果有preventDefault()方法，就调用这个方法；否则，就将event.returnValue设置为false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLink&quot;</span>); </span><br><span class="line">link.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line">  <span class="title class_">EventUtil</span>.<span class="title function_">preventDefault</span>(event); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>第四个方法stopPropagation()以类似的方式运行。同样先检测用于停止事件流的 DOM 方法，如果没有再使用cancelBubble属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>);  </span><br><span class="line">  event = <span class="title class_">EventUtil</span>.<span class="title function_">getEvent</span>(event); </span><br><span class="line">  <span class="title class_">EventUtil</span>.<span class="title function_">stopPropagation</span>(event); </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body clicked&quot;</span>);  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>同样，先通过EventUtil.getEvent()获取事件对象，然后又把它传给了EventUtil.stopPropagation()。不过，这个方法在浏览器上可能会停止事件冒泡，也可能会既停止事件冒泡也停止事件捕获。</p>
<h3 id="17-4-事件类型"><a href="#17-4-事件类型" class="headerlink" title="17.4 事件类型"></a>17.4 事件类型</h3><p>DOM3 Events 定义了如下事件类型。 </p>
<ul>
<li><p>用户界面事件（UIEvent）：涉及与 BOM 交互的通用浏览器事件。 </p>
</li>
<li><p>焦点事件（FocusEvent）：在元素获得和失去焦点时触发。 </p>
</li>
<li><p>鼠标事件（MouseEvent）：使用鼠标在页面上执行某些操作时触发。 </p>
</li>
<li><p>滚轮事件（WheelEvent）：使用鼠标滚轮（或类似设备）时触发。 </p>
</li>
<li><p>输入事件（InputEvent）：向文档中输入文本时触发。 </p>
</li>
<li><p>键盘事件（KeyboardEvent）：使用键盘在页面上执行某些操作时触发。 </p>
</li>
<li><p>合成事件（CompositionEvent）：在使用某种 IME（Input Method Editor，输入法编辑器）输入字符时触发。 </p>
</li>
</ul>
<p>除了这些事件类型之外，HTML5 还定义了另一组事件，而浏览器通常在 DOM 和 BOM 上实现专有事件。</p>
<h4 id="17-4-1-用户界面事件"><a href="#17-4-1-用户界面事件" class="headerlink" title="17.4.1 用户界面事件"></a>17.4.1 用户界面事件</h4><p>用户界面事件或 UI 事件不一定跟用户操作有关。</p>
<p>UI 事件主要有以下几种。</p>
<ul>
<li><p>DOMActivate：元素被用户通过鼠标或键盘操作激活时触发（比click或keydown更通用）。这个事件在 DOM3 Events 中已经废弃。因为浏览器实现之间存在差异，所以不要使用它。</p>
</li>
<li><p>load：在window上当页面加载完成后触发，在窗套（&lt;**frameset**&gt;）上当所有窗格（&lt;**frame**&gt;）都加载完成后触发，在&lt;**img**&gt;元素上当图片加载完成后触发，在&lt;**object**&gt;元素上当相应对象加载完成后触发。 </p>
</li>
<li><p>unload：在window上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在&lt;**object**&gt;元素上当相应对象卸载完成后触发。 </p>
</li>
<li><p>abort：在&lt;**object**&gt;元素上当相应对象加载完成前被用户提前终止下载时触发。 </p>
</li>
<li><p>error：在window上当 JavaScript 报错时触发img元素上当无法加载指定图片时触发，在&lt;**object**&gt;元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。 </p>
</li>
<li><p>select：在文本框（&lt;**input**&gt;或textarea）上当用户选择了一个或多个字符时触发。 </p>
</li>
<li><p>resize：在window或窗格上当窗口或窗格被缩放时触发。 </p>
</li>
<li><p>scroll：当用户滚动包含滚动条的元素时在元素上触发。&lt;**body**&gt;元素包含已加载页面的滚动条。</p>
</li>
</ul>
<p>大多数 HTML 事件与window对象和表单控件有关。</p>
<p>除了DOMActivate，这些事件在 DOM2 Events 中都被归为 HTML Events（DOMActivate在 DOM2中仍旧是 UI 事件）。</p>
<ol>
<li>load事件</li>
</ol>
<p>在window对象上，load事件会在整个页面（包括所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发。可以通过两种方式指定load事件处理程序。第一种是 JavaScript 方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Loaded!&quot;</span>);  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>第二种指定load事件处理程序的方式是向&lt;**body**&gt;元素添加onload属性。</p>
<p>一般来说，任何在window上发生的事件，都可以通过给&lt;**body**&gt;元素上对应的属性赋值来指定，这是因为 HTML 中没有window元素。这实际上是为了保证向后兼容的一个策略，但在所有浏览器中都能得到很好的支持。实际开发中要尽量使用 JavaScript 方式。</p>
<blockquote>
<p>根据 DOM2 Events，load事件应该在document而非window上触发。可是为了向后兼容，所有浏览器都在window上实现了load事件。</p>
</blockquote>
<p>图片上也会触发load事件，包括 DOM中的图片和非 DOM中的图片。可以在 HTML中直接给img元素的onload属性指定事件处理程序。</p>
<p>下载图片并不一定要把img元素添加到文档，只要给它设置了src属性就会立即开始下载。</p>
<p>同样的技术也适用于 DOM0 的Image对象。在 DOM 出现之前，客户端都使用Image对象预先加载图片。可以像使用前面（通过createElement()方法创建）的img元素一样使用Image对象，只是不能把后者添加到 DOM 树。下面的例子使用新Image对象实现了图片预加载：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>(); </span><br><span class="line">  image.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Image loaded!&quot;</span>); </span><br><span class="line">&#125;);  </span><br><span class="line">  image.<span class="property">src</span> = <span class="string">&quot;smile.gif&quot;</span>;       </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 IE8 及早期版本中，如果图片没有添加到 DOM 文档中，则load事件发生时不会生成event对象。对未被添加到文档中的img元素以及Image对象来说都是这样。IE9 修复了这个问题。</p>
</blockquote>
<p>还有一些元素也以非标准的方式支持load事件。&lt; **script** &gt;元素会在 JavaScript 文件加载完成后触发load事件，从而可以动态检测。与图片不同，要下载 JavaScript 文件必须同时指定src属性并把&lt; **script** &gt;元素添加到文档中。</p>
<p>IE 和 Opera 支持&lt;**link**&gt;元素触发load事件，因而支持动态检测样式表是否加载完成。</p>
<ol start="2">
<li>unload事件</li>
</ol>
<p>unload事件会在文档卸载完成后触发。unload事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。与load事件类似，unload事件处理程序也有两种指定方式。第一种是 JavaScript 方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Unloaded!&quot;</span>);  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>这个事件生成的event对象在 DOM 合规的浏览器中只有target属性（值为document）。</p>
<p>第二种方式与load事件类似，就是给<body>元素添加onunload属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Unload Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onunload</span>=<span class="string">&quot;console.log(&#x27;Unloaded!&#x27;)&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>

<p>无论使用何种方式，都要注意事件处理程序中的代码。因为unload事件是在页面卸载完成后触发的，所以不能使用页面加载后才有的对象。此时要访问 DOM 或修改页面外观都会导致错误。</p>
<ol start="3">
<li>resize事件</li>
</ol>
<p>当浏览器窗口被缩放到新高度或宽度时，会触发resize事件。这个事件在window上触发，因此可以通过 JavaScript 在window上或者为<body>元素添加onresize属性来指定事件处理程序。优先使用 JavaScript 方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resized&quot;</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>scroll事件</li>
</ol>
<p>虽然scroll事件发生在window上，但实际上反映的是页面中相应元素的变化。在混杂模式下，可以通过&lt; body &gt;元素检测scrollLeft和scrollTop属性的变化。而在标准模式下，这些变化在除早期版的 Safari 之外的所有浏览器中都发生在&lt; html &gt;元素上（早期版的 Safari 在&lt; body &gt;上跟踪滚动位置）。</p>
<h4 id="17-4-2-焦点事件"><a href="#17-4-2-焦点事件" class="headerlink" title="17.4.2 焦点事件"></a>17.4.2 焦点事件</h4><p>焦点事件在页面元素获得或失去焦点时触发。这些事件可以与document.hasFocus()和document.activeElement一起为开发者提供用户在页面中导航的信息。焦点事件有以下 6 种。</p>
<ul>
<li><p>blur：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。 </p>
</li>
<li><p>DOMFocusIn：当元素获得焦点时触发。这个事件是focus的冒泡版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了DOMFocusIn，推荐focusin。 </p>
</li>
<li><p>DOMFocusOut：当元素失去焦点时触发。这个事件是blur的通用版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了DOMFocusOut，推荐focusout。 </p>
</li>
<li><p>focus：当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。 </p>
</li>
<li><p>focusin：当元素获得焦点时触发。这个事件是focus的冒泡版。 </p>
</li>
<li><p>focusout：当元素失去焦点时触发。这个事件是blur的通用版。</p>
</li>
</ul>
<p>焦点事件中的两个主要事件是focus和blur，这两个事件在 JavaScript 早期就得到了浏览器支持。</p>
<p>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。</p>
<p>(1) focuscout在失去焦点的元素上触发。<br>(2) focusin在获得焦点的元素上触发。<br>(3) blur在失去焦点的元素上触发。<br>(4) DOMFocusOut在失去焦点的元素上触发。<br>(5) focus在获得焦点的元素上触发。<br>(6) DOMFocusIn在获得焦点的元素上触发。<br>其中，blur、DOMFocusOut和focusout的事件目标是失去焦点的元素，而focus、DOMFocusIn和focusin的事件目标是获得焦点的元素。</p>
<h4 id="17-4-3-鼠标和滚轮事件"><a href="#17-4-3-鼠标和滚轮事件" class="headerlink" title="17.4.3 鼠标和滚轮事件"></a>17.4.3 鼠标和滚轮事件</h4><p>鼠标事件是 Web 开发中最常用的一组事件，这是因为鼠标是用户的主要定位设备。DOM3 Events定义了 9 种鼠标事件。</p>
<ul>
<li><p>click：在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发onclick事件处理程序。 </p>
</li>
<li><p>dblclick：在用户双击鼠标主键（通常是左键）时触发。这个事件不是在 DOM2 Events 中定义的，但得到了很好的支持，DOM3 Events 将其进行了标准化。 </p>
</li>
<li><p>mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。</p>
</li>
<li><p>mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseenter事件不是在 DOM2 Events 中定义的，而是 DOM3 Events中新增的事件。 </p>
</li>
<li><p>mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseleave事件不是在 DOM2 Events 中定义的，而是 DOM3 Events中新增的事件。 </p>
</li>
<li><p>mousemove：在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发。 </p>
</li>
<li><p>mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。 </p>
</li>
<li><p>mouseover：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。 </p>
</li>
<li><p>mouseup：在用户释放鼠标键时触发。这个事件不能通过键盘触发。</p>
</li>
</ul>
<p>页面中的所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。<br>由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。</p>
<p>click和dblclick在触发前都依赖其他事件触发，mousedown和mouseup则不会受其他事件影响。</p>
<p>鼠标事件在 DOM3 Events 中对应的类型是”MouseEvent”。</p>
<p>鼠标事件还有一个名为滚轮事件的子类别。滚轮事件只有一个事件mousewheel，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的交互。</p>
<ol>
<li>客户端坐标</li>
</ol>
<p>鼠标事件都是在浏览器视口中的某个位置上发生的。这些信息被保存在event对象的clientX和clientY属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标，所有浏览器都支持。</p>
<p>可以通过下面的方式获取鼠标事件的客户端坐标：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Client coordinates: <span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>`</span>);      </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>客户端坐标不考虑页面滚动，因此这两个值并不代表鼠标在页面上的位置。</p>
<ol start="2">
<li>页面坐标</li>
</ol>
<p>客户端坐标是事件发生时鼠标光标在客户端视口中的坐标，而页面坐标是事件发生时鼠标光标在页面上的坐标，通过event对象的pageX和pageY可以获取。这两个属性表示鼠标光标在页面上的位置，因此反映的是光标到页面而非视口左边与上边的距离。</p>
<p>在页面没有滚动时，pageX和pageY与clientX和clientY的值相同。</p>
<p>IE8 及更早版本没有在event对象上暴露页面坐标。不过，可以通过客户端坐标和滚动信息计算出来。滚动信息可以从document.body（混杂模式）或document.documentElement（标准模式）的scrollLeft和scrollTop属性获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">let</span> pageX = event.<span class="property">pageX</span>,  </span><br><span class="line">    pageY = event.<span class="property">pageY</span>; </span><br><span class="line">  <span class="keyword">if</span> (pageX === <span class="literal">undefined</span>) &#123;  </span><br><span class="line">    pageX = event.<span class="property">clientX</span> + (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollLeft</span> ||  </span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollLeft</span>); </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (pageY === <span class="literal">undefined</span>) &#123;  </span><br><span class="line">    pageY = event.<span class="property">clientY</span> + (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> ||   </span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Page coordinates: <span class="subst">$&#123;pageX&#125;</span>, <span class="subst">$&#123;pageY&#125;</span>`</span>);     </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>屏幕坐标</li>
</ol>
<p>鼠标事件不仅是在浏览器窗口中发生的，也是在整个屏幕上发生的。可以通过event对象的screenX和screenY属性获取鼠标光标在屏幕上的坐标。</p>
<ol start="4">
<li>修饰键</li>
</ol>
<p>键盘上的修饰键 Shift、Ctrl、Alt 和 Meta 经常用于修改鼠标事件的行为。DOM 规定了 4 个属性来表示这几个修饰键的状态：shiftKey、ctrlKey、altKey和metaKey。这几属性会在各自对应的修饰键被按下时包含布尔值true，没有被按下时包含false。在鼠标事件发生的，可以通过这几个属性来检测修饰键是否被按下。</p>
<ol start="5">
<li>相关元素</li>
</ol>
<p>对mouseover事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。类似地，对mouseout事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。</p>
<p>DOM 通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只有在mouseover和mouseout事件发生时才包含值，其他所有事件的这个属性的值都是null。IE8 及更早版本不支持relatedTarget属性，但提供了其他的可以访问到相关元素的属性。在mouseover事件触发时，IE会提供fromElement属性，其中包含相关元素。而在mouseout事件触发时，IE 会提供toElement属性，其中包含相关元素。（IE9 支持所有这些属性。）因此，可以在EventUtil中增加一个通用的获取相关属性的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123; </span><br><span class="line">  <span class="comment">// 其他代码 </span></span><br><span class="line">  <span class="attr">getRelatedTarget</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">relatedTarget</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> event.<span class="property">relatedTarget</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">toElement</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> event.<span class="property">toElement</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">fromElement</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> event.<span class="property">fromElement</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="comment">// 其他代码 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>鼠标按键</li>
</ol>
<p>只有在元素上单击鼠标主键（或按下键盘上的回车键）时click事件才会触发，因此按键信息并不是必需的。对mousedown和mouseup事件来说，event对象上会有一个button属性，表示按下或释放的是哪个按键。DOM 为这个button属性定义了 3 个值：0 表示鼠标主键、1 表示鼠标中键（通常也是滚轮键）、2 表示鼠标副键。</p>
<ol start="7">
<li>额外事件信息</li>
</ol>
<p>DOM2 Events 规范在event对象上提供了detail属性，以给出关于事件的更多信息。对鼠标事件来说，detail包含一个数值，表示在给定位置上发生了多少次单击。单击相当于在同一个像素上发生一次mousedown紧跟一次mouseup。detail的值从 1 开始，每次单击会加 1。如果鼠标在mousedown和mouseup之间移动了，则detail会重置为 0。</p>
<p>IE 还为每个鼠标事件提供了以下额外信息： </p>
<ul>
<li><p>altLeft，布尔值，表示是否按下了左 Alt 键（如果altLeft是true，那么altKey也是true）； </p>
</li>
<li><p>ctrlLeft，布尔值，表示是否按下了左 Ctrl 键（如果ctrlLeft是true，那么ctrlKey也是true）； </p>
</li>
<li><p>offsetX，光标相对于目标元素边界的 x 坐标； </p>
</li>
<li><p>offsetY，光标相对于目标元素边界的 y 坐标； </p>
</li>
<li><p>shiftLeft，布尔值，表示是否按下了左 Shift 键（如果shiftLeft是true，那么shiftKey也是true）。</p>
</li>
</ul>
<ol start="8">
<li>mousewheel事件</li>
</ol>
<p>mousewheel<br>事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。这个事件会在任何元素上触发，并（在IE8 中）冒泡到document和（在所有现代浏览器中）window。mousewheel事件的event对象包含鼠标事件的所有标准信息，此外还有一个名为wheelDelta的新属性。当鼠标滚轮向前滚动时，wheelDelta每次都是+120；而当鼠标滚轮向后滚动时，wheelDelta每次都是–120。</p>
<ol start="9">
<li>触摸屏设备</li>
</ol>
<p>在为触摸屏设备开发时，要记住以下事项。 </p>
<ul>
<li><p>不支持dblclick事件。双击浏览器窗口可以放大，但没有办法覆盖这个行为。 </p>
</li>
<li><p>单指点触屏幕上的可点击元素会触发mousemove事件。如果操作会导致内容变化，则不会再触发其他事件。如果屏幕上没有变化，则会相继触发mousedown、mouseup和click事件。点触不可点击的元素不会触发事件。可点击元素是指点击时有默认动作的元素（如链接）或指定了onclick事件处理程序的元素。 </p>
</li>
<li><p>mousemove事件也会触发mouseover和mouseout事件。 </p>
</li>
<li><p>双指点触屏幕并滑动导致页面滚动时会触发mousewheel和scroll事件。</p>
</li>
</ul>
<ol start="10">
<li>无障碍问题</li>
</ol>
<p>以下是几条使用鼠标事件时应该遵循的无障碍建议。</p>
<ul>
<li><p>使用click事件执行代码。有人认为，当使用onmousedown执行代码时，应用程序会运行得更快。对视力正常用户来说确实如此。但在屏幕阅读器上，这样会导致代码无法执行，这是因为屏幕阅读器无法触发mousedown事件。</p>
</li>
<li><p>不要使用mouseover向用户显示新选项。同样，原因是屏幕阅读器无法触发mousedown事件。如果必须要通过这种方式显示新选项，那么可以考虑显示相同信息的键盘快捷键。 </p>
</li>
<li><p>不要使用dblclick执行重要的操作，这是因为键盘不能触发这个事件。 </p>
</li>
<li><p>遵循这些简单的建议可以极大提升 Web 应用或网站对残障人士的无障碍性。</p>
</li>
</ul>
<h4 id="17-4-4-键盘与输入事件"><a href="#17-4-4-键盘与输入事件" class="headerlink" title="17.4.4 键盘与输入事件"></a>17.4.4 键盘与输入事件</h4><p>键盘事件是用户操作键盘时触发的。键盘事件很大程度上是基于原始的 DOM0 实现的。</p>
<p>DOM3 Events 为键盘事件提供了一个首先在 IE9 中完全实现的规范。</p>
<p>键盘事件包含 3 个事件：</p>
<ul>
<li><p>keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。 </p>
</li>
<li><p>keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc 键也会触发这个事件。DOM3 Events 废弃了keypress事件，而推荐textInput事件。 </p>
</li>
<li><p>keyup，用户释放键盘上某个键时触发。</p>
</li>
</ul>
<p>虽然所有元素都支持这些事件，但当用户在文本框中输入内容时最容易看到。<br>输入事件只有一个，即textInput。这个事件是对keypress事件的扩展，用于在文本显示给用户之前更方便地截获文本输入。textInput会在文本被插入到文本框之前触发。</p>
<p>这里keydown和keypress事件会在文本框出现变化之前触发，而keyup事件会在文本框出现变化之后触发。如果一个字符键被按住不放，keydown和keypress就会重复触发，直到这个键被释放。<br>对于非字符键，在键盘上按一下这个键，会先触发keydown事件，然后触发keyup事件。如果按住某个非字符键不放，则会重复触发keydown事件，直到这个键被释放，此时会触发keyup事件。</p>
<ol>
<li>键码</li>
</ol>
<p>对于 keydown 和 keyup 事件，event 对象的 keyCode 属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，keyCode的值与小写字母和数字的 ASCII 编码一致。</p>
<p>DOM 和 IE 的 event 对象都支持 keyCode属性。</p>
<ol start="2">
<li>字符编码</li>
</ol>
<p>在keypress事件发生时，意味着按键会影响屏幕上显示的文本。对插入或移除字符的键，所有浏览器都会触发keypress事件，其他键则取决于浏览器。</p>
<p>浏览器在event对象上支持charCode属性，只有发生keypress事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。通常，charCode属性的值是 0，在keypress事件发生时则是对应按键的键码。</p>
<p>要以跨浏览器方式获取字符编码，首先要检查charCode属性是否有值，如果没有再使用keyCode：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123;  </span><br><span class="line">  <span class="comment">// 其他代码 </span></span><br><span class="line">  <span class="attr">getCharCode</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> event.<span class="property">charCode</span> == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> event.<span class="property">charCode</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> event.<span class="property">keyCode</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="comment">// 其他代码 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一旦有了字母编码，就可以使用String.fromCharCode()方法将其转换为实际的字符了。</p>
<ol start="3">
<li>DOM3 的变化</li>
</ol>
<p>DOM3 Events 还是做了一些修改。比如，DOM3 Events 规范并未规定charCode属性，而是定义了key和char两个新属性。<br>其中，key属性用于替代keyCode，且包含字符串。在按下字符键时，key的值等于文本字符（如“k”或“M”）；在按下非字符键时，key的值是键名（如“Shift”或“ArrowDown”）。char属性在按下字符键时与key类似，在按下非字符键时为null。</p>
<p>由于缺乏跨浏览器支持，因此不建议使用key、keyIdentifier、和char。<br>DOM3 Events 也支持一个名为location的属性，该属性是一个数值，表示是在哪里按的键。可能的值为：0 是默认键，1 是左边（如左边的 Alt 键），2 是右边（如右边的 Shift 键），3 是数字键盘，4 是移动设备（即虚拟键盘），5 是游戏手柄（如任天堂 Wii 控制器）。</p>
<p>最后一个变化是给event对象增加了getModifierState()方法。这个方法接收一个参数，一个等于Shift、Control、Alt、AltGraph或Meta的字符串，表示要检测的修饰键。如果给定的修饰键处于激活状态（键被按住），则方法返回true，否则返回false。</p>
<ol start="4">
<li>textInput事件</li>
</ol>
<p>DOM3 Events 规范增加了一个名为textInput的事件，其在字符被输入到可编辑区域时触发。作为对keypress的替代，textInput事件的行为有些不一样。一个区别是keypress会在任何可以获得焦点的元素上触发，而textInput只在可编辑区域上触发。另一个区别是textInput只在有新字符被插入时才会触发，而keypress对任何可能影响文本的键都会触发（包括退格键）。<br>因为textInput事件主要关注字符，所以在event对象上提供了一个data属性，包含要插入的字符（不是字符编码）。data的值始终是要被插入的字符，因此如果在按 S 键时没有按 Shift 键，data的值就是”s”，但在按 S 键时同时按 Shift 键，data的值则是”S”。</p>
<p>event对象上还有一个名为inputMethod的属性，该属性表示向控件中输入文本的手段。</p>
<h4 id="17-4-5-合成事件"><a href="#17-4-5-合成事件" class="headerlink" title="17.4.5 合成事件"></a>17.4.5 合成事件</h4><p>合成事件是 DOM3 Events 中新增的，用于处理通常使用 IME 输入时的复杂输入序列。IME 可以让用户输入物理键盘上没有的字符。</p>
<p>合成事件有以下 3 种：</p>
<ul>
<li><p>compositionstart，在 IME 的文本合成系统打开时触发，表示输入即将开始； </p>
</li>
<li><p>compositionupdate，在新字符插入输入字段时触发； </p>
</li>
<li><p>compositionend，在 IME 的文本合成系统关闭时触发，表示恢复正常键盘输入。</p>
</li>
</ul>
<p>合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是data，其中包含的值视情况而异：</p>
<ul>
<li><p>在compositionstart事件中，包含正在编辑的文本（例如，已经选择了文本但还没替换）； </p>
</li>
<li><p>在compositionupdate事件中，包含要插入的新字符； </p>
</li>
<li><p>在compositionend事件中，包含本次合成过程中输入的全部内容。</p>
</li>
</ul>
<p>与文本事件类似，合成事件可以用来在必要时过滤输入内容。</p>
<h4 id="17-4-6-变化事件"><a href="#17-4-6-变化事件" class="headerlink" title="17.4.6 变化事件"></a>17.4.6 变化事件</h4><p>DOM2 的变化事件（Mutation Events）是为了在 DOM 发生变化时提供通知。</p>
<blockquote>
<p>这些事件已经被废弃，浏览器已经在有计划地停止对它们的支持。变化事件已经被Mutation Observers 所取代。</p>
</blockquote>
<h4 id="17-4-7-HTML5-事件"><a href="#17-4-7-HTML5-事件" class="headerlink" title="17.4.7 HTML5 事件"></a>17.4.7 HTML5 事件</h4><ol>
<li>contextmenu事件</li>
</ol>
<p>contextmenu事件，以专门用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单。</p>
<p>contextmenu事件冒泡，因此只要给document指定一个事件处理程序就可以处理页面上的所有同类事件。事件目标是触发操作的元素。这个事件在所有浏览器中都可以取消，在 DOM 合规的浏览器中使用event.preventDefault()，在 IE8 及更早版本中将event.returnValue设置为false。contextmenu事件应该算一种鼠标事件，因此event对象上的很多属性都与光标位置有关。通常，自定义的上下文菜单都是通过oncontextmenu事件处理程序触发显示，并通过onclick事件处理程序触发隐藏的。</p>
<ol start="2">
<li>beforeunload事件</li>
</ol>
<p>beforeunload事件会在window上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上。</p>
<ol start="3">
<li>DOMContentLoaded事件</li>
</ol>
<p>window的load事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而DOMContentLoaded事件会在 DOM 树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS 文件或其他资源加载完成。相对于load事件，DOMContentLoaded可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。<br>要处理DOMContentLoaded事件，需要给document或window添加事件处理程序（实际的事件目标是document，但会冒泡到window）。</p>
<p>DOMContentLoaded事件的event对象中不包含任何额外信息（除了target等于document）。<br>DOMContentLoaded事件通常用于添加事件处理程序或执行其他 DOM操作。这个事件始终在load事件之前触发。<br>对于不支持DOMContentLoaded事件的浏览器，可以使用超时为 0 的setTimeout()函数，通过其回调来设置事件处理程序。</p>
<ol start="4">
<li>readystatechange事件</li>
</ol>
<p>readystatechange事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。支持readystatechange事件的每个对象都有一个readyState属性，该属性具有一个以下列出的可能的字符串值。</p>
<ul>
<li><p>uninitialized：对象存在并尚未初始化。 </p>
</li>
<li><p>loading：对象正在加载数据。 </p>
</li>
<li><p>loaded：对象已经加载完数据。 </p>
</li>
<li><p>interactive：对象可以交互，但尚未加载完成。 </p>
</li>
<li><p>complete：对象加载完成。</p>
</li>
</ul>
<ol start="5">
<li>pageshow与pagehide事件</li>
</ol>
<p>Firefox 和 Opera 开发了一个名为往返缓存（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。这个缓存不仅存储页面数据，也存储 DOM 和 JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发load事件。通常，这不会导致什么问题，因为整个页面状态都被保存起来了。不过，Firefx决定提供一些事件，把往返缓存的行为暴露出来。<br>第一个事件是pageshow，其会在页面显示时触发，无论是否来自往返缓存。在新加载的页面上，pageshow会在load事件之后触发；在来自往返缓存的页面上，pageshow会在页面状态完全恢复后触发。注意，虽然这个事件的目标是document，但事件处理程序必须添加到window上。</p>
<p>pageshow的event对象中还包含一个名为persisted的属性。这个属性是一个布尔值，如果页面存储在了往返缓存中就是true，否则就是false。</p>
<p>通过检测persisted属性可以根据页面是否取自往返缓存而决定是否采取不同的操作。<br>与pageshow对应的事件是pagehide，这个事件会在页面从浏览器中卸载后，在unload事件之前触发。与pageshow事件一样，pagehide事件同样是在document上触发，但事件处理程序必须被添加到window。event对象中同样包含persisted属性，但用法稍有不同。</p>
<p>对pageshow事件来说，persisted为true表示页面是从往返缓存中加载的；而对pagehide事件来说，persisted为true表示页面在卸载之后会被保存在往返缓存中。因此，第一次触发pageshow事件时persisted始终是false，而第一次触发pagehide事件时persisted始终是true（除非页面不符合使用往返缓存的条件）。</p>
<blockquote>
<p>册了onunload事件处理程序（即使是空函数）的页面会自动排除在往返缓存之外。这是因为onunload事件典型的使用场景是撤销onload事件发生时所做的事情，如果使用往返缓存，则下一次页面显示时就不会触发onload事件，而这可能导致页面无法使用。</p>
</blockquote>
<ol start="6">
<li>hashchange事件</li>
</ol>
<p>HTML5 增加了hashchange事件，用于在 URL 散列值（URL 最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在 Ajax 应用程序中使用 URL 散列值存储状态信息或路由导航信息。<br>onhashchange事件处理程序必须添加给window，每次 URL 散列值发生变化时会调用它。event对象有两个新属性：oldURL和newURL。这两个属性分别保存变化前后的 URL，而且是包含散列值的完整 URL。</p>
<h4 id="17-4-8-设备事件"><a href="#17-4-8-设备事件" class="headerlink" title="17.4.8 设备事件"></a>17.4.8 设备事件</h4><p>设备事件可以用于确定用户使用设备的方式。</p>
<ol>
<li>orientationchange事件</li>
</ol>
<p>苹果公司在移动 Safari 浏览器上创造了orientationchange事件，以方便开发者判断用户的设备是处于垂直模式还是水平模式。移动 Safari 在window上暴露了window.orientation属性，它有以下 3 种值之一：0 表示垂直模式，90 表示左转水平模式（主屏幕键在右侧），–90 表示右转水平模式（主屏幕键在左）。</p>
<p>每当用户旋转设备改变了模式，就会触发orientationchange事件。但event对象上没有暴露任何有用的信息，这是因为相关信息都可以从window.orientation属性中获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">  div.<span class="property">innerHTML</span> = <span class="string">&quot;Current orientation is &quot;</span> + <span class="variable language_">window</span>.<span class="property">orientation</span>; </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;orientationchange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">    div.<span class="property">innerHTML</span> = <span class="string">&quot;Current orientation is &quot;</span> + <span class="variable language_">window</span>.<span class="property">orientation</span>; </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为orientationchange事件被认为是window事件，所以也可以通过给&lt;**body**&gt;元素添加onorientationchange属性来指定事件处理程序。</p>
</blockquote>
<ol start="2">
<li>deviceorientation事件</li>
</ol>
<p>deviceorientation是 DeviceOrientationEvent规范定义的事件。如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在window上触发。要注意的是，deviceorientation事件只反映设备在空间中的朝向，而不涉及移动相关的信息。<br>设备本身处于 3D 空间即拥有 x 轴、y 轴和 z 轴的坐标系中。如果把设备静止放在水平的表面上，那么三轴的值均为 0，其中，x 轴方向为从设备左侧到右侧，y 轴方向为从设备底部到上部，z 轴方向为从设备背面到正面。</p>
<p>当deviceorientation触发时，event对象中会包含各个轴相对于设备静置时坐标值的变化，主要是以下 5 个属性。</p>
<ul>
<li><p>alpha：0~360 范围内的浮点值，表示围绕 z 轴旋转时 y 轴的度数（左右转）。 </p>
</li>
<li><p>beta：–180~180 范围内的浮点值，表示围绕 x 轴旋转时 z 轴的度数（前后转）。 </p>
</li>
<li><p>gamma：–90~90 范围内的浮点值，表示围绕 y 轴旋转时 z 轴的度数（扭转）。 </p>
</li>
<li><p>absolute：布尔值，表示设备是否返回绝对值。 </p>
</li>
<li><p>compassCalibrated：布尔值，表示设备的指南针是否正确校准。</p>
</li>
</ul>
<ol start="3">
<li>devicemotion事件</li>
</ol>
<p>DeviceOrientationEvent 规范也定义了devicemotion事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。</p>
<p>当devicemotion事件触发时，event对象中包含如下额外的属性。</p>
<ul>
<li><p>acceleration：对象，包含x、y和z属性，反映不考虑重力情况下各个维度的加速信息。 </p>
</li>
<li><p>accelerationIncludingGravity：对象，包含x、y和z属性，反映各个维度的加速信息，包含 z 轴自然重力加速度。 </p>
</li>
<li><p>interval：毫秒，距离下次触发devicemotion事件的时间。此值在事件之间应为常量。 </p>
</li>
<li><p>rotationRate：对象，包含alpha、beta和gamma属性，表示设备朝向。</p>
</li>
</ul>
<p>如果无法提供acceleration、accelerationIncludingGravity和rotationRate信息，则属性值为null。为此，在使用这些属性前必须先检测它们的值是否为null。</p>
<h4 id="17-4-9-触摸及手势事件"><a href="#17-4-9-触摸及手势事件" class="headerlink" title="17.4.9 触摸及手势事件"></a>17.4.9 触摸及手势事件</h4><ol>
<li>触摸事件</li>
</ol>
<p>当手指放在屏幕上、在屏幕上滑动或从屏幕移开时，触摸事件即会触发。触摸事件有如下几种。</p>
<ul>
<li><p>touchstart：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。 </p>
</li>
<li><p>touchmove：手指在屏幕上滑动时连续触发。在这个事件中调用preventDefault()可以阻止滚动。</p>
</li>
<li><p>touchend：手指从屏幕上移开时触发。 </p>
</li>
<li><p>touchcancel：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪。</p>
</li>
</ul>
<p>这些事件都会冒泡，也都可以被取消。每个触摸事件的event对象都提供了鼠标事件的公共属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。</p>
<p>除了这些公共的 DOM 属性，触摸事件还提供了以下 3 个属性用于跟踪触点。 </p>
<ul>
<li><p>touches：Touch对象的数组，表示当前屏幕上的每个触点。 </p>
</li>
<li><p>targetTouches：Touch对象的数组，表示特定于事件目标的触点。 </p>
</li>
<li><p>changedTouches：Touch对象的数组，表示自上次用户动作之后变化的触点。</p>
</li>
</ul>
<p>每个Touch对象都包含下列属性。</p>
<ul>
<li><p>clientX：触点在视口中的 x 坐标。 </p>
</li>
<li><p>clientY：触点在视口中的 y 坐标。 </p>
</li>
<li><p>identifier：触点 ID。 </p>
</li>
<li><p>pageX：触点在页面上的 x 坐标。 </p>
</li>
<li><p>pageY：触点在页面上的 y 坐标。 </p>
</li>
<li><p>screenX：触点在屏幕上的 x 坐标。 </p>
</li>
<li><p>screenY：触点在屏幕上的 y 坐标。 </p>
</li>
<li><p>target：触摸事件的事件目标。<br>这些属性可用于追踪屏幕上的触摸轨迹。</p>
</li>
</ul>
<p>这些事件会在文档的所有元素上触发，因此可以分别控制页面的不同部分。当手指点触屏幕上的元素时，依次会发生如下事件（包括鼠标事件）：<br>(1) touchstart<br>(2) mouseover<br>(3) mousemove（1 次）<br>(4) mousedown<br>(5) mouseup<br>(6) click<br>(7) touchend</p>
<ol start="2">
<li>手势事件</li>
</ol>
<p>手势事件会在两个手指触碰屏幕且相对距离或旋转角度变化时触发。手势事件有以下 3 种。 </p>
<ul>
<li><p>gesturestart：一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。 </p>
</li>
<li><p>gesturechange：任何一个手指在屏幕上的位置发生变化时触发。 </p>
</li>
<li><p>gestureend：其中一个手指离开屏幕时触发。</p>
</li>
</ul>
<p>只有在两个手指同时接触事件接收者时，这些事件才会触发。在一个元素上设置事件处理程序，意味着两个手指必须都在元素边界以内才能触发手势事件（这个元素就是事件目标）。因为这些事件会冒泡，所以也可以把事件处理程序放到文档级别，从而可以处理所有手势事件。使用这种方式时，事件的目标就是两个手指均位于其边界内的元素。<br>触摸事件和手势事件存在一定的关系。</p>
<p>每个手势事件的event对象都包含所有标准的鼠标事件属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。新增的两个event对象属性是rotation和scale。rotation属性表示手指变化旋转的度数，负值表示逆时针旋转，正值表示顺时针旋转（从 0 开始）。scale属性表示两指之间距离变化（对捏）的程度。开始时为 1，然后随着距离增大或缩小相应地增大或缩小。</p>
<h3 id="17-5-内存与性能"><a href="#17-5-内存与性能" class="headerlink" title="17.5 内存与性能"></a>17.5 内存与性能</h3><p>在 JavaScript 中，页面中事件处理程序的数量与页面整体性能直接相关。原因有很多。首先，每个函数都是对象，都占用内存空间，对象越多，性能越差。其次，为指定事件处理程序所需访问 DOM 的次数会先期造成整个页面交互的延迟。只要在使用事件处理程序时多注意一些方法，就可以改善页面性能。</p>
<h4 id="17-5-1-事件委托"><a href="#17-5-1-事件委托" class="headerlink" title="17.5.1 事件委托"></a>17.5.1 事件委托</h4><p>“过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。</p>
<p>事件委托具有如下优点。 </p>
<ul>
<li><p>document对象随时可用，任何时候都可以给它添加事件处理程序（不用等待DOMContentLoaded或load事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。 </p>
</li>
<li><p>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也可以节省时间。 </p>
</li>
<li><p>减少整个页面所需的内存，提升整体性能。 </p>
</li>
</ul>
<p>最适合使用事件委托的事件包括：click、mousedown、mouseup、keydown和keypress。mouseover和mouseout事件冒泡。</p>
<h4 id="17-5-2-删除事件处理程序"><a href="#17-5-2-删除事件处理程序" class="headerlink" title="17.5.2 删除事件处理程序"></a>17.5.2 删除事件处理程序</h4><p>把事件处理程序指定给元素后，在浏览器代码和负责页面交互的 JavaScript 代码之间就建立了联系。这种联系建立得越多，页面性能就越差。除了通过事件委托来限制这种连接之外，还应该及时删除不用的事件处理程序。</p>
<p>导致这个问题的原因主要有两个。第一个是删除带有事件处理程序的元素。最常见的还是使用innerHTML整体替换页面的某一部分。在事件处理程序中删除按钮会阻止事件冒泡。只有事件目标仍然存在于文档中时，事件才会冒泡。</p>
<blockquote>
<p>事件委托也有助于解决这种问题。如果提前知道页面某一部分会被使用innerHTML删除，就不要直接给该部分中的元素添加事件处理程序了。把事件处理程序添加到更高层级的节点上同样可以处理该区域的事件。</p>
</blockquote>
<p>另一个可能导致内存中残留引用的问题是页面卸载。</p>
<p>一般来说，最好在onunload事件处理程序中趁页面尚未卸载先删除所有事件处理程序。这时候也能体现使用事件委托的优势，因为事件处理程序很少，所以很容易记住要删除哪些。关于卸载页面时的清理，可以记住一点：onload事件处理程序中做了什么，最好在onunload事件处理程序中恢复。</p>
<blockquote>
<p>在页面中使用onunload事件处理程序意味着页面不会被保存在往返缓存（bfcache）中。如果这对应用很重要，可以考虑只在 IE 中使用onunload来删除事件处理程序。</p>
</blockquote>
<h3 id="17-6-模拟事件"><a href="#17-6-模拟事件" class="headerlink" title="17.6 模拟事件"></a>17.6 模拟事件</h3><p>通常，事件都是由用户交互或浏览器功能触发。事实上，可能很少有人知道可以通过 JavaScript 在任何时候触发任意事件，而这些事件会被当成浏览器创建的事件。这意味着同样会有事件冒泡，因而也会触发相应的事件处理程序。</p>
<h4 id="17-6-1-DOM-事件模拟"><a href="#17-6-1-DOM-事件模拟" class="headerlink" title="17.6.1 DOM 事件模拟"></a>17.6.1 DOM 事件模拟</h4><p>任何时候，都可以使用document.createEvent()方法创建一个event对象。这个方法接收一个参数，此参数是一个表示要创建事件类型的字符串。在 DOM2 中，所有这些字符串都是英文复数形式，但在 DOM3 中，又把它们改成了英文单数形式。可用的字符串值是以下值之一。</p>
<ul>
<li><p>“UIEvents”（DOM3 中是”UIEvent”）：通用用户界面事件（鼠标事件和键盘事件都继承自这个事件）。 </p>
</li>
<li><p>“MouseEvents”（DOM3 中是”MouseEvent”）：通用鼠标事件。 </p>
</li>
<li><p>“HTMLEvents”（DOM3 中没有）：通用 HTML 事件（HTML 事件已经分散到了其他事件大类中）。</p>
</li>
</ul>
<p>键盘事件不是在 DOM2 Events 中规定的，而是后来在 DOM3 Events 中增加的。<br>创建event对象之后，需要使用事件相关的信息来初始化。每种类型的event对象都有特定的方法，可以使用相应数据来完成初始化。方法的名字并不相同，这取决于调用createEvent()时传入的参数。<br>事件模拟的最后一步是触发事件。为此要使用dispatchEvent()方法，这个方法存在于所有支持事件的 DOM 节点之上。dispatchEvent()方法接收一个参数，即表示要触发事件的event对象。调用dispatchEvent()方法之后，事件就“转正”了，接着便冒泡并触发事件处理程序执行。</p>
<ol>
<li>模拟鼠标事件</li>
</ol>
<p>模拟鼠标事件需要先创建一个新的鼠标event对象，然后再使用必要的信息对其进行初始化。要创建鼠标event对象，可以调用createEvent()方法并传入”MouseEvents”参数。这样就会返回一个event对象，这个对象有一个initMouseEvent()方法，用于为新对象指定鼠标的特定信息。initMouseEvent()方法接收 15 个参数，分别对应鼠标事件会暴露的属性。</p>
<ul>
<li><p>type（字符串）：要触发的事件类型，如”click”。 </p>
</li>
<li><p>bubbles（布尔值）：表示事件是否冒泡。为精确模拟鼠标事件，应该设置为true。</p>
</li>
<li><p>cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。 </p>
</li>
<li><p>view（AbstractView）：与事件关联的视图。基本上始终是document.defaultView。 </p>
</li>
<li><p>detail（整数）：关于事件的额外信息。只被事件处理程序使用，通常为 0。 </p>
</li>
<li><p>screenX（整数）：事件相对于屏幕的 x 坐标。 </p>
</li>
<li><p>screenY（整数）：事件相对于屏幕的 y 坐标。 </p>
</li>
<li><p>clientX（整数）：事件相对于视口的 x 坐标。 </p>
</li>
<li><p>clientY（整数）：事件相对于视口的 y 坐标。 </p>
</li>
<li><p>ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为false。 </p>
</li>
<li><p>altkey（布尔值）：表示是否按下了 Alt 键。默认为false。 </p>
</li>
<li><p>shiftkey（布尔值）：表示是否按下了 Shift 键。默认为false。 </p>
</li>
<li><p>metakey（布尔值）：表示是否按下了 Meta 键。默认为false。 </p>
</li>
<li><p>button（整数）：表示按下了哪个按钮。默认为 0。 </p>
</li>
<li><p>relatedTarget（对象）：与事件相关的对象。只在模拟mouseover和mouseout时使用。</p>
</li>
</ul>
<p>显然，initMouseEvent()方法的这些参数与鼠标事件的event对象属性是一一对应的。前 4 个参数是正确模拟事件唯一重要的几个参数，这是因为它们是浏览器要用的，其他参数则是事件处理程序要用的。event对象的target属性会自动设置为调用dispatchEvent()方法时传入的节点。</p>
<ol start="2">
<li>模拟键盘事件</li>
</ol>
<p>在 DOM3 中创建键盘事件的方式是给createEvent()方法传入参数”KeyboardEvent”。这样会返回一个event对象，这个对象有一个initKeyboardEvent()方法。这个方法接收以下参数。 </p>
<ul>
<li><p>type（字符串）：要触发的事件类型，如”keydown”。 </p>
</li>
<li><p>bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为true。 </p>
</li>
<li><p>cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为true。 </p>
</li>
<li><p>view（AbstractView）：与事件关联的视图。基本上始终是document.defaultView。 </p>
</li>
<li><p>key（字符串）：按下按键的字符串代码。</p>
</li>
<li><p>location（整数）：按下按键的位置。0 表示默认键，1 表示左边，2 表示右边，3 表示数字键盘，4 表示移动设备（虚拟键盘），5 表示游戏手柄。 </p>
</li>
<li><p>modifiers（字符串）：空格分隔的修饰键列表，如”Shift”。 </p>
</li>
<li><p>repeat（整数）：连续按了这个键多少次。</p>
</li>
</ul>
<ol start="3">
<li>模拟其他事件</li>
</ol>
<p>模拟 HTML 事件要调用createEvent()方法并传入”HTMLEvents”，然后再使用返回对象的initEvent()方法来初始化。</p>
<ol start="4">
<li>自定义 DOM 事件</li>
</ol>
<p>DOM3 增加了自定义事件的类型。自定义事件不会触发原生 DOM 事件，但可以让开发者定义自己的 事 件 。 要 创 建 自 定 义 事 件 ， 需 要 调 用createEvent(“CustomEvent”)。 返 回 的 对 象 包 含initCustomEvent()方法，该方法接收以下 4 个参数。 </p>
<ul>
<li><p>type（字符串）：要触发的事件类型，如”myevent”。 </p>
</li>
<li><p>bubbles（布尔值）：表示事件是否冒泡。 </p>
</li>
<li><p>cancelable（布尔值）：表示事件是否可以取消。 </p>
</li>
<li><p>detail（对象）：任意值。作为event对象的detail属性。 </p>
<p>自定义事件可以像其他事件一样在 DOM 中派发</p>
</li>
</ul>
<h4 id="17-6-2-IE-事件模拟"><a href="#17-6-2-IE-事件模拟" class="headerlink" title="17.6.2 IE 事件模拟"></a>17.6.2 IE 事件模拟</h4><p>在 IE8 及更早版本中模拟事件的过程与 DOM 方式类似：创建event对象，指定相应信息，然后使用这个对象触发。当然，IE 实现每一步的方式都不一样。<br>首先，要使用document对象的createEventObject()方法来创建event对象。与 DOM 不同，这个方法不接收参数，返回一个通用event对象。然后，可以手工给返回的对象指定希望该对象具备的所有属性。（没有初始化方法。）最后一步是在事件目标上调用fireEvent()方法，这个方法接收两个参数：事件处理程序的名字和event对象。调用fireEvent()时，srcElement和type属性会自动指派到event对象（其他所有属性必须手工指定）。这意味着 IE 支持的所有事件都可以通过相同的方式来模拟。</p>
<h3 id="17-7-小结"><a href="#17-7-小结" class="headerlink" title="17.7 小结"></a>17.7 小结</h3><p>事件是 JavaScript 与网页结合的主要方式。最常见的事件是在 DOM3 Events 规范或 HTML5 中定义的。虽然基本的事件都有规范定义，但很多浏览器在规范之外实现了自己专有的事件，以方便开发者更好地满足用户交互需求，其中一些专有事件直接与特殊的设备相关。</p>
<p>围绕着使用事件，需要考虑内存与性能问题。例如： </p>
<ul>
<li><p>最好限制一个页面中事件处理程序的数量，因为它们会占用过多内存，导致页面响应缓慢； </p>
</li>
<li><p>利用事件冒泡，事件委托可以解决限制事件处理程序数量的问题； </p>
</li>
<li><p>最好在页面卸载之前删除所有事件处理程序。</p>
</li>
</ul>
<p>使用 JavaScript 也可以在浏览器中模拟事件。DOM2 Events 和 DOM3 Events 规范提供了模拟方法，可以模拟所有原生 DOM 事件。键盘事件一定程度上也是可以模拟的，有时候需要组合其他技术。IE8及更早版本也支持事件模拟，只是接口与 DOM 方式不同。<br>事件是 JavaScript 中最重要的主题之一，理解事件的原理及其对性能的影响非常重要。</p>
<h2 id="十八、动画与-Canvas-图形"><a href="#十八、动画与-Canvas-图形" class="headerlink" title="十八、动画与 Canvas 图形"></a>十八、动画与 Canvas 图形</h2><h3 id="18-1-使用requestAnimationFrame"><a href="#18-1-使用requestAnimationFrame" class="headerlink" title="18.1 使用requestAnimationFrame"></a>18.1 使用requestAnimationFrame</h3><p>Firefox 4 率先在浏览器中为 JavaScript动画增加了一个名为mozRequestAnimationFrame()方法的 API。这个方法会告诉浏览器要执行动画了，于是浏览器可以通过最优方式确定重绘的时序。</p>
<h4 id="18-1-1-早期定时动画"><a href="#18-1-1-早期定时动画" class="headerlink" title="18.1.1 早期定时动画"></a>18.1.1 早期定时动画</h4><p>以前，在 JavaScript 中创建动画基本上就是使用setInterval()来控制动画的执行。</p>
<p>实现平滑动画最佳的重绘间隔为 1000 毫秒/60，大约 17 毫秒。</p>
<h4 id="18-1-2-时间间隔的问题"><a href="#18-1-2-时间间隔的问题" class="headerlink" title="18.1.2 时间间隔的问题"></a>18.1.2 时间间隔的问题</h4><p>浏览器的计时器精度不足毫秒。以下是几个浏览器计时器的精度情况：</p>
<ul>
<li><p>IE8 及更早版本的计时器精度为 15.625 毫秒； </p>
</li>
<li><p>IE9 及更晚版本的计时器精度为 4 毫秒； </p>
</li>
<li><p>Firefox 和 Safari 的计时器精度为约 10 毫秒； </p>
</li>
<li><p>Chrome 的计时器精度为 4 毫秒。</p>
</li>
</ul>
<h4 id="18-1-3-requestAnimationFrame"><a href="#18-1-3-requestAnimationFrame" class="headerlink" title="18.1.3 requestAnimationFrame"></a>18.1.3 requestAnimationFrame</h4><p>mozRequestAnimationFrame() 方法，用以通知浏览器某些 JavaScript 代码要执行动画了。这样浏览器就可以在运行某些代码后进行适当的优化。目前所有浏览器都支持这个方法不带前缀的版本，即requestAnimationFrame()。</p>
<p>requestAnimationFrame()方法接收一个参数，此参数是一个要在重绘屏幕前调用的函数。这个函数就是修改 DOM 样式以反映下一次重绘有什么变化的地方。为了实现动画循环，可以把多个 requestAnimationFrame() 调用串联起来，就像以前使用setTimeout()时一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>); </span><br><span class="line">  div.<span class="property">style</span>.<span class="property">width</span> = (<span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">width</span>, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">&quot;%&quot;</span>;  </span><br><span class="line">  <span class="keyword">if</span> (div.<span class="property">style</span>.<span class="property">left</span> != <span class="string">&quot;100%&quot;</span>) &#123; </span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(updateProgress);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(updateProgress);</span><br></pre></td></tr></table></figure>

<p>requestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题，以及最佳间隔是多少的问题。</p>
<p>传给requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个DOMHighResTimeStamp的实例（比如performance.now()返回的值），表示下次重绘的时间。这一点非常重要：requestAnimationFrame()实际上把重绘任务安排在了未来一个已知的时间点上，而且通过这个参数告诉了开发者。基于这个参数，就可以更好地决定如何调优动画了。</p>
<h4 id="18-1-4-cancelAnimationFrame"><a href="#18-1-4-cancelAnimationFrame" class="headerlink" title="18.1.4 cancelAnimationFrame"></a>18.1.4 cancelAnimationFrame</h4><p>与setTimeout()类似，requestAnimationFrame()也返回一个请求 ID，可以用于通过另一个方法cancelAnimationFrame()来取消重绘任务。</p>
<h4 id="18-1-5-通过requestAnimationFrame节流"><a href="#18-1-5-通过requestAnimationFrame节流" class="headerlink" title="18.1.5 通过requestAnimationFrame节流"></a>18.1.5 通过requestAnimationFrame节流</h4><p>所谓钩子（hook），就是浏览器在执行下一次重绘之前的一个点。这个回调队列是一个可修改的函数列表，包含应该在重绘之前调用的函数。每次调用requestAnimationFrame()都会在队列上推入一个回调函数，队列的长度没有限制。<br>这个回调队列的行为不一定跟动画有关。不过，通过requestAnimationFrame()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。这是一个非常好的节流工具。在频繁执行影响页面外观的代码时（比如滚动事件监听器），可以利用这个回调队列进行节流。</p>
<p>如果想把事件处理程序的调用限制在每次重绘前发生，那么可以像这样下面把它封装到requestAnimationFrame()调用中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>());  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>这样会把所有回调的执行集中在重绘钩子，但不会过滤掉每次重绘的多余调用。此时，定义一个标志变量，由回调设置其开关状态，就可以将多余的调用屏蔽:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enqueued = <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>());  </span><br><span class="line">  enqueued = <span class="literal">false</span>; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (!enqueued) &#123; </span><br><span class="line">    enqueued = <span class="literal">true</span>; </span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="18-2-基本的画布功能"><a href="#18-2-基本的画布功能" class="headerlink" title="18.2 基本的画布功能"></a>18.2 基本的画布功能</h3><p>创建&lt;**canvas**&gt;元素时至少要设置其width和height属性。</p>
<p>与其他元素一样，width和height属性也可以在 DOM 节点上设置，因此可以随时修改。整个元素还可以通过 CSS 添加样式，并且元素在添加样式或实际绘制内容前是不可见的。<br>要在画布上绘制图形，首先要取得绘图上下文。使用getContext()方法可以获取对绘图上下文的引用。对于平面图形，需要给这个方法传入参数”2d”，表示要获取 2D 上下文对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用&lt;**canvas**&gt;元素时，最好先测试一下getContext()方法是否存在。有些浏览器对 HTML 规范中没有的元素会创建默认 HTML 元素对象。这就意味着即使drawing包含一个有效的元素引用，getContext()方法也未必存在。<br>可以使用toDataURL()方法导出&lt;**canvas**&gt;元素上的图像。这个方法接收一个参数：要生成图像的 MIME 类型（与用来创建图形的上下文无关）。</p>
<p>浏览器默认将图像编码为 PNG 格式，除非另行指定。Firefox 和 Opera 还支持传入”image/jpeg”进行 JPEG 编码。因为这个方法是后来才增加到规范中的，所以支持的浏览器也是在后面的版本实现的，包括 IE9、Firefox 3.5 和 Opera 10。</p>
<blockquote>
<p>如果画布中的图像是其他域绘制过来的，toDataURL()方法就会抛出错误。</p>
</blockquote>
<h3 id="18-3-2D-绘图上下文"><a href="#18-3-2D-绘图上下文" class="headerlink" title="18.3 2D 绘图上下文"></a>18.3 2D 绘图上下文</h3><p>2D 绘图上下文提供了绘制 2D 图形的方法，包括矩形、弧形和路径。2D 上下文的坐标原点(0, 0)在&lt;**canvas**&gt;元素的左上角。所有坐标值都相对于该点计算，因此 x 坐标向右增长，y 坐标向下增长。默认情况下，width和height表示两个方向上像素的最大值。</p>
<h4 id="18-3-1-填充和描边"><a href="#18-3-1-填充和描边" class="headerlink" title="18.3.1 填充和描边"></a>18.3.1 填充和描边</h4><p>2D 上下文有两个基本绘制操作：填充和描边。填充以指定样式（颜色、渐变或图像）自动填充形状，而描边只为图形边界着色。大多数 2D 上下文操作有填充和描边的变体，显示效果取决于两个属性：fillStyle和strokeStyle。<br>这两个属性可以是字符串、渐变对象或图案对象，默认值都为”#000000”。字符串表示颜色值，可以是 CSS 支持的任意格式：名称、十六进制代码、rgb、rgba、hsl或hsla。</p>
<h4 id="18-3-2-绘制矩形"><a href="#18-3-2-绘制矩形" class="headerlink" title="18.3.2 绘制矩形"></a>18.3.2 绘制矩形</h4><p>矩形是唯一一个可以直接在 2D 绘图上下文中绘制的形状。与绘制矩形相关的方法有 3 个：fillRect()、strokeRect()和clearRect()。这些方法都接收 4 个参数：矩形 x 坐标、矩形 y 坐标、矩形宽度和矩形高度。这几个参数的单位都是像素。<br>fillRect()方法用于以指定颜色在画布上绘制并填充矩形。填充的颜色使用fillStyle属性指定。</p>
<p>strokeRect()方法使用通过strokeStyle属性指定的颜色绘制矩形轮廓。</p>
<blockquote>
<p>描边宽度由lineWidth属性控制，它可以是任意整数值。类似地，lineCap属性控制线条端点的形状［”butt”（平头）、”round”（出圆头）或”square”（出方头）］，而lineJoin属性控制线条交点的形状［”round”（圆转）、”bevel”（取平）或”miter”（出尖）］。</p>
</blockquote>
<p>使用clearRect()方法可以擦除画布中某个区域。该方法用于把绘图上下文中的某个区域变透明。</p>
<h4 id="18-3-3-绘制路径"><a href="#18-3-3-绘制路径" class="headerlink" title="18.3.3 绘制路径"></a>18.3.3 绘制路径</h4><p>2D 绘图上下文支持很多在画布上绘制路径的方法。通过路径可以创建复杂的形状和线条。要绘制路径，必须首先调用beginPath()方法以表示要开始绘制新路径。然后，再调用下列方法来绘制路径。 </p>
<ul>
<li><p>arc(x, y, radius, startAngle, endAngle, counterclockwise)：以坐标(x, y)为圆心，以radius为半径绘制一条弧线，起始角度为startAngle，结束角度为endAngle（都是弧度）。最后一个参数counterclockwise表示是否逆时针计算起始角度和结束角度（默认为顺时针）。 </p>
</li>
<li><p>arcTo(x1, y1, x2, y2, radius)：以给定半径radius，经由(x1, y1)绘制一条从上一点到(x2, y2)的弧线。 </p>
</li>
<li><p>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：以(c1x, c1y)和(c2x, c2y)为控制点，绘制一条从上一点到(x, y)的弧线（三次贝塞尔曲线）。 </p>
</li>
<li><p>lineTo(x, y)：绘制一条从上一点到(x, y)的直线。 </p>
</li>
<li><p>moveTo(x, y)：不绘制线条，只把绘制光标移动到(x, y)。 </p>
</li>
<li><p>quadraticCurveTo(cx, cy, x, y)：以(cx, cy)为控制点，绘制一条从上一点到(x, y)的弧线（二次贝塞尔曲线）。 </p>
</li>
<li><p>rect(x, y, width, height)：以给定宽度和高度在坐标点(x, y)绘制一个矩形。这个方法与strokeRect()和fillRect()的区别在于，它创建的是一条路径，而不是独立的图形。</p>
</li>
</ul>
<p>创建路径之后，可以使用closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可以指定fillStyle属性并调用fill()方法来填充路径，也可以指定strokeStyle属性并调用stroke()方法来描画路径，还可以调用clip()方法基于已有路径创建一个新剪切区域。</p>
<p>路径是 2D 上下文的主要绘制机制，为绘制结果提供了很多控制。因为路径经常被使用，所以也有一个isPointInPath()方法，接收 x 轴和 y 轴坐标作为参数。这个方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context.<span class="title function_">isPointInPath</span>(<span class="number">100</span>, <span class="number">100</span>)) &#123;  </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Point (100, 100) is in the path.&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="18-3-4-绘制文本"><a href="#18-3-4-绘制文本" class="headerlink" title="18.3.4 绘制文本"></a>18.3.4 绘制文本</h4><p>2D绘图上下文还提供了绘制文本的方法，即fillText()和strokeText()。这两个方法都接收 4 个参数：要绘制的字符串、x 坐标、y 坐标和可选的最大像素宽度。而且，这两个方法最终绘制的结果都取决于以下 3 个属性。 </p>
<ul>
<li><p>font：以 CSS 语法指定的字体样式、大小、字体族等，比如”10px Arial”。 </p>
</li>
<li><p>textAlign：指定文本的对齐方式，可能的值包括”start”、”end”、”left”、”right”和”center”。推荐使用”start”和”end”，不使用”left”和”right”，因为前者无论在从左到右书写的语言还是从右到左书写的语言中含义都更明确。 </p>
</li>
<li><p>textBaseLine： 指 定 文 本 的 基 线 ， 可 能 的 值 包 括”top”、”hanging”、”middle”、”alphabetic”、”ideographic”和”bottom”。</p>
</li>
</ul>
<p>这些属性都有相应的默认值，因此没必要每次绘制文本时都设置它们。fillText()方法使用fillStyle属性绘制文本，而strokeText()方法使用strokeStyle属性。通常，fillText()方法是使用最多的，因为它模拟了在网页中渲染文本。</p>
<p>由于绘制文本很复杂，特别是想把文本绘制到特定区域的时候，因此 2D 上下文提供了用于辅助确定文本大小的measureText()方法。这个方法接收一个参数，即要绘制的文本，然后返回一个TextMetrics对象。这个返回的对象目前只有一个属性width，不过将来应该会增加更多度量指标。<br>measureText()方法使用font、textAlign和textBaseline属性当前的值计算绘制指定文本后的大小。</p>
<p>fillText()和strokeText()方法还有第四个参数，即文本的最大宽度。这个参数是可选的（Firefox 4 是第一个实现它的浏览器），如果调用fillText()和strokeText()时提供了此参数，但要绘制的字符串超出了最大宽度限制，则文本会以正确的字符高度绘制，这时字符会被水平压缩，以达到限定宽度。</p>
<h4 id="18-3-5-变换"><a href="#18-3-5-变换" class="headerlink" title="18.3.5 变换"></a>18.3.5 变换</h4><p>上下文变换可以操作绘制在画布上的图像。2D 绘图上下文支持所有常见的绘制变换。在创建绘制上下文时，会以默认值初始化变换矩阵，从而让绘制操作如实应用到绘制结果上。对绘制上下文应用变换，可以导致以不同的变换矩阵应用绘制操作，从而产生不同的结果。<br>以下方法可用于改变绘制上下文的变换矩阵。</p>
<ul>
<li><p>rotate(angle)：围绕原点把图像旋转angle弧度。 </p>
</li>
<li><p>scale(scaleX, scaleY)：通过在 x 轴乘以scaleX、在 y 轴乘以scaleY来缩放图像。scaleX和scaleY的默认值都是 1.0。 </p>
</li>
<li><p>translate(x, y)：把原点移动到(x, y)。执行这个操作后，坐标(0, 0)就会变成(x, y)。 </p>
</li>
<li><p>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：像下面这样通过矩阵乘法直接修改矩阵。<br>m1_1   m1_2   dx<br>m2_1   m2_2   dy<br>0           0         1 </p>
</li>
<li><p>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：把矩阵重置为默认值，再以传入的参数调用transform()。</p>
</li>
</ul>
<p>所有这些变换，包括fillStyle和strokeStyle属性，会一直保留在上下文中，直到再次修改它们。虽然没有办法明确地将所有值都重置为默认值，但有两个方法可以帮我们跟踪变化。如果想着什么时候再回到当前的属性和变换状态，可以调用save()方法。调用这个方法后，所有这一时刻的设置会被放到一个暂存栈中。保存之后，可以继续修改上下文。而在需要恢复之前的上下文时，可以调用restore()方法。这个方法会从暂存栈中取出并恢复之前保存的设置。多次调用save()方法可以在暂存栈中存储多套设置，然后通过restore()可以系统地恢复。</p>
<blockquote>
<p>save()方法只保存应用到绘图上下文的设置和变换，不保存绘图上下文的内容。</p>
</blockquote>
<h4 id="18-3-6-绘制图像"><a href="#18-3-6-绘制图像" class="headerlink" title="18.3.6 绘制图像"></a>18.3.6 绘制图像</h4><p>2D 绘图上下文内置支持操作图像。如果想把现有图像绘制到画布上，可以使用drawImage()方法。这个方法可以接收 3 组不同的参数，并产生不同的结果。最简单的调用是传入一个 HTML 的img元素，以及表示绘制目标的 x 和 y 坐标，结果是把图像绘制到指定位置。</p>
<p>如果想改变所绘制图像的大小，可以再传入另外两个参数：目标宽度和目标高度。这里的缩放只影响绘制的图像，不影响上下文的变换矩阵。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>还可以只把图像绘制到上下文中的一个区域。此时，需要给drawImage()提供 9 个参数：要绘制的图像、源图像 x 坐标、源图像 y 坐标、源图像宽度、源图像高度、目标区域 x 坐标、目标区域 y 坐标、目标区域宽度和目标区域高度。这个重载后的drawImage()方法可以实现最大限度的控制。</p>
<p>第一个参数除了可以是 HTML 的 img 元素，还可以是另一个&lt;**canvas**&gt;元素，这样就会把另一个画布的内容绘制到当前画布上。<br>结合其他一些方法，drawImage()方法可以方便地实现常见的图像操作。操作的结果可以使用toDataURL()方法获取。不过有一种情况例外：如果绘制的图像来自其他域而非当前页面，则不能获取其数据。此时，调用toDataURL()将抛出错误。</p>
<h4 id="18-3-7-阴影"><a href="#18-3-7-阴影" class="headerlink" title="18.3.7 阴影"></a>18.3.7 阴影</h4><p>2D 上下文可以根据以下属性的值自动为已有形状或路径生成阴影。 </p>
<ul>
<li><p>shadowColor：CSS 颜色值，表示要绘制的阴影颜色，默认为黑色。 </p>
</li>
<li><p>shadowOffsetX：阴影相对于形状或路径的 x 坐标的偏移量，默认为 0。 </p>
</li>
<li><p>shadowOffsetY：阴影相对于形状或路径的 y 坐标的偏移量，默认为 0。 </p>
</li>
<li><p>shadowBlur：像素，表示阴影的模糊量。默认值为 0，表示不模糊。</p>
</li>
</ul>
<p>这些属性都可以通过context对象读写。只要在绘制图形或路径前给这些属性设置好适当的值，阴影就会自动生成。</p>
<h4 id="18-3-8-渐变"><a href="#18-3-8-渐变" class="headerlink" title="18.3.8 渐变"></a>18.3.8 渐变</h4><p>渐变通过CanvasGradient的实例表示，在 2D 上下文中创建和修改都非常简单。要创建一个新的线性渐变，可以调用上下文的createLinearGradient()方法。这个方法接收 4 个参数：起点 x 坐标、起点 y 坐标、终点 x 坐标和终点 y 坐标。调用之后，该方法会以指定大小创建一个新的CanvasGradient对象并返回实例。<br>有了gradient对象后，接下来要使用addColorStop()方法为渐变指定色标。这个方法接收两个参数：色标位置和 CSS 颜色字符串。色标位置通过 0～1 范围内的值表示，0 是第一种颜色，1 是最后一种颜色。</p>
<p>如果矩形没有绘制到渐变的范围内，则只会显示部分渐变。</p>
<p>径向渐变（或放射性渐变）要使用createRadialGradient()方法来创建。这个方法接收 6 个参数，分别对应两个圆形圆心的坐标和半径。前 3 个参数指定起点圆形中心的 x、y 坐标和半径，后 3 个参数指定终点圆形中心的 x、y 坐标和半径。在创建径向渐变时，可以把两个圆形想象成一个圆柱体的两个圆形表面。把一个表面定义得小一点，另一个定义得大一点，就会得到一个圆锥体。然后，通过移动两个圆形的圆心，就可以旋转这个圆锥体。<br>要创建起点圆心在形状中心并向外扩散的径向渐变，需要将两个圆形设置为同心圆。</p>
<h4 id="18-3-9-图案"><a href="#18-3-9-图案" class="headerlink" title="18.3.9 图案"></a>18.3.9 图案</h4><p>图案是用于填充和描画图形的重复图像。要创建新图案，可以调用createPattern()方法并传入两个参数：一个 HTML img元素和一个表示该如何重复图像的字符串。第二个参数的值与 CSS 的background-repeat属性是一样的，包括”repeat”、”repeat-x”、”repeat-y”和”no-repeat”。</p>
<p>跟渐变一样，图案的起点实际上是画布的原点(0, 0)。将填充样式设置为图案，表示在指定位置而不是开始绘制的位置显示图案。</p>
<p>传给createPattern()方法的第一个参数也可以是&lt;**video**&gt;元素或者另一个&lt;**canvas**&gt;元素。</p>
<h4 id="18-3-10-图像数据"><a href="#18-3-10-图像数据" class="headerlink" title="18.3.10 图像数据"></a>18.3.10 图像数据</h4><p>2D 上下文中比较强大的一种能力是可以使用getImageData()方法获取原始图像数据。这个方法接收 4 个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度。例如，要从(10, 5)开始取得 50 像素宽、50 像素高的区域对应的数据，可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageData = context.<span class="title function_">getImageData</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>返回的对象是一个ImageData的实例。每个ImageData对象都包含 3 个属性：width、height和data，其中，data属性是包含图像的原始像素信息的数组。每个像素在data数组中都由 4 个值表示，分别代表红、绿、蓝和透明度值。</p>
<blockquote>
<p>只有在画布没有加载跨域内容时才可以获取图像数据。如果画布上绘制的是跨域内容，则尝试获取图像数据会导致 JavaScript 报错。</p>
</blockquote>
<h4 id="18-3-11-合成"><a href="#18-3-11-合成" class="headerlink" title="18.3.11 合成"></a>18.3.11 合成</h4><p>2D 上下文中绘制的所有内容都会应用两个属性：globalAlpha和globalComposition Operation，其中，globalAlpha属性是一个范围在 0~1 的值（包括 0 和 1），用于指定所有绘制内容的透明度，默认值为 0。如果所有后来的绘制都需要使用同样的透明度，那么可以将globalAlpha设置为适当的值，执行绘制，然后再把globalAlpha设置为 0。</p>
<p>globalCompositionOperation属性表示新绘制的形状如何与上下文中已有的形状融合。这个属性是一个字符串，可以取下列值。</p>
<ul>
<li><p>source-over：默认值，新图形绘制在原有图形上面。 </p>
</li>
<li><p>source-in：新图形只绘制出与原有图形重叠的部分，画布上其余部分全部透明。 </p>
</li>
<li><p>source-out：新图形只绘制出不与原有图形重叠的部分，画布上其余部分全部透明。 </p>
</li>
<li><p>source-atop：新图形只绘制出与原有图形重叠的部分，原有图形不受影响。 </p>
</li>
<li><p>destination-over：新图形绘制在原有图形下面，重叠部分只有原图形透明像素下的部分可见。 </p>
</li>
<li><p>destination-in：新图形绘制在原有图形下面，画布上只剩下二者重叠的部分，其余部分完全透明。 </p>
</li>
<li><p>destination-out：新图形与原有图形重叠的部分完全透明，原图形其余部分不受影响。 </p>
</li>
<li><p>destination-atop：新图形绘制在原有图形下面，原有图形与新图形不重叠的部分完全透明。 </p>
</li>
<li><p>lighter：新图形与原有图形重叠部分的像素值相加，使该部分变亮。 </p>
</li>
<li><p>copy：新图形将擦除并完全取代原有图形。 </p>
</li>
<li><p>xor：新图形与原有图形重叠部分的像素执行“异或”计算。</p>
</li>
</ul>
<p>使用globalCompositeOperation属性时，一定记得要在不同浏览器上进行测试。不同浏览器在实现这些选项时可能存在差异。</p>
<h3 id="18-4-WebGL"><a href="#18-4-WebGL" class="headerlink" title="18.4 WebGL"></a>18.4 WebGL</h3><h4 id="18-4-1-WebGL-上下文"><a href="#18-4-1-WebGL-上下文" class="headerlink" title="18.4.1 WebGL 上下文"></a>18.4.1 WebGL 上下文</h4><p>在完全支持的浏览器中，WebGL 2.0 上下文的名字叫”webgl2”，WebGL 1.0 上下文的名字叫”webgl1”。如果浏览器不支持 WebGL，则尝试访问 WebGL 上下文会返回null。在使用上下文之前，应该先检测返回值是否存在：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;  </span><br><span class="line">  <span class="keyword">let</span> gl = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>); </span><br><span class="line">  <span class="keyword">if</span> (gl)&#123; </span><br><span class="line">    <span class="comment">// 使用 WebGL </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这里把 WebGL context对象命名为gl。大多数 WebGL 应用和例子遵循这个约定，因为 OpenGL ES 2.0 方法和值通常以”gl”开头。这样可以让 JavaScript 代码看起来更接近 OpenGL 程序。</p>
<h4 id="18-4-2-WebGL-基础"><a href="#18-4-2-WebGL-基础" class="headerlink" title="18.4.2 WebGL 基础"></a>18.4.2 WebGL 基础</h4><p>可以在调用getContext()取得 WebGL 上下文时指定一些选项。这些选项通过一个参数对象传入，选项就是参数对象的一个或多个属性。</p>
<ul>
<li><p>alpha：布尔值，表示是否为上下文创建透明通道缓冲区，默认为true。 </p>
</li>
<li><p>depth：布尔值，表示是否使用 16 位深缓冲区，默认为true。 </p>
</li>
<li><p>stencil：布尔值，表示是否使用 8 位模板缓冲区，默认为false。 </p>
</li>
<li><p>antialias：布尔值，表示是否使用默认机制执行抗锯齿操作，默认为true。 </p>
</li>
<li><p>premultipliedAlpha：布尔值，表示绘图缓冲区是否预乘透明度值，默认为true。 </p>
</li>
<li><p>preserveDrawingBuffer：布尔值，表示绘图完成后是否保留绘图缓冲区，默认为false。</p>
</li>
</ul>
<p>如果调用getContext()不能创建 WebGL 上下文，某些浏览器就会抛出错误。为此，最好把这个方法调用包装在try/catch块中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Insert</span> <span class="title class_">IconMargin</span>     [download]<span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>), </span><br><span class="line">  gl;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    gl = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>);  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123; </span><br><span class="line">    <span class="comment">// 什么也不做 </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">if</span> (gl) &#123; </span><br><span class="line">    <span class="comment">// 使用 WebGL </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;WebGL context could not be created.&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol>
<li>常量</li>
</ol>
<p>在 WebGL 中，context对象上的常量则不包含GL_前缀。例如，GL_COLOR_BUFFER_BIT常量在WebGL 中要这样访问gl.COLOR_BUFFER_BIT。WebGL 以这种方式支持大部分 OpenGL 常量（少数常量不支持）。</p>
<ol start="2">
<li>方法命名</li>
</ol>
<p>OpenGL（同时也是 WebGL）中的很多方法会包含相关的数据类型信息。接收不同类型和不同数量参数的方法，会通过方法名的后缀体现这些信息。表示参数数量的数字（1~4）在先，表示数据类型的字符串（“f”表示浮点数，“i”表示整数）在后。比如，gl.uniform4f()的意思是需要 4 个浮点数值参数，而gl.uniform3i()表示需要 3 个整数值参数。<br>还有很多方法接收数组，这类方法用字母“v”（vector）来表示。因此，gl.uniform3iv()就是要接收一个包含 3 个值的数组参数。在编写 WebGL 代码时，要记住这些约定。</p>
<ol start="3">
<li>准备绘图</li>
</ol>
<p>准备使用 WebGL 上下文之前，通常需要先指定一种实心颜色清除&lt;**canvas**&gt;。为此，要调用clearColor()方法并传入 4 个参数，分别表示红、绿、蓝和透明度值。每个参数必须是 0~1 范围内的值，表示各个组件在最终颜色的强度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">clearColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 黑色 </span></span><br><span class="line">gl.<span class="title function_">clear</span>(gl.<span class="property">COLOR_BUFFER_BIT</span>); </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>视口与坐标</li>
</ol>
<p>绘图前还要定义 WebGL 视口。默认情况下，视口使用整个&lt;**canvas**&gt;区域。要改变视口，可以调用viewport()方法并传入视口相对于&lt;**canvas**&gt;元素的 x、y 坐标及宽度和高度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码表示要使用整个&lt;canvas&gt;元素： </span></span><br><span class="line">gl.<span class="title function_">viewport</span>(<span class="number">0</span>, <span class="number">0</span>, drawing.<span class="property">width</span>, </span><br><span class="line">drawing.<span class="property">height</span>);</span><br></pre></td></tr></table></figure>

<p>这个视口的坐标系统与网页中通常的坐标系统不一样。视口的 x 和 y 坐标起点(0, 0)表示&lt;**canvas**&gt;元素的左下角，向上、向右增长可以用点(width–1, height–1)定义。</p>
<ol start="5">
<li>缓冲区</li>
</ol>
<p>在 JavaScript 中，顶点信息保存在定型数组中。要使用这些信息，必须先把它们转换为 WebGL 缓冲区。创建缓冲区要调用gl.createBuffer()方法，并使用gl.bindBuffer()方法将缓冲区绑定到WebGL 上下文。绑定之后，就可以用数据填充缓冲区了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = gl.<span class="title function_">createBuffer</span>();  </span><br><span class="line">gl.<span class="title function_">bindBuffer</span>(gl.<span class="property">ARRAY_BUFFER</span>, buffer);  </span><br><span class="line">gl.<span class="title function_">bufferData</span>(gl.<span class="property">ARRAY_BUFFER</span>, <span class="keyword">new</span> <span class="title class_">Float32Array</span>([<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]), gl.<span class="property">STATIC_DRAW</span>);</span><br></pre></td></tr></table></figure>

<p>如果想输出缓冲区内容，那么可以调用drawElements()方法并传入gl.ELEMENT_ARRAY_BUFFER。<br>gl.bufferData()方法的最后一个参数表示如何使用缓冲区。</p>
<ul>
<li><p>gl.STATIC_DRAW：数据加载一次，可以在多次绘制中使用。 </p>
</li>
<li><p>gl.STREAM_DRAW：数据加载一次，只能在几次绘制中使用。 </p>
</li>
<li><p>gl.DYNAMIC_DRAW：数据可以重复修改，在多次绘制中使用。</p>
</li>
</ul>
<p>缓冲区会一直驻留在内存中，直到页面卸载。如果不再需要缓冲区，那么最好调用gl.deleteBuffer()方法释放其占用的内存。</p>
<ol start="6">
<li>错误</li>
</ol>
<p>在 WebGL 操作中通常不会抛出错误。必须在调用可能失败的方法后，调用gl.getError()方法。这个方法返回一个常量，表示发生的错误类型。下面列出了这些常量。 </p>
<ul>
<li><p>gl.NO_ERROR：上一次操作没有发生错误（0 值）。 </p>
</li>
<li><p>gl.INVALID_ENUM：上一次操作没有传入 WebGL 预定义的常量。 </p>
</li>
<li><p>gl.INVALID_VALUE：上一次操作需要无符号数值，但是传入了负数。 </p>
</li>
<li><p>gl.INVALID_OPERATION：上一次操作在当前状态下无法完成。 </p>
</li>
<li><p>gl.OUT_OF_MEMORY：上一次操作因内存不足而无法完成。 </p>
</li>
<li><p>gl.CONTEXT_LOST_WEBGL：上一次操作因外部事件（如设备掉电）而丢失了 WebGL 上下文。</p>
</li>
</ul>
<p>每次调用gl.getError()方法会返回一个错误值。第一次调用之后，再调用gl.getError()可能会返回另一个错误值。如果有多个错误，则可以重复这个过程，直到gl.getError()返回gl.NO_ERROR。</p>
<ol start="7">
<li>着色器</li>
</ol>
<p>着色器是 OpenGL 中的另一个概念。WebGL 中有两种着色器：顶点着色器和片段（或像素）着色器。顶点着色器用于把 3D 顶点转换为可以渲染的 2D 点。片段着色器用于计算绘制一个像素的正确颜色。WebGL 着色器的独特之处在于，它们不是 JavaScript 实现的，而是使用一种与 C 或 JavaScript 完全不同的语言 GLSL（OpenGL Shading Language）写的。</p>
<ul>
<li>编写着色器</li>
</ul>
<p>每个着色器都有一个main()方法，在绘制期间会重复执行。给着色器传递数据的方式有两种：attribute和uniform。attribute用于将顶点传入顶点着色器，而uniform用于将常量值传入任何着色器。attribute和uniform是在main()函数外部定义的。在值类型关键字之后是数据类型，然后是变量名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是一个简单的顶点着色器的例子： </span></span><br><span class="line"><span class="comment">// OpenGL 着色器语言 </span></span><br><span class="line"><span class="comment">// 着色器，摘自 Bartek Drozdz 的文章“Get started with WebGL—draw a square” </span></span><br><span class="line">attribute vec2 aVertexPosition;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  gl_Position = <span class="title function_">vec4</span>(aVertexPosition, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器与顶点着色器类似，只不过是通过uniform传入数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenGL 着色器语言 </span></span><br><span class="line"><span class="comment">// 着色器，摘自 Bartek Drozdz 的文章“Get started with WebGL—draw a square” </span></span><br><span class="line">uniform vec4 uColor; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>) &#123; </span><br><span class="line">  gl_FragColor = uColor; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器必须返回一个值，保存到变量gl_FragColor中，这个值表示绘制时使用的颜色。这个着色器定义了一个uniform，包含颜色的 4 个组件（vec4），保存在uColor中。从代码上看，这个着色器只是把传入的值赋给了gl_FragColor。uColor的值在着色器内不能改变。</p>
<ul>
<li>创建着色器程序</li>
</ul>
<p>GLSL 代码的字符串必须经过编译并链接到一个着色器程序中。为便于使用，通常可以使用带有自定义type属性的&lt;**script**&gt;元素把着色器代码包含在网页中。如果type属性无效，则浏览器不会解析&lt;**script**&gt;的内容，但这并不妨碍读写其中的内容。</p>
<p>更复杂的 WebGL 应用可以动态加载着色器。重点在于要使用着色器，必须先拿到 GLSL 代码的字符串。<br>有了 GLSL 字符串，下一步是创建shader对象。为此，需要调用gl.createShader()方法，并传 入 想 要 创 建 的 着 色 器 类 型 （gl.VERTEX_SHADER或gl.FRAGMENT_SHADER）。 然 后 ， 调 用gl.shaderSource()方法把 GLSL 代码应用到着色器，再调用gl.compileShader()编译着色器。</p>
<ul>
<li>给着色器传值</li>
</ul>
<p>前面定义的每个着色器都需要传入一个值，才能完成工作。要给着色器传值，必须先找到要接收值的变量。对于uniform变量，可以调用gl.getUniformLocation()方法。这个方法返回一个对象，表示该uniform变量在内存中的位置。然后，可以使用这个位置来完成赋值。</p>
<p>给顶点着色器传值也是类似的过程。而要获得attribute变量的位置，可以调用gl.getAttribLocation()方法。</p>
<ul>
<li>调试着色器和程序</li>
</ul>
<p>与 WebGL 中的其他操作类似，着色器操作也可能失败，而且是静默失败。如果想知道发生了什么错误，则必须手工通过 WebGL 上下文获取关于着色器或程序的信息。</p>
<p>对于着色器，可以调用gl.getShaderParameter()方法取得编译之后的编译状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gl.<span class="title function_">getShaderParameter</span>(vertexShader, gl.<span class="property">COMPILE_STATUS</span>)) &#123;  </span><br><span class="line">  <span class="title function_">alert</span>(gl.<span class="title function_">getShaderInfoLog</span>(vertexShader));  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>着色器程序也可能失败，因此也有类似的方法。gl.getProgramParameter()用于检测状态。最常见的程序错误发生在链接阶段，为此可以使用以下代码来检查：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!gl.<span class="title function_">getProgramParameter</span>(program, gl.<span class="property">LINK_STATUS</span>)) &#123; </span><br><span class="line">  <span class="title function_">alert</span>(gl.<span class="title function_">getProgramInfoLog</span>(program));  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>与gl.getShaderParameter()一样，gl.getProgramParameter()会在链接成功时返回true，失败时返回false。当然也有一个gl.getProgramInfoLog()方法，可以在程序失败时获取错误信息。<br>这些方法主要在开发时用于辅助调试。只要没有外部依赖，在产品环境中就可以放心地删除它们。</p>
<ul>
<li>GLSL 100 升级到 GLSL 300</li>
</ul>
<p>WebGL2 的主要变化是升级到了 GLSL 3.00 ES 着色器。这个升级暴露了很多新的着色器功能，包括 3D纹理等在支持 OpenGL ES 3.0 的设备上都有的功能。要使用升级版的着色器，着色器代码的第一行必须是：#version 300 es </p>
<p>这个升级需要一些语法的变化。</p>
<ul>
<li><p>顶点attribute变量要使用in而不是attribute关键字声明。</p>
</li>
<li><p>使用varying关键字为顶点或片段着色器声明的变量，现在必须根据相应着色器的行为改为使用in或out。 </p>
</li>
<li><p>预定义的输出变量gl_FragColor没有了，片段着色器必须为颜色输出声明自己的out变量。 </p>
</li>
<li><p>纹理查找函数texture2D和textureCube统一成了一个texture函数。</p>
</li>
</ul>
<ol start="8">
<li>绘图</li>
</ol>
<p>WebGL 只能绘制三种形状：点、线和三角形。其他形状必须通过这三种基本形状在 3D 空间的组合来绘制。WebGL 绘图要使用drawArrays()和drawElements()方法，前者使用数组缓冲区，后者则操作元素数组缓冲区。<br>drawArrays()和drawElements()的第一个参数都表示要绘制形状的常量。下面列出了这些常量。 </p>
<ul>
<li><p>gl.POINTS：将每个顶点当成一个点来绘制。 </p>
</li>
<li><p>gl.LINES：将数组作为一系列顶点，在这些顶点间绘制直线。每个顶点既是起点也是终点，因此数组中的顶点必须是偶数个才能开始绘制。 </p>
</li>
<li><p>gl.LINE_LOOP：将数组作为一系列顶点，在这些顶点间绘制直线。从第一个顶点到第二个顶点绘制一条直线，再从第二个顶点到第三个顶点绘制一条直线，以此类推，直到绘制到最后一个顶点。此时再从最后一个顶点到第一个顶点绘制一条直线。这样就可以绘制出形状的轮廓。 </p>
</li>
<li><p>gl.LINE_STRIP：类似于gl.LINE_LOOP，区别在于不会从最后一个顶点到第一个顶点绘制直线。 </p>
</li>
<li><p>gl.TRIANGLES：将数组作为一系列顶点，在这些顶点间绘制三角形。如不特殊指定，每个三角形都分开绘制，不共享顶点。 </p>
</li>
<li><p>gl.TRIANGLES_STRIP：类似于gl.TRIANGLES，区别在于前 3 个顶点之后的顶点会作为第三个顶点与其前面的两个顶点构成三角形。例如，如果数组中包含顶点 A、B、C、D，那么第一个三角形使用 ABC，第二个三角形使用 BCD。 </p>
</li>
<li><p>gl.TRIANGLES_FAN：类似于gl.TRIANGLES，区别在于前 3 个顶点之后的顶点会作为第三个顶点与其前面的顶点和第一个顶点构成三角形。例如，如果数组中包含顶点 A、B、C、D，那第一个三角形使用 ABC，第二个三角形使用 ACD。</p>
</li>
</ul>
<p>以上常量可以作为gl.drawArrays()方法的第一个参数，第二个参数是数组缓冲区的起点索引，第三个参数是数组缓冲区包含的顶点集合的数量。</p>
<ol start="9">
<li>纹理</li>
</ol>
<p>WebGL 纹理可以使用 DOM 中的图片。可以使用gl.createTexture()方法创建新的纹理，然后再将图片绑定到这个纹理。如果图片还没有加载，则可以创建一个Image对象来动态加载。图片加载完成后才能初始化纹理，因此在图片的load事件之后才能使用纹理。</p>
<p>除了使用 DOM 图片，这些步骤跟在 OpenGL 中创建纹理是一样的。最大的区别在于使用gl.pixelStorei()设置了像素存储格式。常量gl.UNPACK_FLIP_Y_WEBGL是 WebGL 独有的，在基于 Web 加载图片时通常要使用。原因在于 GIF、JPEG 和 PNG 图片使用的坐标系统与 WebGL 内部的坐标系统不一样。如果不使用这个标志，图片就会倒过来。<br>用于纹理的图片必须跟当前页面同源，或者是来自启用了跨源资源共享（CORS，Cross-Origin Resource Sharing）的服务器上。</p>
<ol start="10">
<li>读取像素</li>
</ol>
<p>与 2D 上下文一样，可以从 WebGL 上下文中读取像素数据。读取像素的readPixels()方法与OpenGL 中的方法有同样的参数，只不过最后一个参数必须是定型数组。像素信息是从帧缓冲区读出来并放到这个定型数组中的。readPixels()方法的参数包括 x 和 y 坐标、宽度、高度、图像格式、类型和定型数组。前 4 个参数用于指定要读取像素的位置。图像格式参数几乎总是gl.RGBA。类型参数指的是要存储在定型数组中的数据类型，有如下限制： </p>
<ul>
<li><p>如果这个类型是gl.UNSIGNED_BYTE，则定型数组必须是Uint8Array； </p>
</li>
<li><p>如果这个类型是gl.UNSIGNED_SHORT_5_6_5、gl.UNSIGNED_SHORT_4_4_4_4或gl.UNSIGNED_ SHORT_5_5_5_1，则定型数组必须是Uint16Array。</p>
</li>
</ul>
<p>在浏览器绘制更新后的 WebGL 图像之前调用readPixels()没有问题。而在绘制完成后，帧缓冲区会恢复到其初始清除状态，此时调用readPixels()会得到与清除状态一致的像素数据。如果想在绘制之后读取像素，则必须使用前面讨论过的preserveDrawingBuffer选项初始化 WebGL 上下文：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gl = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>, &#123; <span class="attr">preserveDrawingBuffer</span>: <span class="literal">true</span>; &#125;);</span><br></pre></td></tr></table></figure>

<p>设置这个标志可以强制帧缓冲区在下一次绘制之前保持上一次绘制的状态。这个选项可能会影响性能，因此尽量不要使用。</p>
<h4 id="18-4-3-WebGL1-与-WebGL2"><a href="#18-4-3-WebGL1-与-WebGL2" class="headerlink" title="18.4.3 WebGL1 与 WebGL2"></a>18.4.3 WebGL1 与 WebGL2</h4><p>以下特性都已成为 WebGL2 的标准特性： </p>
<ul>
<li><p>ANGLE_instanced_arrays </p>
</li>
<li><p>EXT_blend_minmax </p>
</li>
<li><p>EXT_frag_depth </p>
</li>
<li><p>EXT_shader_texture_lod </p>
</li>
<li><p>OES_element_index_uint </p>
</li>
<li><p>OES_standard_derivatives </p>
</li>
<li><p>OES_texture_float </p>
</li>
<li><p>OES_texture_float_linear </p>
</li>
<li><p>OES_vertex_array_object </p>
</li>
<li><p>WEBGL_depth_texture </p>
</li>
<li><p>WEBGL_draw_buffers </p>
</li>
<li><p>Vertex shader texture access</p>
</li>
</ul>
<h3 id="18-5-小结"><a href="#18-5-小结" class="headerlink" title="18.5 小结"></a>18.5 小结</h3><p>requestAnimationFrame是简单但实用的工具，可以让 JavaScript 跟进浏览器渲染周期，从而更加有效地实现网页视觉动效。<br>HTML5 的&lt;**canvas**&gt;元素为 JavaScript 提供了动态创建图形的 API。这些图形需要使用特定上下文绘制，主要有两种。第一种是支持基本绘图操作的 2D 上下文：</p>
<ul>
<li><p>填充和描绘颜色及图案 </p>
</li>
<li><p>绘制矩形 </p>
</li>
<li><p>绘制路径 </p>
</li>
<li><p>绘制文本 </p>
</li>
<li><p>创建渐变和图案</p>
</li>
</ul>
<p>第二种是 3D 上下文，也就是 WebGL。WebGL 是浏览器对 OpenGL ES 2.0 的实现。OpenGL ES 2.0是游戏图形开发常用的一个标准。WebGL 支持比 2D 上下文更强大的绘图能力，包括： </p>
<ul>
<li><p>用 OpenGL 着色器语言（GLSL）编写顶点和片段着色器； </p>
</li>
<li><p>支持定型数组，限定数组中包含数值的类型； </p>
</li>
<li><p>创建和操作纹理。</p>
</li>
</ul>
<h2 id="十九、表单脚本"><a href="#十九、表单脚本" class="headerlink" title="十九、表单脚本"></a>十九、表单脚本</h2><h3 id="19-1-表单基础"><a href="#19-1-表单基础" class="headerlink" title="19.1 表单基础"></a>19.1 表单基础</h3><p>Web 表单在 HTML 中以&lt;**form**&gt;元素表示，在 JavaScript 中则以HTMLFormElement类型表示。HTMLFormElement类型继承自HTMLElement类型，因此拥有与其他 HTML 元素一样的默认属性。不过，HTMLFormElement也有自己的属性和方法。</p>
<ul>
<li><p>acceptCharset：服务器可以接收的字符集，等价于 HTML 的accept-charset属性。 </p>
</li>
<li><p>action：请求的 URL，等价于 HTML 的action属性。 </p>
</li>
<li><p>elements：表单中所有控件的HTMLCollection。 </p>
</li>
<li><p>enctype：请求的编码类型，等价于 HTML 的enctype属性。 </p>
</li>
<li><p>length：表单中控件的数量。 </p>
</li>
<li><p>method：HTTP 请求的方法类型，通常是”get”或”post”，等价于 HTML 的method属性。 </p>
</li>
<li><p>name：表单的名字，等价于 HTML 的name属性。 </p>
</li>
<li><p>reset()：把表单字段重置为各自的默认值。 </p>
</li>
<li><p>submit()：提交表单。 </p>
</li>
<li><p>target：用于发送请求和接收响应的窗口的名字，等价于 HTML 的target属性。</p>
</li>
</ul>
<p>有几种方式可以取得对&lt;**form**&gt;元素的引用。最常用的是将表单当作普通元素为它指定一个id属性，从而可以使用getElementById()来获取表单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;form1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此外，使用document.forms集合可以获取页面上所有的表单元素。然后，可以进一步使用数字索引或表单的名字（name）来访问特定的表单。</p>
<blockquote>
<p>表单可以同时拥有id和name，而且两者可以不相同。</p>
</blockquote>
<h4 id="19-1-1-提交表单"><a href="#19-1-1-提交表单" class="headerlink" title="19.1.1 提交表单"></a>19.1.1 提交表单</h4><p>表单是通过用户点击提交按钮或图片按钮的方式提交的。提交按钮可以使用type属性为”submit”的&lt;**input**&gt;或&lt;**button**&gt;元素来定义，图片按钮可以使用type属性为”image”的&lt;**input**&gt;元素来定义。点击下面例子中定义的所有按钮都可以提交它们所在的表单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通用提交按钮 --&gt;  </span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Submit Form&quot;&gt;  </span><br><span class="line"></span><br><span class="line">&lt;!-- 自定义提交按钮 --&gt;  </span><br><span class="line">&lt;button type=&quot;submit&quot;&gt;Submit Form&lt;/button&gt; </span><br><span class="line"></span><br><span class="line">&lt;!-- 图片按钮 --&gt; </span><br><span class="line">&lt;input type=&quot;image&quot; src=&quot;graphic.gif&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果表单中有上述任何一个按钮，且焦点在表单中某个控件上，则按回车键也可以提交表单。（textarea控件是个例外，当焦点在它上面时，按回车键会换行。）注意，没有提交按钮的表单在按回车键时不会提交。<br>以这种方式提交表单会在向服务器发送请求之前触发submit事件。这样就提供了一个验证表单数据的机会，可以根据验证结果决定是否真的要提交。阻止这个事件的默认行为可以取消提交表单。</p>
<p>调用preventDefault()方法可以阻止表单提交。通常，在表单数据无效以及不应该发送到服务器时可以这样处理。</p>
<p>也可以通过编程方式在 JavaScript 中调用submit()方法来提交表单。可以在任何时候调用这个方法来提交表单，而且表单中不存在提交按钮也不影响表单提交。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交表单 </span></span><br><span class="line">form.<span class="title function_">submit</span>(); </span><br></pre></td></tr></table></figure>

<p>通过submit()提交表单时，submit事件不会触发。因此在调用这个方法前要先做数据验证。</p>
<p>表单提交的一个最大的 <strong>问题</strong> 是可能会提交两次表单。如果提交表单之后没有什么反应，那么没有耐心的用户可能会多次点击提交按钮。结果是很烦人的（因为服务器要处理重复的请求），甚至可能造成损失（如果用户正在购物，则可能会多次下单）。解决这个问题主要有两种方式：在表单提交后禁用提交按钮，或者通过onsubmit事件处理程序取消之后的表单提交。</p>
<h4 id="19-1-2-重置表单"><a href="#19-1-2-重置表单" class="headerlink" title="19.1.2 重置表单"></a>19.1.2 重置表单</h4><p>用户单击重置按钮可以重置表单。重置按钮可以使用type属性为”reset”的&lt;**input**&gt;或&lt;**button**&gt;元素来创建。</p>
<p>表单重置后，所有表单字段都会重置回页面第一次渲染时各自拥有的值。如果字段原来是空的，就会变成空的；如果字段有默认值，则恢复为默认值。<br>用户单击重置按钮重置表单会触发reset事件。这个事件为取消重置提供了机会。</p>
<p>与表单提交一样，重置表单也可以通过 JavaScript 调用reset()方法来完成。</p>
<p>与submit()方法的功能不同，调用reset()方法会像单击了重置按钮一样触发reset事件。</p>
<blockquote>
<p>表单设计中通常不提倡重置表单，因为重置表单经常会导致用户迷失方向，如果意外触发则会令人感到厌烦。实践中几乎没有重置表单的需求。一般来说，提供一个取消按钮，让用户点击返回前一个页面，而不是恢复表单中所有的值来得更直观。</p>
</blockquote>
<h4 id="19-1-3-表单字段"><a href="#19-1-3-表单字段" class="headerlink" title="19.1.3 表单字段"></a>19.1.3 表单字段</h4><p>表单元素可以像页面中的其他元素一样使用原生 DOM 方法来访问。此外，所有表单元素都是表单elements属性（元素集合）中包含的一个值。这个elements集合是一个有序列表，包含对表单中所有字段的引用，包括所有&lt;**input**&gt;、<textarea>、&lt;**button**&gt;、&lt;**select**&gt;和&lt;**fieldset**&gt;元素。elements集合中的每个字段都以它们在 HTML 标记中出现的次序保存，可以通过索引位置和name属性来访问。</p>
<p>如果多个表单控件使用了同一个name，比如像单选按钮那样，则会返回包含所有同名元素的 HTMLCollection。</p>
<blockquote>
<p>也可以通过表单属性的方式访问表单字段，比如form[0]这种使用索引和form [“color”]这种使用字段名字的方式。访问这些属性与访问form.elements集合是一样的。这种方式是为向后兼容旧版本浏览器而提供的，实际开发中应该使用elements。</p>
</blockquote>
<ol>
<li>表单字段的公共属性</li>
</ol>
<p>除&lt;**fieldset**&gt;元素以外，所有表单字段都有一组同样的属性。由于&lt;**input**&gt;类型可以表示多种表单字段，因此某些属性只适用于特定类型的字段。除此之外的属性可以在任何表单字段上使用。</p>
<ul>
<li><p>disabled：布尔值，表示表单字段是否禁用。 </p>
</li>
<li><p>form：指针，指向表单字段所属的表单。这个属性是只读的。 </p>
</li>
<li><p>name：字符串，这个字段的名字。 </p>
</li>
<li><p>readOnly：布尔值，表示这个字段是否只读。 </p>
</li>
<li><p>tabIndex：数值，表示这个字段在按 Tab 键时的切换顺序。 </p>
</li>
<li><p>type：字符串，表示字段类型,如”checkbox”、”radio”等。 </p>
</li>
<li><p>value：要提交给服务器的字段值。对文件输入字段来说，这个属性是只读的，仅包含计算机上某个文件的路径。</p>
</li>
</ul>
<p>除了form属性以外，JavaScript 可以动态修改任何属性。</p>
<p>type属性可以用于除&lt;**fieldset**&gt;之外的任何表单字段。对于&lt;**input**&gt;元素，这个值等于 HTML的type属性值。</p>
<p>对于&lt;**input**&gt;和&lt;**button**&gt;元素，可以动态修改其type属性。但&lt;**select**&gt;元素的type属性是只读的。</p>
<ol start="2">
<li>表单字段的公共方法</li>
</ol>
<p>每个表单字段都有两个公共方法：focus()和blur()。focus()方法把浏览器焦点设置到表单字段，这意味着该字段会变成活动字段并可以响应键盘事件。例如，文本框在获得焦点时会在内部显示闪烁的光标，表示可以接收输入。focus()方法主要用来引起用户对页面中某个部分的注意。比如，在页面加载后把焦点定位到表单中第一个字段就是很常见的做法。实现方法是监听load事件，然后在第一个字段上调用focus()，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="number">0</span>].<span class="title function_">focus</span>();  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>如果表单中第一个字段是type为”hidden”的&lt;**input**&gt;元素，或者该字段被 CSS 属性display或visibility隐藏了，以上代码就会出错。<br>HTML5 为表单字段增加了autofocus属性，支持的浏览器会自动为带有该属性的元素设置焦点，而无须使用 JavaScript。</p>
<p>autofocus是布尔值属性，所以在支持的浏览器中通过 JavaScript 访问表单字段的autofocus属性会返回true（在不支持的浏览器中是空字符串）。</p>
<blockquote>
<p>默认情况下只能给表单元素设置焦点。不过，通过将tabIndex属性设置为–1 再调用focus()，也可以给任意元素设置焦点。只有 Opera 不支持这个技术。</p>
</blockquote>
<p>focus()的反向操作是blur()，其用于从元素上移除焦点。调用blur()时，焦点不会转移到任何特定元素，仅仅只是从调用这个方法的元素上移除了。</p>
<ol start="3">
<li>表单字段的公共事件</li>
</ol>
<p>除了鼠标、键盘、变化和 HTML 事件外，所有字段还支持以下 3 个事件。</p>
<ul>
<li><p>blur：在字段失去焦点时触发。 </p>
</li>
<li><p>change：在&lt;**input**&gt;和<textarea>元素的value发生变化且失去焦点时触发，或者在&lt;**select**&gt;元素中选中项发生变化时触发。 </p>
</li>
<li><p>focus：在字段获得焦点时触发</p>
</li>
</ul>
<p>blur和focus事件会因为用户手动改变字段焦点或者调用blur()或focus()方法而触发。这两个事件对所有表单都会一视同仁。change事件则不然，它会因控件不同而在不同时机触发。对于&lt;**input**&gt;和<textarea>元素，change事件会在字段失去焦点，同时value自控件获得焦点后发生变化时触发。对于&lt;**select**&gt;元素，change事件会在用户改变了选中项时触发，不需要控件失去焦点。<br>focus和blur事件通常用于以某种方式改变用户界面，以提供可见的提示或额外功能（例如在文本框下面显示下拉菜单）。change事件通常用于验证用户在字段中输入的内容。</p>
<blockquote>
<p>blur和change事件的关系并没有明确定义。在某些浏览器中，blur事件会先于change事件触发；在其他浏览器中，触发顺序则相反。因此不能依赖这两个事件触发的顺序，必须区分时要多加注意。</p>
</blockquote>
<h3 id="19-2-文本框编程"><a href="#19-2-文本框编程" class="headerlink" title="19.2 文本框编程"></a>19.2 文本框编程</h3><p>在 HTML 中有两种表示文本框的方式：单行使用&lt;**input**&gt;元素，多行使用<textarea>元素。这两个控件非常相似，大多数时候行为也一样。不过，它们也有非常重要的区别。</p>
<p>默认情况下，&lt;**input**&gt;元素显示为文本框，省略type属性会以”text”作为默认值。然后可以通过size属性指定文本框的宽度，这个宽度是以字符数来计量的。而value属性用于指定文本框的初始值，maxLength属性用于指定文本框允许的最多字符数。</p>
<textarea>元素总是会创建多行文本框。可以使用rows属性指定这个文本框的高度，以字符数计量；以cols属性指定以字符数计量的文本框宽度，类似于<**input**>元素的size属性。与<**input**>不同的是，<textarea>的初始值必须包含在<textarea>和</textarea>之间。

<p>同样与&lt;**input**&gt;元素不同的是，<textarea>不能在 HTML 中指定最大允许的字符数。<br>除了标记中的不同，这两种类型的文本框都会在value属性中保存自己的内容。通过这个属性，可以读取也可以设置文本模式的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(textbox.<span class="property">value</span>);  </span><br><span class="line"></span><br><span class="line">textbox.<span class="property">value</span> = <span class="string">&quot;Some new value&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>应该使用value属性，而不是标准 DOM 方法读写文本框的值。比如，不要使用setAttribute()设置&lt;**input**&gt;元素value属性的值，也不要尝试修改<textarea>元素的第一个子节点。对value属性的修改也不会总体现在 DOM 中，因此在处理文本框值的时候最好不要使用 DOM 方法。</p>
<h4 id="19-2-1-选择文本"><a href="#19-2-1-选择文本" class="headerlink" title="19.2.1 选择文本"></a>19.2.1 选择文本</h4><p>两种文本框都支持一个名为select()的方法，此方法用于全部选中文本框中的文本。大多数浏览器会在调用select()方法后自动将焦点设置到文本框（Opera 例外）。这个方法不接收参数，可以在任何时候调用。</p>
<ol>
<li>select事件</li>
</ol>
<p>与select()方法相对，还有一个select事件。当选中文本框中的文本时，会触发select事件。这个事件确切的触发时机因浏览器而异。在 IE9+、Opera、Firefox、Chrome 和 Safari 中，select事件会在用户选择完文本后立即触发；在 IE8 及更早版本中，则会在第一个字符被选中时触发。另外，调用select()方法也会触发select事件。</p>
<ol start="2">
<li>取得选中文本</li>
</ol>
<p>虽然select事件能够表明有文本被选中，但不能提供选中了哪些文本的信息。HTML5 对此进行了扩展，以方便更好地获取选中的文本。扩展为文本框添加了两个属性：selectionStart和selectionEnd。这两个属性包含基于 0 的数值，分别表示文本选区的起点和终点（文本选区起点的偏移量和文本选区终点的偏移量）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSelectedText</span>(<span class="params">textbox</span>)&#123; </span><br><span class="line">  <span class="keyword">return</span> textbox.<span class="property">value</span>.<span class="title function_">substring</span>(textbox.<span class="property">selectionStart</span>,  </span><br><span class="line">                                 textbox.<span class="property">selectionEnd</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>部分选中文本</li>
</ol>
<p>除了select()方法之外，Firefox最早实现的setSelectionRange()方法也可以在所有文本框中使用。这个方法接收两个参数：要选择的第一个字符的索引和停止选择的字符的索引（与字符串的substring()方法一样）。</p>
<p>如果想看到选择，则必须在调用setSelectionRange()之前或之后给文本框设置焦点。</p>
<p>IE8 及更早版本支持通过范围部分选中文本。这也就是说，要选择文本框中的部分文本，必须先使用 IE 在文本框上提供的createTextRange()方法创建一个范围，并使用moveStart()和moveEnd()范围方法把这个范围放到正确的位置上。不过，在调用这两个方法前需要先调用collapse()方法把范围折叠到文本框的开始。接着，moveStart()可以把范围的起点和终点都移动到相同的位置，再给moveEnd()传入要选择的字符总数作为参数。最后一步是使用范围的select()方法选中文本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="property">value</span> = <span class="string">&quot;Hello world!&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> range = textbox.<span class="title function_">createTextRange</span>();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择所有文本 </span></span><br><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>); </span><br><span class="line">range.<span class="title function_">moveStart</span>(<span class="string">&quot;character&quot;</span>, <span class="number">0</span>); </span><br><span class="line">range.<span class="title function_">moveEnd</span>(<span class="string">&quot;character&quot;</span>, textbox.<span class="property">value</span>.<span class="property">length</span>);   <span class="comment">// &quot;Hello world!&quot;  </span></span><br><span class="line">range.<span class="title function_">select</span>();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择前 3 个字符 </span></span><br><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>); </span><br><span class="line">range.<span class="title function_">moveStart</span>(<span class="string">&quot;character&quot;</span>, <span class="number">0</span>); </span><br><span class="line">range.<span class="title function_">moveEnd</span>(<span class="string">&quot;character&quot;</span>, <span class="number">3</span>);  </span><br><span class="line">range.<span class="title function_">select</span>();  <span class="comment">// &quot;Hel&quot;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择第 4~6 个字符 </span></span><br><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>); </span><br><span class="line">range.<span class="title function_">moveStart</span>(<span class="string">&quot;character&quot;</span>, <span class="number">4</span>); </span><br><span class="line">range.<span class="title function_">moveEnd</span>(<span class="string">&quot;character&quot;</span>, <span class="number">6</span>);  </span><br><span class="line">range.<span class="title function_">select</span>();  <span class="comment">// &quot;o w&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="19-2-2-输入过滤"><a href="#19-2-2-输入过滤" class="headerlink" title="19.2.2 输入过滤"></a>19.2.2 输入过滤</h4><p>不同文本框经常需要保证输入特定类型或格式的数据。或许数据需要包含特定字符或必须匹配某个特定模式。由于文本框默认并未提供什么验证功能，因此必须通过 JavaScript 来实现这种输入过滤。组合使用相关事件及 DOM 能力，可以把常规的文本框转换为能够理解自己所收集数据的智能输入框。</p>
<ol>
<li>屏蔽字符</li>
</ol>
<p>有些输入框需要出现或不出现特定字符。keypress事件负责向文本框插入字符，因此可以通过阻止这个事件的默认行为来屏蔽非数字字符。</p>
<p>如果想只屏蔽特定字符，则需要检查事件的charCode属性，以确定正确的回应方式。</p>
<p>在Firefox 中，所有触发keypress事件的非字符键的charCode都是 0，而在 Safari 3 之前这些键的<br>charCode都是 8。综合考虑这些情况，就是不能屏蔽charCode小于 10 的键。为此，可以改进为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keypress&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/\d/</span>.<span class="title function_">test</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(event.<span class="property">charCode</span>)) &amp;&amp;  </span><br><span class="line">      event.<span class="property">charCode</span> &gt; <span class="number">9</span>)&#123; </span><br><span class="line">    event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>这个事件处理程序可以在所有浏览器中使用，屏蔽非数字字符但允许同样会触发keypress事件的所有基础按键。<br>还有一个问题需要处理：复制、粘贴及涉及 Ctrl 键的其他功能。在除 IE 外的所有浏览器中，前面代码会屏蔽快捷键 Ctrl+C、Ctrl+V 及其他使用 Ctrl 的组合键。因此，最后一项检测是确保没有按下 Ctrl键，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keypress&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/\d/</span>.<span class="title function_">test</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(event.<span class="property">charCode</span>)) &amp;&amp;  </span><br><span class="line">      event.<span class="property">charCode</span> &gt; <span class="number">9</span> &amp;&amp;  </span><br><span class="line">      !event.<span class="property">ctrlKey</span>)&#123; </span><br><span class="line">    event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>处理剪贴板</li>
</ol>
<p>以下是与剪贴板相关的 6 个事件。</p>
<ul>
<li><p>beforecopy：复制操作发生前触发。 </p>
</li>
<li><p>copy：复制操作发生时触发。 </p>
</li>
<li><p>beforecut：剪切操作发生前触发。 </p>
</li>
<li><p>cut：剪切操作发生时触发。 </p>
</li>
<li><p>beforepaste：粘贴操作发生前触发。 </p>
</li>
<li><p>paste：粘贴操作发生时触发。</p>
</li>
</ul>
<p>在 Safari、Chrome 和 Firefox 中，beforecopy、beforecut和beforepaste事件只会在显示文本框的上下文菜单（预期会发生剪贴板事件）时触发，但 IE 不仅在这种情况下触发，也会在copy、cut和paste事件之前触发。无论是在上下文菜单中做出选择还是使用键盘快捷键，copy、cut和paste事件在所有浏览器中都会按预期触发。<br>通过beforecopy、beforecut和beforepaste事件可以在向剪贴板发送或从中检索数据前修改数据。不过，取消这些事件并不会取消剪贴板操作。要阻止实际的剪贴板操作，必须取消copy、cut和paste事件。<br>剪贴板上的数据可以通过window对象（IE）或event对象（Firefox、Safari 和 Chrome）上的clipboardData对象来获取。在 Firefox、Safari 和 Chrome 中，为防止未经授权访问剪贴板，只能在剪贴板事件期间访问clipboardData对象；IE 则在任何时候都会暴露clipboardData对象。为了跨浏览器兼容，最好只在剪贴板事件期间使用这个对象。<br>clipboardData对象上有 3 个方法：getData()、setData()和clearData()，其中getData()方法从剪贴板检索字符串数据，并接收一个参数，该参数是要检索的数据的格式。IE 为此规定了两个选项：”text”和”URL”。Firefox、Safari 和 Chrome 则期待 MIME 类型，不过会将”text”视为等价于”text/plain”。<br>setData()方法也类似，其第一个参数用于指定数据类型，第二个参数是要放到剪贴板上的文本。同样，IE 支持”text”和”URL”，Safari 和 Chrome 则期待 MIME 类型。不过，与getData()不同的是，Safari 和 Chrome 不认可”text”类型。只有在 IE8 及更早版本中调用setData()才有效，其他浏览器会忽略对这个方法的调用。为抹平差异，可以使用以下跨浏览器的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getClipboardText</span>(<span class="params">event</span>)&#123; </span><br><span class="line">  <span class="keyword">var</span> clipboardData =  (event.<span class="property">clipboardData</span> || <span class="variable language_">window</span>.<span class="property">clipboardData</span>); </span><br><span class="line">  <span class="keyword">return</span> clipboardData.<span class="title function_">getData</span>(<span class="string">&quot;text&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setClipboardText</span> (event, value)&#123; </span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">clipboardData</span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> event.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&quot;text/plain&quot;</span>, value); </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">clipboardData</span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&quot;text&quot;</span>, value); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-2-3-自动切换"><a href="#19-2-3-自动切换" class="headerlink" title="19.2.3 自动切换"></a>19.2.3 自动切换</h4><p>JavaScript 可以通过很多方式来增强表单字段的易用性。最常用的是在当前字段完成时自动切换到下一个字段。</p>
<h4 id="19-2-4-HTML5-约束验证-API"><a href="#19-2-4-HTML5-约束验证-API" class="headerlink" title="19.2.4 HTML5 约束验证 API"></a>19.2.4 HTML5 约束验证 API</h4><p>HTML5为浏览器新增了在提交表单前验证数据的能力。这些能力实现了基本的验证，即使JavaScript不可用或加载失败也没关系。</p>
<ol>
<li>必填字段</li>
</ol>
<p>第一个条件是给表单字段添加required属性，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> required&gt;</span><br></pre></td></tr></table></figure>

<p>任何带有required属性的字段都必须有值，否则无法提交表单。这个属性适用于&lt;**input**&gt;、<textarea>和&lt;**select**&gt;字段（Opera 直到版本 11 都不支持&lt;**select**&gt;的required属性）。可以通过JavaScript 检测对应元素的required属性来判断表单字段是否为必填:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isUsernameRequired = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;username&quot;</span>].<span class="property">required</span>;</span><br></pre></td></tr></table></figure>

<p>还可以使用下面的代码检测浏览器是否支持required属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isRequiredSupported = <span class="string">&quot;required&quot;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不同浏览器处理必填字段的机制不同。Firefox、Chrome、IE 和 Opera 会阻止表单提交并在相应字段下面显示有帮助信息的弹框，而 Safari 什么也不做，也不会阻止提交表单。</p>
</blockquote>
<ol start="2">
<li>更多输入类型</li>
</ol>
<p>HTML5 为&lt;**input**&gt;元素增加了几个新的type值。这些类型属性不仅表明了字段期待的数据类型，而且也提供了一些默认验证，其中两个新的输入类型是已经得到广泛支持的”email”和”url”，二者都有浏览器提供的自定义验证。</p>
<p>“email”类型确保输入的文本匹配电子邮件地址，而”url”类型确保输入的文本匹配 URL。</p>
<blockquote>
<p>浏览器在匹配模式时都存在问题。最明显的是文本”-@-“会被认为是有效的电子邮件地址。浏览器厂商仍然在解决这些问题。</p>
</blockquote>
<p>对于这两个新类型，除非应用了required属性，否则空字段是有效的。另外，指定一个特殊输入类型并不会阻止用户输入无效的值。新类型只是会应用一些默认验证。</p>
<ol start="3">
<li>数值范围</li>
</ol>
<p>HTML5 还定义了其他几种新的输入元素类型，它们都是期待某种数值输入的，包括：”number”、”range”、”datetime”、”datetime-local”、”date”、”month”、”week”和”time”。</p>
<p>对上述每种数值类型，都可以指定min属性（最小可能值）、max属性（最大可能值），以及step属性（从min到max的步长值）。</p>
<p>根据浏览器的不同，可能会也可能不会出现旋转控件（上下按钮）用于自动增加和减少。<br>上面每个属性在 JavaScript 中也可以通过对应元素的 DOM 属性来访问和修改。此外，还有两个方法，即stepUp()和stepDown()。这两个方法都接收一个可选的参数：要从当前值加上或减去的数值。（默认情况下，步长值会递增或递减 1。</p>
<ol start="4">
<li>输入模式</li>
</ol>
<p>HTML5 为文本字段新增了pattern属性。这个属性用于指定一个正则表达式，用户输入的文本必须与之匹配。</p>
<p>注意模式的开头和末尾分别假设有^和$。这意味着输入内容必须从头到尾都严格与模式匹配。<br>与新增的输入类型一样，指定pattern属性也不会阻止用户输入无效内容。模式会应用到值，然后浏览器会知道值是否有效。</p>
<ol start="5">
<li>检测有效性</li>
</ol>
<p>使用checkValidity()方法可以检测表单中任意给定字段是否有效。这个方法在所有表单元素上都可以使用，如果字段值有效就会返回true，否则返回false。</p>
<p>要检查整个表单是否有效，可以直接在表单上调用checkValidity()方法。这个方法会在所有字段都有效时返回true，有一个字段无效就会返回false：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">checkValidity</span>())&#123; </span><br><span class="line">  <span class="comment">// 表单有效，继续 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 表单无效 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>checkValidity()方法只会告诉我们字段是否有效，而validity属性会告诉我们字段为什么有效或无效。这个属性是一个对象，包含一系列返回布尔值的属性。</p>
<ul>
<li><p>customError：如果设置了setCustomValidity()就返回true，否则返回false。 </p>
</li>
<li><p>patternMismatch：如果字段值不匹配指定的pattern属性则返回true。 </p>
</li>
<li><p>rangeOverflow：如果字段值大于max的值则返回true。 </p>
</li>
<li><p>rangeUnderflow：如果字段值小于min的值则返回true。 </p>
</li>
<li><p>stepMisMatch：如果字段值与min、max和step的值不相符则返回true。 </p>
</li>
<li><p>tooLong：如果字段值的长度超过了maxlength属性指定的值则返回true。某些浏览器，如Firefox 4 会自动限制字符数量，因此这个属性值始终为false。 </p>
</li>
<li><p>typeMismatch：如果字段值不是”email”或”url”要求的格式则返回true。 </p>
</li>
<li><p>valid：如果其他所有属性的值都为false则返回true。与checkValidity()的条件一致。 </p>
</li>
<li><p>valueMissing：如果字段是必填的但没有值则返回true。</p>
</li>
</ul>
<p>通过validity属性可以检查表单字段的有效性，从而获取更具体的信息，如下面的代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (input.<span class="property">validity</span> &amp;&amp; !input.<span class="property">validity</span>.<span class="property">valid</span>)&#123; </span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">validity</span>.<span class="property">valueMissing</span>)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Please specify a value.&quot;</span>)  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.<span class="property">validity</span>.<span class="property">typeMismatch</span>)&#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Please enter an email address.&quot;</span>);  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value is invalid.&quot;</span>); </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>禁用验证</li>
</ol>
<p>通过指定novalidate属性可以禁止对表单进行任何验证：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/signup&quot;</span> novalidate&gt; </span><br><span class="line">    &lt;!-- 表单元素 --&gt;  </span><br><span class="line">&lt;/form&gt; </span><br></pre></td></tr></table></figure>

<p>这个值也可以通过 JavaScript 属性noValidate检索或设置，设置为true表示属性存在，设置为false表示属性不存在。</p>
<p>如果一个表单中有多个提交按钮，那么可以给特定的提交按钮添加formnovalidate属性，指定通过该按钮无须验证即可提交表单。</p>
<h3 id="19-3-选择框编程"><a href="#19-3-选择框编程" class="headerlink" title="19.3 选择框编程"></a>19.3 选择框编程</h3><p>选择框是使用&lt;**select**&gt;和&lt;**option**&gt;元素创建的。为方便交互，HTMLSelectElement类型在所有表单字段的公共能力之外又提供了以下属性和方法。</p>
<ul>
<li><p>add(newOption, relOption)：在relOption之前向控件中添加新的&lt;**option**&gt;。 </p>
</li>
<li><p>multiple：布尔值，表示是否允许多选，等价于 HTML 的multiple属性。 </p>
</li>
<li><p>options：控件中所有&lt;**option**&gt;元素的HTMLCollection。 </p>
</li>
<li><p>remove(index)：移除给定位置的选项。 </p>
</li>
<li><p>selectedIndex：选中项基于 0 的索引值，如果没有选中项则为–1。对于允许多选的列表，始终是第一个选项的索引。 </p>
</li>
<li><p>size：选择框中可见的行数，等价于 HTML 的size属性。</p>
</li>
</ul>
<p>选择框的type属性可能是”select-one”或”select-multiple”，具体取决于multiple属性是否存在。当前选中项根据以下规则决定选择框的value属性。</p>
<ul>
<li><p>如果没有选中项，则选择框的值是空字符串。 </p>
</li>
<li><p>如果有一个选中项，且其value属性有值，则选择框的值就是选中项value属性的值。即使value属性的值是空字符串也是如此。 </p>
</li>
<li><p>如果有一个选中项，且其value属性没有指定值，则选择框的值是该项的文本内容。 </p>
</li>
<li><p>如果有多个选中项，则选择框的值根据前两条规则取得第一个选中项的值。</p>
</li>
</ul>
<p>每个&lt;**option**&gt;元素在 DOM 中都由一个HTMLOptionElement对象表示。HTMLOptionElement类型为方便数据存取添加了以下属性。</p>
<ul>
<li><p>index：选项在options集合中的索引。</p>
</li>
<li><p>label：选项的标签，等价于 HTML 的label属性。 </p>
</li>
<li><p>selected：布尔值，表示是否选中了当前选项。把这个属性设置为true会选中当前选项。 </p>
</li>
<li><p>text：选项的文本。 </p>
</li>
<li><p>value：选项的值（等价于 HTML 的value属性）。</p>
</li>
</ul>
<p>在操作选项时，最好使用特定于选项的属性，因为这些属性得到了跨浏览器的良好支持。在操作DOM 节点时，与表单控制实际的交互可能会因浏览器而异。</p>
<p>选择框的change事件与其他表单字段是不一样的。其他表单字段会在自己的值改变后触发change事件，然后字段失去焦点。而选择框会在选中一项时立即触发change事件。</p>
<h4 id="19-3-1-选项处理"><a href="#19-3-1-选项处理" class="headerlink" title="19.3.1 选项处理"></a>19.3.1 选项处理</h4><p>对于只允许选择一项的选择框，获取选项最简单的方式是使用选择框的selectedIndex属性，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selectedOption = selectbox.<span class="property">options</span>[selectbox.<span class="property">selectedIndex</span>];</span><br></pre></td></tr></table></figure>

<p>设置selectedIndex会移除所有选项，只选择指定的项，而获取selectedIndex只会返回选中的第一项的索引。</p>
<p>选项还可以通过取得选项的引用并将其selected属性设置为true来选中。</p>
<p>与selectedIndex不同，设置选项的selected属性不会在多选时移除其他选项，从而可以动态选择任意多个选项。如果修改单选框中选项的selected属性，则其他选项会被移除。要注意的是，把selected属性设置为false对单选框没有影响。<br>通过selected属性可以确定选择框中哪个选项被选中。要取得所有选中项，需要循环选项集合逐一检测selected属性，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSelectedOptions</span>(<span class="params">selectbox</span>)&#123; </span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> option <span class="keyword">of</span> selectbox.<span class="property">options</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (option.<span class="property">selected</span>) &#123;  </span><br><span class="line">      result.<span class="title function_">push</span>(option);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-3-2-添加选项"><a href="#19-3-2-添加选项" class="headerlink" title="19.3.2 添加选项"></a>19.3.2 添加选项</h4><p>可以使用 JavaScript 动态创建选项并将它们添加到选择框。首先，可以使用 DOM 方法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newOption = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;option&quot;</span>); </span><br><span class="line">newOption.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Option text&quot;</span>));  </span><br><span class="line">newOption.<span class="title function_">setAttribute</span>(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Option value&quot;</span>); </span><br><span class="line"></span><br><span class="line">selectbox.<span class="title function_">appendChild</span>(newOption);</span><br></pre></td></tr></table></figure>

<p>另外，也可以使用Option构造函数创建新选项，这个构造函数是 DOM 出现之前就已经得到浏览器支持的。Option构造函数接收两个参数：text和value，其中value是可选的。虽然这个构造函数通常会创建Object的实例，但 DOM 合规的浏览器都会返回一个&lt;**option**&gt;元素。这意味着仍然可以使用appendChild()方法把这样创建的选项添加到选择框。</p>
<p>另一种添加新选项的方式是使用选择框的add()方法。DOM 规定这个方法接收两个参数：要添加的新选项和要添加到其前面的参考选项。如果想在列表末尾添加选项，那么第二个参数应该是null。</p>
<p>DOM 合规的浏览器要求必须传入第二个参数，因此在跨浏览器方法中不能只使用一个参数（IE9 是符合 DOM 规范的）。此时，传入undefined作为第二个参数可以保证在所有浏览器中都将选项添加到列表末尾。</p>
<h4 id="19-3-3-移除选项"><a href="#19-3-3-移除选项" class="headerlink" title="19.3.3 移除选项"></a>19.3.3 移除选项</h4><p>第一种方式是使用 DOM 的removeChild()方法并传入要移除的选项，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.<span class="title function_">removeChild</span>(selectbox.<span class="property">options</span>[<span class="number">0</span>]);   <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure>

<p>第二种方式是使用选择框的remove()方法。这个方法接收一个参数，即要移除选项的索引，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectbox.<span class="title function_">remove</span>(<span class="number">0</span>);   <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure>

<p>最后一种方式是直接将选项设置为等于null。</p>
<p>要清除选择框的所有选项，需要迭代所有选项并逐一移除它们，如下面例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clearSelectbox</span>(<span class="params">selectbox</span>) &#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> option <span class="keyword">of</span> selectbox.<span class="property">options</span>) &#123;  </span><br><span class="line">    selectbox.<span class="title function_">remove</span>(<span class="number">0</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-3-4-移动和重排选项"><a href="#19-3-4-移动和重排选项" class="headerlink" title="19.3.4 移动和重排选项"></a>19.3.4 移动和重排选项</h4><p>在 DOM 之前，从一个选择框向另一个选择框移动选项是非常麻烦的，要先从第一个选择框移除选项，然后以相同文本和值创建新选项，再将新选项添加到第二个选择框。DOM 方法则可以直接将某个选项从第一个选择框移动到第二个选择框，只要对相应选项使用appendChild()方法即可。如果给这个方法传入文档中已有的元素，则该元素会先从其父元素中移除，然后再插入指定位置。</p>
<p>移动选项和移除选项都会导致每个选项的index属性重置。<br>重排选项非常类似，DOM 方法同样是最佳途径。要将选项移动到选择框中的特定位置，insertBefore()方法是最合适的。不过，要把选项移动到最后，还是appendChild()方法比较方便。</p>
<h3 id="19-4-表单序列化"><a href="#19-4-表单序列化" class="headerlink" title="19.4 表单序列化"></a>19.4 表单序列化</h3><p>表单在 JavaScript 中可以使用表单字段的type属性连同其name属性和value属性来进行序列化。</p>
<p>浏览器如何确定在提交表单时要把什么发送到服务器。</p>
<ul>
<li><p>字段名和值是 URL 编码的并以和号（&amp;）分隔。 </p>
</li>
<li><p>禁用字段不会发送。 </p>
</li>
<li><p>复选框或单选按钮只在被选中时才发送。 </p>
</li>
<li><p>类型为”reset”或”button”的按钮不会发送。 </p>
</li>
<li><p>多选字段的每个选中项都有一个值。 </p>
</li>
<li><p>通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的&lt;**input**&gt;元素视同提交按钮。<br> &lt;**select**&gt;元素的值是被选中&lt;**option**&gt;元素的value属性。如果&lt;**option**&gt;元素没有value属性，则该值是它的文本。</p>
</li>
</ul>
<p>表单序列化通常不包含任何按钮，因为序列化得到的字符串很可能以其他方式提交。除此之外其他规则都应该遵循。最终完成表单序列化的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">serialize</span>(<span class="params">form</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> parts = [];  </span><br><span class="line">  <span class="keyword">let</span> optValue;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> field <span class="keyword">of</span> form.<span class="property">elements</span>) &#123; </span><br><span class="line">    <span class="keyword">switch</span>(field.<span class="property">type</span>) &#123; </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;select-one&quot;</span>: </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;select-multiple&quot;</span>:  </span><br><span class="line">        <span class="keyword">if</span> (field.<span class="property">name</span>.<span class="property">length</span>) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> option <span class="keyword">of</span> field.<span class="property">options</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (option.<span class="property">selected</span>) &#123; </span><br><span class="line">              <span class="keyword">if</span> (option.<span class="property">hasAttribute</span>)&#123;  </span><br><span class="line">                optValue = (option.<span class="title function_">hasAttribute</span>(<span class="string">&quot;value&quot;</span>) ?  </span><br><span class="line">                            option.<span class="property">value</span> : option.<span class="property">text</span>);  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                optValue = (option.<span class="property">attributes</span>[<span class="string">&quot;value&quot;</span>].<span class="property">specified</span> ?   </span><br><span class="line">                            option.<span class="property">value</span> : option.<span class="property">text</span>);  </span><br><span class="line">              &#125;  </span><br><span class="line">              parts.<span class="title function_">push</span>(<span class="built_in">encodeURIComponent</span>(field.<span class="property">name</span>)&#125; + <span class="string">&quot;=&quot;</span> +    </span><br><span class="line">                         <span class="built_in">encodeURIComponent</span>(optValue));  </span><br><span class="line">            &#125;  </span><br><span class="line">          &#125; </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">      <span class="keyword">case</span> <span class="attr">undefined</span>:     <span class="comment">// 字段集 </span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;file&quot;</span>:        <span class="comment">// 文件输入 </span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;submit&quot;</span>:      <span class="comment">// 提交按钮 </span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;reset&quot;</span>:       <span class="comment">// 重置按钮 </span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;button&quot;</span>:      <span class="comment">// 自定义按钮 </span></span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;radio&quot;</span>:       <span class="comment">// 单选按钮 </span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;checkbox&quot;</span>:    <span class="comment">// 复选框 </span></span><br><span class="line">        <span class="keyword">if</span> (!field.<span class="property">checked</span>) &#123;  </span><br><span class="line">          <span class="keyword">break</span>;  </span><br><span class="line">        &#125; </span><br><span class="line">      <span class="attr">default</span>:  </span><br><span class="line">        <span class="comment">// 不包含没有名字的表单字段 </span></span><br><span class="line">        <span class="keyword">if</span> (field.<span class="property">name</span>.<span class="property">length</span>) &#123; </span><br><span class="line">          parts.<span class="title function_">push</span>(<span class="string">&#x27;$&#123;encodeURIComponent(field.name)&#125;=&#x27;</span> +   </span><br><span class="line">                     <span class="string">&#x27;$&#123;encodeURIComponent(field.value)&#125;&#x27;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> parts.<span class="title function_">join</span>(<span class="string">&quot;&amp;&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-5-富文本编辑"><a href="#19-5-富文本编辑" class="headerlink" title="19.5 富文本编辑"></a>19.5 富文本编辑</h3><p>基本的技术就是在空白 HTML 文件中嵌入一个iframe。通过designMode属性，可以将这个空白文档变成可以编辑的，实际编辑的则是<body>元素的 HTML。designMode属性有两个可能的值：”off”（默认值）和”on”。设置为”on”时，整个文档都会变成可以编辑的（显示插入光标），从而可以像使用文字处理程序一样编辑文本，通过键盘将文本标记为粗体、斜体，等等。</p>
<h4 id="19-5-1-使用contenteditable"><a href="#19-5-1-使用contenteditable" class="headerlink" title="19.5.1 使用contenteditable"></a>19.5.1 使用contenteditable</h4><p>还有一种处理富文本的方式，也是 IE 最早实现的，即指定contenteditable属性。可以给页面中的任何元素指定contenteditable属性，然后该元素会立即被用户编辑。</p>
<p>通过设置contentEditable属性，也可以随时切换元素的可编辑状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;richedit&quot;</span>); </span><br><span class="line">richedit.<span class="property">contentEditable</span> = <span class="string">&quot;true&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>contentEditable属性有 3 个可能的值：”true”表示开启，”false”表示关闭，”inherit”表示继承父元素的设置（因为在contenteditable元素内部会创建和删除元素）。</p>
<blockquote>
<p>contenteditable是一个非常多才多艺的属性。比如，访问伪 URL data:text/ html, <html contenteditable>可以把浏览器窗口转换为一个记事本。这是因为这样会临时创建 DOM 树并将整个文档变成可编辑区域。</p>
</blockquote>
<h4 id="19-5-2-与富文本交互"><a href="#19-5-2-与富文本交互" class="headerlink" title="19.5.2 与富文本交互"></a>19.5.2 与富文本交互</h4><p>与富文本编辑器交互的主要方法是使用document.execCommand()。这个方法在文档上执行既定的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值（如果不需要则为null）。为跨浏览器兼容，第二个参数应该始终为false，因为 Firefox 会在其为true时抛出错误。</p>
<p>还有与命令相关的其他一些方法。第一个方法是queryCommandEnabled()，此方法用于确定对当前选中文本或光标所在位置是否可以执行相关命令。它只接收一个参数，即要检查的命令名。如果可编辑区可以执行该命令就返回true，否则返回false。</p>
<p>另一个方法queryCommandState()用于确定相关命令是否应用到了当前文本选区。</p>
<p>最后一个方法是queryCommandValue()，此方法可以返回执行命令时使用的值（即execCommand()中的第三个参数）。</p>
<h4 id="19-5-3-富文件选择"><a href="#19-5-3-富文件选择" class="headerlink" title="19.5.3 富文件选择"></a>19.5.3 富文件选择</h4><p>在内嵌窗格中使用getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document和window对象上，返回表示当前选中文本的Selection对象。每个Selection对象都拥有以下属性。</p>
<ul>
<li><p>anchorNode：选区开始的节点。 </p>
</li>
<li><p>anchorOffset：在anchorNode中，从开头到选区开始跳过的字符数。 </p>
</li>
<li><p>focusNode：选区结束的节点。 </p>
</li>
<li><p>focusOffset：focusNode中包含在选区内的字符数。 </p>
</li>
<li><p>isCollapsed：布尔值，表示选区起点和终点是否在同一个地方。 </p>
</li>
<li><p>rangeCount：选区中包含的 DOM 范围数量。</p>
</li>
</ul>
<p>Selection的属性并没有包含很多有用的信息。好在它的以下方法提供了更多信息，并允许操作选区。</p>
<ul>
<li><p>addRange(range)：把给定的 DOM 范围添加到选区。 </p>
</li>
<li><p>collapse(node, offset)：将选区折叠到给定节点中给定的文本偏移处。 </p>
</li>
<li><p>collapseToEnd()：将选区折叠到终点。 </p>
</li>
<li><p>collapseToStart()：将选区折叠到起点。 </p>
</li>
<li><p>containsNode(node)：确定给定节点是否包含在选区中。 </p>
</li>
<li><p>deleteFromDocument()：从文档中删除选区文本。与执行execCommand(“delete”, false, null)命令结果相同。 </p>
</li>
<li><p>extend(node, offset)：通过将focusNode和focusOffset移动到指定值来扩展选区。</p>
</li>
<li><p>getRangeAt(index)：返回选区中指定索引处的 DOM 范围。 </p>
</li>
<li><p>removeAllRanges()：从选区中移除所有 DOM 范围。这实际上会移除选区，因为选区中至少要包含一个范围。 </p>
</li>
<li><p>removeRange(range)：从选区中移除指定的 DOM 范围。 </p>
</li>
<li><p>selectAllChildren(node)：清除选区并选择给定节点的所有子节点。 </p>
</li>
<li><p>toString()：返回选区中的文本内容。</p>
</li>
</ul>
<h4 id="19-5-4-通过表单提交富文本"><a href="#19-5-4-通过表单提交富文本" class="headerlink" title="19.5.4 通过表单提交富文本"></a>19.5.4 通过表单提交富文本</h4><p>要把富文本编辑的结果提交给服务器，必须手工提取 HTML 并自己提交。通常的解决方案是在表单中添加一个隐藏字段，使用内嵌窗格或contenteditable元素的 HTML 更新它的值。在表单提交之前，从内嵌窗格或contenteditable元素中提取出 HTML 并插入隐藏字段中。</p>
<h3 id="19-6-小结"><a href="#19-6-小结" class="headerlink" title="19.6 小结"></a>19.6 小结</h3><p>尽管 HTML 和 Web 应用自诞生以来已经发生了天翻地覆的变化，但 Web 表单几乎从来没有变过。JavaScript 可以增加现有的表单字段以提供新功能或增强易用性。为此，表单字段也暴露了属性、方法和事件供 JavaScript 使用。以下是本章介绍的一些概念。</p>
<ul>
<li><p>可以使用标准或非标准的方法全部或部分选择文本框中的文本。 </p>
</li>
<li><p>所有浏览器都采用了 Firefox 操作文本选区的方式，使其成为真正的标准。 </p>
</li>
<li><p>可以通过监听键盘事件并检测要插入的字符来控制文本框接受或不接受某些字符。</p>
</li>
</ul>
<p>所有浏览器都支持剪贴板相关的事件，包括copy、cut和paste。剪贴板事件在不同浏览器中的实现有很大差异。<br>在文本框只限某些字符时，可以利用剪贴板事件屏幕粘贴事件。<br>选择框也是经常使用 JavaScript 来控制的一种表单控件。借助 DOM，操作选择框比以前方便了很多。使用标准的 DOM 技术，可以为选择框添加或移除选项，也可以将选项从一个选择框移动到另一个选择框，或者重排选项。<br>富文本编辑通常以使用包含空白 HTML 文档的内嵌窗格来处理。通过将文档的designMode属性设置为”on”，可以让整个页面变成编辑区，就像文字处理软件一样。另外，给元素添加contenteditable属性也可以将元素转换为可编辑区。默认情况下，可以切换文本的粗体、斜体样式，也可以使用剪贴板功能。JavaScript 通过execCommand()方法可以执行一些富文本编辑功能，通过queryCommandEnabled()、queryCommandState()和queryCommandValue()方法则可以获取有关文本选区的信息。由于富文本编辑区不涉及表单字段，因此要将富文本内容提交到服务器，必须把 HTML 从iframe或contenteditable元素中复制到一个表单字段。</p>
<h2 id="二十、JavaScript-API"><a href="#二十、JavaScript-API" class="headerlink" title="二十、JavaScript API"></a>二十、JavaScript API</h2><h3 id="20-1-Atomics-与SharedArrayBuffer"><a href="#20-1-Atomics-与SharedArrayBuffer" class="headerlink" title="20.1 Atomics 与SharedArrayBuffer"></a>20.1 Atomics 与SharedArrayBuffer</h3><p>多个上下文访问SharedArrayBuffer时，如果同时对缓冲区执行操作，就可能出现资源争用问题。Atomics API 通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个SharedArrayBuffer。Atomics API 是 ES2017 中定义的。</p>
<p>Atomics API 的设计初衷是在最少但很稳定的原子行为基础之上，构建复杂的多线程 JavaScript 程序。</p>
<h4 id="20-1-1-SharedArrayBuffer"><a href="#20-1-1-SharedArrayBuffer" class="headerlink" title="20.1.1 SharedArrayBuffer"></a>20.1.1 SharedArrayBuffer</h4><p>SharedArrayBuffer与ArrayBuffer具有同样的 API。二者的主要区别是ArrayBuffer必须在不同执行上下文间切换，SharedArrayBuffer则可以被任意多个执行上下文同时使用。</p>
<p>下面的例子演示了4个专用工作线程访问同一个SharedArrayBuffer导致的资源争用问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string">self.onmessage = (&#123;data&#125;) =&gt; &#123;  </span></span><br><span class="line"><span class="string">  const view = new Uint32Array(data); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 执行 1 000 000 次加操作 </span></span><br><span class="line"><span class="string">  for (let i = 0; i &lt; 1E6; ++i) &#123; </span></span><br><span class="line"><span class="string">    ?1// 线程不安全加操作会导致资源争用 </span></span><br><span class="line"><span class="string">    view[0] += 1; </span></span><br><span class="line"><span class="string">    ?2// 线程安全的加操作 </span></span><br><span class="line"><span class="string">    Atomics.add(view, 0, 1);</span></span><br><span class="line"><span class="string">  &#125;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  self.postMessage(null);  </span></span><br><span class="line"><span class="string">&#125;;  </span></span><br><span class="line"><span class="string">`</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workerScriptBlobUrl = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript])); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建容量为 4 的工作线程池 </span></span><br><span class="line"><span class="keyword">const</span> workers = [];  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;  </span><br><span class="line">  workers.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(workerScriptBlobUrl)); </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最后一个工作线程完成后打印出最终值 </span></span><br><span class="line"><span class="keyword">let</span> responseCount = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (++responseCount == workers.<span class="property">length</span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final buffer value: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 SharedArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>);  </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 SharedArrayBuffer 发送到每个工作线程 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="title function_">postMessage</span>(sharedArrayBuffer);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//（期待结果为 4000001。实际输出可能类似这样：） </span></span><br><span class="line"><span class="comment">// Final buffer value: 2145106 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?<span class="number">2</span><span class="comment">//（期待结果为 4000001） </span></span><br><span class="line">  <span class="comment">// Final buffer value: 4000001</span></span><br></pre></td></tr></table></figure>

<p>Atomics API 可以保证SharedArrayBuffer上的JavaScript 操作是线程安全的。</p>
<h4 id="20-1-2-原子操作基础"><a href="#20-1-2-原子操作基础" class="headerlink" title="20.1.2 原子操作基础"></a>20.1.2 原子操作基础</h4><p>任何全局上下文中都有Atomics对象，这个对象上暴露了用于执行线程安全操作的一套静态方法，其中多数方法以一个TypedArray实例（一个SharedArrayBuffer的引用）作为第一个参数，以相关操作数作为后续参数。</p>
<ol>
<li>算术及位操作方法</li>
</ol>
<p>在 ECMA 规范中，这些方法被定义为AtomicReadModifyWrite操作。在底层，这些方法都会从SharedArrayBuffer中某个位置读取值，然后执行算术或位操作，最后再把计算结果写回相同的位置。这些操作的原子本质意味着上述读取、修改、写回操作会按照顺序执行，不会被其他线程中断。</p>
<p>以下代码演示了所有算术方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建大小为 1 的缓冲区 </span></span><br><span class="line"><span class="keyword">let</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于缓冲创建 Uint8Array </span></span><br><span class="line"><span class="keyword">let</span> typedArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 ArrayBuffer 全部初始化为 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[0] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">const</span> increment = <span class="number">5</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子加 5 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">add</span>(typedArray, index, increment); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[5] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子减 5 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">sub</span>(typedArray, index, increment); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[0]</span></span><br></pre></td></tr></table></figure>

<p>以下代码演示了所有位方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建大小为 1 的缓冲区 </span></span><br><span class="line"><span class="keyword">let</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于缓冲创建 Uint8Array </span></span><br><span class="line"><span class="keyword">let</span> typedArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 ArrayBuffer 全部初始化为 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[0] </span></span><br><span class="line"><span class="keyword">const</span> index = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子或 0b1111 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">or</span>(typedArray, index, <span class="number">0b1111</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[15] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子与 0b1111 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">and</span>(typedArray, index, <span class="number">0b1100</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[12] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子异或 0b1111 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">xor</span>(typedArray, index, <span class="number">0b1111</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[3]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原子读和写</li>
</ol>
<p>浏览器的 JavaScript 编译器和 CPU 架构本身都有权限重排指令以提升程序执行效率。正常情况下，JavaScript 的单线程环境是可以随时进行这种优化的。但多线程下的指令重排可能导致资源争用，而且极难排错。</p>
<p>Atomics API 通过两种主要方式解决了这个问题。</p>
<ul>
<li><p>所有原子指令相互之间的顺序永远不会重排。 </p>
</li>
<li><p>使用原子读或原子写保证所有指令（包括原子和非原子指令）都不会相对原子读/写重新排序。这意味着位于原子读/写之前的所有指令会在原子读/写发生前完成，而位于原子读/写之后的所有指令会在原子读/写完成后才会开始。</p>
</li>
</ul>
<p>除了读写缓冲区的值，Atomics.load()和Atomics.store()还可以构建“代码围栏”。JavaScript引擎保证非原子指令可以相对于load()或store()本地重排，但这个重排不会侵犯原子读/写的边界。以下代码演示了这种行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行非原子写 </span></span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原子写可以保证在这个读操作之前完成，因此这里一定会读到 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>)); <span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行原子写 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">store</span>(view, <span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 非原子读可以保证在原子写完成后发生，因此这里一定会读到 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(view[<span class="number">0</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>原子交换</li>
</ol>
<p>为了保证连续、不间断的先读后写，Atomics API 提供了两种 方法 ：exchange()和compareExchange()。Atomics.exchange()执行简单的交换，以保证其他线程不会中断值的交换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在索引 0 处写入 3 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">store</span>(view, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 0 处读取值，然后在索引 0 处写入 4 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">exchange</span>(view, <span class="number">0</span>, <span class="number">4</span>));  <span class="comment">// 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 0 处读取值 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>));         <span class="comment">// 4 </span></span><br></pre></td></tr></table></figure>

<p>在多线程程序中，一个线程可能只希望在上次读取某个值之后没有其他线程修改该值的情况下才对共享缓冲区执行写操作。如果这个值没有被修改，这个线程就可以安全地写入更新后的值；如果这个值被修改了，那么执行写操作将会破坏其他线程计算的值。对于这种任务，Atomics API 提供了compareExchange()方法。这个方法只在目标索引处的值与预期值匹配时才会执行写操作。来看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在索引 0 处写入 5 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">store</span>(view, <span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 从缓冲区读取值 </span></span><br><span class="line"><span class="keyword">let</span> initial = <span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对这个值执行非原子操作 </span></span><br><span class="line"><span class="keyword">let</span> result = initial ** <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在缓冲区未被修改的情况下才会向缓冲区写入新值 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">compareExchange</span>(view, <span class="number">0</span>, initial, result); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查写入成功 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>)); <span class="comment">// 25 </span></span><br></pre></td></tr></table></figure>

<p>如果值不匹配，compareExchange()调用则什么也不做。</p>
<ol start="4">
<li>原子 Futex 操作与加锁</li>
</ol>
<p>如果没有某种锁机制，多线程程序就无法支持复杂需求。为此，Atomics API 提供了模仿 Linux Futex（快速用户空间互斥量，fast user-space mutex）的方法。这些方法本身虽然非常简单，但可以作为更复杂锁机制的基本组件。</p>
<blockquote>
<p>所有原子 Futex 操作只能用于Int32Array视图。而且，也只能用在工作线程内部。</p>
</blockquote>
<p>Atomics.wait()和Atomics.notify()通过示例很容易理解。下面这个简单的例子创建了 4 个工作线程，用于对长度为 1 的Int32Array进行操作。这些工作线程会依次取得锁并执行自己的加操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string">self.onmessage = (&#123;data&#125;) =&gt; &#123; </span></span><br><span class="line"><span class="string">  const view = new Int32Array(data); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  console.log(&#x27;Waiting to obtain lock&#x27;); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 遇到初始值则停止，10 000 毫秒超时 </span></span><br><span class="line"><span class="string">Atomics.wait(view, 0, 0, 1E5); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  console.log(&#x27;Obtained lock&#x27;); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 在索引 0 处加 1 </span></span><br><span class="line"><span class="string">  Atomics.add(view, 0, 1); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  console.log(&#x27;Releasing lock&#x27;); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 只允许 1 个工作线程继续执行 </span></span><br><span class="line"><span class="string">  Atomics.notify(view, 0, 1); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  self.postMessage(null); </span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workerScriptBlobUrl = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript])); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workers = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; </span><br><span class="line">  workers.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(workerScriptBlobUrl)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最后一个工作线程完成后打印出最终值 </span></span><br><span class="line"><span class="keyword">let</span> responseCount = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (++responseCount == workers.<span class="property">length</span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final buffer value: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 SharedArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">8</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 SharedArrayBuffer 发送到每个工作线程 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="title function_">postMessage</span>(sharedArrayBuffer); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000 毫秒后释放第一个锁 </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title class_">Atomics</span>.<span class="title function_">notify</span>(view, <span class="number">0</span>, <span class="number">1</span>), <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Final buffer value: 4 </span></span><br></pre></td></tr></table></figure>

<p>Atomics API 还提供了Atomics.isLockFree()方法。不过我们基本上应该不会用到。这个方法在高性能算法中可以用来确定是否有必要获取锁。规范中的介绍如下：<br>Atomics.isLockFree()是一个优化原语。基本上，如果一个原子原语（compareExchange、load、store、add、sub、and、or、xor或exchange）在 n 字节大小的数据上的原子步骤在不调用代理在组成数据的n字节之外获得锁的情况下可以执行，则Atomics.isLockFree(n)会返回true。高性能算法会使用Atomics.isLockFree确定是否在关键部分使用锁或原子操作。如果原子原语需要加锁，则算法提供自己的锁会更高效。<br>Atomics.isLockFree(4)始终返回true，因为在所有已知的相关硬件上都是支持的。能够如此假设通常可以简化程序。</p>
<h3 id="20-2-跨上下文消息"><a href="#20-2-跨上下文消息" class="headerlink" title="20.2 跨上下文消息"></a>20.2 跨上下文消息</h3><p>跨文档消息，有时候也简称为 XDM（cross-document messaging），是一种在不同执行上下文（如不同工作线程或不同源的页面）间传递信息的能力。</p>
<p>XDM 的核心是postMessage()方法。除了 XDM，这个方法名还在 HTML5 中很多地方用到过，但目的都一样，都是把数据传送到另一个位置。<br>postMessage()方法接收 3 个参数：消息、表示目标接收源的字符串和可选的可传输对象的数组（只与工作线程相关）。第二个参数对于安全非常重要，其可以限制浏览器交付数据的目标。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myframe&quot;</span>).<span class="property">contentWindow</span>; </span><br><span class="line">iframeWindow.<span class="title function_">postMessage</span>(<span class="string">&quot;A secret&quot;</span>, <span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>接收到 XDM 消息后，window对象上会触发message事件。这个事件是异步触发的，因此从消息发出到接收到消息（接收窗口触发message事件）可能有延迟。传给onmessage事件处理程序的event对象包含以下 3 方面重要信息。</p>
<ul>
<li><p>data：作为第一个参数传递给postMessage()的字符串数据。 </p>
</li>
<li><p>origin：发送消息的文档源，例如”<a target="_blank" rel="noopener" href="http://www.wrox.com&quot;./">http://www.wrox.com&quot;。</a> </p>
</li>
<li><p>source：发送消息的文档中window对象的代理。这个代理对象主要用于在发送上一条消息的窗口中执行postMessage()方法。如果发送窗口有相同的源，那么这个对象应该就是window对象。</p>
</li>
</ul>
<p>接收消息之后验证发送窗口的源是非常重要的。与postMessage()的第二个参数可以保证数据不会意外传给未知页面一样，在onmessage事件处理程序中检查发送窗口的源可以保证数据来自正确的地方。基本的使用方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 确保来自预期发送者 </span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">origin</span> == <span class="string">&quot;http://www.wrox.com&quot;</span>) &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行一些处理 </span></span><br><span class="line">    <span class="title function_">processMessage</span>(event.<span class="property">data</span>); </span><br><span class="line">    <span class="comment">// 可选：向来源窗口发送一条消息 </span></span><br><span class="line">    event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&quot;Received!&quot;</span>, <span class="string">&quot;http://p2p.wrox.com&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>大多数情况下，event.source是某个window对象的代理，而非实际的window对象。因此不能通过它访问所有窗口下的信息。最好只使用postMessage()，这个方法永远存在而且可以调用。<br>XDM 有一些怪异之处。首先，postMessage()的第一个参数的最初实现始终是一个字符串。后来，第一个参数改为允许任何结构的数据传入，不过并非所有浏览器都实现了这个改变。为此，最好就是只通过postMessage()发送字符串。 如果需要传递结构化数据 ， 那最好先对该数据调用 JSON.stringify()，通过postMessage()传过去之后，再在onmessage事件处理程序中调用JSON.parse()。</p>
<h3 id="20-3-Encoding-API"><a href="#20-3-Encoding-API" class="headerlink" title="20.3 Encoding API"></a>20.3 Encoding API</h3><p>Encoding API 主要用于实现字符串与定型数组之间的转换。规范新增了 4 个用于执行转换的全局类：TextEncoder、TextEncoderStream、TextDecoder和TextDecoderStream。</p>
<blockquote>
<p>相比于批量（bulk）的编解码，对流（stream）编解码的支持很有限。</p>
</blockquote>
<h4 id="20-3-1-文本编码"><a href="#20-3-1-文本编码" class="headerlink" title="20.3.1 文本编码"></a>20.3.1 文本编码</h4><p>Encoding API 提供了两种将字符串转换为定型数组二进制格式的方法：批量编码和流编码。把字符串转换为定型数组时，编码器始终使用 UTF-8。</p>
<ol>
<li>批量编码</li>
</ol>
<p>所谓批量，指的是 JavaScript 引擎会同步编码整个字符串。对于非常长的字符串，可能会花较长时间。批量编码是通过TextEncoder的实例完成的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br></pre></td></tr></table></figure>

<p>这个实例上有一个encode()方法，该方法接收一个字符串参数，并以Uint8Array格式返回每个字符的 UTF-8 编码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>(); </span><br><span class="line"><span class="keyword">const</span> decodedText = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> encodedText = textEncoder.<span class="title function_">encode</span>(decodedText); </span><br><span class="line"></span><br><span class="line"><span class="comment">// f 的 UTF-8 编码是 0x66（即十进制 102） </span></span><br><span class="line"><span class="comment">// o 的 UTF-8 编码是 0x6F（即二进制 111） </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedText); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br></pre></td></tr></table></figure>

<p>编码器是用于处理字符的，有些字符（如表情符号）在最终返回的数组中可能会占多个索引。</p>
<p>编码器实例还有一个encodeInto()方法，该方法接收一个字符串和目标Unit8Array，返回一个字典，该字典包含read和written属性，分别表示成功从源字符串读取了多少字符和向目标数组写入了多少字符。如果定型数组的空间不够，编码就会提前终止，返回的字典会体现这个结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>(); </span><br><span class="line"><span class="keyword">const</span> fooArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">3</span>); </span><br><span class="line"><span class="keyword">const</span> barArr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> fooResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">&#x27;foo&#x27;</span>, fooArr); </span><br><span class="line"><span class="keyword">const</span> barResult = textEncoder.<span class="title function_">encodeInto</span>(<span class="string">&#x27;bar&#x27;</span>, barArr); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooArr);    <span class="comment">// Uint8Array(3) [102, 111, 111] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooResult); <span class="comment">// &#123; read: 3, written: 3 &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barArr);    <span class="comment">// Uint8Array(2) [98, 97] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barResult); <span class="comment">// &#123; read: 2, written: 2 &#125; </span></span><br></pre></td></tr></table></figure>

<p>encode()要求分配一个新的Unit8Array，encodeInto()则不需要。</p>
<blockquote>
<p>文本编码会始终使用 UTF-8 格式，而且必须写入Unit8Array实例。使用其他类型数组会导致encodeInto()抛出错误。</p>
</blockquote>
<ol start="2">
<li>流编码</li>
</ol>
<p>TextEncoderStream其实就是TransformStream形式的TextEncoder。将解码后的文本流通过管道输入流编码器会得到编码后文本块的流：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">chars</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> decodedText = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> decodedText) &#123; </span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, char)); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodedTextStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">chars</span>()) &#123; </span><br><span class="line">      controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    controller.<span class="title function_">close</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encodedTextStream = decodedTextStream.<span class="title function_">pipeThrough</span>(<span class="keyword">new</span> <span class="title class_">TextEncoderStream</span>()); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readableStreamDefaultReader = encodedTextStream.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> &#123; done, value &#125; = <span class="keyword">await</span> readableStreamDefaultReader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123; </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Uint8Array[102] </span></span><br><span class="line"><span class="comment">// Uint8Array[111] </span></span><br><span class="line"><span class="comment">// Uint8Array[111]</span></span><br></pre></td></tr></table></figure>

<h4 id="20-3-2-文本解码"><a href="#20-3-2-文本解码" class="headerlink" title="20.3.2 文本解码"></a>20.3.2 文本解码</h4><p>Encoding API 提供了两种将定型数组转换为字符串的方式：批量解码和流解码。与编码器类不同，在将定型数组转换为字符串时，解码器支持非常多的字符串编码。</p>
<p>默认字符编码格式是 UTF-8。</p>
<ol>
<li>批量解码</li>
</ol>
<p>所谓批量，指的是 JavaScript 引擎会同步解码整个字符串。对于非常长的字符串，可能会花较长时间。批量解码是通过TextDecoder的实例完成的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textDecoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>();</span><br></pre></td></tr></table></figure>

<p>这个实例上有一个decode()方法，该方法接收一个定型数组参数，返回解码后的字符串。</p>
<p>解码器不关心传入的是哪种定型数组，它只会专心解码整个二进制表示。在下面这个例子中，只包含 8 位字符的 32 位值被解码为 UTF-8 格式，解码得到的字符串中填充了空格：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textDecoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// f 的 UTF-8 编码是 0x66（即十进制 102） </span></span><br><span class="line"><span class="comment">// o 的 UTF-8 编码是 0x6F（即二进制 111） </span></span><br><span class="line"><span class="keyword">const</span> encodedText = <span class="title class_">Uint32Array</span>.<span class="title function_">of</span>(<span class="number">102</span>, <span class="number">111</span>, <span class="number">111</span>); </span><br><span class="line"><span class="keyword">const</span> decodedText = textDecoder.<span class="title function_">decode</span>(encodedText); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(decodedText);  <span class="comment">// &quot;f   o   o   &quot;</span></span><br></pre></td></tr></table></figure>

<p>与TextEncoder不同，TextDecoder可以兼容很多字符编码。</p>
<ol start="2">
<li>流解码</li>
</ol>
<p>TextDecoderStream其实就是TransformStream形式的TextDecoder。将编码后的文本流通过管道输入流解码器会得到解码后文本块的流：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">chars</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 每个块必须是一个定型数组 </span></span><br><span class="line">  <span class="keyword">const</span> encodedText = [<span class="number">102</span>, <span class="number">111</span>, <span class="number">111</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(x)); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> encodedText) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, char)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encodedTextStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">chars</span>()) &#123; </span><br><span class="line">      controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    controller.<span class="title function_">close</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodedTextStream = encodedTextStream.<span class="title function_">pipeThrough</span>(<span class="keyword">new</span> <span class="title class_">TextDecoderStream</span>()); </span><br><span class="line"><span class="keyword">const</span> readableStreamDefaultReader = decodedTextStream.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> &#123; done, value &#125; = <span class="keyword">await</span> readableStreamDefaultReader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123; </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// f </span></span><br><span class="line"><span class="comment">// o </span></span><br><span class="line"><span class="comment">// o </span></span><br></pre></td></tr></table></figure>

<p>文本解码器流能够识别可能分散在不同块上的代理对。解码器流会保持块片段直到取得完整的字符。</p>
<h3 id="20-4-File-API-与-Blob-API"><a href="#20-4-File-API-与-Blob-API" class="headerlink" title="20.4 File API 与 Blob API"></a>20.4 File API 与 Blob API</h3><h4 id="20-4-1-File类型"><a href="#20-4-1-File类型" class="headerlink" title="20.4.1 File类型"></a>20.4.1 File类型</h4><p>File API 仍然以表单中的文件输入字段为基础，但是增加了直接访问文件信息的能力。HTML5 在DOM 上为文件输入元素添加了files集合。当用户在文件字段中选择一个或多个文件时，这个files集合中会包含一组File对象，表示被选中的文件。每个File对象都有一些只读属性。</p>
<ul>
<li><p>name：本地系统中的文件名。 </p>
</li>
<li><p>size：以字节计的文件大小。 </p>
</li>
<li><p>type：包含文件 MIME 类型的字符串。 </p>
</li>
<li><p>lastModifiedDate：表示文件最后修改时间的字符串。这个属性只有 Chome 实现了。</p>
</li>
</ul>
<h4 id="20-4-2-FileReader类型"><a href="#20-4-2-FileReader类型" class="headerlink" title="20.4.2 FileReader类型"></a>20.4.2 FileReader类型</h4><p>FileReader类型表示一种异步文件读取机制。可以把FileReader想象成类似于XMLHttpRequest，只不过是用于从文件系统读取文件，而不是从服务器读取数据。FileReader类型提供了几个读取文件数据的方法。</p>
<ul>
<li><p>readAsText(file, encoding)：从文件中读取纯文本内容并保存在result属性中。第二个参数表示编码，是可选的。</p>
</li>
<li><p>readAsDataURL(file)：读取文件并将内容的数据 URI 保存在result属性中。 </p>
</li>
<li><p>readAsBinaryString(file)：读取文件并将每个字符的二进制数据保存在result属性中。</p>
</li>
<li><p>readAsArrayBuffer(file)：读取文件并将文件内容以ArrayBuffer形式保存在result属性。</p>
</li>
</ul>
<p>因为这些读取方法是异步的，所以每个FileReader会发布几个事件，其中 3 个最有用的事件是progress、error和load，分别表示还有更多数据、发生了错误和读取完成。<br>progress事件每 50 毫秒就会触发一次，其与 XHR 的progress事件具有相同的信息：lengthComputable、loaded和total。此外，在progress事件中可以读取FileReader的result属性，即使其中尚未包含全部数据。<br>error事件会在由于某种原因无法读取文件时触发。触发error事件时，FileReader的error属性会包含错误信息。这个属性是一个对象，只包含一个属性：code。这个错误码的值可能是 1（未找到文件）、2（安全错误）、3（读取被中断）、4（文件不可读）或 5（编码错误）。<br>load事件会在文件成功加载后触发。如果error事件被触发，则不会再触发load事件。</p>
<h4 id="20-4-3-FileReaderSync类型"><a href="#20-4-3-FileReaderSync类型" class="headerlink" title="20.4.3 FileReaderSync类型"></a>20.4.3 FileReaderSync类型</h4><p>FileReaderSync类型就是FileReader的同步版本。这个类型拥有与FileReader相同的方法，只有在整个文件都加载到内存之后才会继续执行。FileReaderSync只在工作线程中可用，因为如果读取整个文件耗时太长则会影响全局。<br>假设通过postMessage()向工作线程发送了一个File对象。以下代码会让工作线程同步将文件读取到内存中，然后将文件的数据 URL 发回来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js </span></span><br><span class="line"></span><br><span class="line">self.<span class="property">omessage</span> = <span class="function">(<span class="params">messageEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> syncReader = <span class="keyword">new</span> <span class="title class_">FileReaderSync</span>(); </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(syncReader); <span class="comment">// FileReaderSync &#123;&#125; </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件时阻塞工作线程 </span></span><br><span class="line">  <span class="keyword">const</span> result = syncReader.<span class="title function_">readAsDataUrl</span>(messageEvent.<span class="property">data</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// PDF 文件的示例响应 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// data:application/pdf;base64,JVBERi0xLjQK... </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 URL 发回去 </span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(result); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="20-4-4-Blob与部分读取"><a href="#20-4-4-Blob与部分读取" class="headerlink" title="20.4.4 Blob与部分读取"></a>20.4.4 Blob与部分读取</h4><p>某些情况下，可能需要读取部分文件而不是整个文件。为此，File对象提供了一个名为slice()的方法。slice()方法接收两个参数：起始字节和要读取的字节数。这个方法返回一个Blob的实例，而Blob实际上是File的超类。<br>blob 表示二进制大对象（binary larget object），是 JavaScript 对不可修改二进制数据的封装类型。包含字符串的数组、ArrayBuffers、ArrayBufferViews，甚至其他Blob都可以用来创建 blob。Blob构造函数可以接收一个options参数，并在其中指定 MIME 类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;foo&#x27;</span>])); </span><br><span class="line"><span class="comment">// Blob &#123;size: 3, type: &quot;&quot;&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;&#123;&quot;a&quot;: &quot;b&quot;&#125;&#x27;</span>], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;)); </span><br><span class="line"><span class="comment">// &#123;size: 10, type: &quot;application/json&quot;&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;&lt;p&gt;Foo&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;&lt;p&gt;Bar&lt;/p&gt;&#x27;</span>], &#123; <span class="attr">type</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;)); </span><br><span class="line"><span class="comment">// &#123;size: 20, type: &quot;text/html&quot;&#125; </span></span><br></pre></td></tr></table></figure>

<p>Blob对象有一个size属性和一个type属性，还有一个slice()方法用于进一步切分数据。另外也可以使用FileReader从Blob中读取数据。</p>
<h4 id="20-4-5-对象-URL-与Blob"><a href="#20-4-5-对象-URL-与Blob" class="headerlink" title="20.4.5 对象 URL 与Blob"></a>20.4.5 对象 URL 与Blob</h4><p>对象 URL 有时候也称作 Blob URL，是指引用存储在File或Blob中数据的 URL。对象 URL 的优点是不用把文件内容读取到 JavaScript 也可以使用文件。只要在适当位置提供对象 URL 即可。要创建对象 URL，可以使用window.URL.createObjectURL()方法并传入File或Blob对象。这个函数返回的值是一个指向内存中地址的字符串。因为这个字符串是 URL，所以可以在 DOM 中直接使用。</p>
<p>以下代码使用对象 URL 在页面中显示了一张图片：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;files-list&quot;</span>); </span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>), </span><br><span class="line">    progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;progress&quot;</span>), </span><br><span class="line">    files = event.<span class="property">target</span>.<span class="property">files</span>, </span><br><span class="line">    reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(), </span><br><span class="line">    url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(files[<span class="number">0</span>]); </span><br><span class="line">  <span class="keyword">if</span> (url) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) &#123; </span><br><span class="line">      output.<span class="property">innerHTML</span> = <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;url&#125;</span>&quot;&gt;`</span>; </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      output.<span class="property">innerHTML</span> = <span class="string">&quot;Not an image.&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    output.<span class="property">innerHTML</span> = <span class="string">&quot;Your browser doesn&#x27;t support object URLs.&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果把对象 URL 直接放到img标签，就不需要把数据先读到 JavaScript 中了。img标签可以直接从相应的内存位置把数据读取到页面上。<br>使用完数据之后，最好能释放与之关联的内存。只要对象 URL 在使用中，就不能释放内存。如果想表明不再使用某个对象 URL，则可以把它传给window.URL.revokeObjectURL()。页面卸载时，所有对象 URL 占用的内存都会被释放。不过，最好在不使用时就立即释放内存，以便尽可能保持页面占用最少资源。</p>
<h4 id="20-4-6-读取拖放文件"><a href="#20-4-6-读取拖放文件" class="headerlink" title="20.4.6 读取拖放文件"></a>20.4.6 读取拖放文件</h4><p>组合使用 HTML5 拖放 API 与 File API 可以创建读取文件信息的有趣功能。在页面上创建放置目标后，可以从桌面上把文件拖动并放到放置目标。这样会像拖放图片或链接一样触发drop事件。被放置的文件可以通过事件的event.dataTransfer.files属性读到，这个属性保存着一组File对象，就像文本输入字段一样。<br>下面的例子会把拖放到页面放置目标上的文件信息打印出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> droptarget = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;droptarget&quot;</span>); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> info = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>), </span><br><span class="line">    files, i, len; </span><br><span class="line">  event.<span class="title function_">preventDefault</span>(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">type</span> == <span class="string">&quot;drop&quot;</span>) &#123; </span><br><span class="line">    files = event.<span class="property">dataTransfer</span>.<span class="property">files</span>; </span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    len = files.<span class="property">length</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123; </span><br><span class="line">      info += <span class="string">`<span class="subst">$&#123;files[i].name&#125;</span> (<span class="subst">$&#123;files[i].type&#125;</span>, <span class="subst">$&#123;files[i].size&#125;</span> bytes)&lt;br&gt;`</span>; </span><br><span class="line">      i++; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    output.<span class="property">innerHTML</span> = info; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragenter&quot;</span>, handleEvent); </span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragover&quot;</span>, handleEvent); </span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">&quot;drop&quot;</span>, handleEvent);</span><br></pre></td></tr></table></figure>

<p>与后面要介绍的拖放的例子一样，必须取消dragenter、dragover和drop的默认行为。在drop事件处理程序中，可以通过event.dataTransfer.files读到文件，此时可以获取文件的信息。</p>
<h3 id="20-5-媒体元素"><a href="#20-5-媒体元素" class="headerlink" title="20.5 媒体元素"></a>20.5 媒体元素</h3><p>HTML5 新增了两个与媒体相关的元素，即&lt;**audio**&gt;和&lt;**video**&gt;，从而为浏览器提供了嵌入音频和视频的统一解决方案。<br>这两个元素既支持 Web 开发者在页面中嵌入媒体文件，也支持 JavaScript 实现对媒体的自定义控制。<br>以下是它们的用法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌入视频 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;conference.mpg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myVideo&quot;</span>&gt;</span>Video player not available.<span class="tag">&lt;/<span class="name">video</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 嵌入音频 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;song.mp3&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myAudio&quot;</span>&gt;</span>Audio player not available.<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个元素至少要求有一个src属性，以表示要加载的媒体文件。我们也可以指定表示视频播放器大小的width和height属性，以及在视频加载期间显示图片 URI 的poster属性。另外，controls属性如果存在，则表示浏览器应该显示播放界面，让用户可以直接控制媒体。开始和结束标签之间的内容是在媒体播放器不可用时显示的替代内容。<br>由于浏览器支持的媒体格式不同，因此可以指定多个不同的媒体源。为此，需要从元素中删除src属性，使用一个或多个&lt;**source**&gt;元素代替。</p>
<h4 id="20-5-1-属性"><a href="#20-5-1-属性" class="headerlink" title="20.5.1 属性"></a>20.5.1 属性</h4><p>&lt;**video**&gt;和&lt;**audio**&gt;元素提供了稳健的 JavaScript 接口。这两个元素有很多共有属性，可以用于确定媒体的当前状态。</p>
<h4 id="20-5-2-事件"><a href="#20-5-2-事件" class="headerlink" title="20.5.2 事件"></a>20.5.2 事件</h4><p>除了有很多属性，媒体元素还有很多事件。这些事件会监控由于媒体回放或用户交互导致的不同属性的变化。</p>
<h4 id="20-5-3-自定义媒体播放器"><a href="#20-5-3-自定义媒体播放器" class="headerlink" title="20.5.3 自定义媒体播放器"></a>20.5.3 自定义媒体播放器</h4><p>使用&lt;**audio**&gt;和&lt;**video**&gt;的play()和pause()方法，可以手动控制媒体文件的播放。综合使用属性、事件和这些方法，可以方便地创建自定义的媒体播放器，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mediaplayer&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;player&quot;</span> <span class="attr">src</span>=<span class="string">&quot;movie.mov&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;mymovie.jpg&quot;</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span> </span><br><span class="line">      Video player not available. </span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;controls&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Play&quot;</span> <span class="attr">id</span>=<span class="string">&quot;video-btn&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;curtime&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>/<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;duration&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>通过使用 JavaScript 创建一个简单的视频播放器，上面这个基本的 HTML 就可以被激活了，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得元素的引用 </span></span><br><span class="line"><span class="keyword">let</span> player = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;player&quot;</span>), </span><br><span class="line">  btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;video-btn&quot;</span>), </span><br><span class="line">  curtime = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;curtime&quot;</span>), </span><br><span class="line">  duration = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;duration&quot;</span>); </span><br><span class="line"><span class="comment">// 更新时长 </span></span><br><span class="line">duration.<span class="property">innerHTML</span> = player.<span class="property">duration</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 为按钮添加事件处理程序 </span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>( <span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (player.<span class="property">paused</span>) &#123; </span><br><span class="line">    player.<span class="title function_">play</span>(); </span><br><span class="line">    btn.<span class="property">value</span> = <span class="string">&quot;Pause&quot;</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    player.<span class="title function_">pause</span>(); </span><br><span class="line">    btn.<span class="property">value</span> = <span class="string">&quot;Play&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性更新当前时间 </span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  curtime.<span class="property">innerHTML</span> = player.<span class="property">currentTime</span>; </span><br><span class="line">&#125;, <span class="number">250</span>);</span><br></pre></td></tr></table></figure>

<h4 id="20-5-4-检测编解码器"><a href="#20-5-4-检测编解码器" class="headerlink" title="20.5.4 检测编解码器"></a>20.5.4 检测编解码器</h4><p>JavaScript API 可以用来检测浏览器是否支持给定格式和编解码器。这两个媒体元素都有一个名为canPlayType()的方法，该方法接收一个格式/编解码器字符串，返回一个字符串值：”probably”、”maybe”或””（空字符串），其中空字符串就是假值，意味着可以在if语句中像这样使用canPlayType()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (audio.<span class="title function_">canPlayType</span>(<span class="string">&quot;audio/mpeg&quot;</span>)) &#123; </span><br><span class="line">  <span class="comment">// 执行某些操作 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>“probably”和”maybe”都是真值，在if语句的上下文中可以转型为true。<br>在只给canPlayType()提供一个 MIME 类型的情况下，最可能返回的值是”maybe”和空字符串。这是因为文件实际上只是一个包装音频和视频数据的容器，而真正决定文件是否可以播放的是编码。在同时提供 MIME 类型和编解码器的情况下，返回值的可能性会提高到”probably”。</p>
<blockquote>
<p>编解码器必须放到引号中。同样，也可以在视频元素上使用canPlayType()检测视频格式。</p>
</blockquote>
<h4 id="20-5-5-音频类型"><a href="#20-5-5-音频类型" class="headerlink" title="20.5.5 音频类型"></a>20.5.5 音频类型</h4><p>audio&gt;元素还有一个名为Audio的原生 JavaScript 构造函数，支持在任何时候播放音频。Audio类型与Image类似，都是 DOM 元素的对等体，只是不需插入文档即可工作。要通过 Audio 播放音频，只需创建一个新实例并传入音频源文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> audio = <span class="keyword">new</span> <span class="title class_">Audio</span>(<span class="string">&quot;sound.mp3&quot;</span>); </span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">addHandler</span>(audio, <span class="string">&quot;canplaythrough&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  audio.<span class="title function_">play</span>(); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>在 iOS 中调用play()方法会弹出一个对话框，请求用户授权播放声音。为了连续播放，必须在onfinish事件处理程序中立即调用play()。</p>
<h3 id="20-6-原生拖放"><a href="#20-6-原生拖放" class="headerlink" title="20.6 原生拖放"></a>20.6 原生拖放</h3><h4 id="20-6-1-拖放事件"><a href="#20-6-1-拖放事件" class="headerlink" title="20.6.1 拖放事件"></a>20.6.1 拖放事件</h4><p>在某个元素被拖动时，会（按顺序）触发以下事件：<br>(1) dragstart<br>(2) drag<br>(3) dragend</p>
<p>在按住鼠标键不放并开始移动鼠标的那一刻，被拖动元素上会触发dragstart事件。此时光标会变成非放置符号（圆环中间一条斜杠），表示元素不能放到自身上。拖动开始时，可以在ondragstart事件处理程序中通过 JavaScript 执行某些操作。<br>dragstart事件触发后，只要目标还被拖动就会持续触发drag事件。这个事件类似于mousemove，即随着鼠标移动而不断触发。当拖动停止时（把元素放到有效或无效的放置目标上），会触发dragend事件。</p>
<p>所有这 3 个事件的目标都是被拖动的元素。默认情况下，浏览器在拖动开始后不会改变被拖动元素的外观，因此是否改变外观由你来决定。不过，大多数浏览器此时会创建元素的一个半透明副本，始终跟随在光标下方。<br>在把元素拖动到一个有效的放置目标上时，会依次触发以下事件：<br>(1) dragenter<br>(2) dragover<br>(3) dragleave或drop<br>只要一把元素拖动到放置目标上，dragenter事件（类似于mouseover事件）就会触发。dragenter事件触发之后，会立即触发dragover事件，并且元素在放置目标范围内被拖动期间此事件会持续触发。当元素被拖动到放置目标之外，dragover事件停止触发，dragleave事件触发（类似于mouseout事件）。如果被拖动元素被放到了目标上，则会触发drop事件而不是dragleave事件。这些事件的目标是放置目标元素。</p>
<h4 id="20-6-2-自定义放置目标"><a href="#20-6-2-自定义放置目标" class="headerlink" title="20.6.2 自定义放置目标"></a>20.6.2 自定义放置目标</h4><p>在把某个元素拖动到无效放置目标上时，会看到一个特殊光标（圆环中间一条斜杠）表示不能放下。即使所有元素都支持放置目标事件，这些元素默认也是不允许放置的。如果把元素拖动到不允许放置的目标上，无论用户动作是什么都不会触发drop事件。不过，通过覆盖dragenter和dragover事件的默认行为，可以把任何元素转换为有效的放置目标。例如，如果有一个 ID 为”droptarget”的&lt;**div**&gt;元素，那么可以使用以下代码把它转换成一个放置目标：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> droptarget = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;droptarget&quot;</span>); </span><br><span class="line"></span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragover&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragenter&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>在 Firefox 中，放置事件的默认行为是导航到放在放置目标上的 URL。这意味着把图片拖动到放置目标上会导致页面导航到图片文件，把文本拖动到放置目标上会导致无效 URL 错误。为阻止这个行为，在 Firefox 中必须取消drop事件的默认行为。</p>
<h4 id="20-6-3-dataTransfer对象"><a href="#20-6-3-dataTransfer对象" class="headerlink" title="20.6.3 dataTransfer对象"></a>20.6.3 dataTransfer对象</h4><p>为实现拖动操作中的数据传输，IE5 在event对象上暴露了dataTransfer对象，用于从被拖动元素向放置目标传递字符串数据。因为这个对象是event的属性，所以在拖放事件的事件处理程序外部无法访问dataTransfer。在事件处理程序内部，可以使用这个对象的属性和方法实现拖放功能。</p>
<p>dataTransfer对象有两个主要方法：getData()和setData()。顾名思义，getData()用于获取setData()存储的值。setData()的第一个参数以及getData()的唯一参数是一个字符串，表示要设置的数据类型：”text”或”URL”，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递文本 </span></span><br><span class="line">event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;some text&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> text = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&quot;text&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递 URL </span></span><br><span class="line">event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&quot;URL&quot;</span>, <span class="string">&quot;http://www.wrox.com/&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> url = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&quot;URL&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>HTML5 已经将其扩展为允许任何 MIME 类型。为向后兼容，HTML5 还会继续支持”text”和”URL”，但它们会分别被映射到”text/plain”和”text/uri-list”。<br>dataTransfer对象实际上可以包含每种 MIME 类型的一个值，也就是说可以同时保存文本和URL，两者不会相互覆盖。存储在dataTransfer对象中的数据只能在放置事件中读取。如果没有在ondrop事件处理程序中取得这些数据，dataTransfer对象就会被销毁，数据也会丢失。<br>在从文本框拖动文本时，浏览器会调用setData()并将拖动的文本以”text”格式存储起来。类似地，在拖动链接或图片时，浏览器会调用setData()并把 URL 存储起来。当数据被放置在目标上时，可以使用getData()获取这些数据。当然，可以在dragstart事件中手动调用setData()存储自定义数据，以便将来使用。<br>作为文本的数据和作为 URL 的数据有一个区别。当把数据作为文本存储时，数据不会被特殊对待。而当把数据作为 URL 存储时，数据会被作为网页中的一个链接，意味着如果把它放到另一个浏览器窗口，浏览器会导航到该 URL。</p>
<p>在通过dataTransfer获取数据时，为保持最大兼容性，需要对 URL 检测两个值并对文本使用”Text”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataTransfer = event.<span class="property">dataTransfer</span>; </span><br><span class="line"><span class="comment">// 读取 URL </span></span><br><span class="line"><span class="keyword">let</span> url = dataTransfer.<span class="title function_">getData</span>(<span class="string">&quot;url&quot;</span>) || dataTransfer.<span class="title function_">getData</span>(<span class="string">&quot;text/uri-list&quot;</span>); </span><br><span class="line"><span class="comment">// 读取文本 </span></span><br><span class="line"><span class="keyword">let</span> text = dataTransfer.<span class="title function_">getData</span>(<span class="string">&quot;Text&quot;</span>); </span><br></pre></td></tr></table></figure>

<h4 id="20-6-4-dropEffect与effectAllowed"><a href="#20-6-4-dropEffect与effectAllowed" class="headerlink" title="20.6.4 dropEffect与effectAllowed"></a>20.6.4 dropEffect与effectAllowed</h4><p>dataTransfer对象不仅可以用于实现简单的数据传输，还可以用于确定能够对被拖动元素和放置目标执行什么操作。为此，可以使用两个属性：dropEffect与effectAllowed。<br>dropEffect属性可以告诉浏览器允许哪种放置行为。这个属性有以下 4 种可能的值。</p>
<ul>
<li><p>“none”：被拖动元素不能放到这里。这是除文本框之外所有元素的默认值。 </p>
</li>
<li><p>“move”：被拖动元素应该移动到放置目标。 </p>
</li>
<li><p>“copy”：被拖动元素应该复制到放置目标。</p>
</li>
<li><p>“link”：表示放置目标会导航到被拖动元素（仅在它是 URL 的情况下）。</p>
</li>
</ul>
<p>在把元素拖动到放置目标上时，上述每种值都会导致显示一种不同的光标。不过，是否导致光标示意的动作还要取决于开发者。换句话说，如果没有代码参与，则没有什么会自动移动、复制或链接。唯一不用考虑的就是光标自己会变。为了使用dropEffect属性，必须在放置目标的ondragenter事件处理程序中设置它。<br>除非同时设置effectAllowed，否则dropEffect属性也没有用。effectAllowed属性表示对被拖动元素是否允许dropEffect。这个属性有如下几个可能的值。</p>
<ul>
<li><p>“uninitialized”：没有给被拖动元素设置动作。 </p>
</li>
<li><p>“none”：被拖动元素上没有允许的操作。 </p>
</li>
<li><p>“copy”：只允许”copy”这种dropEffect。 </p>
</li>
<li><p>“link”：只允许”link”这种dropEffect。 </p>
</li>
<li><p>“move”：只允许”move”这种dropEffect。 </p>
</li>
<li><p>“copyLink”：允许”copy”和”link”两种dropEffect。 </p>
</li>
<li><p>“copyMove”：允许”copy”和”move”两种dropEffect。 </p>
</li>
<li><p>“linkMove”：允许”link”和”move”两种dropEffect。 </p>
</li>
<li><p>“all”：允许所有dropEffect。</p>
</li>
</ul>
<p>必须在ondragstart事件处理程序中设置这个属性。<br>假设我们想允许用户把文本从一个文本框拖动到一个&lt;**div**&gt;元素。那么必须同时把dropEffect和effectAllowed属性设置为”move”。因为&lt;**div**&gt;元素上放置事件的默认行为是什么也不做，所以文本不会自动地移动自己。如果覆盖这个默认行为，文本就会自动从文本框中被移除。然后是否把文本插入&lt;**div**&gt;元素就取决于你了。如果是把dropEffect和effectAllowed属性设置为”copy”，那么文本框中的文本不会自动被移除。</p>
<h4 id="20-6-5-可拖动能力"><a href="#20-6-5-可拖动能力" class="headerlink" title="20.6.5 可拖动能力"></a>20.6.5 可拖动能力</h4><p>默认情况下，图片、链接和文本是可拖动的，这意味着无须额外代码用户便可以拖动它们。文本只有在被选中后才可以拖动，而图片和链接在任意时候都是可以拖动的。</p>
<p>HTML5 在所有 HTML 元素上规定了一个draggable属性，表示元素是否可以拖动。图片和链接的draggable属性自动被设置为true，而其他所有元素此属性的默认值为false。如果想让其他元素可拖动，或者不允许图片和链接被拖动，都可以设置这个属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 禁止拖动图片 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;smile.gif&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Smiley face&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 让元素可以拖动 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="20-6-6-其他成员"><a href="#20-6-6-其他成员" class="headerlink" title="20.6.6 其他成员"></a>20.6.6 其他成员</h4><p>HTML5 规范还为dataTransfer对象定义了下列方法。</p>
<ul>
<li><p>addElement(element)：为拖动操作添加元素。这纯粹是为了传输数据，不会影响拖动操作的外观。在本书写作时，还没有浏览器实现这个方法。</p>
</li>
<li><p>clearData(format)：清除以特定格式存储的数据。 </p>
</li>
<li><p>setDragImage(element, x, y)：允许指定拖动发生时显示在光标下面的图片。这个方法接收 3 个参数：要显示的 HTML 元素及标识光标位置的图片上的 x 和 y 坐标。这里的 HTML 元素可以是一张图片，此时显示图片；也可以是其他任何元素，此时显示渲染后的元素。 </p>
</li>
<li><p>types：当前存储的数据类型列表。这个集合类似数组，以字符串形式保存数据类型，比如”text”。</p>
</li>
</ul>
<h3 id="20-7-Notifications-API"><a href="#20-7-Notifications-API" class="headerlink" title="20.7 Notifications API"></a>20.7 Notifications API</h3><p>Notifications API 用于向用户显示通知。</p>
<h4 id="20-7-1-通知权限"><a href="#20-7-1-通知权限" class="headerlink" title="20.7.1 通知权限"></a>20.7.1 通知权限</h4><p>Notifications API 有被滥用的可能，因此默认会开启两项安全措施： </p>
<ul>
<li><p>通知只能在运行在安全上下文的代码中被触发； </p>
</li>
<li><p>通知必须按照每个源的原则明确得到用户允许。</p>
</li>
</ul>
<p>用户授权显示通知是通过浏览器内部的一个对话框完成的。除非用户没有明确给出允许或拒绝的答复，否则这个权限请求对每个域只会出现一次。浏览器会记住用户的选择，如果被拒绝则无法重来。<br>页面可以使用全局对象Notification向用户请求通知权限。这个对象有一个requestPemission()方法，该方法返回一个期约，用户在授权对话框上执行操作后这个期约会解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>() </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">permission</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User responded to permission request:&#x27;</span>, permission); </span><br><span class="line">    &#125;); </span><br></pre></td></tr></table></figure>

<p>“granted”值意味着用户明确授权了显示通知的权限。除此之外的其他值意味着显示通知会静默失败。如果用户拒绝授权，这个值就是”denied”。一旦拒绝，就无法通过编程方式挽回，因为不可能再触发授权提示。</p>
<h4 id="20-7-2-显示和隐藏通知"><a href="#20-7-2-显示和隐藏通知" class="headerlink" title="20.7.2 显示和隐藏通知"></a>20.7.2 显示和隐藏通知</h4><p>Notification构造函数用于创建和显示通知。最简单的通知形式是只显示一个标题，这个标题内容可以作为第一个参数传给Notification构造函数。以下面这种方式调用Notification，应该会立即显示通知：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&#x27;Title text!&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>可以通过options参数对通知进行自定义，包括设置通知的主体、图片和振动等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&#x27;Title text!&#x27;</span>, &#123; </span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;Body text!&#x27;</span>, </span><br><span class="line">  <span class="attr">image</span>: <span class="string">&#x27;path/to/image.png&#x27;</span>, </span><br><span class="line">  <span class="attr">vibrate</span>: <span class="literal">true</span> </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>调用这个构造函数返回的Notification对象的close()方法可以关闭显示的通知。</p>
<h4 id="20-7-3-通知生命周期回调"><a href="#20-7-3-通知生命周期回调" class="headerlink" title="20.7.3 通知生命周期回调"></a>20.7.3 通知生命周期回调</h4><p>通知并非只用于显示文本字符串，也可用于实现交互。Notifications API 提供了 4 个用于添加回调的生命周期方法：</p>
<ul>
<li><p>onshow在通知显示时触发； </p>
</li>
<li><p>onclick在通知被点击时触发； </p>
</li>
<li><p>onclose在通知消失或通过close()关闭时触发； </p>
</li>
<li><p>onerror在发生错误阻止通知显示时触发。</p>
</li>
</ul>
<h3 id="20-8-Page-Visibility-API"><a href="#20-8-Page-Visibility-API" class="headerlink" title="20.8 Page Visibility API"></a>20.8 Page Visibility API</h3><p>Web 开发中一个常见的问题是开发者不知道用户什么时候真正在使用页面。如果页面被最小化或隐藏在其他标签页后面，那么轮询服务器或更新动画等功能可能就没有必要了。Page Visibility API 旨在为开发者提供页面对用户是否可见的信息。<br>这个 API 本身非常简单，由 3 部分构成。</p>
<ul>
<li><p>document.visibilityState值，表示下面 4 种状态之一。 </p>
<ul>
<li><p>页面在后台标签页或浏览器中最小化了。 </p>
</li>
<li><p>页面在前台标签页中。 </p>
</li>
<li><p>实际页面隐藏了，但对页面的预览是可见的（例如在 Windows 7 上，用户鼠标移到任务栏图标上会显示网页预览）。 </p>
</li>
<li><p>页面在屏外预渲染。</p>
</li>
</ul>
</li>
<li><p>visibilitychange事件，该事件会在文档从隐藏变可见（或反之）时触发。 </p>
</li>
<li><p>document.hidden布尔值，表示页面是否隐藏。这可能意味着页面在后台标签页或浏览器中被最小化了。这个值是为了向后兼容才继续被浏览器支持的，应该优先使用document.visibilityState检测页面可见性。</p>
</li>
</ul>
<p>要想在页面从可见变为隐藏或从隐藏变为可见时得到通知，需要监听visibilitychange事件。 </p>
<p>document.visibilityState的值是以下三个字符串之一：</p>
<ul>
<li><p>“hidden” </p>
</li>
<li><p>“visible” </p>
</li>
<li><p>“prerender”</p>
</li>
</ul>
<h3 id="20-9-Streams-API"><a href="#20-9-Streams-API" class="headerlink" title="20.9 Streams API"></a>20.9 Streams API</h3><p>Streams API 是为了解决一个简单但又基础的问题而生的：Web 应用如何消费有序的小信息块而不是大块信息？这种能力主要有两种应用场景。</p>
<ul>
<li><p>大块数据可能不会一次性都可用。网络请求的响应就是一个典型的例子。网络负载是以连续信息包形式交付的，而流式处理可以让应用在数据一到达就能使用，而不必等到所有数据都加载完毕。 </p>
</li>
<li><p>大块数据可能需要分小部分处理。视频处理、数据压缩、图像编码和 JSON 解析都是可以分成小部分进行处理，而不必等到所有数据都在内存中时再处理的例子。</p>
</li>
</ul>
<h4 id="20-9-1-理解流"><a href="#20-9-1-理解流" class="headerlink" title="20.9.1 理解流"></a>20.9.1 理解流</h4><p>Stream API 直接解决的问题是处理网络请求和读写磁盘。</p>
<p>Stream API 定义了三种流。</p>
<ul>
<li><p>可读流：可以通过某个公共接口读取数据块的流。数据在内部从底层源进入流，然后由消费者（consumer）进行处理。 </p>
</li>
<li><p>可写流：可以通过某个公共接口写入数据块的流。生产者（producer）将数据写入流，数据在内部传入底层数据槽（sink）。 </p>
</li>
<li><p>转换流：由两种流组成，可写流用于接收数据（可写端），可读流用于输出数据（可读端）。这两个流之间是转换程序（transformer），可以根据需要检查和修改流内容。</p>
</li>
</ul>
<p>流的基本单位是块（chunk）。块可是任意数据类型，但通常是定型数组。每个块都是离散的流片段，可以作为一个整体来处理。更重要的是，块不是固定大小的，也不一定按固定间隔到达。在理想的流当中，块的大小通常近似相同，到达间隔也近似相等。不过好的流实现需要考虑边界情况。</p>
<p>有时候，由于数据进出速率不同，可能会出现不匹配的情况。为此流平衡可能出现如下三种情形。</p>
<ul>
<li><p>流出口处理数据的速度比入口提供数据的速度快。流出口经常空闲（可能意味着流入口效率较低），但只会浪费一点内存或计算资源，因此这种流的不平衡是可以接受的。 </p>
</li>
<li><p>流入和流出均衡。这是理想状态。 </p>
</li>
<li><p>流入口提供数据的速度比出口处理数据的速度快。这种流不平衡是固有的问题。此时一定会在某个地方出现数据积压，流必须相应做出处理。</p>
</li>
</ul>
<p>流不平衡是常见问题，但流也提供了解决这个问题的工具。所有流都会为已进入流但尚未离开流的块提供一个内部队列。对于均衡流，这个内部队列中会有零个或少量排队的块，因为流出口块出列的速度与流入口块入列的速度近似相等。这种流的内部队列所占用的内存相对比较小。<br>如果块入列速度快于出列速度，则内部队列会不断增大。流不能允许其内部队列无限增大，因此它会使用反压（backpressure）通知流入口停止发送数据，直到队列大小降到某个既定的阈值之下。这个阈值由排列策略决定，这个策略定义了内部队列可以占用的最大内存，即高水位线（high water mark）。</p>
<h4 id="20-9-2-可读流"><a href="#20-9-2-可读流" class="headerlink" title="20.9.2 可读流"></a>20.9.2 可读流</h4><p>可读流是对底层数据源的封装。底层数据源可以将数据填充到流中，允许消费者通过流的公共接口读取数据。</p>
<ol>
<li>ReadableStreamDefaultController</li>
</ol>
<p>来看下面的生成器，它每 1000 毫秒就会生成一个递增的整数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="comment">// 每 1000 毫秒生成一个递增的整数 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这个生成器的值可以通过可读流的控制器传入可读流。访问这个控制器最简单的方式就是创建ReadableStream的一个实例，并在这个构造函数的underlyingSource参数（第一个参数）中定义start()方法，然后在这个方法中使用作为参数传入的controller。默认情况下，这个控制器参数是ReadableStreamDefaultController的一个实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readableStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">  <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(controller); <span class="comment">// ReadableStreamDefaultController &#123;&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>调用控制器的enqueue()方法可以把值传入控制器。所有值都传完之后，调用close()关闭流：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 每 1000 毫秒生成一个递增的整数 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readableStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line">      controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    controller.<span class="title function_">close</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ReadableStreamDefaultReader</li>
</ol>
<p>前面的例子把 5 个值加入了流的队列，但没有把它们从队列中读出来。为此，需要一个ReadableStreamDefaultReader的实例，该实例可以通过流的getReader()方法获取。调用这个方法会获得流的锁，保证只有这个读取器可以从流中读取值,消费者使用这个读取器实例的read()方法可以读出值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 每 1000 毫秒生成一个递增的整数 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readableStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line">      controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    controller.<span class="title function_">close</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readableStream.<span class="property">locked</span>); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">const</span> readableStreamDefaultReader = readableStream.<span class="title function_">getReader</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readableStream.<span class="property">locked</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者 </span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> &#123; done, value &#125; = <span class="keyword">await</span> readableStreamDefaultReader.<span class="title function_">read</span>(); </span><br><span class="line">      <span class="keyword">if</span> (done) &#123; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">      &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="20-9-3-可写流"><a href="#20-9-3-可写流" class="headerlink" title="20.9.3 可写流"></a>20.9.3 可写流</h4><p>可写流是底层数据槽的封装。底层数据槽处理通过流的公共接口写入的数据。</p>
<ol>
<li>创建WritableStrea</li>
</ol>
<p>在传给WritableStream构造函数的underlyingSink参数中，通过实现write()方法可以获得写入的数据。</p>
<ol start="2">
<li>WritableStreamDefaultWriter</li>
</ol>
<p>要把获得的数据写入流，可以通过流的getWriter()方法获取WritableStreamDefaultWriter的实例。这样会获得流的锁，确保只有一个写入器可以向流中写入数据。</p>
<p>在向流中写入数据前，生产者必须确保写入器可以接收值。writableStreamDefaultWriter.ready返回一个期约，此期约会在能够向流中写入数据时解决。然后，就可以把值传给writableStreamDefaultWriter.write()方法。写入数据之后，调用writableStreamDefaultWriter.close()将流关闭：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 每 1000 毫秒生成一个递增的整数 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> writableStream = <span class="keyword">new</span> <span class="title class_">WritableStream</span>(&#123; </span><br><span class="line"><span class="title function_">write</span>(<span class="params">value</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(writableStream.<span class="property">locked</span>); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">const</span> writableStreamDefaultWriter = writableStream.<span class="title function_">getWriter</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(writableStream.<span class="property">locked</span>); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者 </span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line">    <span class="keyword">await</span> writableStreamDefaultWriter.<span class="property">ready</span>; </span><br><span class="line">    writableStreamDefaultWriter.<span class="title function_">write</span>(chunk); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  writableStreamDefaultWriter.<span class="title function_">close</span>(); </span><br><span class="line">&#125;)(); </span><br></pre></td></tr></table></figure>

<h4 id="20-9-4-转换流"><a href="#20-9-4-转换流" class="headerlink" title="20.9.4 转换流"></a>20.9.4 转换流</h4><p>转换流用于组合可读流和可写流。数据块在两个流之间的转换是通过transform()方法完成的。</p>
<p>向转换流的组件流（可读流和可写流）传入数据和从中获取数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="comment">// 每 1000 毫秒生成一个递增的整数 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; writable, readable &#125; = <span class="keyword">new</span> <span class="title class_">TransformStream</span>(&#123; </span><br><span class="line">  <span class="title function_">transform</span>(<span class="params">chunk, controller</span>) &#123; </span><br><span class="line">    controller.<span class="title function_">enqueue</span>(chunk * <span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readableStreamDefaultReader = readable.<span class="title function_">getReader</span>(); </span><br><span class="line"><span class="keyword">const</span> writableStreamDefaultWriter = writable.<span class="title function_">getWriter</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者 </span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> &#123; done, value &#125; = <span class="keyword">await</span> readableStreamDefaultReader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123; </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者 </span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line">    <span class="keyword">await</span> writableStreamDefaultWriter.<span class="property">ready</span>; </span><br><span class="line">    writableStreamDefaultWriter.<span class="title function_">write</span>(chunk); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  writableStreamDefaultWriter.<span class="title function_">close</span>(); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="20-9-5-通过管道连接流"><a href="#20-9-5-通过管道连接流" class="headerlink" title="20.9.5 通过管道连接流"></a>20.9.5 通过管道连接流</h4><p>流可以通过管道连接成一串。最常见的用例是使用pipeThrough()方法把ReadableStream接入TransformStream。从内部看，ReadableStream先把自己的值传给TransformStream内部的WritableStream，然后执行转换，接着转换后的值又在新的ReadableStream上出现。下面的例子将一个整数的ReadableStream传入TransformStream，TransformStream对每个值做加倍处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 每 1000 毫秒生成一个递增的整数 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> integerStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line">      controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    controller.<span class="title function_">close</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doublingStream = <span class="keyword">new</span> <span class="title class_">TransformStream</span>(&#123; </span><br><span class="line">  <span class="title function_">transform</span>(<span class="params">chunk, controller</span>) &#123; </span><br><span class="line">    controller.<span class="title function_">enqueue</span>(chunk * <span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过管道连接流 </span></span><br><span class="line"><span class="keyword">const</span> pipedStream = integerStream.<span class="title function_">pipeThrough</span>(doublingStream); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从连接流的输出获得读取器 </span></span><br><span class="line"><span class="keyword">const</span> pipedStreamDefaultReader = pipedStream.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者 </span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> &#123; done, value &#125; = <span class="keyword">await</span> pipedStreamDefaultReader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123; </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>另外，使用pipeTo()方法也可以将ReadableStream连接到WritableStream。整个过程与使用pipeThrough()类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 每 1000 毫秒生成一个递增的整数 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> integerStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line">      controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    controller.<span class="title function_">close</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> writableStream = <span class="keyword">new</span> <span class="title class_">WritableStream</span>(&#123; </span><br><span class="line">  <span class="title function_">write</span>(<span class="params">value</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pipedStream = integerStream.<span class="title function_">pipeTo</span>(writableStream);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的管道连接操作隐式从ReadableStream获得了一个读取器，并把产生的值填充到WritableStream。</p>
</blockquote>
<h3 id="20-10-计时-API"><a href="#20-10-计时-API" class="headerlink" title="20.10 计时 API"></a>20.10 计时 API</h3><p>Performance接口通过 JavaScript API 暴露了浏览器内部的度量指标，允许开发者直接访问这些信息并基于这些信息现自己想要的功能。这个接口暴露在window.performance对象上。所有与页面相关的指标，包括已经定义和将来会定义的，都会存在于这个对象上。</p>
<h4 id="20-10-1-High-Resolution-Time-API"><a href="#20-10-1-High-Resolution-Time-API" class="headerlink" title="20.10.1 High Resolution Time API"></a>20.10.1 High Resolution Time API</h4><p>Date.now()方法只适用于日期时间相关操作，而且是不要求计时精度的操作。</p>
<p>High Resolution Time API 定义了window.performance.now()，这个方法返回一个微秒精度的浮点值。因此，使用这个方法先后捕获的时间戳更不可能出现相等的情况。而且这个方法可以保证时间戳单调增长。</p>
<p>performance.now()计时器采用相对度量。这个计时器在执行上下文创建时从 0 开始计时。例如，打开页面或创建工作线程时，performance.now()就会从 0 开始计时。由于这个计时器在不同上下文中初始化时可能存在时间差，因此不同上下文之间如果没有共享参照点则不可能直接比较performance.now()。performance.timeOrigin属性返回计时器初始化时全局系统时钟的值。</p>
<h4 id="20-10-2-Performance-Timeline-API"><a href="#20-10-2-Performance-Timeline-API" class="headerlink" title="20.10.2 Performance Timeline API"></a>20.10.2 Performance Timeline API</h4><p>Performance Timeline API 使用一套用于度量客户端延迟的工具扩展了Performance接口。性能度量将会采用计算结束与开始时间差的形式。这些开始和结束时间会被记录为DOMHighResTimeStamp值，而封装这个时间戳的对象是PerformanceEntry的实例。<br>浏览器会自动记录各种PerformanceEntry对象，而使用performance.mark()也可以记录自定义的PerformanceEntry对象。在一个执行上下文中被记录的所有性能条目可以通过performance. getEntries()获取：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(performance.<span class="title function_">getEntries</span>()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// [PerformanceNavigationTiming, PerformanceResourceTiming, ... ]</span></span><br></pre></td></tr></table></figure>

<p>这个返回的集合代表浏览器的性能时间线（performance timeline）。每个PerformanceEntry对象都有name、entryType、startTime和duration属性。</p>
<p>PerformanceEntry实际上是一个抽象基类。所有记录条目虽然都继承PerformanceEntry，但最终还是如下某个具体类的实例：</p>
<ul>
<li><p>PerformanceMark </p>
</li>
<li><p>PerformanceMeasure </p>
</li>
<li><p>PerformanceFrameTiming </p>
</li>
<li><p>PerformanceNavigationTiming </p>
</li>
<li><p>PerformanceResourceTiming </p>
</li>
<li><p>PerformancePaintTiming</p>
</li>
</ul>
<p>上面每个类都会增加大量属性，用于描述与相应条目有关的元数据。每个实例的name和entryType属性会因为各自的类不同而不同。</p>
<ol>
<li>User Timing API</li>
</ol>
<p>User Timing API 用于记录和分析自定义性能条目。如前所述，记录自定义性能条目要使用performance.mark()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">performance.<span class="title function_">mark</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(performance.<span class="title function_">getEntriesByType</span>(<span class="string">&#x27;mark&#x27;</span>)[<span class="number">0</span>]); </span><br><span class="line"><span class="comment">// PerformanceMark &#123; </span></span><br><span class="line"><span class="comment">//   name: &quot;foo&quot;, </span></span><br><span class="line"><span class="comment">//   entryType: &quot;mark&quot;, </span></span><br><span class="line"><span class="comment">//   startTime: 269.8800000362098, </span></span><br><span class="line"><span class="comment">//   duration: 0 </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>在计算开始前和结束后各创建一个自定义性能条目可以计算时间差。最新的标记（mark）会被推到getEntriesByType()返回数组的开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">performance.<span class="title function_">mark</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1E6</span>; ++i) &#123;&#125; </span><br><span class="line">performance.<span class="title function_">mark</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [endMark, startMark] = performance.<span class="title function_">getEntriesByType</span>(<span class="string">&#x27;mark&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(startMark.<span class="property">startTime</span> - endMark.<span class="property">startTime</span>); <span class="comment">// 1.3299999991431832</span></span><br></pre></td></tr></table></figure>

<p>除了自定义性能条目，还可以生成PerformanceMeasure（性能度量）条目，对应由名字作为标识的两个标记之间的持续时间。PerformanceMeasure的实例由performance.measure()方法生成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">performance.<span class="title function_">mark</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1E6</span>; ++i) &#123;&#125; </span><br><span class="line">performance.<span class="title function_">mark</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"></span><br><span class="line">performance.<span class="title function_">measure</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [differenceMark] = performance.<span class="title function_">getEntriesByType</span>(<span class="string">&#x27;measure&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(differenceMark); </span><br><span class="line"><span class="comment">// PerformanceMeasure &#123; </span></span><br><span class="line"><span class="comment">//   name: &quot;baz&quot;, </span></span><br><span class="line"><span class="comment">//   entryType: &quot;measure&quot;, </span></span><br><span class="line"><span class="comment">//   startTime: 298.9800000214018, </span></span><br><span class="line"><span class="comment">//   duration: 1.349999976810068 </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Navigation Timing API</li>
</ol>
<p>Navigation Timing API 提供了高精度时间戳，用于度量当前页面加载速度。浏览器会在导航事件发生时自动记录PerformanceNavigationTiming条目。这个对象会捕获大量时间戳，用于描述页面是何时以及如何加载的。</p>
<ol start="3">
<li>Resource Timing API</li>
</ol>
<p>Resource Timing API 提供了高精度时间戳，用于度量当前页面加载时请求资源的速度。浏览器会在加载资源时自动记录PerformanceResourceTiming。这个对象会捕获大量时间戳，用于描述资源加载的速度。</p>
<h3 id="20-11-Web-组件"><a href="#20-11-Web-组件" class="headerlink" title="20.11 Web 组件"></a>20.11 Web 组件</h3><h4 id="20-11-1-HTML-模板"><a href="#20-11-1-HTML-模板" class="headerlink" title="20.11.1 HTML 模板"></a>20.11.1 HTML 模板</h4><p>在 Web 组件之前，一直缺少基于 HTML 解析构建 DOM 子树，然后在需要时再把这个子树渲染出来的机制。一种间接方案是使用innerHTML把标记字符串转换为 DOM 元素，但这种方式存在严重的安全隐患。另一种间接方案是使用document.createElement()构建每个元素，然后逐个把它们添加到孤儿根节点（不是添加到 DOM），但这样做特别麻烦，完全与标记无关。<br>相反，更好的方式是提前在页面中写出特殊标记，让浏览器自动将其解析为 DOM 子树，但跳过渲染。这正是 HTML 模板的核心思想，而<template>标签正是为这个目的而生的。</p>
<ol>
<li>使用DocumentFragment</li>
</ol>
<p>在浏览器中渲染时，上面例子中的文本不会被渲染到页面上。因为<template>的内容不属于活动文档，所以document.querySelector()等 DOM 查询方法不会发现其中的&lt;**p**&gt;标签。这是因为&lt;**p**&gt;存在于一个包含在 HTML 模板中的DocumentFragment节点内。<br>在浏览器中通过开发者工具检查网页内容时，可以看到<template>中的DocumentFragment：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span> </span><br><span class="line">  #document-fragment </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I&#x27;m inside a template!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>通过<template>元素的content属性可以取得这个DocumentFragment的引用</p>
<p>此时的DocumentFragment就像一个对应子树的最小化document对象 。换句话说，DocumentFragment上的 DOM 匹配方法可以查询其子树中的节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>).<span class="property">content</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>)); <span class="comment">// null </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fragment.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>)); <span class="comment">// &lt;p&gt;...&lt;p&gt;</span></span><br></pre></td></tr></table></figure>

<p>DocumentFragment也是批量向 HTML 中添加元素的高效工具。比如，我们想以最快的方式给某个 HTML 元素添加多个子元素。如果连续调用document.appendChild()，则不仅费事，还会导致多次布局重排。而使用DocumentFragment可以一次性添加所有子节点，最多只会有一次布局重排。</p>
<ol start="2">
<li>使用<template>标签</li>
</ol>
<p>DocumentFragment的所有子节点都高效地转移到了foo元素上，转移之后DocumentFragment变空了。同样的过程也可以使用<template>标签重现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barTemplate = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#bar&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barFragment = barTemplate.<span class="property">content</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;/div&gt; </span></span><br><span class="line"><span class="comment">// &lt;template id=&quot;bar&quot;&gt; </span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/template&gt; </span></span><br><span class="line"></span><br><span class="line">fooElement.<span class="title function_">appendChild</span>(barFragment); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/div&gt; </span></span><br><span class="line"><span class="comment">// &lt;tempate id=&quot;bar&quot;&gt;&lt;/template&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想要复制模板，可以使用importNode()方法克隆DocumentFragment。</p>
<ol start="3">
<li>模板脚本</li>
</ol>
<p>脚本执行可以推迟到将DocumentFragment的内容实际添加到 DOM 树。</p>
<h4 id="20-11-2-影子-DOM"><a href="#20-11-2-影子-DOM" class="headerlink" title="20.11.2 影子 DOM"></a>20.11.2 影子 DOM</h4><p>概念上讲，影子 DOM（shadow DOM） Web 组件相当直观，通过它可以将一个完整的 DOM 树作为节点添加到父 DOM 树。这样可以实现 DOM 封装，意味着 CSS 样式和 CSS 选择符可以限制在影子 DOM子树而不是整个顶级 DOM 树中。</p>
<p>影子 DOM 与 HTML 模板还是有区别的，主要表现在影子 DOM 的内容会实际渲染到页面上，而 HTML 模板的内容不会。</p>
<ol>
<li>创建影子 DOM</li>
</ol>
<p>考虑到安全及避免影子 DOM 冲突，并非所有元素都可以包含影子 DOM。尝试给无效元素或者已经有了影子 DOM 的元素添加影子 DOM 会导致抛出错误。<br>以下是可以容纳影子 DOM 的元素。</p>
<ul>
<li><p>任何以有效名称创建的自定义元素（参见 HTML 规范中相关的定义） </p>
</li>
<li><p>&lt;**article**&gt; </p>
</li>
<li><p>&lt;**aside**&gt; </p>
</li>
<li><p>&lt;**blockquote**&gt; </p>
</li>
<li><body></li>
<li><p>&lt;**div**&gt; </p>
</li>
<li><p>&lt;**footer**&gt; </p>
</li>
<li><p>&lt;**h1**&gt; -&lt;**h6**&gt;</p>
</li>
<li><p>&lt;**header**&gt; </p>
</li>
<li><p>&lt;**main**&gt; </p>
</li>
<li><p>&lt;**nav**&gt; </p>
</li>
<li><p>&lt;**p**&gt;</p>
</li>
<li><p>&lt;**section**&gt; </p>
</li>
<li><p>&lt;**span**&gt;</p>
</li>
</ul>
<p>影子 DOM 是通过attachShadow()方法创建并添加给有效 HTML 元素的。容纳影子 DOM 的元素被称为影子宿主（shadow host）。影子 DOM 的根节点被称为影子根（shadow root）。<br>attachShadow()方法需要一个shadowRootInit对象，返回影子 DOM的实例。shadowRootInit对象必须包含一个mode属性，值为”open”或”closed”。对”open”影子 DOM的引用可以通过shadowRoot属性在 HTML 元素上获得，而对”closed”影子 DOM 的引用无法这样获取。</p>
<p>下面的代码演示了不同mode的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">  &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">  &lt;div id=&quot;bar&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> bar = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#bar&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> openShadowDOM = foo.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;); </span><br><span class="line"><span class="keyword">const</span> closedShadowDOM = bar.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;closed&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(openShadowDOM);   <span class="comment">// #shadow-root (open) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(closedShadowDOM); <span class="comment">// #shadow-root (closed) </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">shadowRoot</span>);  <span class="comment">// #shadow-root (open) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">shadowRoot</span>);  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>一般来说，需要创建保密（closed）影子 DOM 的场景很少。虽然这可以限制通过影子宿主访问影子 DOM，但恶意代码有很多方法绕过这个限制，恢复对影子 DOM 的访问。简言之，不能为了安全而创建保密影子 DOM。</p>
<ol start="2">
<li>使用影子 DOM</li>
</ol>
<p>把影子 DOM 添加到元素之后，可以像使用常规 DOM 一样使用影子 DOM。</p>
<ol start="3">
<li>合成与影子 DOM 槽位</li>
</ol>
<p>影子 DOM 是为自定义 Web 组件设计的，为此需要支持嵌套 DOM 片段。从概念上讲，可以这么说：位于影子宿主中的 HTML 需要一种机制以渲染到影子 DOM中去，但这些 HTML 又不必属于影子 DOM树。<br>默认情况下，嵌套内容会隐藏。</p>
<p>影子 DOM 一添加到元素中，浏览器就会赋予它最高优先级，优先渲染它的内容而不是原来的文本。</p>
<p>除了默认槽位，还可以使用命名槽位（named slot）实现多个投射。这是通过匹配的slot/name属性对实现的。</p>
<ol start="4">
<li>事件重定向</li>
</ol>
<p>如果影子 DOM 中发生了浏览器事件（如click），那么浏览器需要一种方式以让父 DOM 处理事件。不过，实现也必须考虑影子 DOM 的边界。为此，事件会逃出影子 DOM 并经过事件重定向（event retarget）在外部被处理。逃出后，事件就好像是由影子宿主本身而非真正的包装元素触发的一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个元素作为影子宿主 </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;div onclick=&quot;console.log(&#x27;Handled outside:&#x27;, event.target)&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加影子 DOM 并向其中插入 HTML </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>) </span><br><span class="line">  .<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;) </span><br><span class="line">  .<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;button onclick=&quot;console.log(&#x27;Handled inside:&#x27;, event.target)&quot;&gt;Foo&lt;/button&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击按钮时： </span></span><br><span class="line"><span class="comment">// Handled inside:  &lt;button onclick=&quot;...&quot;&gt;&lt;/button&gt; </span></span><br><span class="line"><span class="comment">// Handled outside: &lt;div onclick=&quot;...&quot;&gt;&lt;/div&gt; </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>件重定向只会发生在影子 DOM 中实际存在的元素上。使用<slot>标签从外部投射进来的元素不会发生事件重定向，因为从技术上讲，这些元素仍然存在于影子 DOM 外部。</p>
</blockquote>
<h4 id="20-11-3-自定义元素"><a href="#20-11-3-自定义元素" class="headerlink" title="20.11.3 自定义元素"></a>20.11.3 自定义元素</h4><ol>
<li>创建自定义元素</li>
</ol>
<p>浏览器会尝试将无法识别的元素作为通用元素整合进 DOM。当然，这些元素默认也不会做任何通用 HTML 元素不能做的事。</p>
<p>自定义元素要使用全局属性customElements，这个属性会返回CustomElementRegistry对象。</p>
<p>调用customElements.define()方法可以创建自定义元素。下面的代码创建了一个简单的自定义元素，这个元素继承HTMLElement：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;x-foo &gt;I&#x27;m inside a nonsense element.&lt;/x-foo &gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;x-foo&#x27;</span>) <span class="keyword">instanceof</span> <span class="title class_">FooElement</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自定义元素名必须至少包含一个不在名称开头和末尾的连字符，而且元素标签不能自关闭。</p>
</blockquote>
<p>自定义元素的威力源自类定义。例如，可以通过调用自定义元素的构造函数来控制这个类在 DOM中每个实例的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x-foo&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;x-foo&gt;&lt;/x-foo&gt; </span></span><br><span class="line"><span class="string">&lt;x-foo&gt;&lt;/x-foo&gt; </span></span><br><span class="line"><span class="string">&lt;x-foo&gt;&lt;/x-foo&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在自定义元素的构造函数中必须始终先调用super()。如果元素继承了HTMLElement或相似类型而不会覆盖构造函数，则没有必要调用super()，因为原型构造函数默认会做这件事。很少有创建自定义元素而不继承HTMLElement的。</p>
</blockquote>
<p>如果自定义元素继承了一个元素类，那么可以使用is属性和extends选项将标签指定为该自定义元素的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLDivElement</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x-foo&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>, &#123; <span class="attr">extends</span>: <span class="string">&#x27;div&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">&lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">&lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加 Web 组件内容</li>
</ol>
<p>因为每次将自定义元素添加到 DOM 中都会调用其类构造函数，所以很容易自动给自定义元素添加子 DOM 内容。虽然不能在构造函数中添加子 DOM（会抛出DOMException），但可以为自定义元素添加影子 DOM 并将内容添加到这个影子 DOM 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// this 引用 Web 组件节点 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">      &lt;p&gt;I&#x27;m inside a custom element!&lt;/p&gt; </span></span><br><span class="line"><span class="string">    `</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> += <span class="string">`&lt;x-foo&gt;&lt;/x-foo`</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果 DOM： </span></span><br><span class="line"><span class="comment">// &lt;body&gt; </span></span><br><span class="line"><span class="comment">// &lt;x-foo&gt; </span></span><br><span class="line"><span class="comment">//   #shadow-root (open) </span></span><br><span class="line"><span class="comment">//     &lt;p&gt;I&#x27;m inside a custom element!&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;x-foo&gt; </span></span><br><span class="line"><span class="comment">// &lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用自定义元素生命周期方法</li>
</ol>
<p>可以在自定义元素的不同生命周期执行代码。带有相应名称的自定义元素类的实例方法会在不同生命周期阶段被调用。自定义元素有以下 5 个生命周期方法。</p>
<ul>
<li><p>constructor()：在创建元素实例或将已有 DOM 元素升级为自定义元素时调用。 </p>
</li>
<li><p>connectedCallback()：在每次将这个自定义元素实例添加到 DOM 中时调用。 </p>
</li>
<li><p>disconnectedCallback()：在每次将这个自定义元素实例从 DOM 中移除时调用。 </p>
</li>
<li><p>attributeChangedCallback()：在每次可观察属性的值发生变化时调用。在元素实例初始化时，初始值的定义也算一次变化。 </p>
</li>
<li><p>adoptedCallback()：在通过document.adoptNode()将这个自定义元素实例移动到新文档对象时调用。</p>
</li>
</ul>
<ol start="4">
<li>反射自定义元素属性</li>
</ol>
<p>自定义元素既是 DOM 实体又是 JavaScript 对象，因此两者之间应该同步变化。换句话说，对 DOM的修改应该反映到 JavaScript 对象，反之亦然。要从 JavaScript 对象反射到 DOM，常见的方式是使用获取函数和设置函数。下面的例子演示了在 JavaScript 对象和 DOM 之间反射bar属性的过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;x-foo&gt;&lt;/x-foo&gt;`</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="literal">true</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, value) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;x-foo bar=&quot;true&quot;&gt;&lt;/x-foo&gt;</span></span><br></pre></td></tr></table></figure>

<p>另一个方向的反射（从 DOM 到 JavaScript 对象）需要给相应的属性添加监听器。为此，可以使用observedAttributes()获取函数让自定义元素的属性值每次改变时都调用attributeChangedCallback()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title function_">observedAttributes</span>() &#123; </span><br><span class="line">    <span class="comment">// 返回应该触发 attributeChangedCallback()执行的属性 </span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, value) </span><br><span class="line"><span class="title function_">attributeChangedCallback</span>(<span class="params">name, oldValue, newValue</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (oldValue !== newValue) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;oldValue&#125;</span> -&gt; <span class="subst">$&#123;newValue&#125;</span>`</span>); </span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>[name] = newValue; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;x-foo bar=&quot;false&quot;&gt;&lt;/x-foo&gt;`</span>; </span><br><span class="line"><span class="comment">// null -&gt; false </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;x-foo&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// false -&gt; true</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>升级自定义元素</li>
</ol>
<p>并非始终可以先定义自定义元素，然后再在 DOM 中使用相应的元素标签。为解决这个先后次序问题，Web 组件在CustomElementRegistry上额外暴露了一些方法。这些方法可以用来检测自定义元素是否定义完成，然后可以用它来升级已有元素。<br>如果自定义元素已经有定义，那么CustomElementRegistry.get()方法会返回相应自定义元素的类。类似地，CustomElementRegistry.whenDefined()方法会返回一个期约，当相应自定义元素有定义之后解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">customElements.<span class="title function_">whenDefined</span>(<span class="string">&#x27;x-foo&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defined!&#x27;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customElements.<span class="title function_">get</span>(<span class="string">&#x27;x-foo&#x27;</span>)); </span><br><span class="line"><span class="comment">// undefined </span></span><br><span class="line"></span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="keyword">class</span> &#123;&#125;); </span><br><span class="line"><span class="comment">// defined! </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customElements.<span class="title function_">get</span>(<span class="string">&#x27;x-foo&#x27;</span>)); </span><br><span class="line"><span class="comment">// class FooElement &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>连接到 DOM 的元素在自定义元素有定义时会自动升级。如果想在元素连接到 DOM 之前强制升级，可以使用CustomElementRegistry.upgrade()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在自定义元素有定义之前会创建 HTMLUnknownElement 对象 </span></span><br><span class="line"><span class="keyword">const</span> fooElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;x-foo&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义元素 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooElement <span class="keyword">instanceof</span> <span class="title class_">FooElement</span>); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制升级 </span></span><br><span class="line">customElements.<span class="title function_">upgrade</span>(fooElement); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooElement <span class="keyword">instanceof</span> <span class="title class_">FooElement</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="20-12-Web-Cryptography-API"><a href="#20-12-Web-Cryptography-API" class="headerlink" title="20.12 Web Cryptography API"></a>20.12 Web Cryptography API</h3><p>Web Cryptography API 描述了一套密码学工具，规范了 JavaScript 如何以安全和符合惯例的方式实现加密。这些工具包括生成、使用和应用加密密钥对，加密和解密消息，以及可靠地生成随机数。</p>
<blockquote>
<p>加密接口的组织方式有点奇怪，其外部是一个Crypto对象，内部是一个SubtleCrypto对象。在 Web Cryptography API 标准化之前，window.crypto属性在不同浏览器中的实现差异非常大。为实现跨浏览器兼容，标准 API 都暴露在SubtleCrypto对象上。</p>
</blockquote>
<h4 id="20-12-1-生成随机数"><a href="#20-12-1-生成随机数" class="headerlink" title="20.12.1 生成随机数"></a>20.12.1 生成随机数</h4><p>在需要生成随机值时，很多人会使用Math.random()。这个方法在浏览器中是以伪随机数生成器（PRNG，PseudoRandom Number Generator）方式实现的。所谓“伪”指的是生成值的过程不是真的随机。PRNG 生成的值只是模拟了随机的特性。</p>
<p>xorshift128+使用128 位内部状态，而算法的设计让任何初始状态在重复自身之前都会产生 2128–1 个伪随机值。这种循环被称为置换循环（permutation cycle），而这个循环的长度被称为一个周期（period）。很明显，如果攻击者知道 PRNG 的内部状态，就可以预测后续生成的伪随机值。如果开发者无意中使用 PRNG 生成了私有密钥用于加密，则攻击者就可以利用 PRNG 的这个特性算出私有密钥。</p>
<p>密码学安全伪随机数生成器（CSPRNG，Cryptographically Secure PseudoRandom Number Generator）额外增加了一个熵作为输入，例如测试硬件时间或其他无法预计行为的系统特性。这样一来，计算速度明显比常规 PRNG 慢很多，但 CSPRNG 生成的值就很难预测，可以用于加密了。</p>
<p>Web Cryptography API 引入了 CSPRNG，这个 CSPRNG 可以通过crypto.getRandomValues()在全局Crypto对象上访问。与Math.random()返回一个介于 0 和 1 之间的浮点数不同，getRandomValues()会把随机值写入作为参数传给它的定型数组。定型数组的类不重要，因为底层缓冲区会被随机的二进制位填充。</p>
<p>getRandomValues()最多可以生成 216（65 536）字节，超出则会抛出错误。</p>
<p>要使用 CSPRNG 重新实现Math.random()，可以通过生成一个随机的 32 位数值，然后用它去除最大的可能值0xFFFFFFFF。这样就会得到一个介于 0 和 1 之间的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomFloat</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 生成 32 位随机值 </span></span><br><span class="line">  <span class="keyword">const</span> fooArray = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大值是 2^32 –1 </span></span><br><span class="line">  <span class="keyword">const</span> maxUint32 = <span class="number">0xFFFFFFFF</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用最大可能的值来除 </span></span><br><span class="line">  <span class="keyword">return</span> crypto.<span class="title function_">getRandomValues</span>(fooArray)[<span class="number">0</span>] / maxUint32; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomFloat</span>()); <span class="comment">// 0.5033651619458955</span></span><br></pre></td></tr></table></figure>

<h4 id="20-12-2-使用SubtleCrypto对象"><a href="#20-12-2-使用SubtleCrypto对象" class="headerlink" title="20.12.2 使用SubtleCrypto对象"></a>20.12.2 使用SubtleCrypto对象</h4><p>Web Cryptography API 重头特性都暴露在了SubtleCrypto对象上，可以通过window.crypto. subtle访问。</p>
<p>这个对象包含一组方法，用于执行常见的密码学功能，如加密、散列、签名和生成密钥。因为所有密码学操作都在原始二进制数据上执行，所以SubtleCrypto的每个方法都要用到ArrayBuffer和ArrayBufferView类型。由于字符串是密码学操作的重要应用场景，因此TextEncoder和TextDecoder是经常与SubtleCrypto一起使用的类，用于实现二进制数据与字符串之间的相互转换。</p>
<blockquote>
<p>SubtleCrypto对象只能在安全上下文（https）中使用。在不安全的上下文中，subtle属性是undefined。</p>
</blockquote>
<ol>
<li>生成密码学摘要</li>
</ol>
<p>计算数据的密码学摘要是非常常用的密码学操作。这个规范支持 4 种摘要算法：SHA-1 和 3 种SHA-2。</p>
<ul>
<li><p>SHA-1（Secure Hash Algorithm 1）：架构类似 MD5 的散列函数。接收任意大小的输入，生成160 位消息散列。由于容易受到碰撞攻击，这个算法已经不再安全。 </p>
</li>
<li><p>SHA-2（Secure Hash Algorithm 2）：构建于相同耐碰撞单向压缩函数之上的一套散列函数。规范支持其中 3 种：SHA-256、SHA-384 和 SHA-512。生成的消息摘要可以是 256 位（SHA-256）、384 位（SHA-384）或 512 位（SHA-512）。这个算法被认为是安全的，广泛应用于很多领域和协议，包括 TLS、PGP 和加密货币（如比特币）。</p>
</li>
</ul>
<p>SubtleCrypto.digest()方法用于生成消息摘要。要使用的散列算法通过字符串”SHA-1”、”SHA-256”、”SHA-384”或”SHA-512”指定。</p>
<p>下面的代码展示了一个使用 SHA-256 为字符串”foo”生成消息摘要的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>(); </span><br><span class="line">  <span class="keyword">const</span> message = textEncoder.<span class="title function_">encode</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">  <span class="keyword">const</span> messageDigest = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">digest</span>(<span class="string">&#x27;SHA-256&#x27;</span>, message); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Uint32Array</span>(messageDigest)); </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Uint32Array(8) [1806968364, 2412183400, 1011194873, 876687389, </span></span><br><span class="line"><span class="comment">//                 1882014227, 2696905572, 2287897337, 2934400610]</span></span><br></pre></td></tr></table></figure>

<p>通常，在使用时，二进制的消息摘要会转换为十六进制字符串格式。通过将二进制数据按 8 位进行分割，然后再调用toString(16)就可以把任何数组缓冲区转换为十六进制字符串。</p>
<ol start="2">
<li>CryptoKey与算法</li>
</ol>
<p>SubtleCrypto对象使用CryptoKey类的实例来生成密钥。CryptoKey类支持多种加密算法，允许控制密钥抽取和使用。</p>
<ol start="3">
<li>生成CryptoKey</li>
</ol>
<p>使用SubtleCrypto.generateKey()方法可以生成随机CryptoKey，这个方法返回一个期约，解决为一个或多个CryptoKey实例。使用时需要给这个方法传入一个指定目标算法的参数对象、一个表示密钥是否可以从CryptoKey对象中提取出来的布尔值，以及一个表示这个密钥可以与哪个SubtleCrypto方法一起使用的字符串数组（keyUsages）。<br>由于不同的密码系统需要不同的输入来生成密钥，上述参数对象为每种密码系统都规定了必需的输入：</p>
<ul>
<li><p>RSA 密码系统使用RsaHashedKeyGenParams对象；</p>
</li>
<li><p>ECC 密码系统使用EcKeyGenParams对象； </p>
</li>
<li><p>HMAC 密码系统使用HmacKeyGenParams对象； </p>
</li>
<li><p>AES 密码系统使用AesKeyGenParams对象。</p>
</li>
</ul>
<p>keyUsages对象用于说明密钥可以与哪个算法一起使用。至少要包含下列中的一个字符串：</p>
<ul>
<li><p>encrypt </p>
</li>
<li><p>decrypt </p>
</li>
<li><p>sign </p>
</li>
<li><p>verify </p>
</li>
<li><p>deriveKey </p>
</li>
<li><p>deriveBits </p>
</li>
<li><p>wrapKey </p>
</li>
<li><p>unwrapKey</p>
</li>
</ul>
<p>假设要生成一个满足如下条件的对称密钥：</p>
<ul>
<li><p>支持 AES-CTR 算法； </p>
</li>
<li><p>密钥长度 128 位； </p>
</li>
<li><p>不能从CryptoKey对象中提取； </p>
</li>
<li><p>可以跟encrypt()和decrypt()方法一起使用。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> params = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;AES-CTR&#x27;</span>, </span><br><span class="line">    <span class="attr">length</span>: <span class="number">128</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;encrypt&#x27;</span>, <span class="string">&#x27;decrypt&#x27;</span>]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> key = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(params, <span class="literal">false</span>, keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); </span><br><span class="line">  <span class="comment">// CryptoKey &#123;type: &quot;secret&quot;, extractable: true, algorithm: &#123;...&#125;, usages: Array(2)&#125; </span></span><br><span class="line">&#125;)(); </span><br></pre></td></tr></table></figure>

<p>假设要生成一个满足如下条件的非对称密钥：</p>
<ul>
<li><p>支持 ECDSA 算法； </p>
</li>
<li><p>使用 P-256 椭圆曲线； </p>
</li>
<li><p>可以从CryptoKey中提取； </p>
</li>
<li><p>可以跟sign()和verify()方法一起使用。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> params = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ECDSA&#x27;</span>, </span><br><span class="line">    <span class="attr">namedCurve</span>: <span class="string">&#x27;P-256&#x27;</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;sign&#x27;</span>, <span class="string">&#x27;verify&#x27;</span>]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;publicKey, privateKey&#125; = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(params, <span class="literal">true</span>, </span><br><span class="line">      keyUsages); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(publicKey); </span><br><span class="line">  <span class="comment">// CryptoKey &#123;type: &quot;public&quot;, extractable: true, algorithm: &#123;...&#125;, usages: Array(1)&#125; </span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(privateKey); </span><br><span class="line">  <span class="comment">// CryptoKey &#123;type: &quot;private&quot;, extractable: true, algorithm: &#123;...&#125;, usages: Array(1)&#125; </span></span><br><span class="line">&#125;)(); </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>导出和导入密钥</li>
</ol>
<p>如果密钥是可提取的，那么就可以在CryptoKey对象内部暴露密钥原始的二进制内容。使用exportKey()方法并指定目标格式（”raw”、”pkcs8”、”spki”或”jwk”）就可以取得密钥。这个方法返回一个期约，解决后的ArrayBuffer中包含密钥：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> params = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;AES-CTR&#x27;</span>, </span><br><span class="line">    <span class="attr">length</span>: <span class="number">128</span> </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;encrypt&#x27;</span>, <span class="string">&#x27;decrypt&#x27;</span>]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> key = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(params, <span class="literal">true</span>, keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rawKey = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">exportKey</span>(<span class="string">&#x27;raw&#x27;</span>, key); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(rawKey)); </span><br><span class="line">  <span class="comment">// Uint8Array[93, 122, 66, 135, 144, 182, 119, 196, 234, 73, 84, 7, 139, 43, 238, </span></span><br><span class="line">  <span class="comment">// 110] </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>与exportKey()相反的操作要使用importKey()方法实现。importKey()方法的签名实际上是generateKey()和exportKey()的组合。下面的方法会生成密钥、导出密钥，然后再导入密钥：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> params = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;AES-CTR&#x27;</span>, </span><br><span class="line">    <span class="attr">length</span>: <span class="number">128</span> </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;encrypt&#x27;</span>, <span class="string">&#x27;decrypt&#x27;</span>]; </span><br><span class="line">  <span class="keyword">const</span> keyFormat = <span class="string">&#x27;raw&#x27;</span>; </span><br><span class="line">  <span class="keyword">const</span> isExtractable = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> key = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(params, isExtractable, keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rawKey = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">exportKey</span>(keyFormat, key); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> importedKey = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.importKey(keyFormat, rawKey, params.<span class="property">name</span>, </span><br><span class="line">      isExtractable, keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(importedKey); </span><br><span class="line">  <span class="comment">// CryptoKey &#123;type: &quot;secret&quot;, extractable: true, algorithm: &#123;...&#125;, usages: Array(2)&#125; </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>从主密钥派生密钥</li>
</ol>
<p>使用SubtleCrypto对象可以通过可配置的属性从已有密钥获得新密钥。SubtleCrypto支持一个deriveKey()方法和一个deriveBits()方法，前者返回一个解决为CryptoKey的期约，后者返回一个解决为ArrayBuffer的期约。</p>
<blockquote>
<p>deriveKey()与deriveBits()的区别很微妙，因为调用deriveKey()实际上与调用deriveBits()之后再把结果传给importKey()相同。</p>
</blockquote>
<p>deriveBits()方法接收一个算法参数对象、主密钥和输出的位长作为参数。当两个人分别拥有自己的密钥对，但希望获得共享的加密密钥时可以使用这个方法。下面的例子使用 ECDH 算法基于两个密钥对生成了对等密钥，并确保它们派生相同的密钥位：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> ellipticCurve = <span class="string">&#x27;P-256&#x27;</span>; </span><br><span class="line">  <span class="keyword">const</span> algoIdentifier = <span class="string">&#x27;ECDH&#x27;</span>; </span><br><span class="line">  <span class="keyword">const</span> derivedKeySize = <span class="number">128</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> params = &#123; </span><br><span class="line">    <span class="attr">name</span>: algoIdentifier, </span><br><span class="line">    <span class="attr">namedCurve</span>: ellipticCurve </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;deriveBits&#x27;</span>]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyPairA = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(params, <span class="literal">true</span>, keyUsages); </span><br><span class="line">  <span class="keyword">const</span> keyPairB = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(params, <span class="literal">true</span>, keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 A 的公钥和 B 的私钥派生密钥位 </span></span><br><span class="line">  <span class="keyword">const</span> derivedBitsAB = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">deriveBits</span>( </span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">public</span>: keyPairA.<span class="property">publicKey</span> &#125;, params), </span><br><span class="line">      keyPairB.<span class="property">privateKey</span>, </span><br><span class="line">      derivedKeySize); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 B 的公钥和 A 的私钥派生密钥位 </span></span><br><span class="line">  <span class="keyword">const</span> derivedBitsBA = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">deriveBits</span>( </span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">public</span>: keyPairB.<span class="property">publicKey</span> &#125;, params), </span><br><span class="line">      keyPairA.<span class="property">privateKey</span>, </span><br><span class="line">      derivedKeySize); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> arrayAB = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(derivedBitsAB); </span><br><span class="line">  <span class="keyword">const</span> arrayBA = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(derivedBitsBA); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保密钥数组相等 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( </span><br><span class="line">      arrayAB.<span class="property">length</span> === arrayBA.<span class="property">length</span> &amp;&amp; </span><br><span class="line">      arrayAB.<span class="title function_">every</span>(<span class="function">(<span class="params">val, i</span>) =&gt;</span> val === arrayBA[i])); <span class="comment">// true </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>deriveKey()方法是类似的，只不过返回的是CryptoKey的实例而不是ArrayBuffer。</p>
<ol start="6">
<li>使用非对称密钥签名和验证消息</li>
</ol>
<p>通过SubtleCrypto对象可以使用公钥算法用私钥生成签名，或者用公钥验证签名。这两种操作分别通过SubtleCrypto.sign()和SubtleCrypto.verify()方法完成。<br>签名消息需要传入参数对象以指定算法和必要的值、CryptoKey和要签名的ArrayBuffer或ArrayBufferView。下面的例子会生成一个椭圆曲线密钥对，并使用私钥签名消息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> keyParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ECDSA&#x27;</span>, </span><br><span class="line">    <span class="attr">namedCurve</span>: <span class="string">&#x27;P-256&#x27;</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;sign&#x27;</span>, <span class="string">&#x27;verify&#x27;</span>]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;publicKey, privateKey&#125; = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(keyParams, <span class="literal">true</span>, </span><br><span class="line">      keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> message = (<span class="keyword">new</span> <span class="title class_">TextEncoder</span>()).<span class="title function_">encode</span>(<span class="string">&#x27;I am Satoshi Nakamoto&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> signParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ECDSA&#x27;</span>, </span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&#x27;SHA-256&#x27;</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> signature = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">sign</span>(signParams, privateKey, message); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Uint32Array</span>(signature)); </span><br><span class="line">  <span class="comment">// Uint32Array(16) [2202267297, 698413658, 1501924384, 691450316, 778757775, ... ] </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>希望通过这个签名验证消息的人可以使用公钥和SubtleCrypto.verify()方法。这个方法的签名几乎与sign()相同，只是必须提供公钥以及签名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> keyParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ECDSA&#x27;</span>, </span><br><span class="line">    <span class="attr">namedCurve</span>: <span class="string">&#x27;P-256&#x27;</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;sign&#x27;</span>, <span class="string">&#x27;verify&#x27;</span>]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;publicKey, privateKey&#125; = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(keyParams, <span class="literal">true</span>, </span><br><span class="line">      keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> message = (<span class="keyword">new</span> <span class="title class_">TextEncoder</span>()).<span class="title function_">encode</span>(<span class="string">&#x27;I am Satoshi Nakamoto&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> signParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ECDSA&#x27;</span>, </span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&#x27;SHA-256&#x27;</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> signature = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">sign</span>(signParams, privateKey, message); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> verified = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">verify</span>(signParams, publicKey, signature, </span><br><span class="line">      message); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(verified); <span class="comment">// true </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>使用对称密钥加密和解密</li>
</ol>
<p>SubtleCrypto对象支持使用公钥和对称算法加密和解密消息。这两种操作分别通过SubtleCrypto. encrypt()和SubtleCrypto.decrypt()方法完成。<br>加密消息需要传入参数对象以指定算法和必要的值、加密密钥和要加密的数据。下面的例子会生成对称 AES-CBC 密钥，用它加密消息，最后解密消息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> algoIdentifier = <span class="string">&#x27;AES-CBC&#x27;</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: algoIdentifier, </span><br><span class="line">    <span class="attr">length</span>: <span class="number">256</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;encrypt&#x27;</span>, <span class="string">&#x27;decrypt&#x27;</span>]; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> key = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(keyParams, <span class="literal">true</span>, </span><br><span class="line">      keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> originalPlaintext = (<span class="keyword">new</span> <span class="title class_">TextEncoder</span>()).<span class="title function_">encode</span>(<span class="string">&#x27;I am Satoshi Nakamoto&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> encryptDecryptParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: algoIdentifier, </span><br><span class="line">    <span class="attr">iv</span>: crypto.<span class="title function_">getRandomValues</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">16</span>)) </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ciphertext = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">encrypt</span>(encryptDecryptParams, key, </span><br><span class="line">      originalPlaintext); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ciphertext); </span><br><span class="line">  <span class="comment">// ArrayBuffer(32) &#123;&#125; </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decryptedPlaintext = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">decrypt</span>(encryptDecryptParams, key, </span><br><span class="line">      ciphertext); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">TextDecoder</span>()).<span class="title function_">decode</span>(decryptedPlaintext)); </span><br><span class="line">  <span class="comment">// I am Satoshi Nakamoto </span></span><br><span class="line">&#125;)(); </span><br></pre></td></tr></table></figure>

<ol start="8">
<li>包装和解包密钥</li>
</ol>
<p>SubtleCrypto对象支持包装和解包密钥，以便在非信任渠道传输。这两种操作分别通过SubtleCrypto.wrapKey()和SubtleCrypto.unwrapKey()方法完成。<br>包装密钥需要传入一个格式字符串、要包装的CryptoKey实例、要执行包装的CryptoKey，以及一个参数对象用于指定算法和必要的值。下面的例子生成了一个对称 AES-GCM 密钥，用 AES-KW 来包装这个密钥，最后又将包装的密钥解包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> keyFormat = <span class="string">&#x27;raw&#x27;</span>; </span><br><span class="line">  <span class="keyword">const</span> extractable = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrappingKeyAlgoIdentifier = <span class="string">&#x27;AES-KW&#x27;</span>; </span><br><span class="line">  <span class="keyword">const</span> wrappingKeyUsages = [<span class="string">&#x27;wrapKey&#x27;</span>, <span class="string">&#x27;unwrapKey&#x27;</span>]; </span><br><span class="line">  <span class="keyword">const</span> wrappingKeyParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: wrappingKeyAlgoIdentifier, </span><br><span class="line">    <span class="attr">length</span>: <span class="number">256</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyAlgoIdentifier = <span class="string">&#x27;AES-GCM&#x27;</span>; </span><br><span class="line">  <span class="keyword">const</span> keyUsages = [<span class="string">&#x27;encrypt&#x27;</span>]; </span><br><span class="line">  <span class="keyword">const</span> keyParams = &#123; </span><br><span class="line">    <span class="attr">name</span>: keyAlgoIdentifier, </span><br><span class="line">    <span class="attr">length</span>: <span class="number">256</span> </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrappingKey = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(wrappingKeyParams, extractable, </span><br><span class="line">      wrappingKeyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(wrappingKey); </span><br><span class="line">  <span class="comment">// CryptoKey &#123;type: &quot;secret&quot;, extractable: true, algorithm: &#123;...&#125;, usages: Array(2)&#125; </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> key = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">generateKey</span>(keyParams, extractable, keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); </span><br><span class="line">  <span class="comment">// CryptoKey &#123;type: &quot;secret&quot;, extractable: true, algorithm: &#123;...&#125;, usages: Array(1)&#125; </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wrappedKey = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">wrapKey</span>(keyFormat, key, wrappingKey, </span><br><span class="line">      wrappingKeyAlgoIdentifier); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(wrappedKey); </span><br><span class="line">  <span class="comment">// ArrayBuffer(40) &#123;&#125; </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> unwrappedKey = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">unwrapKey</span>(keyFormat, wrappedKey, </span><br><span class="line">      wrappingKey, wrappingKeyParams, keyParams, extractable, keyUsages); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(unwrappedKey); </span><br><span class="line">  <span class="comment">// CryptoKey &#123;type: &quot;secret&quot;, extractable: true, algorithm: &#123;...&#125;, usages: Array(1)&#125; </span></span><br><span class="line">&#125;)() </span><br></pre></td></tr></table></figure>

<h3 id="20-13-小结"><a href="#20-13-小结" class="headerlink" title="20.13 小结"></a>20.13 小结</h3><p>除了定义新标签，HTML5 还定义了一些 JavaScript API。这些 API 可以为开发者提供更便捷的 Web接口，暴露堪比桌面应用的能力。本章主要介绍了以下 API。</p>
<ul>
<li><p>Atomics API 用于保护代码在多线程内存访问模式下不发生资源争用。 </p>
</li>
<li><p>postMessage() API 支持从不同源跨文档发送消息，同时保证安全和遵循同源策略。 </p>
</li>
<li><p>Encoding API 用于实现字符串与缓冲区之间的无缝转换（越来越常见的操作）。 </p>
</li>
<li><p>File API 提供了发送、接收和读取大型二进制对象的可靠工具。 </p>
</li>
<li><p>媒体元素&lt;**audio**&gt;和&lt;**video**&gt;拥有自己的 API，用于操作音频和视频。并不是每个浏览器都会支持所有媒体格式，使用canPlayType()方法可以检测浏览器支持情况。 </p>
</li>
<li><p>拖放 API 支持方便地将元素标识为可拖动，并在操作系统完成放置时给出回应。可以利用它创建自定义可拖动元素和放置目标。 </p>
</li>
<li><p>Notifications API 提供了一种浏览器中立的方式，以此向用户展示消通知弹层。 </p>
</li>
<li><p>Streams API 支持以全新的方式读取、写入和处理数据。 </p>
</li>
<li><p>Timing API 提供了一组度量数据进出浏览器时间的可靠工具。 </p>
</li>
<li><p>Web Components API 为元素重用和封装技术向前迈进提供了有力支撑。 </p>
</li>
<li><p>Web Cryptography API 让生成随机数、加密和签名消息成为一类特性。</p>
</li>
</ul>
<h2 id="二十一、错误处理与调试"><a href="#二十一、错误处理与调试" class="headerlink" title="二十一、错误处理与调试"></a>二十一、错误处理与调试</h2><h3 id="21-1-浏览器错误报告"><a href="#21-1-浏览器错误报告" class="headerlink" title="21.1 浏览器错误报告"></a>21.1 浏览器错误报告</h3><p>默认情况下，所有浏览器都会隐藏错误信息。一个原因是除了开发者之外这些信息对别人没什么用，另一个原因是网页在正常操作中报错的固有特性。</p>
<h4 id="21-1-1-桌面控制台"><a href="#21-1-1-桌面控制台" class="headerlink" title="21.1.1 桌面控制台"></a>21.1.1 桌面控制台</h4><p>所有现代桌面浏览器都会通过控制台暴露错误。这些错误可以显示在开发者工具内嵌的控制台中。</p>
<p>最简单的查看错误的方式就是在页面上单击鼠标右键，然后在上下文菜单中选择 Inspect（检查）或 Inspect Element（检查元素），然后再单击 Console（控制台）选项卡。</p>
<h4 id="21-1-2-移动控制台"><a href="#21-1-2-移动控制台" class="headerlink" title="21.1.2 移动控制台"></a>21.1.2 移动控制台</h4><p>移动浏览器不会直接在设备上提供控制台界面。不过，还是有一些途径可以在移动设备中检查错误。<br>Chrome 移动版和 Safari 的 iOS 版内置了实用工具，支持将设备连接到宿主操作系统中相同的浏览器。然后，就可以在对应的桌面浏览器中查看错误了。<br>此外也可以使用第三方工具直接在移动设备上调试。Firefox 常用的调试工具是 Firebug Lite，这需要通过 JavaScript 的书签小工具向当前页面中加入 Firebug 脚本才可以。脚本运行后，就可以直接在移动浏览器上打开调试界面。Firebug Lite 也有面向其他浏览器（如 Chrome）的版本。</p>
<h3 id="21-2-错误处理"><a href="#21-2-错误处理" class="headerlink" title="21.2 错误处理"></a>21.2 错误处理</h3><h4 id="21-2-1-try-catch语句"><a href="#21-2-1-try-catch语句" class="headerlink" title="21.2.1 try/catch语句"></a>21.2.1 try/catch语句</h4><p>ECMA-262 第 3 版新增了try/catch语句，作为在 JavaScript 中处理异常的一种方式。基本的语法如下所示，跟 Java 中的try/catch语句一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="comment">// 可能出错的代码 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line">  <span class="comment">// 出错时要做什么 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">someNonexistentFunction</span>(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error)&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;An error happened!&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何可能出错的代码都应该放到try块中，而处理错误的代码则放在catch块中。</p>
<p>如果try块中有代码发生错误，代码会立即退出执行，并跳到catch块中。catch块此时接收到一个对象，该对象包含发生错误的相关信息。与其他语言不同，即使在catch块中不使用错误对象，也必须为它定义名称。错误对象中暴露的实际信息因浏览器而异，但至少包含保存错误消息的message属性。ECMA-262 也指定了定义错误类型的name属性，目前所有浏览器中都有这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">someNonexistentFunction</span>(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error)&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">message</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>message属性是唯一一个在 IE、Firefox、Safari、Chrome 和 Opera 中都有的属性，尽管每个浏览器添加了其他属性。IE 添加了description属性（其值始终等于message）和number属性（它包含内部错误号）。Firefox 添加了fileName、lineNumber和stack（包含栈跟踪信息）属性。Safari 添加了line（行号）、sourceId（内部错误号）和sourceURL属性。同样，为保证跨浏览器兼容，最好只依赖message属性。</p>
<ol>
<li>finally子句</li>
</ol>
<p>try/catch语句中可选的finally子句始终运行。如果try块中的代码运行完，则接着执行finally块中的代码。如果出错并执行catch块中的代码，则finally块中的代码仍执行。try或catch块无法阻止finally块执行，包括return语句。</p>
<p>如果写出finally子句，catch块就成了可选的（它们两者中只有一个是必需的）。</p>
<blockquote>
<p>只要代码中包含了finally子句，try块或catch块中的return语句就会被忽略。</p>
</blockquote>
<ol start="2">
<li>错误类型</li>
</ol>
<p>每种类型都会对应一个错误发生时抛出的错误对象。ECMA-262 定义了以下 8 种错误类型：</p>
<ul>
<li><p>Error </p>
</li>
<li><p>InternalError </p>
</li>
<li><p>EvalError </p>
</li>
<li><p>RangeError </p>
</li>
<li><p>ReferenceError </p>
</li>
<li><p>SyntaxError </p>
</li>
<li><p>TypeError </p>
</li>
<li><p>URIError</p>
</li>
</ul>
<p>Error是基类型，其他错误类型继承该类型。因此，所有错误类型都共享相同的属性（所有错误对象上的方法都是这个默认类型定义的方法）。浏览器很少会抛出Error类型的错误，该类型主要用于开发者抛出自定义错误。</p>
<p>InternalError类型的错误会在底层 JavaScript 引擎抛出异常时由浏览器抛出。例如，递归过多导致了栈溢出。这个类型并不是代码中通常要处理的错误，如果真发生了这种错误，很可能代码哪里弄错了或者有危险了。</p>
<p>EvalError类型的错误会在使用eval()函数发生异常时抛出。</p>
<p>RangeError错误会在数值越界时抛出。</p>
<p>ReferenceError会在找不到对象时发生。（这就是著名的”object expected”浏览器错误的原因。）这种错误经常是由访问不存在的变量而导致的。</p>
<p>SyntaxError经常在给eval()传入的字符串包含 JavaScript 语法错误时发生。</p>
<p>TypeError在 JavaScript 中很常见，主要发生在变量不是预期类型，或者访问不存在的方法时。很多原因可能导致这种错误，尤其是在使用类型特定的操作而变量类型不对时。</p>
<p>最后一种错误类型是URIError，只会在使用encodeURI()或decodeURI()但传入了格式错误的URI 时发生。</p>
<p>不同的错误类型可用于为异常提供更多信息，以便实现适当的错误处理逻辑。在try/catch语句的catch块中，可以使用instanceof操作符确定错误的类型。</p>
<p>检查错误类型是以跨浏览器方式确定适当操作过程的最简单方法，因为message属性中包含的错误消息因浏览器而异。</p>
<ol start="3">
<li>try/catch的用法</li>
</ol>
<p>当try/catch中发生错误时，浏览器会认为错误被处理了，因此就不会再使用本章前面提到的机制报告错误。使用try/catch可以针对特定错误类型实现自定义的错误处理。</p>
<p>try/catch语句最好用在自己无法控制的错误上。</p>
<p>如果你明确知道自己的代码会发生某种错误，那么就不适合使用try/catch语句。</p>
<h4 id="21-2-2-抛出错误"><a href="#21-2-2-抛出错误" class="headerlink" title="21.2.2 抛出错误"></a>21.2.2 抛出错误</h4><p>与try/catch语句对应的一个机制是throw操作符，用于在任何时候抛出自定义错误。throw操作符必须有一个值，但值的类型不限。</p>
<p>使用throw操作符时，代码立即停止执行，除非try/catch语句捕获了抛出的值。<br>可以通过内置的错误类型来模拟浏览器错误。每种错误类型的构造函数都只接收一个参数，就是错误消息。下面看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Something bad happened.&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>以上代码使用一个自定义的错误消息生成了一个通用错误。浏览器会像处理自己生成的错误一样来处理这个自定义错误。换句话说，浏览器会像通常一样报告这个错误，最终显示这个自定义错误。当然，使用特定的错误类型也是一样的。</p>
<p>自定义错误常用的错误类型是Error、RangeError、ReferenceError和TypeError。</p>
<p>此外，通过继承Error也可以创建自定义的错误类型。创建自定义错误类型时，需要提供name属性和message属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(message); </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;CustomError&quot;</span>; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">&quot;My message&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>继承Error的自定义错误类型会被浏览器当成其他内置错误类型。自定义错误类型有助于在捕获错误时更准确地区分错误。</p>
<ol>
<li>何时抛出错误</li>
</ol>
<p>抛出自定义错误是解释函数为什么失败的有效方式。在出现已知函数无法正确执行的情况时就应该抛出错误。换句话说，浏览器会在给定条件下执行该函数时抛出错误。</p>
<p>使用适当的信息创建自定义错误可以有效提高代码的可维护性。</p>
<ol start="2">
<li>抛出错误与try/catch</li>
</ol>
<p>一个常见的问题是何时抛出错误，何时使用try/catch捕获错误。应该只在确切知道接下来该做什么的时候捕获错误。捕获错误的目的是阻止浏览器以其默认方式响应；抛出错误的目的是为错误提供有关其发生原因的说明。</p>
<h4 id="21-2-3-error事件"><a href="#21-2-3-error事件" class="headerlink" title="21.2.3 error事件"></a>21.2.3 error事件</h4><p>任何没有被try/catch语句处理的错误都会在window对象上触发error事件。该事件是浏览器早期支持的事件，为保持向后兼容，很多浏览器保持了其格式不变。在onerror事件处理程序中，任何浏览器都不会传入event对象。相反，会传入 3 个参数：错误消息、发生错误的 URL 和行号。大多数情况下，只有错误消息有用，因为 URL 就是当前文档的地址，而行号可能指嵌入 JavaScript 或外部文件中的代码。另外，onerror事件处理程序需要使用 DOM Level 0 技术来指定，因为它不遵循 DOM Level 2 Events标准格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="function">(<span class="params">message, url, line</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>在任何错误发生时，无论是否是浏览器生成的，都会触发error事件并执行这个事件处理程序。然后，浏览器的默认行为就会生效，像往常一样显示这条错误消息。可以返回false来阻止浏览器默认报告错误的行为。</p>
<p>通过返回false，这个函数实际上就变成了整个文档的try/catch语句，可以捕获所有未处理的运行时错误。这个事件处理程序应该是处理浏览器报告错误的最后一道防线。理想情况下，最好永远不要用到。适当使用try/catch语句意味着不会有错误到达浏览器这个层次，因此也就不会触发error事件。</p>
<blockquote>
<p>浏览器在使用这个事件处理错误时存在明显差异。在 IE 中发生error事件时，正常代码会继续执行，所有变量和数据会保持，且可以在onerror事件处理程序中访问。然而在 Firefox 中，正常代码会执行会终止，错误发生之前的所有变量和数据会被销毁，导致很难真正分析处理错误。</p>
</blockquote>
<p>图片也支持error事件。任何时候，如果图片src属性中的 URL 没有返回可识别的图片格式，就会触发error事件。这个事件遵循 DOM 格式，返回一个以图片为目标的event对象。</p>
<h4 id="21-2-4-错误处理策略"><a href="#21-2-4-错误处理策略" class="headerlink" title="21.2.4 错误处理策略"></a>21.2.4 错误处理策略</h4><p>Web 应用程序的错误处理策略基本上是在服务器上落地。错误处理策略涉及很多错误和错误处理考量，包括日志记录和监控系统。这些主要是为了分析模式，以期找到问题的根源并了解有多少用户会受错误影响。<br>在 Web 应用程序的 JavaScipt 层面落地错误处理策略同样重要。因为任何 JavaScript 错误都可能导致网页无法使用，所以理解这些错误会在什么情况下发生以及为什么会发生非常重要。作为开发者，应该非常清楚自己的代码在什么情况下会失败，以及失败会导致什么结果。另外，还要有一个系统跟踪这些问题。</p>
<h4 id="21-2-5-识别错误"><a href="#21-2-5-识别错误" class="headerlink" title="21.2.5 识别错误"></a>21.2.5 识别错误</h4><p>错误处理非常重要的部分是首先识别错误可能会在代码中的什么地方发生。因为 JavaScript 是松散类型的，不会验证函数参数，所以很多错误只有在代码真正运行起来时才会出现。通常，需要注意 3 类错误：</p>
<ul>
<li><p>类型转换错误 </p>
</li>
<li><p>数据类型错误 </p>
</li>
<li><p>通信错误</p>
</li>
</ul>
<p>上面这几种错误会在特定情况下，在没有对值进行充分检测时发生。</p>
<ol>
<li>静态代码分析器</li>
</ol>
<p>通过在代码构建流程中添加静态代码分析或代码检查器（linter），可以预先发现非常多的错误。常用的静态分析工具是 JSHint、JSLint、Google Closure 和 TypeScript。<br>静态代码分析器要求使用类型、函数签名及其他指令来注解 JavaScript，以此描述程序如何在基本可执行代码之外运行。分析器会比较注解和 JavaScript 代码的各个部分，对在实际运行时可能出现的潜在不兼容问题给出提醒。</p>
<ol start="2">
<li>类型转换错误</li>
</ol>
<p>类型转换错误的主要原因是使用了会自动改变某个值的数据类型的操作符或语言构造。使用等于（==）或不等于（!=）操作符，以及在if、for或while等流控制语句中使用非布尔值，经常会导致类型转换错误。</p>
<p>大多数情况下，最好使用严格相等（===）和严格不相等（!==）操作符来避免类型转换。</p>
<p>类型转换错误也会发生在流控制语句中。比如，if语句会自动把条件表达式转换为布尔值，然后再决定下一步的走向。在实践中，if语句是问题比较多的。</p>
<p>在流控制语句中使用非布尔值作为条件是很常见的错误来源。为避免这类错误，需要始终坚持使用布尔值作为条件。这通常可以借助某种比较来实现。</p>
<ol start="3">
<li>数据类型错误</li>
</ol>
<p>因为 JavaScript 是松散类型的，所以变量和函数参数都不能保证会使用正确的数据类型。开发者需要自己检查数据类型，确保不会发生错误。数据类型错误常发生在将意外值传给函数的时候。</p>
<p>另一个常见的错误是将参数与null比较用参数值与null比较只会保证不是两个值：null和undefined（对于使用相等和不相等操作符而言是等价的）。与null比较不足以保证适当的值，因此不要使用这种方式。出于同样的原因，也不推荐与undefined比较。<br>另一个错误的做法是在检测特性时只检查使用的特性。</p>
<p>一般来说，原始类型的值应该使用typeof检测，而对象值应该使用instanceof检测。根据函数的用法，不一定要检查每个参数的数据类型，但对外的任何 API 都应该做类型检查以保证正确执行。</p>
<ol start="4">
<li>通信错误</li>
</ol>
<p>随着 Ajax 编程的出现，Web 应用程序在运行期间动态加载数据和功能成为常见的情形。JavaScript和服务器之间的通信也会出现错误。<br>第一种错误是 URL 格式或发送数据的格式不正确。通常，在把数据发送到服务器之前没有用encodeURIComponent()编码，会导致这种错误。</p>
<p>对于查询字符串，应该都要通过encodeURIComponent()编码。</p>
<p>在服务器响应非预期值时也会发生通信错误。在动态加载脚本或样式时，请求的资源有可能不可用。有些浏览器在没有返回预期资源时会静默失败，而其他浏览器则会报告错误。不过，在动态加载资源的情况下出错，是不太好做错误处理的。有时候，使用 Ajax 通信可能会提供关于错误条件的更多信息。</p>
<h4 id="21-2-6-区分重大与非重大错误"><a href="#21-2-6-区分重大与非重大错误" class="headerlink" title="21.2.6 区分重大与非重大错误"></a>21.2.6 区分重大与非重大错误</h4><p>任何错误处理策略中一个非常重要的方面就是确定某个错误是否为重大错误。具有以下一个或多个特性的错误属于非重大错误： </p>
<ul>
<li><p>不会影响用户的主要任务； </p>
</li>
<li><p>只会影响页面中某个部分； </p>
</li>
<li><p>可以恢复； </p>
</li>
<li><p>重复操作可能成功。</p>
</li>
</ul>
<p>另一方面，重大错误具备如下特性： </p>
<ul>
<li><p>应用程序绝对无法继续运行； </p>
</li>
<li><p>错误严重影响了用户的主要目标； </p>
</li>
<li><p>会导致其他错误发生。</p>
</li>
</ul>
<p>当重大错误发生时，应该立即发送消息让用户知晓自己不能再继续使用应用程序了。如果必须刷新页面才能恢复应用程序，那就应该明确告知用户，并提供一个自动刷新页面的按钮。<br>代码中则不要区分什么是或什么不是重大错误。非重大错误和重大错误的区别主要体现在对用户的影响上。好的代码设计意味着应用程序某个部分的错误不会影响其他部分，实际上根本不应该相关。</p>
<h4 id="21-2-7-把错误记录到服务器中"><a href="#21-2-7-把错误记录到服务器中" class="headerlink" title="21.2.7 把错误记录到服务器中"></a>21.2.7 把错误记录到服务器中</h4><p>Web 应用程序开发中的一个常见做法是建立中心化的错误日志存储和跟踪系统。数据库和服务器错误正常写到日志中并按照常用 API 加以分类。对复杂的 Web 应用程序而言，最好也把 JavaScript 错误发送回服务器记录下来。这样做可以把错误记录到与服务器相同的系统，只要把它们归类到前端错误即可。使用相同的系统可以进行相同的分析，而不用考虑错误来源。<br>要建立 JavaScript 错误日志系统，首先需要在服务器上有页面或入口可以处理错误数据。该页面只要从查询字符串中取得错误数据，然后把它们保存到错误日志中即可。比如，该页面可以使用如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logError</span>(<span class="params">sev, msg</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>(), </span><br><span class="line">      encodedSev = <span class="built_in">encodeURIComponent</span>(sev), </span><br><span class="line">      encodedMsg = <span class="built_in">encodeURIComponent</span>(msg); </span><br><span class="line">  img.<span class="property">src</span> = <span class="string">&#x27;log.php?sev=$&#123;encodedSev&#125;&amp;msg=$&#123;encodedMsg&#125;&#x27;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>logError()函数接收两个参数：严重程度和错误消息。严重程度可以是数值或字符串，具体取决于使用的日志系统。这里使用Image对象发送请求主要是从灵活性方面考虑的。 </p>
<ul>
<li><p>所有浏览器都支持Image对象，即使不支持XMLHttpRequest对象也一样。 </p>
</li>
<li><p>不受跨域规则限制。通常，接收错误消息的应该是多个服务器中的一个，而XMLHttpRequest此时就比较麻烦。 </p>
</li>
<li><p>记录错误的过程很少出错。大多数 Ajax 通信借助 JavaScript 库的包装来处理。如果这个库本身出错，而你又要利用它记录错误，那么显然错误消息永远不会发给服务器。</p>
</li>
</ul>
<p>只要是使用try/catch语句的地方，都可以把相关错误记录下来。</p>
<h3 id="21-3-调试技术"><a href="#21-3-调试技术" class="headerlink" title="21.3 调试技术"></a>21.3 调试技术</h3><h4 id="21-3-1-把消息记录到控制台"><a href="#21-3-1-把消息记录到控制台" class="headerlink" title="21.3.1 把消息记录到控制台"></a>21.3.1 把消息记录到控制台</h4><p>所有主流浏览器都有 JavaScript 控制台，该控制台可用于查询 JavaScript 错误。另外，这些浏览器都支持通过console对象直接把 JavaScript 消息写入控制台，这个对象包含如下方法。 </p>
<ul>
<li><p>error(message)：在控制台中记录错误消息。 </p>
</li>
<li><p>info(message)：在控制台中记录信息性内容。 </p>
</li>
<li><p>log(message)：在控制台记录常规消息。 </p>
</li>
<li><p>warn(message)：在控制台中记录警告消息。 </p>
</li>
</ul>
<p>记录消息时使用的方法不同，消息显示的样式也不同。错误消息包含一个红叉图标，而警告消息包含一个黄色叹号图标。</p>
<h4 id="21-3-2-理解控制台运行时"><a href="#21-3-2-理解控制台运行时" class="headerlink" title="21.3.2 理解控制台运行时"></a>21.3.2 理解控制台运行时</h4><p>浏览器控制台是个读取求值打印循环（REPL，read-eval-print-loop），与页面的 JavaScript 运行时并发。这个运行时就像浏览器对新出现在 DOM 中的&lt;**script**&gt;标签求值一样。在控制台中执行的命令可以像页面级 JavaScript 一样访问全局和各种 API。控制台中可以执行任意数量的代码，与它可能会阻塞的任何页面级代码一样。修改、对象和回调都会保留在 DOM 和运行时中。<br>JavaScript 运行时会限制不同窗口可以访问哪些内容，因而在所有主流浏览器中都可以选择在哪个窗口中执行 JavaScript 控制台输入。</p>
<p>控制台运行时也会集成开发者工具，提供常规 JavaScript 开发中所没有的上下文调试工具。</p>
<h4 id="21-3-3-使用-JavaScript-调试器"><a href="#21-3-3-使用-JavaScript-调试器" class="headerlink" title="21.3.3 使用 JavaScript 调试器"></a>21.3.3 使用 JavaScript 调试器</h4><p>在所有主流浏览器中都可以使用的还有 JavaScript 调试器。ECMAScript 5.1 规范定义了debugger关键字，用于调用可能存在的调试功能。如果没有相关的功能，这条语句会被简单地跳过。</p>
<p>在运行时碰到这个关键字时，所有主流浏览器都会打开开发者工具面板，并在指定位置显示断点。然后，可以通过单独的浏览器控制台在断点所在的特定词法作用域中执行代码。此外，还可以执行标准的代码调试器操作（单步进入、单步跳过、继续，等等）。<br>浏览器也支持在开发者工具的源代码标签页中选择希望设置断点的代码行来手动设置断点（不使用debugger关键字）。这样设置的断点与使用debugger关键字设置的一样，只是不会在不同浏览器会话之间保持。</p>
<h4 id="21-3-4-在页面中打印消息"><a href="#21-3-4-在页面中打印消息" class="headerlink" title="21.3.4 在页面中打印消息"></a>21.3.4 在页面中打印消息</h4><p>另一种常见的打印调试消息的方式是把消息写到页面中指定的区域。这个区域可以是所有页面中都包含的元素，但仅用于调试目的；也可以是在需要时临时创建的元素。</p>
<h4 id="21-3-5-补充控制台方法"><a href="#21-3-5-补充控制台方法" class="headerlink" title="21.3.5 补充控制台方法"></a>21.3.5 补充控制台方法</h4><p>记住使用哪个日志方法（原生的console.log()和自定义的log()方法），对开发者来说是一种负担。因为console是一个全局对象，所以可以为这个对象添加方法，也可以用自定义的函数重写已有的方法，这样无论在哪里用到的日志打印方法，都会按照自定义的方式行事。</p>
<h4 id="21-3-6-抛出错误"><a href="#21-3-6-抛出错误" class="headerlink" title="21.3.6 抛出错误"></a>21.3.6 抛出错误</h4><p>抛出错误是调试代码的很好方式。如果错误消息足够具体，只要看一眼错误就可以确定原因。好的错误消息包含关于错误原因的确切信息，因此可以减少额外调试的工作量。</p>
<h3 id="21-4-旧版-IE-的常见错误"><a href="#21-4-旧版-IE-的常见错误" class="headerlink" title="21.4 旧版 IE 的常见错误"></a>21.4 旧版 IE 的常见错误</h3><h4 id="21-4-1-无效字符"><a href="#21-4-1-无效字符" class="headerlink" title="21.4.1 无效字符"></a>21.4.1 无效字符</h4><p>JavaScript 文件中的代码必须由特定字符构成。在检测到 JavaScript 文件中存在无效字符时，IE 会抛出”invalid character”错误。所谓无效字符，指的是 JavaScript 语法中没有定义过的字符。</p>
<h4 id="21-4-2-未找到成员"><a href="#21-4-2-未找到成员" class="headerlink" title="21.4.2 未找到成员"></a>21.4.2 未找到成员</h4><p>旧版 IE 中所有 DOM 对象都是用 COM 对象实现的，并非原生 JavaScript 对象。在涉及垃圾回收时，这可能会导致很多奇怪的行为。其中，”member not found”错误是 IE 中垃圾回收程序常报告的错误。<br>这个错误通常会在给一个已被销毁的对象赋值时发生。这个对象必须是 COM 对象才会出现这个消息。最好的一个例子就是event对象。IE 的event对象是作为window的一个属性存在的，会在事件发生时创建，在事件处理程序执行完毕后销毁。</p>
<h4 id="21-4-3-未知运行时错误"><a href="#21-4-3-未知运行时错误" class="headerlink" title="21.4.3 未知运行时错误"></a>21.4.3 未知运行时错误</h4><p>使用innerHTML或outerHTML属性以下面一种方式添加 HTML 时会发生未知运行时错误：比如将块级元素插入行内元素，或者在表格的任何部分（&lt;**table**&gt;、<tbody>等）访问了其中一个属性。</p>
<p>在将块级元素插入不恰当的位置时，其他浏览器会尝试纠正，这样就不会发生错误，但 IE 在这种情况下要严格得多。</p>
<h4 id="21-4-4-语法错误"><a href="#21-4-4-语法错误" class="headerlink" title="21.4.4 语法错误"></a>21.4.4 语法错误</h4><p>通常，当 IE 报告语法错误时，原因是很清楚的。一般来说，可以通过错误消息追踪到少了一个分号或括号错配。不过，有一种情况下报告的语法错误并不清楚。<br>如果网页中引用的一个外部 JavaScript 文件由于某种原因返回了非 JavaScript 代码，则 IE 会抛出语法错误。</p>
<h4 id="21-4-5-系统找不到指定资源"><a href="#21-4-5-系统找不到指定资源" class="headerlink" title="21.4.5 系统找不到指定资源"></a>21.4.5 系统找不到指定资源</h4><p>还有一个可能最没用的消息：“The system cannot locate the resource specified”（系统找不到指定资源）。这个错误会在 JavaScript向某个 URL 发送请求，而该 URL 长度超过了 IE 允许的最大 URL 长度（2083个字符）时发生。这个长度限制不仅针对 JavaScript，而且针对 IE 本身。（其他浏览器没有这么严格地限制 URL 长度。）另外，IE 对 URL 路径还有 2048 个字符的限制。</p>
<h3 id="21-5-小结"><a href="#21-5-小结" class="headerlink" title="21.5 小结"></a>21.5 小结</h3><p>对于今天复杂的 Web 应用程序而言，JavaScript 中的错误处理十分重要。未能预测什么时候会发生错误以及如何从错误中恢复，会导致糟糕的用户体验，甚至造成用户流失。大多数浏览器默认不向用户报告 JavaScript 错误，因此在开发和调试时需要自己实现错误报告。不过在生产环境中，不应该以这种方式报告错误。<br>下列方法可用于阻止浏览器对 JavaScript 错误作出反应。 </p>
<ul>
<li><p>使用try/catch语句，可以通过更合适的方式对错误做出处理，避免浏览器处理。 </p>
</li>
<li><p>定义window.onerror事件处理程序，所有没有通过try/catch处理的错误都会被该事件处理程序接收到（仅限 IE、Firefox 和 Chrome）。 </p>
</li>
</ul>
<p>开发 Web 应用程序时，应该认真考虑可能发生的错误，以及如何处理这些错误。 </p>
<ul>
<li><p>首先，应该分清哪些算重大错误，哪些不算重大错误。 </p>
</li>
<li><p>然后，要通过分析代码预测很可能发生哪些错误。由于以下因素，JavaScript 中经常出现错误： </p>
<ul>
<li><p>类型转换； </p>
</li>
<li><p>数据类型检测不足； </p>
</li>
<li><p>向服务器发送错误数据或从服务器接收到错误数据。 </p>
</li>
</ul>
</li>
</ul>
<p>IE、Firefox、Chrome、Opera 和 Safari 都有 JavaScript 调试器，有的内置在浏览器中，有的是作为扩展，需另行下载。所有调试器都能够设置断点、控制代码执行和在运行时检查变量值。</p>
<h2 id="二十二、处理-XML"><a href="#二十二、处理-XML" class="headerlink" title="二十二、处理 XML"></a>二十二、处理 XML</h2><h3 id="22-1-浏览器对-XML-DOM-的支持"><a href="#22-1-浏览器对-XML-DOM-的支持" class="headerlink" title="22.1 浏览器对 XML DOM 的支持"></a>22.1 浏览器对 XML DOM 的支持</h3><h4 id="22-1-1-DOM-Level-2-Core"><a href="#22-1-1-DOM-Level-2-Core" class="headerlink" title="22.1.1 DOM Level 2 Core"></a>22.1.1 DOM Level 2 Core</h4><p>DOM Level 2 增加了document.implementation的createDocument()方法。创建空 XML 文档：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xmldom = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createDocument</span>(namespaceUri, root, doctype);</span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中处理 XML 时，root参数通常只会使用一次，因为这个参数定义的是 XML DOM中document元素的标签名。namespaceUri参数用得很少，因为在 JavaScript 中很难管理命名空间。doctype参数则更是少用。<br>要创建一个document对象标签名为&lt;**root**&gt;的新 XML 文档，可以使用以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xmldom = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createDocument</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xmldom.<span class="property">documentElement</span>.<span class="property">tagName</span>); <span class="comment">// &quot;root&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = xmldom.<span class="title function_">createElement</span>(<span class="string">&quot;child&quot;</span>); </span><br><span class="line">xmldom.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使不指定命名空间和文档类型，参数还是要传的。</p>
</blockquote>
<p>要检查浏览器是否支持 DOM Level 2 XML，可以使用如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasXmlDom = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;XML&quot;</span>, <span class="string">&quot;2.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="22-1-2-DOMParser类型"><a href="#22-1-2-DOMParser类型" class="headerlink" title="22.1.2 DOMParser类型"></a>22.1.2 DOMParser类型</h4><p>Firefox 专门为把 XML 解析为 DOM 文档新增了DOMParser类型，后来所有其他浏览器也实现了该类型。要使用DOMParser，需要先创建它的一个实例，然后再调用parseFromString()方法。这个方法接收两个参数：要解析的 XML 字符串和内容类型（始终应该是”text/html”）。返回值是Document的实例。</p>
<p>DOMParser只能解析格式良好的 XML，因此不能把 HTML 解析为 HTML 文档。在发生解析错误时，不同浏览器的行为也不一样。Firefox、Opera、Safari 和 Chrome 在发生解析错误时，parseFromString()方法仍会返回一个Document对象，只不过其document元素是&lt;**parsererror**&gt;，该元素的内容为解析错误的描述。下面是一个解析错误的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;parsererror xmlns=<span class="string">&quot;http://www.mozilla.org/newlayout/xml/parsererror.xml&quot;</span>&gt;<span class="variable constant_">XML</span> </span><br><span class="line"><span class="title class_">Parsing</span> <span class="title class_">Error</span>: no element found <span class="title class_">Location</span>: <span class="attr">file</span>:<span class="comment">// /I:/My%20Writing/My%20Books/ </span></span><br><span class="line"><span class="title class_">Professional</span>%20JavaScript/<span class="title class_">Second</span>%20Edition/<span class="title class_">Examples</span>/<span class="title class_">Ch15</span>/<span class="title class_">DOMParserExample2</span>.<span class="property">js</span> <span class="title class_">Line</span> </span><br><span class="line"><span class="title class_">Number</span> <span class="number">1</span>, <span class="title class_">Column</span> <span class="number">7</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">sourcetext</span>&gt;</span><span class="tag">&lt;<span class="name">root</span>&gt;</span> ------^<span class="tag">&lt;/<span class="name">sourcetext</span>&gt;</span><span class="tag">&lt;/<span class="name">parsererror</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>Firefox 和 Opera 都会返回这种格式的文档。Safari 和 Chrome 返回的文档会把&lt;**parsererror**&gt;元素嵌入在发生解析错误的位置。早期 IE 版本会在调用parseFromString()的地方抛出解析错误。由于这些差异，最好使用try/catch来判断是否发生了解析错误，如果没有错误，则通过getElementsByTagName()方法查找文档中是否包含&lt;**parsererror**&gt;元素。</p>
<h4 id="22-1-3-XMLSerializer类型"><a href="#22-1-3-XMLSerializer类型" class="headerlink" title="22.1.3 XMLSerializer类型"></a>22.1.3 XMLSerializer类型</h4><p>与DOMParser相对，Firefox 也增加了XMLSerializer类型用于提供相反的功能：把 DOM 文档序列化为 XML 字符串。此后，XMLSerializer也得到了所有主流浏览器的支持。 要序列化 DOM文档，必须创建XMLSerializer的新实例，然后把文档传给serializeToString()方法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serializer = <span class="keyword">new</span> <span class="title class_">XMLSerializer</span>(); </span><br><span class="line"><span class="keyword">let</span> xml = serializer.<span class="title function_">serializeToString</span>(xmldom); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xml);</span><br></pre></td></tr></table></figure>

<p>XMLSerializer能够序列化任何有效的 DOM 对象，包括个别节点和 HTML 文档。在把 HTML 文档传给serializeToString()时，这个文档会被当成 XML 文档，因此得到的结果是格式良好的。</p>
<blockquote>
<p>如果给serializeToString()传入非 DOM 对象，就会导致抛出错误。</p>
</blockquote>
<h3 id="22-2-浏览器对-XPath-的支持"><a href="#22-2-浏览器对-XPath-的支持" class="headerlink" title="22.2 浏览器对 XPath 的支持"></a>22.2 浏览器对 XPath 的支持</h3><p>XPath 是为了在 DOM 文档中定位特定节点而创建的，因此它对 XML 处理很重要。</p>
<h4 id="22-2-1-DOM-Level-3-XPath"><a href="#22-2-1-DOM-Level-3-XPath" class="headerlink" title="22.2.1 DOM Level 3 XPath"></a>22.2.1 DOM Level 3 XPath</h4><p>DOM Level 3 XPath 规范定义了接口，用于在 DOM 中求值 XPath 表达式。要确定浏览器是否支持DOM Level 3 XPath，可以使用以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> supportsXPath = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;XPath&quot;</span>, <span class="string">&quot;3.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最重要的两个是XPathEvaluator和XPathResult。XPathEvaluator用于在特定上下文中求值 XPath 表达式，包含三个方法。</p>
<ul>
<li><p>createExpression(expression, nsresolver)，用于根据 XPath 表达式及相应的命名空间计算得到一个XPathExpression，XPathExpression是查询的编译版本。这适合于同样的查询要运行多次的情况。</p>
</li>
<li><p>createNSResolver(node)，基于node的命名空间创建新的XPathNSResolver对象。当对使用名称空间的 XML 文档求值时，需要XPathNSResolver对象。</p>
</li>
<li><p>evaluate(expression, context, nsresolver, type, result)，根据给定的上下文和命名空间对 XPath 进行求值。其他参数表示如何返回结果。</p>
</li>
</ul>
<p>Document类型通常是通过XPathEvaluator接口实现的，因此可以创建XPathEvaluator的实例，或使用Document实例上的方法（包括 XML 和 HTML 文档）。<br>在上述三个方法中，使用最频繁的是evaluate()。这个方法接收五个参数：XPath 表达式、上下文节点、命名空间解析器、返回的结果类型和XPathResult对象（用于填充结果，通常是null，因为结果也可能是函数值）。第三个参数，命名空间解析器，只在 XML 代码使用 XML 命名空间的情况下有必要。如果没有使用命名空间，这个参数也应该是null。第四个参数要返回值的类型是如下 10 个常量值之一。</p>
<ul>
<li><p>XPathResult.ANY_TYPE：返回适合 XPath 表达式的数据类型。</p>
</li>
<li><p>XPathResult.NUMBER_TYPE：返回数值。</p>
</li>
<li><p>XPathResult.STRING_TYPE：返回字符串值。</p>
</li>
<li><p>XPathResult.BOOLEAN_TYPE：返回布尔值。</p>
</li>
<li><p>XPathResult.UNORDERED_NODE_ITERATOR_TYPE：返回匹配节点的集合，但集合中节点的顺序可能与它们在文档中的顺序不一致。</p>
</li>
<li><p>XPathResult.ORDERED_NODE_ITERATOR_TYPE：返回匹配节点的集合，集合中节点的顺序与它们在文档中的顺序一致。这是非常常用的结果类型。</p>
</li>
<li><p>XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，在文档外部捕获节点，因此对文档的进一步修改不会影响该节点集合。集合中节点的顺序可能与它们在文档中的顺序不一致。</p>
</li>
<li><p>XPathResult.ORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，在文档外部捕获节点，因此对文档的进一步修改不会影响这个节点集合。集合中节点的顺序与它们在文档中的顺序一致。</p>
</li>
<li><p>XPathResult.ANY_UNORDERED_NODE_TYPE：返回匹配节点的集合，但集合中节点的顺序可能与它们在文档中的顺序不一致。</p>
</li>
<li><p>XPathResult.FIRST_ORDERED_NODE_TYPE：返回只有一个节点的节点集合，包含文档中第一个匹配的节点。</p>
</li>
</ul>
<p>指定的结果类型决定了如何获取结果的值。</p>
<p>如果指定了快照结果类型（无论有序还是无序），都必须使用snapshotItem()方法和snapshotLength属性获取结果，如以下代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = xmldom.evaluate(<span class="string">&quot;employee/name&quot;</span>, xmldom.<span class="property">documentElement</span>, <span class="literal">null</span>, </span><br><span class="line">                  <span class="title class_">XPathResult</span>.<span class="property">ORDERED_NODE_SNAPSHOT_TYPE</span>, <span class="literal">null</span>); </span><br><span class="line"><span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len=result.<span class="property">snapshotLength</span>; i &lt; len; i++) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">snapshotItem</span>(i).<span class="property">tagName</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-2-2-单个节点结果"><a href="#22-2-2-单个节点结果" class="headerlink" title="22.2.2 单个节点结果"></a>22.2.2 单个节点结果</h4><p>XPathResult.FIRST_ORDERED_NODE_TYPE结果类型返回匹配的第一个节点，可以通过结果的singleNodeValue属性获取。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = xmldom.evaluate(<span class="string">&quot;employee/name&quot;</span>, xmldom.<span class="property">documentElement</span>, <span class="literal">null</span>, </span><br><span class="line">                  <span class="title class_">XPathResult</span>.<span class="property">FIRST_ORDERED_NODE_TYPE</span>, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">singleNodeValue</span>.<span class="property">tagName</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他查询一样，如果没有匹配的节点，evaluate()返回null。如果有一个匹配的节点，则要使用singleNodeValue属性取得该节点。这对XPathResult.FIRST_ORDERED_NODE_TYPE也一样。</p>
<h4 id="22-2-3-简单类型结果"><a href="#22-2-3-简单类型结果" class="headerlink" title="22.2.3 简单类型结果"></a>22.2.3 简单类型结果</h4><p>使用布尔值、数值和字符串XPathResult类型，可以根据 XPath 获取简单、非节点数据类型。这些结果类型返回的值需要分别使用booleanValue、numberValue和stringValue属性获取。对于布尔值类型，如果至少有一个节点匹配 XPath 表达式，booleanValue就是true；否则，booleanValue为false。</p>
<p>如果有任何节点匹配”employee/name”，booleanValue属性就等于true。<br>对于数值类型，XPath 表达式必须使用返回数值的 XPath 函数，如count()可以计算匹配给定模式的节点数。</p>
<p>对于字符串类型，evaluate()方法查找匹配 XPath 表达式的第一个节点，然后返回其第一个子节点的值，前提是第一个子节点是文本节点。如果不是，就返回空字符串。</p>
<h4 id="22-2-4-默认类型结果"><a href="#22-2-4-默认类型结果" class="headerlink" title="22.2.4 默认类型结果"></a>22.2.4 默认类型结果</h4><p>所有 XPath 表达式都会自动映射到特定类型的结果。设置特定结果类型会限制表达式的输出。不过，可以使用XPathResult.ANY_TYPE类型让求值自动返回默认类型结果。通常，默认类型结果是布尔值、数值、字符串或无序节点迭代器。要确定返回的结果类型，可以访问求值结果的resultType属性，如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = xmldom.evaluate(<span class="string">&quot;employee/name&quot;</span>, xmldom.<span class="property">documentElement</span>, <span class="literal">null</span>, </span><br><span class="line">                  <span class="title class_">XPathResult</span>.<span class="property">ANY_TYPE</span>, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123; </span><br><span class="line">  <span class="keyword">switch</span>(result.<span class="property">resultType</span>) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">XPathResult</span>.<span class="property">STRING_TYPE</span>: </span><br><span class="line">      <span class="comment">// 处理字符串类型 </span></span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">XPathResult</span>.<span class="property">NUMBER_TYPE</span>: </span><br><span class="line">      <span class="comment">// 处理数值类型 </span></span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">XPathResult</span>.<span class="property">BOOLEAN_TYPE</span>: </span><br><span class="line">      <span class="comment">// 处理布尔值类型 </span></span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">XPathResult</span>.<span class="property">UNORDERED_NODE_ITERATOR_TYPE</span>: </span><br><span class="line">      <span class="comment">// 处理无序节点迭代器类型 </span></span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">      <span class="comment">// 处理其他可能的结果类型 </span></span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用XPathResult.ANY_TYPE可以让使用 XPath 变得更自然，但在返回结果后则需要增加额外的判断和处理。</p>
<h4 id="22-2-5-命名空间支持"><a href="#22-2-5-命名空间支持" class="headerlink" title="22.2.5 命名空间支持"></a>22.2.5 命名空间支持</h4><p>对于使用命名空间的 XML 文档，必须告诉XPathEvaluator命名空间信息，才能进行正确求值。</p>
<p>第一种处理命名空间的方式是通过createNSResolver()方法创建XPathNSResolver对象。这个方法只接收一个参数，即包含命名空间定义的文档节点。</p>
<p>第二种处理命名空间的方式是定义一个接收命名空间前缀并返回相应 URI 的函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nsresolver = <span class="keyword">function</span>(<span class="params">prefix</span>) &#123; </span><br><span class="line">  <span class="keyword">switch</span>(prefix) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;wrox&quot;</span>: <span class="keyword">return</span> <span class="string">&quot;http://www.wrox.com/&quot;</span>; </span><br><span class="line">    <span class="comment">// 其他前缀及返回值 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = xmldom.evaluate(<span class="string">&quot;count(wrox:book/wrox:author)&quot;</span>, </span><br><span class="line">        xmldom.<span class="property">documentElement</span>, nsresolver, <span class="title class_">XPathResult</span>.<span class="property">NUMBER_TYPE</span>, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">numberValue</span>);</span><br></pre></td></tr></table></figure>

<p>在并不知晓文档的哪个节点包含命名空间定义时，可以采用这种定义命名空间解析函数的方式。只要知道前缀和 URI，就可以定义这样一个函数，然后把它作为第三个参数传给evaluate()。</p>
<h3 id="22-3-浏览器对-XSLT-的支持"><a href="#22-3-浏览器对-XSLT-的支持" class="headerlink" title="22.3 浏览器对 XSLT 的支持"></a>22.3 浏览器对 XSLT 的支持</h3><p>可扩展样式表语言转换（XSLT，Extensible Stylesheet Language Transformations）是与 XML 相伴的一种技术，可以利用 XPath 将一种文档表示转换为另一种文档表示。</p>
<h4 id="22-3-1-XSLTProcessor类型"><a href="#22-3-1-XSLTProcessor类型" class="headerlink" title="22.3.1 XSLTProcessor类型"></a>22.3.1 XSLTProcessor类型</h4><p>Mozilla 通过增加了一个新类型XSLTProcessor，在 JavaScript 中实现了对 XSLT 的支持。通过使用XSLTProcessor类型，开发者可以使用 XSLT 转换 XML 文档，其方式类似于在 IE 中使用 XSL 处理器。</p>
<p>与 IE 的实现一样，第一步是加载两个 DOM 文档：XML 文档和 XSLT 文档。然后，使用importStyleSheet()方法创建一个新的XSLTProcessor，将 XSLT 指定给它，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> processor = <span class="keyword">new</span> <span class="title class_">XSLTProcessor</span>() </span><br><span class="line">processor.importStylesheet(xsltdom);</span><br></pre></td></tr></table></figure>

<p>最后一步是执行转换，有两种方式。如果想返回完整的 DOM文档，就调用transformToDocument()；如果想得到文档片段，则可以调用transformToFragment()。一般来说，使用transformToFragment()的唯一原因是想把结果添加到另一个 DOM 文档。<br>如果使用transformToDocument()，只要传给它 XML DOM，就可以将结果当作另一个完全不同的 DOM 来使用。</p>
<p>transformToFragment()方法接收两个参数：要转换的 XML DOM 和最终会拥有结果片段的文档。这可以确保新文本片段可以在目标文档中使用。</p>
<p>如果 XSLT 样式表的输出格式是”xml”或”html”，则创建文档或文档片段理所当然。不过，如果输出格式是”text”，则通常意味着只想得到转换后的文本结果。然而，没有方法直接返回文本。在输出格式为”text”时调用transformToDocument()会返回完整的 XML 文档，但这个文档的内容会因浏览器而异。比如，Safari 返回整个 HTML 文档，而 Opera 和 Firefox 则返回只包含一个元素的文档，其中输出就是该元素的文本。<br>解决方案是调用transformToFragment()，返回只有一个子节点、其中包含结果文本的文档片段。之后，可以再使用以下代码取得文本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = processor.<span class="title function_">transformToFragment</span>(xmldom, <span class="variable language_">document</span>); </span><br><span class="line"><span class="keyword">let</span> text = fragment.<span class="property">firstChild</span>.<span class="property">nodeValue</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br></pre></td></tr></table></figure>

<p>这种方式在所有支持的浏览器中都可以正确返回转换后的输出文本。</p>
<h4 id="22-3-2-使用参数"><a href="#22-3-2-使用参数" class="headerlink" title="22.3.2 使用参数"></a>22.3.2 使用参数</h4><p>XSLTProcessor还允许使用setParameter()方法设置 XSLT 参数。该方法接收三个参数：命名空间 URI、参数本地名称和要设置的值。通常，命名空间 URI 是null，本地名称就是参数名称。setParameter()方法必须在调用transformToDocument()或transformToFragment()之前调用。例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> processor = <span class="keyword">new</span> <span class="title class_">XSLTProcessor</span>() </span><br><span class="line">processor.importStylesheet(xsltdom); </span><br><span class="line">processor.<span class="title function_">setParameter</span>(<span class="literal">null</span>, <span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> result = processor.<span class="title function_">transformToDocument</span>(xmldom);</span><br></pre></td></tr></table></figure>

<p>与参数相关的还有两个方法：getParameter()和removeParameter()。它们分别用于取得参数的当前值和移除参数的值。它们都以一个命名空间 URI（同样，一般是null）和参数的本地名称为参数。</p>
<h4 id="22-3-3-重置处理器"><a href="#22-3-3-重置处理器" class="headerlink" title="22.3.3 重置处理器"></a>22.3.3 重置处理器</h4><p>每个XSLTProcessor实例都可以重用于多个转换，只是要使用不同的 XSLT 样式表。处理器的reset()方法可以删除所有参数和样式表。然后，可以使用importStylesheet()方法加载不同的XSLT 样表，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> processor = <span class="keyword">new</span> <span class="title class_">XSLTProcessor</span>() </span><br><span class="line">processor.importStylesheet(xsltdom); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行某些转换 </span></span><br><span class="line"></span><br><span class="line">processor.<span class="title function_">reset</span>(); </span><br><span class="line">processor.importStylesheet(xsltdom2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 再执行一些转换</span></span><br></pre></td></tr></table></figure>

<h3 id="22-4-小结"><a href="#22-4-小结" class="headerlink" title="22.4 小结"></a>22.4 小结</h3><p>浏览器对使用 JavaScript 处理 XML 实现及相关技术相当支持。然而，由于早期缺少规范，常用的功能出现了不同实现。DOM Level 2 提供了创建空 XML 文档的 API，但不能解析和序列化。浏览器为解析和序列化 XML 实现了两个新类型。</p>
<ul>
<li><p>DOMParser类型是简单的对象，可以将 XML 字符串解析为 DOM 文档。</p>
</li>
<li><p>XMLSerializer类型执行相反操作，将 DOM 文档序列化为 XML 字符串。</p>
</li>
</ul>
<p>基于所有主流浏览器的实现，DOM Level 3 新增了针对 XPath API 的规范。该 API 可以让 JavaScript针对 DOM 文档执行任何 XPath 查询并得到不同数据类型的结果。<br>最后一个与 XML 相关的技术是 XSLT，目前并没有规范定义其 API。Firefox最早增加了XSLTProcessor类型用于通过 JavaScript 处理转换。 </p>
<h2 id="二十三、JSON"><a href="#二十三、JSON" class="headerlink" title="二十三、JSON"></a>二十三、JSON</h2><p>JSON 是 JavaScript 的严格子集，利用 JavaScript 中的几种模式来表示结构化数据。理解 JSON 最关键的一点是要把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript，它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。</p>
<h3 id="23-1-语法"><a href="#23-1-语法" class="headerlink" title="23.1 语法"></a>23.1 语法</h3><p>JSON 语法支持表示 3 种类型的值。</p>
<ul>
<li><p>简单值：字符串、数值、布尔值和null可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值undefined不可以。</p>
</li>
<li><p>对象：第一种复杂数据类型，对象表示有序键/值对。每个值可以是简单值，也可以是复杂类型。</p>
</li>
<li><p>数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。</p>
</li>
</ul>
<p>JSON 没有变量、函数或对象实例的概念。JSON 的所有记号都只为表示结构化数据。</p>
<h4 id="23-1-1-简单值"><a href="#23-1-1-简单值" class="headerlink" title="23.1.1 简单值"></a>23.1.1 简单值</h4><p>最简单的 JSON 可以是一个数值。</p>
<p>JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。<br>布尔值和null本身也是有效的 JSON 值。不过，实践中更多使用 JSON 表示比较复杂的数据结构，其中会包含简单值。</p>
<h4 id="23-1-2-对象"><a href="#23-1-2-对象" class="headerlink" title="23.1.2 对象"></a>23.1.2 对象</h4><p>对象使用与 JavaScript 对象字面量略为不同的方式表示。</p>
<p>JSON 中的对象必须使用双引号把属性名包围起来。</p>
<p>与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，没有变量声明（JSON 中没有变量）。其次，最后没有分号（不需要，因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">29</span>, </span><br><span class="line">  <span class="string">&quot;school&quot;</span>: &#123; </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Merrimack College&quot;</span>, </span><br><span class="line">    <span class="string">&quot;location&quot;</span>: <span class="string">&quot;North Andover, MA&quot;</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>与 JavaScript 不同，JSON 中的对象属性名必须始终带双引号。手动编写 JSON 时漏掉这些双引号或用单引号是常见错误。</p>
<h4 id="23-1-3-数组"><a href="#23-1-3-数组" class="headerlink" title="23.1.3 数组"></a>23.1.3 数组</h4><p>JSON 的第二种复杂数据类型是数组。数组在 JSON 中使用 JavaScript 的数组字面量形式表示。</p>
<p>在 JSON 中可以使用类似语法表示相同的数组。</p>
<p>同样，这里没有变量，也没有分号。数组和对象可以组合使用，以表示更加复杂的数据结构。</p>
<p>对象和数组通常会作为 JSON 数组的顶级结构（尽管不是必需的），以便创建大型复杂数据结构。</p>
<h3 id="23-2-解析与序列化"><a href="#23-2-解析与序列化" class="headerlink" title="23.2 解析与序列化"></a>23.2 解析与序列化</h3><p>JSON 可以直接被解析成可用的 JavaScript 对象。</p>
<h4 id="23-2-1-JSON-对象"><a href="#23-2-1-JSON-对象" class="headerlink" title="23.2.1 JSON 对象"></a>23.2.1 JSON 对象</h4><p>早期的 JSON 解析器基本上就相当于 JavaScript 的eval()函数。因为 JSON 是 JavaScript 语法的子集，所以eval()可以解析、解释，并将其作为 JavaScript 对象和数组返回。ECMAScript 5 增加了JSON全局对象，正式引入解析 JSON 的能力。</p>
<p>JSON 对象有两个方法：stringify()和parse()。在简单的情况下，这两个方法分别可以将JavaScript 序列化为 JSON 字符串，以及将 JSON 解析为原生 JavaScript 值。</p>
<p>JSON.stringify()把一个 JavaScript 对象序列化为一个 JSON 字符串，默认情况下，JSON.stringify()会输出不包含空格或缩进的 JSON 字符串。</p>
<p>在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为undefined的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表示。<br>JSON 字符串可以直接传给JSON.parse()，然后得到相应的 JavaScript 值。</p>
<p>如果给JSON.parse()传入的 JSON 字符串无效，则会导致抛出错误。</p>
<h4 id="23-2-2-序列化选项"><a href="#23-2-2-序列化选项" class="headerlink" title="23.2.2 序列化选项"></a>23.2.2 序列化选项</h4><p>JSON.stringify()方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。单独或组合使用这些参数可以更好地控制 JSON 序列化。</p>
<ol>
<li>过滤结果</li>
</ol>
<p>如果第二个参数是一个数组，那么JSON.stringify()返回的结果只会包含该数组中列出的对象属性。</p>
<p>如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个key决定要对相应属性执行什么操作。这个key始终是字符串，只是在值不属于某个键/值对时会是空字符串。<br>为了改变对象的序列化，返回的值就是相应key应该包含的结果。注意，返回undefined会导致属性被忽略。</p>
<blockquote>
<p>函数过滤器会应用到要序列化的对象所包含的所有对象，因此如果数组中包含多个具有这些属性的对象，则序列化之后每个对象都只会剩下上面这些属性。</p>
</blockquote>
<ol start="2">
<li>字符串缩进</li>
</ol>
<p>JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。</p>
<blockquote>
<p>除了缩进，JSON.stringify()方法还为方便阅读插入了换行符。这个行为对于所有有效的缩进参数都会发生。（只缩进不换行也没什么用。）最大缩进值为 10，大于 10 的值会自动设置为 10。</p>
</blockquote>
<p>如果缩进参数是一个字符串而非数值，那么 JSON 字符串中就会使用这个字符串而不是空格来缩进。使用字符串，也可以将缩进字符设置为 Tab 或任意字符。</p>
<ol start="3">
<li>toJSON()方法</li>
</ol>
<p>有时候，对象需要在JSON.stringify()之上自定义 JSON 序列化。此时，可以在要序列化的对象中添加toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示。事实上，原生Date对象就有一个toJSON()方法，能够自动将 JavaScript 的Date对象转换为 ISO 8601 日期字符串（本质上与在Date对象上调用toISOString()方法一样）。<br>下面的对象为自定义序列化而添加了一个toJSON()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line">  <span class="attr">authors</span>: [ </span><br><span class="line">    <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line">  ], </span><br><span class="line">  <span class="attr">edition</span>: <span class="number">4</span>, </span><br><span class="line">  <span class="attr">year</span>: <span class="number">2017</span>, </span><br><span class="line">  <span class="attr">toJSON</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">title</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(book);</span><br></pre></td></tr></table></figure>

<p>toJSON()方法可以返回任意序列化值，都可以起到相应的作用。如果对象被嵌入在另一个对象中，返回undefined会导致值变成null；或者如果是顶级对象，则本身就是undefined。注意，箭头函数不能用来定义toJSON()方法。主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适。<br>toJSON()方法可以与过滤函数一起使用，因此理解不同序列化流程的顺序非常重要。在把对象传给JSON.stringify()时会执行如下步骤。</p>
<p>(1) 如果可以获取实际的值，则调用toJSON()方法获取实际的值，否则使用默认的序列化。</p>
<p>(2) 如果提供了第二个参数，则应用过滤。传入过滤函数的值就是第(1)步返回的值。</p>
<p>(3) 第(2)步返回的每个值都会相应地进行序列化。</p>
<p>(4) 如果提供了第三个参数，则相应地进行缩进。</p>
<h4 id="23-2-3-解析选项"><a href="#23-2-3-解析选项" class="headerlink" title="23.2.3 解析选项"></a>23.2.3 解析选项</h4><p>JSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键/值对都调用一次。为区别于传给JSON.stringify()的起过滤作用的替代函数（replacer），这个函数被称为还原函数（reviver）。实际上它们的格式完全一样，即还原函数也接收两个参数，属性名（key）和属性值（value），另外也需要返回值。<br>如果还原函数返回undefined，则结果中就会删除相应的键。如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。还原函数经常被用于把日期字符串转换为Date对象。</p>
<h3 id="23-3-小结"><a href="#23-3-小结" class="headerlink" title="23.3 小结"></a>23.3 小结</h3><p>JSON 是一种轻量级数据格式，可以方便地表示复杂数据结构。这个格式使用 JavaScript 语法的一个子集表示对象、数组、字符串、数值、布尔值和null。虽然 XML 也能胜任同样的角色，但 JSON 更简洁，JavaScript 支持也更好。更重要的是，所有浏览器都已经原生支持全局JSON对象。<br>ECMAScript 5 定义了原生JSON对象，用于将 JavaScript 对象序列化为 JSON 字符串，以及将 JSON数组解析为 JavaScript 对象。JSON.stringify()和JSON.parse()方法分别用于实现这两种操作。这两个方法都有一些选项可以用来改变默认的行为，以实现过滤或修改流程。</p>
<h2 id="二十四、网络请求与远程资源"><a href="#二十四、网络请求与远程资源" class="headerlink" title="二十四、网络请求与远程资源"></a>二十四、网络请求与远程资源</h2><h3 id="24-1-XMLHttpRequest对象"><a href="#24-1-XMLHttpRequest对象" class="headerlink" title="24.1 XMLHttpRequest对象"></a>24.1 XMLHttpRequest对象</h3><p>这个对象是通过 ActiveX 对象实现并包含在 MSXML 库中的。为此，XHR 对象的 3 个版本在浏览器中分别被暴露为MSXML2.XMLHttp、MSXML2.XMLHttp.3.0和MXSML2.XMLHttp.6.0。</p>
<p>所有现代浏览器都通过XMLHttpRequest构造函数原生支持 XHR 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>

<h4 id="24-1-1-使用-XHR"><a href="#24-1-1-使用-XHR" class="headerlink" title="24.1.1 使用 XHR"></a>24.1.1 使用 XHR</h4><p>使用 XHR 对象首先要调用open()方法，这个方法接收 3 个参数：请求类型（”get”、”post”等）、请求 URL，以及表示请求是否异步的布尔值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>首先，这里的 URL 是相对于代码所在页面的，当然也可以使用绝对 URL。其次，调用open()不会实际发送请求，只是为发送请求做好准备。</p>
<blockquote>
<p>只能访问同源 URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与发送请求的页面在任何方面有所不同，则会抛出安全错误。</p>
</blockquote>
<p>要发送定义好的请求，必须像下面这样调用send()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">false</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传null，因为这个参数在某些浏览器中是必需的。调用send()之后，请求就会发送到服务器。<br>因为这个请求是同步的，所以 JavaScript 代码会等待服务器响应之后再继续执行。收到响应后，XHR对象的以下属性会被填充上数据。</p>
<ul>
<li><p>responseText：作为响应体返回的文本。</p>
</li>
<li><p>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，那就是包含响应数据的 XML DOM 文档。</p>
</li>
<li><p>status：响应的 HTTP 状态。</p>
</li>
<li><p>statusText：响应的 HTTP 状态描述。</p>
</li>
</ul>
<p>收到响应后，第一步要检查status属性以确保响应成功返回。一般来说，HTTP 状态码为 2xx 表示成功。此时，responseText或responseXML（如果内容类型正确）属性中会有内容。如果 HTTP状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。为确保收到正确的响应，应该检查这些状态，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">false</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line">  <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是什么响应内容类型，responseText属性始终会保存响应体，而responseXML则对于非 XML 数据是null。</p>
<p>多数情况下最好使用异步请求，这样可以不阻塞JavaScript 代码继续执行。XHR 对象有一个readyState属性，表示当前处在请求/响应过程的哪个阶段。这个属性有如下可能的值。</p>
<ul>
<li><p>0：未初始化（Uninitialized）。尚未调用open()方法。</p>
</li>
<li><p>1：已打开（Open）。已调用open()方法，尚未调用send()方法。</p>
</li>
<li><p>2：已发送（Sent）。已调用send()方法，尚未收到响应。</p>
</li>
<li><p>3：接收中（Receiving）。已经收到部分响应。</p>
</li>
<li><p>4：完成（Complete）。已经收到所有响应，可以使用了。</p>
</li>
</ul>
<p>每次readyState从一个值变成另一个值，都会触发readystatechange事件。可以借此机会检查readyState的值。一般来说，我们唯一关心的readyState值是 4，表示数据已就绪。为保证跨浏览器兼容，onreadystatechange事件处理程序应该在调用open()之前赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>与其他事件处理程序不同，onreadystatechange事件处理程序不会收到event对象。在事件处理程序中，必须使用 XHR 对象本身来确定接下来该做什么。</p>
<blockquote>
<p>由于onreadystatechange事件处理程序的作用域问题，这个例子在onreadystatechange事件处理程序中使用了xhr对象而不是this对象。使用this可能导致功能失败或导致错误，取决于用户使用的是什么浏览器。因此还是使用保存 XHR 对象的变量更保险一些。</p>
</blockquote>
<p>在收到响应之前如果想取消异步请求，可以调用abort()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure>

<p>调用这个方法后，XHR 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中断请求后，应该取消对 XHR 对象的引用。由于内存问题，不推荐重用 XHR 对象。</p>
<h4 id="24-1-2-HTTP-头部"><a href="#24-1-2-HTTP-头部" class="headerlink" title="24.1.2 HTTP 头部"></a>24.1.2 HTTP 头部</h4><p>每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一些方法暴露与请求和响应相关的头部字段。<br>默认情况下，XHR 请求会发送以下头部字段。</p>
<ul>
<li><p>Accept：浏览器可以处理的内容类型。</p>
</li>
<li><p>Accept-Charset：浏览器可以显示的字符集。</p>
</li>
<li><p>Accept-Encoding：浏览器可以处理的压缩编码类型。</p>
</li>
<li><p>Accept-Language：浏览器使用的语言。</p>
</li>
<li><p>Connection：浏览器与服务器的连接类型。</p>
</li>
<li><p>Cookie：页面中设置的 Cookie。</p>
</li>
<li><p>Host：发送请求的页面所在的域。</p>
</li>
<li><p>Referer：发送请求的页面的 URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容性也必须将错就错。（正确的拼写应该是 Referrer。）</p>
</li>
<li><p>User-Agent：浏览器的用户代理字符串。</p>
</li>
</ul>
<p>如果需要发送额外的请求头部，可以使用setRequestHeader()方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在open()之后、send()之前调用setRequestHeader()，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;MyHeader&quot;</span>, <span class="string">&quot;MyValue&quot;</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>服务器通过读取自定义头部可以确定适当的操作。自定义头部一定要区别于浏览器正常发送的头部，否则可能影响服务器正常响应。有些浏览器允许重写默认头部，有些浏览器则不允许。<br>可以使用getResponseHeader()方法从 XHR 对象获取响应头部，只要传入要获取头部的名称即可。如果想取得所有响应头部，可以使用getAllResponseHeaders()方法，这个方法会返回包含所有响应头部的字符串。</p>
<p>服务器可以使用头部向浏览器传递额外的结构化数据。getAllResponseHeaders()方法通常返回类似如下的字符串：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date: Sun, 14 Nov 2004 18:04:03 GMT </span><br><span class="line">Server: Apache/1.3.29 (Unix) </span><br><span class="line">Vary: Accept </span><br><span class="line">X-Powered-By: PHP/4.3.8 </span><br><span class="line">Connection: close </span><br><span class="line">Content-Type: text/html; charset=iso-8859-1</span><br></pre></td></tr></table></figure>

<p>通过解析以上头部字段的输出，就可以知道服务器发送的所有头部，而不需要单独去检查了。</p>
<h4 id="24-1-3-GET-请求"><a href="#24-1-3-GET-请求" class="headerlink" title="24.1.3 GET 请求"></a>24.1.3 GET 请求</h4><p>最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时，需要在 GET 请求的 URL后面添加查询字符串参数。对 XHR 而言，查询字符串必须正确编码后添加到 URL 后面，然后再传给open()方法。<br>发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用encodeURIComponent()编码，所有名/值对必须以和号（&amp;）分隔，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php?name1=value1&amp;name2=value2&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>可以使用以下函数将查询字符串参数添加到现有的 URL 末尾：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addURLParam</span>(<span class="params">url, name, value</span>) &#123; </span><br><span class="line">  url += (url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) == -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>); </span><br><span class="line">  url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value); </span><br><span class="line">  <span class="keyword">return</span> url; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-1-4-POST-请求"><a href="#24-1-4-POST-请求" class="headerlink" title="24.1.4 POST 请求"></a>24.1.4 POST 请求</h4><p>POST 请求用于向服务器发送应该保存的数据。每个 POST 请求都应该在请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据可以是任意格式。要初始化 POST 请求，open()方法的第一个参数要传”post”，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>接下来就是要给send()方法传入要发送的数据。因为 XHR 最初主要设计用于发送 XML，所以可以传入序列化之后的 XML DOM 文档作为请求体。当然，也可以传入任意字符串。<br>默认情况下，对服务器而言，POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST数据才能取得浏览器发送的数据。不过，可以使用 XHR 模拟表单提交。为此，第一步需要把ContentType头部设置为”application/x-www-formurlencoded”，这是提交表单时使用的内容类型。第二步是创建对应格式的字符串。POST 数据此时使用与查询字符串相同的格式。如果网页中确实有一个表单需要序列化并通过 XHR 发送到服务器，则可以使用第 14 章的serialize()函数来创建相应的字符串，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">submitData</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123; </span><br><span class="line">      <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">  xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>); </span><br><span class="line">  <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;user-info&quot;</span>); </span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="title function_">serialize</span>(form)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>POST 请求相比 GET 请求要占用更多资源。从性能方面说，发送相同数量的数据，GET 请求比 POST 请求要快两倍。</p>
</blockquote>
<h4 id="24-1-5-XMLHttpRequest-Level-2"><a href="#24-1-5-XMLHttpRequest-Level-2" class="headerlink" title="24.1.5 XMLHttpRequest Level 2"></a>24.1.5 XMLHttpRequest Level 2</h4><p>XMLHttpRequest Level 1 只是把已经存在的 XHR 对象的实现细节明确了一下。XMLHttpRequest Level 2又进一步发展了 XHR 对象。并非所有浏览器都实现了 XMLHttpRequest Level 2 的所有部分，但所有浏览器都实现了其中部分功能。</p>
<ol>
<li>FormData类型</li>
</ol>
<p>FormData类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR发送。下面的代码创建了一个FormData对象，并填充了一些数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>(); </span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>append()方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意多个键/值对数据。此外，通过直接给FormData构造函数传入一个表单元素，也可以将表单中的数据作为键/值对填充进去：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>(<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>有了FormData实例，可以像下面这样直接传给 XHR 对象的send()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;user-info&quot;</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="keyword">new</span> <span class="title class_">FormData</span>(form));</span><br></pre></td></tr></table></figure>

<p>使用FormData的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能够识别作为FormData实例传入的数据类型并自动配置相应的头部。</p>
<ol start="2">
<li>超时</li>
</ol>
<p>IE8 给 XHR 对象增加了一个timeout属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有浏览器都在自己的 XHR 实现中增加了这个属性。在给timeout属性设置了一个时间且在该时间过后没有收到响应时，XHR 对象就会触发timeout事件，调用ontimeout事件处理程序。</p>
<ol start="3">
<li>overrideMimeType()方法</li>
</ol>
<p>Firefox 首先引入了overrideMimeType()方法用于重写 XHR 响应的 MIME 类型。</p>
<p>假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是text/plain。结果就会导致虽然数据是 XML，但responseXML属性值是null。此时调用overrideMimeType()可以保证将响应当成 XML 而不是纯文本来处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;text.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&quot;text/xml&quot;</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>这个例子强制让 XHR 把响应当成 XML 而不是纯文本来处理。为了正确覆盖响应的 MIME 类型，必须在调用send()之前调用overrideMimeType()。</p>
<h3 id="24-2-进度事件"><a href="#24-2-进度事件" class="headerlink" title="24.2 进度事件"></a>24.2 进度事件</h3><p>有以下 6 个进度相关的事件。</p>
<ul>
<li><p>loadstart：在接收到响应的第一个字节时触发。</p>
</li>
<li><p>progress：在接收响应期间反复触发。</p>
</li>
<li><p>error：在请求出错时触发。</p>
</li>
<li><p>abort：在调用abort()终止连接时触发。</p>
</li>
<li><p>load：在成功接收完响应时触发。</p>
</li>
<li><p>loadend：在通信完成时，且在error、abort或load之后触发。</p>
</li>
</ul>
<p>每次请求都会首先触发loadstart事件，之后是一个或多个progress事件，接着是error、abort或load中的一个，最后以loadend事件结束。</p>
<h4 id="24-2-1-load事件"><a href="#24-2-1-load事件" class="headerlink" title="24.2.1 load事件"></a>24.2.1 load事件</h4><p>load事件在响应接收完成后立即触发，这样就不用检查readyState属性了。onload事件处理程序会收到一个event对象，其target属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法。不过，并不是所有浏览器都实现了这个事件的event对象。考虑到跨浏览器兼容，还是需要像下面这样使用 XHR 对象变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line">    <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;altevents.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>只要是从服务器收到响应，无论状态码是什么，都会触发load事件。这意味着还需要检查status属性才能确定数据是否有效。Firefox、Opera、Chrome 和 Safari 都支持load事件。</p>
<h4 id="24-2-2-progress事件"><a href="#24-2-2-progress事件" class="headerlink" title="24.2.2 progress事件"></a>24.2.2 progress事件</h4><p>在浏览器接收数据期间，这个事件会反复触发。每次触发时，onprogress事件处理程序都会收到event对象，其target属性是 XHR 对象，且包含 3 个额外属性：lengthComputable、position和totalSize。其中，lengthComputable是一个布尔值，表示进度信息是否可用；position是接收到的字节数；totalSize是响应的ContentLength头部定义的总字节数。有了这些信息，就可以给用户提供进度条了。以下代码演示了如何向用户展示进度：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || </span><br><span class="line">      xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line">    <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> divStatus = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>); </span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123; </span><br><span class="line">    divStatus.<span class="property">innerHTML</span> = <span class="string">&quot;Received &quot;</span> + event.<span class="property">position</span> + <span class="string">&quot; of &quot;</span> + </span><br><span class="line">      event.<span class="property">totalSize</span> + </span><br><span class="line"><span class="string">&quot; bytes&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;altevents.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>为了保证正确执行，必须在调用open()之前添加onprogress事件处理程序。</p>
<h3 id="24-3-跨源资源共享"><a href="#24-3-跨源资源共享" class="headerlink" title="24.3 跨源资源共享"></a>24.3 跨源资源共享</h3><p>通过 XHR 进行 Ajax 通信的一个主要限制是跨源安全策略。默认情况下，XHR 只能访问与发起请求的页面在同一个域内的资源。这个安全限制可以防止某些恶意行为。不过，浏览器也需要支持合法跨源访问的能力。<br>跨源资源共享（CORS，Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。<br>对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是text/plain类型，这样的请求在发送时会有一个额外的头部叫Origin。Origin头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。下面是Origin头部的一个示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//www.nczonline.net</span></span><br></pre></td></tr></table></figure>

<p>如果服务器决定响应请求，那么应该发送Access-Control-Allow-Origin头部，包含相同的源；或者如果资源是公开的，那么就包含”*”。</p>
<p>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。<br>现代浏览器通过XMLHttpRequest对象原生支持 CORS。在尝试访问不同源的资源时，这个行为会被自动触发。要向不同域的源发送请求，可以使用标准 XHR 对象并给open()方法传入一个绝对 URL。</p>
<p>跨域 XHR 对象允许访问status和statusText属性，也允许同步请求。出于安全考虑，跨域 XHR对象也施加了一些额外限制。</p>
<ul>
<li><p>不能使用setRequestHeader()设置自定义头部。</p>
</li>
<li><p>不能发送和接收 cookie。</p>
</li>
<li><p>getAllResponseHeaders()方法始终返回空字符串。</p>
</li>
</ul>
<p>因为无论同域还是跨域请求都使用同一个接口，所以最好在访问本地资源时使用相对 URL，在访问远程资源时使用绝对 URL。这样可以更明确地区分使用场景，同时避免出现访问本地资源时出现头部或 cookie 信息访问受限的问题。</p>
<h4 id="24-3-1-预检请求"><a href="#24-3-1-预检请求" class="headerlink" title="24.3.1 预检请求"></a>24.3.1 预检请求</h4><p>CORS 通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部、除 GET和 POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部。</p>
<ul>
<li><p>Origin：与简单请求相同。</p>
</li>
<li><p>Access-Control-Request-Method：请求希望使用的方法。</p>
</li>
<li><p>Access-Control-Request-Headers：（可选）要使用的逗号分隔的自定义头部列表。</p>
</li>
</ul>
<p>下面是一个假设的 POST 请求，包含自定义的NCZ头部：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//www.nczonline.net </span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: <span class="variable constant_">POST</span> </span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: <span class="variable constant_">NCZ</span></span><br></pre></td></tr></table></figure>

<p>在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息。</p>
<ul>
<li><p>Access-Control-Allow-Origin：与简单请求相同。</p>
</li>
<li><p>Access-Control-Allow-Methods：允许的方法（逗号分隔的列表）。</p>
</li>
<li><p>Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）。</p>
</li>
<li><p>Access-Control-Max-Age：缓存预检请求的秒数。</p>
</li>
</ul>
<p>预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求。</p>
<h4 id="24-3-2-凭据请求"><a href="#24-3-2-凭据请求" class="headerlink" title="24.3.2 凭据请求"></a>24.3.2 凭据请求</h4><p>默认情况下，跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书）。可以通过将withCredentials属性设置为true来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下 HTTP 头部：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给 JavaScript（responseText是空字符串，status是0，onerror()被调用）。注意，服务器也可以在预检请求的响应中发送这个 HTTP 头部，以表明这个源允许发送凭据请求。</p>
<h3 id="24-4-替代性跨源技术"><a href="#24-4-替代性跨源技术" class="headerlink" title="24.4 替代性跨源技术"></a>24.4 替代性跨源技术</h3><h4 id="24-4-1-图片探测"><a href="#24-4-1-图片探测" class="headerlink" title="24.4.1 图片探测"></a>24.4.1 图片探测</h4><p>图片探测是利用img标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的onload和onerror事件处理程序得知何时收到响应。<br>这种动态创建图片的技术经常用于图片探测（image pings）。图片探测是与服务器之间简单、跨域、单向的通信。数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为 204 的状态码。浏览器通过图片探测拿不到任何数据，但可以通过监听onload和onerror事件知道什么时候能接收到响应。下面看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>(); </span><br><span class="line">img.<span class="property">onload</span> = img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.example.com/test?name=Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然，图片探测的缺点是只能发送 GET 请求和无法获取服务器响应的内容。这也是只能利用图片探测实现浏览器与服务器单向通信的原因。</p>
<h4 id="24-4-2-JSONP"><a href="#24-4-2-JSONP" class="headerlink" title="24.4.2 JSONP"></a>24.4.2 JSONP</h4><p>JSONP 是“JSON with padding”的简写，是在 Web 服务上流行的一种 JSON 变体。JSONP 看起来跟 JSON 一样，只是会被包在一个函数调用里。</p>
<p>JSONP 格式包含两个部分：回调和数据。回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。而数据就是作为参数传给回调函数的 JSON 数据。下面是一个典型的 JSONP 请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//freegeoip.net/json/?callback=handleResponse</span></span><br></pre></td></tr></table></figure>

<p>这个 JSONP 请求的 URL 是一个地理位置服务。JSONP 服务通常支持以查询字符串形式指定回调函数的名称。</p>
<p>JSONP 调用是通过动态创建&lt;**script**&gt;元素并为src属性指定跨域 URL 实现的。此时的&lt;**script**&gt;与img元素类似，能够不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript，所以 JSONP响应在被加载完成之后会立即执行。比如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">response</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">` </span></span><br><span class="line"><span class="string">      You&#x27;re at IP address <span class="subst">$&#123;response.ip&#125;</span>, which is in </span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;response.city&#125;</span>, <span class="subst">$&#123;response.region_name&#125;</span>`</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(script, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br></pre></td></tr></table></figure>

<p>相比于图片探测，使用 JSONP 可以直接访问响应，实现浏览器与服务器的双向通信。不过 JSONP 也有一些缺点。<br>首先，JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时，一定要保证是可以信任的。<br>第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了</p>
<p>JSONP 是“JSON with padding”的简写，是在 Web 服务上流行的一种 JSON 变体。JSONP 看起来跟 JSON 一样，只是会被包在一个函数调用里。</p>
<p>JSONP 格式包含两个部分：回调和数据。回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。而数据就是作为参数传给回调函数的 JSON 数据。下面是一个典型的 JSONP 请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//freegeoip.net/json/?callback=handleResponse</span></span><br></pre></td></tr></table></figure>

<p>这个 JSONP 请求的 URL 是一个地理位置服务。JSONP 服务通常支持以查询字符串形式指定回调函数的名称。</p>
<p>JSONP 调用是通过动态创建&lt;**script**&gt;元素并为src属性指定跨域 URL 实现的。此时的&lt;**script**&gt;与img元素类似，能够不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript，所以 JSONP响应在被加载完成之后会立即执行。比如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">response</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">` </span></span><br><span class="line"><span class="string">      You&#x27;re at IP address <span class="subst">$&#123;response.ip&#125;</span>, which is in </span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;response.city&#125;</span>, <span class="subst">$&#123;response.region_name&#125;</span>`</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(script, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br></pre></td></tr></table></figure>

<p>相比于图片探测，使用 JSONP 可以直接访问响应，实现浏览器与服务器的双向通信。不过 JSONP 也有一些缺点。<br>首先，JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时，一定要保证是可以信任的。<br>第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了&lt;**script**&gt;元素的onerror事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的。</p>
<h3 id="24-5-Fetch-API"><a href="#24-5-Fetch-API" class="headerlink" title="24.5 Fetch API"></a>24.5 Fetch API</h3><p>Fetch API 能够执行XMLHttpRequest对象的所有任务，但更容易使用，接口也更现代化，能够在Web 工作线程等现代 Web 工具中使用。XMLHttpRequest可以选择异步，而 Fetch API 则必须是异步。</p>
<p>Fetch API 本身是使用 JavaScript 请求资源的优秀工具，同时这个 API 也能够应用在服务线程（service worker）中，提供拦截、重定向和修改通过fetch()生成的请求接口。</p>
<h4 id="24-5-1-基本用法"><a href="#24-5-1-基本用法" class="headerlink" title="24.5.1 基本用法"></a>24.5.1 基本用法</h4><p>fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法，浏览器就会向给定 URL 发送请求。</p>
<ol>
<li>分派请求</li>
</ol>
<p>fetch()只有一个必需的参数input。多数情况下，这个参数是要获取资源的 URL。这个方法返回一个期约：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="title function_">fetch</span>(<span class="string">&#x27;/bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r); <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure>

<p>URL 的格式（相对路径、绝对路径等）的解释与 XHR 对象一样。<br>请求完成、资源可用时，期约会解决为一个Response对象。这个对象是 API 的封装，可以通过它取得相应资源。获取资源要使用这个对象的属性和方法，掌握响应的情况并将负载转换为有用的形式，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;bar.txt&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response); </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Response &#123; type: &quot;basic&quot;, url: ... &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>读取响应</li>
</ol>
<p>读取响应内容的最简单方式是取得纯文本格式的内容，这要用到text()方法。这个方法返回一个期约，会解决为取得资源的完整内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;bar.txt&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    response.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.txt 的内容</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理状态码和请求失败</li>
</ol>
<p>Fetch API 支持通过Response的status（状态码）和statusText（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为 200 的状态码。</p>
<p>请求不存在的资源通常会产生值为 404 的状态码。</p>
<p>请求的 URL 如果抛出服务器错误会产生值为 500 的状态码。</p>
<p>可以显式地设置fetch()在遇到重定向时的行为，不过默认行为是跟随重定向并返回状态码不是 300~399 的响应。跟随重定向时，响应对象的redirected属性会被设置为true，而状态码仍然是 200：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/permanent-redirect&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 默认行为是跟随重定向直到最终 URL </span></span><br><span class="line">    <span class="comment">// 这个例子会出现至少两轮网络请求 </span></span><br><span class="line">    <span class="comment">// &lt;origin url&gt;/permanent-redirect -&gt; &lt;redirect url&gt; </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);     <span class="comment">// 200 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>); <span class="comment">// OK </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">redirected</span>); <span class="comment">// true </span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>虽然请求可能失败（如状态码为 500），但都只执行了期约的解决处理函数。事实上，只要服务器返回了响应，fetch()期约都会解决。这个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。<br>通常状态码为 200 时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在状态码非 200~299 时检查Response对象的ok属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/bar&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 200 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">ok</span>);     <span class="comment">// true </span></span><br><span class="line">  &#125;); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/does-not-exist&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 404 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">ok</span>);     <span class="comment">// false </span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>因为服务器没有响应而导致浏览器超时，这样真正的fetch()失败会导致期约被拒绝。</p>
<p>违反 CORS、无网络连接、HTTPS 错配及其他浏览器/网络策略问题都会导致期约被拒绝。 可以通过url属性检查通过fetch()发送请求时使用的完整 URL：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.com/bar/baz 发送的请求 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>); <span class="comment">// https://foo.com/bar/baz </span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;qux&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>)); </span><br><span class="line"><span class="comment">// https://foo.com/bar/qux </span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/qux&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>)); </span><br><span class="line"><span class="comment">// https://foo.com/qux </span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//qux.com&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>)); </span><br><span class="line"><span class="comment">// https://qux.com </span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://qux.com&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">url</span>)); </span><br><span class="line"><span class="comment">// https://qux.com</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>自定义选项</li>
</ol>
<p>只使用 URL 时，fetch()会发送 GET 请求，只包含最低限度的请求头。要进一步配置如何发送请求，需要传入可选的第二个参数init对象。</p>
<h4 id="24-5-2-常见-Fetch-请求模式"><a href="#24-5-2-常见-Fetch-请求模式" class="headerlink" title="24.5.2 常见 Fetch 请求模式"></a>24.5.2 常见 Fetch 请求模式</h4><p>与XMLHttpRequest一样，fetch()既可以发送数据也可以接收数据。使用init对象参数，可以配置fetch()在请求体中发送各种序列化的数据。</p>
<ol>
<li>发送 JSON 数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; </span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123; </span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-json&#x27;</span>, &#123; </span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,   <span class="comment">// 发送请求体时必须使用一种 HTTP 方法 </span></span><br><span class="line">  <span class="attr">body</span>: payload, </span><br><span class="line">  <span class="attr">headers</span>: jsonHeaders </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在请求体中发送参数</li>
</ol>
<p>因为请求体支持任意字符串值，所以可以通过它发送请求参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paramHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123; </span><br><span class="line">  <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span> </span><br><span class="line"></span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-params&#x27;</span>, &#123; </span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,  <span class="comment">// 发送请求体时必须使用一种 HTTP 方法 </span></span><br><span class="line">  <span class="attr">body</span>: payload, </span><br><span class="line">  <span class="attr">headers</span>: paramHeaders </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发送文件</li>
</ol>
<p>因为请求体支持FormData实现，所以fetch()也可以序列化并发送文件字段中的文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>(); </span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>); </span><br><span class="line"></span><br><span class="line">imageFormData.<span class="title function_">append</span>(<span class="string">&#x27;image&#x27;</span>, imageInput.<span class="property">files</span>[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/img-upload&#x27;</span>, &#123; </span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line">  <span class="attr">body</span>: imageFormData </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>fetch()实现可以支持多个文件。</p>
<ol start="4">
<li>加载Blob文件</li>
</ol>
<p>Fetch API 也能提供Blob类型的响应，而Blob又可以兼容多种浏览器 API。一种常见的做法是明确将图片文件加载到内存，然后将其添加到 HTML 图片元素。为此，可以使用响应对象上暴露的blob()方法。这个方法返回一个期约，解决为一个Blob的实例。然后，可以将这个实例传给URL.createObjectUrl()以生成可以添加给图片元素src属性的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imageElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;my-image.png&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123; </span><br><span class="line">    imageElement.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob); </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>发送跨源请求</li>
</ol>
<p>从不同的源请求资源，响应要包含 CORS 头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。</p>
<p>如果代码不需要访问响应，也可以发送no-cors请求。此时响应的type属性值为opaque，因此无法读取响应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。</p>
<ol start="6">
<li>中断请求</li>
</ol>
<p>Fetch API 支持通过AbortController/AbortSignal对中断请求。调用AbortController. abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的fetch()请求会导致包含错误的拒绝。</p>
<h4 id="24-5-3-Headers对象"><a href="#24-5-3-Headers对象" class="headerlink" title="24.5.3 Headers对象"></a>24.5.3 Headers对象</h4><p>Headers对象是所有外发请求和入站响应头部的容器。每个外发的Request实例都包含一个空的Headers实例，可以通过Request.prototype.headers访问，每个入站Response实例也可以通过Response.prototype.headers访问包含着响应头部的Headers对象。这两个属性都是可修改属性。另外，使用new Headers()也可以创建一个新实例。</p>
<ol>
<li>Headers与Map的相似之处</li>
</ol>
<p>Headers对象与Map对象极为相似。这是合理的，因为 HTTP 头部本质上是序列化后的键/值对，它们的 JavaScript 表示则是中间接口。Headers与Map类型都有get()、set()、has()和delete()等实例方法，如下面的代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(); </span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键 </span></span><br><span class="line">h.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查键 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">has</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新值 </span></span><br><span class="line">h.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>Headers和Map都可以使用一个可迭代对象来初始化。</p>
<p>而且，它们也都有相同的keys()、values()和entries()迭代器接口。</p>
<ol start="2">
<li>Headers独有的特性</li>
</ol>
<p>Headers并不是与Map处处都一样。在初始化Headers对象时，也可以使用键/值对形式的对象，而Map则不可以。</p>
<p>一个 HTTP 头部字段可以有多个值，而Headers对象通过append()方法支持添加多个值。在Headers实例中还不存在的头部上调用append()方法相当于调用set()。后续调用会以逗号为分隔符拼接多个值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(); </span><br><span class="line"></span><br><span class="line">h.<span class="title function_">append</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// &quot;bar&quot; </span></span><br><span class="line">h.<span class="title function_">append</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// &quot;bar, baz&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>头部护卫</li>
</ol>
<p>某些情况下，并非所有 HTTP 头部都可以被客户端修改，而Headers对象使用护卫来防止不被允许的修改。不同的护卫设置会改变set()、append()和delete()的行为。违反护卫限制会抛出TypeError。<br>Headers实例会因来源不同而展现不同的行为，它们的行为由护卫来控制。JavaScript 可以决定Headers实例的护卫设置。下表列出了不同的护卫设置和每种设置对应的行为。</p>
<table>
<thead>
<tr>
<th>护卫</th>
<th>适用情形</th>
<th>限制</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>在通过构造函数创建Headers实例时激活</td>
<td>无</td>
</tr>
<tr>
<td>request</td>
<td>在通过构造函数初始化Request对象，且mode值为非no-cors时激活</td>
<td>不允许修改禁止修改的头部（参见 MDN 文档中的 forbidden header name 词条）</td>
</tr>
<tr>
<td>request-no-cors</td>
<td>在通过构造函数初始化Request对象，且mode</td>
<td></td>
</tr>
<tr>
<td>值为no-cors时激活</td>
<td>不允许修改非简单头部（参见 MDN 文档中的simple header 词条）</td>
<td></td>
</tr>
<tr>
<td>response</td>
<td>在通过构造函数初始化Response对象时激活</td>
<td>不允许修改禁止修改的响应头部（参见 MDN 文档中的 forbidden response header name 词条）</td>
</tr>
<tr>
<td>immutable</td>
<td>在通过error()或redirect()静态方法初始化Response对象时激活</td>
<td>不允许修改任何头部</td>
</tr>
</tbody></table>
<h4 id="24-5-4-Request对象"><a href="#24-5-4-Request对象" class="headerlink" title="24.5.4 Request对象"></a>24.5.4 Request对象</h4><p>Request对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。</p>
<ol>
<li>创建Request对象</li>
</ol>
<p>可以通过构造函数初始化Request对象。为此需要传入一个input参数，一般是 URL：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r); </span><br><span class="line"><span class="comment">// Request &#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<p>Request构造函数也接收第二个参数——一个init对象。这个init对象与fetch()的init对象一样。没有在init对象中涉及的值则会使用默认值。</p>
<ol start="2">
<li>克隆Request对象</li>
</ol>
<p>etch API 提供了两种不太一样的方式用于创建Request对象的副本：使用Request构造函数和使用clone()方法。<br>将Request实例作为input参数传给Request构造函数，会得到该请求的一个副本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> <span class="title class_">Request</span>(r1); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">url</span>); <span class="comment">// https://foo.com/</span></span><br></pre></td></tr></table></figure>

<p>如果再传入init对象，则init对象的值会覆盖源对象中同名的值。</p>
<p>这种克隆方式并不总能得到一模一样的副本。最明显的是，第一个请求的请求体会被标记为“已使用”:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, </span><br><span class="line">                     &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> <span class="title class_">Request</span>(r1); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">bodyUsed</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果源对象与创建的新对象不同源，则referrer属性会被清除。此外，如果源对象的mode为navigate，则会被转换为same-origin。<br>第二种克隆Request对象的方式是使用clone()方法，这个方法会创建一模一样的副本，任何值都不会被覆盖。与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"><span class="keyword">let</span> r2 = r1.<span class="title function_">clone</span>(); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">url</span>);      <span class="comment">// https://foo.com/ </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">url</span>);      <span class="comment">// https://foo.com/ </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">bodyUsed</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">bodyUsed</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果请求对象的bodyUsed属性为true（即请求体已被读取），那么上述任何一种方式都不能用来创建这个对象的副本。在请求体被读取之后再克隆会导致抛出TypeError。</p>
<ol start="3">
<li>在fetch()中使用Request对象</li>
</ol>
<p>fetch()和Request构造函数拥有相同的函数签名并不是巧合。在调用fetch()时，可以传入已经创建好的Request实例而不是 URL。与Request构造函数一样，传给fetch()的init对象会覆盖传入请求对象的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 foo.com 发送 GET 请求 </span></span><br><span class="line"><span class="title function_">fetch</span>(r); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 foo.com 发送 POST 请求 </span></span><br><span class="line"><span class="title function_">fetch</span>(r, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>fetch()会在内部克隆传入的Request对象。与克隆Request一样，fetch()也不能拿请求体已经用过的Request对象来发送请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, </span><br><span class="line">                    &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>(); </span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(r); </span><br><span class="line"><span class="comment">// TypeError: Cannot construct a Request with a Request object that has already </span></span><br><span class="line">been used.</span><br></pre></td></tr></table></figure>

<p>关键在于，通过fetch使用Request会将请求体标记为已使用。也就是说，有请求体的Request只能在一次fetch中使用。（不包含请求体的请求不受此限制。）</p>
<p>要想基于包含请求体的相同Request对象多次调用fetch()，必须在第一次发送fetch()请求前用clone()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, </span><br><span class="line">                    &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 个都会成功 </span></span><br><span class="line"><span class="title function_">fetch</span>(r.<span class="title function_">clone</span>()); </span><br><span class="line"><span class="title function_">fetch</span>(r.<span class="title function_">clone</span>()); </span><br><span class="line"><span class="title function_">fetch</span>(r);</span><br></pre></td></tr></table></figure>

<h4 id="24-5-5-Response对象"><a href="#24-5-5-Response对象" class="headerlink" title="24.5.5 Response对象"></a>24.5.5 Response对象</h4><p>Response对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。</p>
<ol>
<li>创建Response对象</li>
</ol>
<p>可以通过构造函数初始化Response对象且不需要参数。此时响应实例的属性均为默认值，因为它并不代表实际的 HTTP 响应。</p>
<p>Response构造函数接收一个可选的body参数。这个body可以是null，等同于fetch()参数init中的body。还可以接收一个可选的init对象，这个对象可以包含下表所列的键和值。</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>headers</td>
<td>必须是Headers对象实例或包含字符串键/值对的常规对象实例<br>默认为没有键/值对的Headers对象</td>
</tr>
<tr>
<td>status</td>
<td>表示 HTTP 响应状态码的整数</td>
</tr>
<tr>
<td><br>默认为 200</td>
<td></td>
</tr>
<tr>
<td>statusText</td>
<td>表示 HTTP 响应状态的字符串</td>
</tr>
<tr>
<td><br>默认为空字符串</td>
<td></td>
</tr>
</tbody></table>
<p>大多数情况下，产生Response对象的主要方式是调用fetch()，它返回一个最后会解决为Response对象的期约，这个Response对象代表实际的 HTTP 响应。</p>
<p>Response类还有两个用于生成Response对象的静态方法：Response.redirect()和Response. error()。前者接收一个 URL 和一个重定向状态码（301、302、303、307 或 308），返回重定向的Response对象。</p>
<p>提供的状态码必须对应重定向，否则会抛出错误。</p>
<p>另一个静态方法Response.error()用于产生表示网络错误的Response对象（网络错误会导致fetch()期约被拒绝）。</p>
<ol start="2">
<li>读取响应状态信息</li>
</ol>
<p>Response对象包含一组只读属性，描述了请求完成后的状态。</p>
<ol start="3">
<li>克隆Response对象</li>
</ol>
<p>克隆Response对象的主要方式是使用clone()方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。这样不会将任何请求的请求体标记为已使用。</p>
<p>如果响应对象的bodyUsed属性为true（即响应体已被读取），则不能再创建这个对象的副本。在响应体被读取之后再克隆会导致抛出TypeError。</p>
<p>有响应体的Response对象只能读取一次。（不包含响应体的Response对象不受此限制。）比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar </span></span><br><span class="line"></span><br><span class="line">r.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked</span></span><br></pre></td></tr></table></figure>

<p>要多次读取包含响应体的同一个Response对象，必须在第一次读取前调用clone()。</p>
<p>此外，通过创建带有原始响应体的Response实例，可以执行伪克隆操作。关键是这样不会把第一个Response实例标记为已读，而是会在两个响应之间共享：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> <span class="title class_">Response</span>(r1.<span class="property">body</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="property">bodyUsed</span>);    <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="property">bodyUsed</span>);    <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line">r2.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar </span></span><br><span class="line">r1.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;text&#x27; on &#x27;Response&#x27;: body stream is locked</span></span><br></pre></td></tr></table></figure>

<h4 id="24-5-6-Request、Response及Body混入"><a href="#24-5-6-Request、Response及Body混入" class="headerlink" title="24.5.6 Request、Response及Body混入"></a>24.5.6 Request、Response及Body混入</h4><p>Request和Response都使用了 Fetch API 的Body混入，以实现两者承担有效载荷的能力。这个混入为两个类型提供了只读的body属性（实现为ReadableStream）、只读的bodyUsed布尔值（表示body流是否已读）和一组方法，用于从流中读取内容并将结果转换为某种 JavaScript 对象类型。<br>通常，将Request和Response主体作为流来使用主要有两个原因。一个原因是有效载荷的大小可能会导致网络延迟，另一个原因是流 API 本身在处理有效载荷方面是有优势的。除此之外，最好是一次性获取资源主体。<br>Body混入提供了 5 个方法，用于将ReadableStream转存到缓冲区的内存里，将缓冲区转换为某种 JavaScript 对象类型，以及通过期约来产生结果。在解决之前，期约会等待主体流报告完成及缓冲被解析。这意味着客户端必须等待响应的资源完全加载才能访问其内容。</p>
<ol>
<li>Body.text()</li>
</ol>
<p>Body.text()方法返回期约，解决为将缓冲区转存得到的 UTF-8 格式字符串。</p>
<ol start="2">
<li>Body.json()</li>
</ol>
<p>Body.json()方法返回期约，解决为将缓冲区转存得到的 JSON。</p>
<ol start="3">
<li>Body.formData()</li>
</ol>
<p>浏览器可以将FormData对象序列化/反序列化为主体。</p>
<p>Body.formData()方法返回期约，解决为将缓冲区转存得到的FormData实例。</p>
<ol start="4">
<li>Body.arrayBuffer()</li>
</ol>
<p>使用Body.arrayBuffer()将主体内容转换为ArrayBuffer实例。Body.arrayBuffer()方法返回期约，解决为将缓冲区转存得到的ArrayBuffer实例。</p>
<p>下面的代码展示了在Response对象上使Body.arrayBuffer()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">arrayBuffer</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayBuffer(...) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>以下代码展示了在Request对象上使用Body.arrayBuffer()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, </span><br><span class="line">                          &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;abcdefg&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以整数形式打印二进制编码的字符串 </span></span><br><span class="line">request.<span class="title function_">arrayBuffer</span>() </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">buf</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Int8Array</span>(buf))); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Int8Array(7) [97, 98, 99, 100, 101, 102, 103]</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Body.blob()</li>
</ol>
<p>以原始二进制格式使用主体，不用查看和修改。为此，可以使用Body.blob()将主体内容转换为Blob实例。Body.blob()方法返回期约，解决为将缓冲区转存得到的Blob实例。<br>下面的代码展示了在Response对象上使用Body.blob()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Blob(...) &#123;size:..., type: &quot;...&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>以下代码展示了在Request对象上使用Body.blob()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>,  </span><br><span class="line">                          &#123; <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;abcdefg&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line">request.<span class="title function_">blob</span>() </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Blob(7) &#123;size: 7, type: &quot;text/plain;charset=utf-8&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>一次性流</li>
</ol>
<p>因为Body混入是构建在ReadableStream之上的，所以主体流只能使用一次。这意味着所有主体混入方法都只能调用一次，再次调用就会抛出错误。</p>
<p>即使是在读取流的过程中，所有这些方法也会在它们被调用时给ReadableStream加锁，以阻止其他读取器访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://foo.com&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">    response.<span class="title function_">blob</span>(); <span class="comment">// 第一次调用给流加锁 </span></span><br><span class="line">    response.<span class="title function_">blob</span>(); <span class="comment">// 第二次调用再次加锁会失败 </span></span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Response&#x27;: body stream is locked </span></span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, </span><br><span class="line">                          &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line">request.<span class="title function_">blob</span>(); <span class="comment">// 第一次调用给流加锁 </span></span><br><span class="line">request.<span class="title function_">blob</span>(); <span class="comment">// 第二次调用再次加锁会失败 </span></span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;blob&#x27; on &#x27;Request&#x27;: body stream is locked</span></span><br></pre></td></tr></table></figure>

<p>作为Body混入的一部分，bodyUsed布尔值属性表示ReadableStream是否已摄受（disturbed），意思是读取器是否已经在流上加了锁。这不一定表示流已经被完全读取。下面的代码演示了这个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, </span><br><span class="line">                          &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;); </span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">bodyUsed</span>);     <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">bodyUsed</span>);    <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line">request.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);  <span class="comment">// foobar </span></span><br><span class="line">response.<span class="title function_">text</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foobar </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">bodyUsed</span>);     <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">bodyUsed</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>使用ReadableStream主体</li>
</ol>
<p>JavaScript 编程逻辑很多时候会将访问网络作为原子操作，比如请求是同时创建和发送的，响应数据也是以统一的格式一次性暴露出来的。这种约定隐藏了底层的混乱，让涉及网络的代码变得很清晰。<br>从 TCP/IP 角度来看，传输的数据是以分块形式抵达端点的，而且速度受到网速的限制。接收端点会为此分配内存，并将收到的块写入内存。Fetch API 通过ReadableStream支持在这些块到达时就实时读取和操作这些数据。</p>
<p>正如Stream API所定义的，ReadableStream暴露了getReader()方法，用于产生ReadableStreamDefaultReader，这个读取器可以用于在数据到达时异步获取数据块。数据流的格式是Uint8Array。<br>下面的代码调用了读取器的read()方法，把最早可用的块打印了出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://fetch.spec.whatwg.org/&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="property">body</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">body</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> reader = body.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reader); <span class="comment">// ReadableStreamDefaultReader &#123;&#125; </span></span><br><span class="line"></span><br><span class="line">    reader.<span class="title function_">read</span>() </span><br><span class="line">      .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>在随着数据流的到来取得整个有效载荷，可以像下面这样递归调用read()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://fetch.spec.whatwg.org/&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="property">body</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">body</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> reader = body.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">processNextChunk</span>(<span class="params">&#123;value, done&#125;</span>) &#123; </span><br><span class="line">      <span class="keyword">if</span> (done) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> reader.<span class="title function_">read</span>() </span><br><span class="line">          .<span class="title function_">then</span>(processNextChunk); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reader.<span class="title function_">read</span>() </span><br><span class="line">        .<span class="title function_">then</span>(processNextChunk); </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>异步函数非常适合这样的fetch()操作。可以通过使用async/await将上面的递归调用打平：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://fetch.spec.whatwg.org/&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="property">body</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">body</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> reader = body.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">      <span class="keyword">let</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (done) &#123; </span><br><span class="line">          <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>另外，read()方法也可以真接封装到Iterable接口中。因此就可以在for-await-of循环中方便地实现这种转换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://fetch.spec.whatwg.org/&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="property">body</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">body</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> reader = body.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> asyncIterable = &#123; </span><br><span class="line">      [<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">          <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> reader.<span class="title function_">read</span>(); </span><br><span class="line">          &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (chunk <span class="keyword">of</span> asyncIterable) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// &#123; value: Uint8Array&#123;&#125;, done: false &#125; </span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>通过将异步逻辑包装到一个生成器函数中，还可以进一步简化代码。而且，这个实现通过支持只读取部分流也变得更稳健。如果流因为耗尽或错误而终止，读取器会释放锁，以允许不同的流读取器继续操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">streamGenerator</span>(<span class="params">stream</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> reader = stream.<span class="title function_">getReader</span>(); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (done) &#123; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">yield</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    reader.<span class="title function_">releaseLock</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://fetch.spec.whatwg.org/&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="property">body</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">body</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (chunk <span class="keyword">of</span> <span class="title function_">streamGenerator</span>(body)) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这些例子中，当读取完Uint8Array块之后，浏览器会将其标记为可以被垃圾回收。对于需要在不连续的内存中连续检查大量数据的情况，这样可以节省很多内存空间。<br>缓冲区的大小，以及浏览器是否等待缓冲区被填充后才将其推到流中，要根据 JavaScript 运行时的实现。浏览器会控制等待分配的缓冲区被填满，同时会尽快将缓冲区数据（有时候可能未填充数据）发送到流。<br>不同浏览器中分块大小可能不同，这取决于带宽和网络延迟。此外，浏览器如果决定不等待网络，也可以将部分填充的缓冲区发送到流。最终，我们的代码要准备好处理以下情况：</p>
<ul>
<li><p>不同大小的Uint8Array块；</p>
</li>
<li><p>部分填充的Uint8Array块；</p>
</li>
<li><p>块到达的时间间隔不确定。</p>
</li>
</ul>
<p>默认情况下，块是以Uint8Array格式抵达的。因为块的分割不会考虑编码，所以会出现某些值作为多字节字符被分散到两个连续块中的情况。手动处理这些情况是很麻烦的，但很多时候可以使用Encoding API 的可插拔方案。<br>要将Uint8Array转换为可读文本，可以将缓冲区传给TextDecoder，返回转换后的值。通过设置stream: true，可以将之前的缓冲区保留在内存，从而让跨越两个块的内容能够被正确解码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">streamGenerator</span>(<span class="params">stream</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> reader = stream.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (done) &#123; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      &#125; </span><br><span class="line"><span class="keyword">yield</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    reader.<span class="title function_">releaseLock</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://fetch.spec.whatwg.org/&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="property">body</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">body</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (chunk <span class="keyword">of</span> <span class="title function_">streamGenerator</span>(body)) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(decoder.<span class="title function_">decode</span>(chunk, &#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;)); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; ... </span></span><br><span class="line"><span class="comment">// whether a &lt;a data-link-type=&quot;dfn&quot; href=&quot;#concept-header&quot; ... </span></span><br><span class="line"><span class="comment">// result to &lt;var&gt;rangeValue&lt;/var&gt;. ... </span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>因为可以使用ReadableStream创建Response对象，所以就可以在读取流之后，将其通过管道导入另一个流。然后在这个新流上再使用Body的方法，如text()。这样就可以随着流的到达实时检查和操作流内容。下面的代码展示了这种双流技术：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://fetch.spec.whatwg.org/&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="property">body</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">body</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> reader = body.<span class="title function_">getReader</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个流 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line">      <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">            <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>(); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (done) &#123; </span><br><span class="line">              <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将主体流的块推到第二个流 </span></span><br><span class="line">            controller.<span class="title function_">enqueue</span>(value); </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">          controller.<span class="title function_">close</span>(); </span><br><span class="line">          reader.<span class="title function_">releaseLock</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">secondaryStream</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Response</span>(secondaryStream)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; ...</span></span><br></pre></td></tr></table></figure>

<h3 id="24-6-Beacon-API"><a href="#24-6-Beacon-API" class="headerlink" title="24.6 Beacon API"></a>24.6 Beacon API</h3><p>理想的情况下是通过浏览器的unload事件发送网络请求。这个事件表示用户要离开当前页面，不会再生成别的有用信息了。<br>在unload事件触发时，分析工具要停止收集信息并把收集到的数据发给服务器。这时候有一个问题，因为unload事件对浏览器意味着没有理由再发送任何结果未知的网络请求（因为页面都要被销毁了）。例如，在unload事件处理程序中创建的任何异步请求都会被浏览器取消。为此，异步XMLHttpRequest或fetch()不适合这个任务。分析工具可以使用同步XMLHttpRequest强制发送请求，但这样做会导致用户体验问题。浏览器会因为要等待unload事件处理程序完成而延迟导航到下一个页面。<br>为解决这个问题，W3C 引入了补充性的 Beacon API。这个 API 给navigator对象增加了一个sendBeacon()方法。这个简单的方法接收一个 URL 和一个数据有效载荷参数，并会发送一个 POST请求。可选的数据有效载荷参数有ArrayBufferView、Blob、DOMString、FormData实例。如果请求成功进入了最终要发送的任务队列，则这个方法返回true，否则返回false。<br>可以像下面这样使用这个方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 POST 请求 </span></span><br><span class="line"><span class="comment">// URL: &#x27;https://example.com/analytics-reporting-url&#x27; </span></span><br><span class="line"><span class="comment">// 请求负载：&#x27;&#123;foo: &quot;bar&quot;&#125;&#x27; </span></span><br><span class="line"></span><br><span class="line">navigator.<span class="title function_">sendBeacon</span>(<span class="string">&#x27;https://example.com/analytics-reporting-url&#x27;</span>, <span class="string">&#x27;&#123;foo: &quot;bar&quot;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法虽然看起来只不过是 POST 请求的一个语法糖，但它有几个重要的特性。</p>
<ul>
<li><p>sendBeacon()并不是只能在页面生命周期末尾使用，而是任何时候都可以使用。</p>
</li>
<li><p>调用sendBeacon()后，浏览器会把请求添加到一个内部的请求队列。浏览器会主动地发送队列中的请求。</p>
</li>
<li><p>浏览器保证在原始页面已经关闭的情况下也会发送请求。</p>
</li>
<li><p>状态码、超时和其他网络原因造成的失败完全是不透明的，不能通过编程方式处理。</p>
</li>
<li><p>信标（beacon）请求会携带调用sendBeacon()时所有相关的 cookie。</p>
</li>
</ul>
<h4 id="24-7-Web-Socket"><a href="#24-7-Web-Socket" class="headerlink" title="24.7 Web Socket"></a>24.7 Web Socket</h4><p>Web Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在 JavaScript中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP的Upgrade头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务器实现，而必须使用支持该协议的专有服务器。<br>因为 Web Socket 使用了自定义协议，所以 URL方案（scheme）稍有变化：不能再使用 http://或 https://，而要使用 ws://和 wss://。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包含 URL 方案，因为将来有可能再支持其他方案。<br>使用自定义协议而非 HTTP 协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长。Web Socket 得到了所有主流浏览器支持。</p>
<h4 id="24-7-1-API"><a href="#24-7-1-API" class="headerlink" title="24.7.1 API"></a>24.7.1 API</h4><p>要创建一个新的 Web Socket，就要实例化一个WebSocket对象并传入提供连接的 URL：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>必须给WebSocket构造函数传入一个绝对 URL。同源策略不适用于 Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（在握手阶段就可以确定请求来自哪里。）<br>浏览器会在初始化WebSocket对象之后立即创建连接。与 XHR 类似，WebSocket也有一个readyState属性表示当前状态。不过，这个值与 XHR 中相应的值不一样。</p>
<ul>
<li><p>WebSocket.OPENING（0）：连接正在建立。</p>
</li>
<li><p>WebSocket.OPEN（1）：连接已经建立。</p>
</li>
<li><p>WebSocket.CLOSING（2）：连接正在关闭。</p>
</li>
<li><p>WebSocket.CLOSE（3）：连接已经关闭。</p>
</li>
</ul>
<p>WebSocket对象没有readystatechange事件，而是有与上述不同状态对应的其他事件。readyState值从 0 开始。<br>任何时候都可以调用close()方法关闭 Web Socket 连接。</p>
<p>调用close()之后，readyState立即变为 2（连接正在关闭），并会在关闭后变为 3（连接已经关闭）。</p>
<h4 id="24-7-2-发送和接收数据"><a href="#24-7-2-发送和接收数据" class="headerlink" title="24.7.2 发送和接收数据"></a>24.7.2 发送和接收数据</h4><p>打开 Web Socket 之后，可以通过连接发送和接收数据。要向服务器发送数据，使用send()方法并传入一个字符串、ArrayBuffer或Blob，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stringData = <span class="string">&quot;Hello world!&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> arrayBufferData = <span class="title class_">Uint8Array</span>.<span class="title function_">from</span>([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]); </span><br><span class="line"><span class="keyword">let</span> blobData = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]); </span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">send</span>(stringData); </span><br><span class="line">socket.<span class="title function_">send</span>(arrayBufferData.<span class="property">buffer</span>); </span><br><span class="line">socket.<span class="title function_">send</span>(blobData);</span><br></pre></td></tr></table></figure>

<p>服务器向客户端发送消息时，WebSocket对象上会触发message事件。这个message事件与其他消息协议类似，可以通过event.data属性访问到有效载荷：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> data = event.<span class="property">data</span>; </span><br><span class="line">  <span class="comment">// 对数据执行某些操作 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与通过send()方法发送的数据类似，event.data返回的数据也可能是ArrayBuffer或Blob。这由WebSocket对象的binaryType属性决定，该属性可能是”blob”或”arraybuffer”。</p>
<h4 id="24-7-3-其他事件"><a href="#24-7-3-其他事件" class="headerlink" title="24.7.3 其他事件"></a>24.7.3 其他事件</h4><p>WebSocket对象在连接生命周期中有可能触发 3 个其他事件。</p>
<ul>
<li><p>open：在连接成功建立时触发。</p>
</li>
<li><p>error：在发生错误时触发。连接无法存续。</p>
</li>
<li><p>close：在连接关闭时触发。</p>
</li>
</ul>
<p>WebSocket对象不支持 DOM Level 2 事件监听器，因此需要使用 DOM Level 0 风格的事件处理程序来监听这些事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>); </span><br><span class="line">socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Connection established.&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Connection error.&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Connection closed.&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这些事件中，只有close事件的event对象上有额外信息。这个对象上有 3 个额外属性：wasClean、code和reason。其中，wasClean是一个布尔值，表示连接是否干净地关闭：code是一个来自服务器的数值状态码；reason是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`as clean? <span class="subst">$&#123;event.wasClean&#125;</span> Code=<span class="subst">$&#123;event.code&#125;</span> Reason=<span class="subst">$&#123; </span></span></span><br><span class="line"><span class="subst"><span class="string">              event.reason&#125;</span>`</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="24-8-安全"><a href="#24-8-安全" class="headerlink" title="24.8 安全"></a>24.8 安全</h3><p>在通用层面上一般需要考虑以下几个问题。<br>首先，任何 Ajax 可以访问的 URL，也可以通过浏览器或服务器访问。</p>
<p>在未授权系统可以访问某个资源时，可以将其视为跨站点请求伪造（CSRF，cross-site request forgery）攻击。未授权系统会按照处理请求的服务器的要求伪装自己。Ajax 应用程序，无论大小，都会受到 CSRF攻击的影响，包括无害的漏洞验证攻击和恶意的数据盗窃或数据破坏攻击。<br>关于安全防护 Ajax 相关 URL 的一般理论认为，需要验证请求发送者拥有对资源的访问权限。可以通过如下方式实现。</p>
<ul>
<li><p>要求通过 SSL 访问能够被 Ajax 访问的资源。</p>
</li>
<li><p>要求每个请求都发送一个按约定算法计算好的令牌（token）。</p>
</li>
</ul>
<p>注意，以下手段对防护 CSRF 攻击是无效的。</p>
<ul>
<li><p>要求 POST 而非 GET 请求（很容易修改请求方法）。</p>
</li>
<li><p>使用来源 URL 验证来源（来源 URL 很容易伪造）。</p>
</li>
<li><p>基于 cookie 验证（同样很容易伪造）。</p>
</li>
</ul>
<h3 id="24-9-小结"><a href="#24-9-小结" class="headerlink" title="24.9 小结"></a>24.9 小结</h3><p>jax 是无须刷新当前页面即可从服务器获取数据的一个方法，具有如下特点。</p>
<ul>
<li><p>让 Ajax 迅速流行的中心对象是XMLHttpRequest（XHR）。</p>
</li>
<li><p>这个对象最早由微软发明，并在 IE5 中作为通过 JavaScript 从服务器获取 XML 数据的一种手段。</p>
</li>
<li><p>之后，Firefox、Safari、Chrome 和 Opera 都复刻了相同的实现。W3C 随后将 XHR 行为写入 Web标准。</p>
</li>
<li><p>虽然不同浏览器的实现有些差异，但 XHR 对象的基本使用在所有浏览器中相对是规范的，因此可以放心地在 Web 应用程序中使用。</p>
</li>
</ul>
<p>XHR 的一个主要限制是同源策略，即通信只能在相同域名、相同端口和相同协议的前提下完成。访问超出这些限制之外的资源会导致安全错误，除非使用了正式的跨域方案。这个方案叫作跨源资源共享（CORS，Cross-Origin Resource Sharing），XHR 对象原生支持 CORS。图片探测和 JSONP 是另外两种跨域通信技术，但没有 CORS 可靠。<br>Fetch API 是作为对 XHR 对象的一种端到端的替代方案而提出的。这个 API 提供了优秀的基于期约的结构、更直观的接口，以及对 Stream API 的最好支持。<br>Web Socket 是与服务器的全双工、双向通信渠道。与其他方案不同，Web Socket 不使用 HTTP，而使用了自定义协议，目的是更快地发送小数据块。这需要专用的服务器，但速度优势明显。</p>
<h2 id="二十五、客户端存储"><a href="#二十五、客户端存储" class="headerlink" title="二十五、客户端存储"></a>二十五、客户端存储</h2><h3 id="25-1-cookie"><a href="#25-1-cookie" class="headerlink" title="25.1 cookie"></a>25.1 cookie</h3><p>HTTP cookie 通常也叫作 cookie，最初用于在客户端存储会话信息。这个规范要求服务器在响应HTTP 请求时，通过发送Set-Cookie HTTP 头部包含会话信息。例如，下面是包含这个头部的一个 HTTP响应：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span> </span><br><span class="line"><span class="title class_">Content</span>-<span class="attr">type</span>: text/html </span><br><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: name=value </span><br><span class="line"><span class="title class_">Other</span>-<span class="attr">header</span>: other-header-value</span><br></pre></td></tr></table></figure>

<p>这个 HTTP 响应会设置一个名为”name”，值为”value”的 cookie。名和值在发送时都会经过 URL编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服务器，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /index.<span class="property">jsl</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> </span><br><span class="line"><span class="title class_">Cookie</span>: name=value </span><br><span class="line"><span class="title class_">Other</span>-<span class="attr">header</span>: other-header-value</span><br></pre></td></tr></table></figure>

<p>这些发送回服务器的额外信息可用于唯一标识发送请求的客户端。</p>
<h4 id="25-1-1-限制"><a href="#25-1-1-限制" class="headerlink" title="25.1.1 限制"></a>25.1.1 限制</h4><p>cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。这个限制能保证cookie 中存储的信息只对被认可的接收者开放，不被其他域访问。<br>因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie也不会占用太多磁盘空间。</p>
<p>遵守以下大致的限制，就不会在任何浏览器中碰到问题：</p>
<ul>
<li><p>不超过 300 个 cookie；</p>
</li>
<li><p>每个 cookie 不超过 4096 字节；</p>
</li>
<li><p>每个域不超过 20 个 cookie；</p>
</li>
<li><p>每个域不超过 81 920 字节。</p>
</li>
</ul>
<p>每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同。</p>
<p>如果 cookie 总数超过了单个域的上限，浏览器就会删除之前设置的 cookie。</p>
<p>浏览器也会限制 cookie 的大小。大多数浏览器对 cookie 的限制是不超过 4096 字节，上下可以有一个字节的误差。为跨浏览器兼容，最好保证 cookie 的大小不超过 4095 字节。</p>
<p>如果创建的 cookie 超过最大限制，则该 cookie 会被静默删除。注意，一个字符通常会占 1 字节。如果使用多字节字符（如 UTF-8 Unicode 字符），则每个字符最多可能占 4 字节。</p>
<h4 id="25-1-2-cookie-的构成"><a href="#25-1-2-cookie-的构成" class="headerlink" title="25.1.2 cookie 的构成"></a>25.1.2 cookie 的构成</h4><p>cookie 在浏览器中是由以下参数构成的。</p>
<ul>
<li><p>名称：唯一标识 cookie 的名称。cookie 名不区分大小写，因此myCookie和MyCookie是同一个名称。不过，实践中最好将 cookie 名当成区分大小写来对待，因为一些服务器软件可能这样对待它们。cookie 名必须经过 URL 编码。</p>
</li>
<li><p>值：存储在 cookie 里的字符串值。这个值必须经过 URL 编码。</p>
</li>
<li><p>域：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如<a target="_blank" rel="noopener" href="http://www.wrox.com),也可以不包含(如.wrox.com/">www.wrox.com），也可以不包含（如.wrox.com</a> 表示对 wrox.com 的所有子域都有效）。如果不明确设置，则默认为设置 cookie 的域。</p>
</li>
<li><p>路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器。例如，可以指定 cookie 只能由<a target="_blank" rel="noopener" href="http://www.wrox.com/books/%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%AE%BF%E9%97%AE">http://www.wrox.com/books/访问，因此访问</a> <a target="_blank" rel="noopener" href="http://www.wrox.com/">http://www.wrox.com/</a> 下的页面就不会发送 cookie，即<br>使请求的是同一个域。</p>
</li>
<li><p>过期时间：表示何时删除 cookie 的时间戳（即什么时间之后就不发送到服务器了）。默认情况下，浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间。这个值是 GMT 格<br>式（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定删除 cookie 的具体时间。这样即使关闭浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。</p>
</li>
<li><p>安全标志：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。例如，请求 <a target="_blank" rel="noopener" href="https://www.wrox.com/">https://www.wrox.com</a> 会发送 cookie，而请求 <a target="_blank" rel="noopener" href="http://www.wrox.com/">http://www.wrox.com</a> 则不会。</p>
</li>
</ul>
<p>这些参数在Set-Cookie头部中使用分号加空格隔开。</p>
<p>安全标志secure是 cookie 中唯一的非名/值对，只需一个secure就可以了。</p>
<h4 id="25-1-3-JavaScript-中的-cookie"><a href="#25-1-3-JavaScript-中的-cookie" class="headerlink" title="25.1.3 JavaScript 中的 cookie"></a>25.1.3 JavaScript 中的 cookie</h4><p>在 JavaScript 中处理 cookie 比较麻烦，因为接口过于简单，只有 BOM 的document.cookie属性。</p>
<p>要使用该属性获取值时，document.cookie返回包含页面中所有<br>有效 cookie 的字符串（根据域、路径、过期时间和安全设置），以分号分隔。</p>
<p>所有名和值都是 URL 编码的，因此必须使用decodeURIComponent()解码。<br>在设置值时，可以通过document.cookie属性设置新的 cookie 字符串。这个字符串在被解析后会添加到原有 cookie 中。设置document.cookie不会覆盖之前存在的任何 cookie，除非设置了已有的cookie。设置 cookie 的格式如下，与Set-Cookie头部的格式一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure</span><br></pre></td></tr></table></figure>

<p>在所有这些参数中，只有 cookie 的名称和值是必需的。</p>
<p>要为创建的 cookie 指定额外的信息，只要像Set-Cookie头部一样直接在后面追加相同格式的字符串即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="built_in">encodeURIComponent</span>(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;=&quot;</span> + </span><br><span class="line">                  <span class="built_in">encodeURIComponent</span>(<span class="string">&quot;Nicholas&quot;</span>) + <span class="string">&quot;; domain=.wrox.com; path=/&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>与 cookie相关的基本操作有读、写和删除。这些在CookieUtil对象中表示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CookieUtil</span> &#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">get</span>(<span class="params">name</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> cookieName = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=`</span>, </span><br><span class="line">        cookieStart = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(cookieName), </span><br><span class="line">        cookieValue = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -<span class="number">1</span>)&#123; </span><br><span class="line">      <span class="keyword">let</span> cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;;&quot;</span>, cookieStart); </span><br><span class="line">      <span class="keyword">if</span> (cookieEnd == -<span class="number">1</span>)&#123; </span><br><span class="line">        cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="property">length</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">substring</span>(cookieStart </span><br><span class="line">          + cookieName.<span class="property">length</span>, cookieEnd)); </span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> cookieValue; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">set</span>(<span class="params">name, value, expires, path, domain, secure</span>) &#123; </span><br><span class="line">      <span class="keyword">let</span> cookieText = </span><br><span class="line">        <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(value)&#125;</span>`</span> </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123; </span><br><span class="line">        cookieText += <span class="string">`; expires=<span class="subst">$&#123;expires.toGMTString()&#125;</span>`</span>; </span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (path) &#123; </span><br><span class="line">        cookieText += <span class="string">`; path=<span class="subst">$&#123;path&#125;</span>`</span>; </span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (domain) &#123; </span><br><span class="line">        cookieText += <span class="string">`; domain=<span class="subst">$&#123;domain&#125;</span>`</span>; </span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (secure) &#123; </span><br><span class="line">        cookieText += <span class="string">&quot;; secure&quot;</span>; </span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">cookie</span> = cookieText; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">unset</span>(<span class="params">name, path, domain, secure</span>) &#123; </span><br><span class="line">      <span class="title class_">CookieUtil</span>.<span class="title function_">set</span>(name, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>), path, domain, secure); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CookieUtil.get()方法用于取得给定名称的 cookie 值。为此，需要在document.cookie返回的字符串中查找是否存在名称后面加上等号。如果找到了，则使用indexOf()再查找该位置后面的分号（表示该 cookie 的末尾）。如果没有找到分号，说明这个 cookie 在字符串末尾，因此字符串剩余部分都是cookie 的值。取得 cookie 值后使用decodeURIComponent()解码，然后返回。如果没有找到 cookie，则返回null。<br>CookieUtil.set()方法用于设置页面上的 cookie，接收多个参数：cookie 名称、cookie 值、可选的Date对象（表示何时删除 cookie）、可选的 URL 路径、可选的域以及可选的布尔值（表示是否添加secure标志）。这些参数以它们的使用频率为序，只有前两个是必需的。在方法内部，使用了encodeURIComponent()对名称和值进行编码，然后再依次检查其他参数。如果expires参数是Date对象，则使用Date对象的toGMTString()方法添加一个expires选项来获得正确的日期格式。剩下的代码就是简单地追加 cookie 字符串，最终设置document.cookie。<br>没有直接删除已有 cookie 的方法。为此，需要再次设置同名 cookie（包括相同路径、域和安全选项），但要将其过期时间设置为某个过去的时间。CookieUtil.unset()方法实现了这些处理。这个方法接收4 个参数：要删除 cookie 的名称、可选的路径、可选的域和可选的安全标志。<br>这些参数会传给CookieUtil.set()，将 cookie 值设置为空字符串，将过期时间设置为 1970 年1 月 1 日（以 0 毫秒初始化的Date对象的值）。这样可以保证删除 cookie。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 cookie </span></span><br><span class="line"><span class="title class_">CookieUtil</span>.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>); </span><br><span class="line"><span class="title class_">CookieUtil</span>.<span class="title function_">set</span>(<span class="string">&quot;book&quot;</span>, <span class="string">&quot;Professional JavaScript&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 cookie </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">CookieUtil</span>.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">CookieUtil</span>.<span class="title function_">get</span>(<span class="string">&quot;book&quot;</span>)); <span class="comment">// &quot;Professional JavaScript&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 cookie </span></span><br><span class="line"><span class="title class_">CookieUtil</span>.<span class="title function_">unset</span>(<span class="string">&quot;name&quot;</span>); </span><br><span class="line"><span class="title class_">CookieUtil</span>.<span class="title function_">unset</span>(<span class="string">&quot;book&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置有路径、域和过期时间的 cookie </span></span><br><span class="line"><span class="title class_">CookieUtil</span>.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>, <span class="string">&quot;/books/projs/&quot;</span>, <span class="string">&quot;www.wrox.com&quot;</span>, </span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;January 1, 2010&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除刚刚设置的 cookie </span></span><br><span class="line"><span class="title class_">CookieUtil</span>.<span class="title function_">unset</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;/books/projs/&quot;</span>, <span class="string">&quot;www.wrox.com&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置安全 cookie </span></span><br><span class="line"><span class="title class_">CookieUtil</span>.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="25-1-4-子-cookie"><a href="#25-1-4-子-cookie" class="headerlink" title="25.1.4 子 cookie"></a>25.1.4 子 cookie</h4><p>为绕过浏览器对每个域 cookie 数的限制，有些开发者提出了子 cookie 的概念。子 cookie 是在单个cookie 存储的小块数据，本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对。最常用的子 cookie模式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</span><br></pre></td></tr></table></figure>

<p>子 cookie 的格式类似于查询字符串。这些值可以存储为单个 cookie，而不用单独存储为自己的名/值对。结果就是网站或 Web 应用程序能够在单域 cookie 数限制下存储更多的结构化数据。<br>要操作子 cookie，就需要再添加一些辅助方法。解析和序列化子cookie 的方式不一样，且因为对子cookie 的使用而变得更复杂。比如，要取得某个子 cookie，就需要先取得 cookie，然后在解码值之前需要先像下面这样找到子 cookie：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubCookieUtil</span> &#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">get</span>(<span class="params">name, subName</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> subCookies = <span class="title class_">SubCookieUtil</span>.<span class="title function_">getAll</span>(name); </span><br><span class="line">    <span class="keyword">return</span> subCookies ? subCookies[subName] : <span class="literal">null</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getAll</span>(<span class="params">name</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span>, </span><br><span class="line">        cookieStart = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(cookieName), </span><br><span class="line">        cookieValue = <span class="literal">null</span>, </span><br><span class="line">        cookieEnd, </span><br><span class="line">        subCookies, </span><br><span class="line">        parts, </span><br><span class="line">        result = &#123;&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -<span class="number">1</span>) &#123; </span><br><span class="line">      cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;;&quot;</span>, cookieStart); </span><br><span class="line">      <span class="keyword">if</span> (cookieEnd == -<span class="number">1</span>) &#123; </span><br><span class="line">        cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="property">length</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      cookieValue = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">substring</span>(cookieStart + </span><br><span class="line">                                              cookieName.<span class="property">length</span>, cookieEnd); </span><br><span class="line">      <span class="keyword">if</span> (cookieValue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        subCookies = cookieValue.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = subCookies.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line">          parts = subCookies[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>); </span><br><span class="line">          result[<span class="built_in">decodeURIComponent</span>(parts[<span class="number">0</span>])] = </span><br><span class="line">            <span class="built_in">decodeURIComponent</span>(parts[<span class="number">1</span>]); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他代码 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>取得子 cookie 有两个方法：get()和getAll()。get()用于取得一个子 cookie 的值，getAll()用于取得所有子 cookie，并以对象形式返回，对象的属性是子 cookie 的名称，值是子 cookie 的值。get()方法接收两个参数：cookie 的名称和子 cookie 的名称。这个方法先调用getAll()取得所有子 cookie，然后返回要取得的子 cookie（如果不存在则返回null）。<br>SubCookieUtil.getAll()方法在解析 cookie 值方面与CookieUtil.get()方法非常相似。不同的是SubCookieUtil.getAll()方法不会立即解码 cookie 的值，而是先用和号（&amp;）拆分，将所有子cookie 保存到数组。然后，再基于等号（=）拆分每个子 cookie，使parts数组的第一个元素是子 cookie的名称，第二个元素是子 cookie 的值。两个元素都使用decodeURIComponent()解码，并添加到result对象，最后返回result对象。如果 cookie 不存在则返回null。</p>
<p>set()方法接收 7 个参数：cookie 的名称、子 cookie 的名称、子 cookie 的值、可选的Date对象用于设置 cookie 的过期时间、可选的 cookie 路径、可选的 cookie 域和可选的布尔值secure标志。所有可选的参数都作用于 cookie 本身，而不是子 cookie。为了在同一个 cookie 中存储多个子 cookie，路径、域和secure标志也必须相同。过期时间作用于整个 cookie，可以在写入个别子 cookie 时另行设置。在这个方法内部，第一步是取得给定 cookie 名称下包含的所有子 cookie。逻辑或操作符（||）在这里用于在getAll()返回null的情况下将subcookies设置为新对象。然后，在subcookies上设置完子cookie 的值，再将参数传给setAll()。<br>setAll()方法接收 6 个参数：cookie 的名称、包含所有子 cookie 的对象，然后是set()方法中使用的 4 个可选参数。这个方法会在for-in循环中迭代第二个参数的属性。为保证只存储合适的数据，这里使用了hasOwnProperty()方法确保只有实例属性才会序列化为子 cookie。因为存在属性名等于空字符串的可能，所以在添加到subcookieParts数组之前也要检查属性名的长度。subcookieParts数组包含了子 cookie 的名/值对，这样我们可以方便地使用join()方法用和号将它们拼接成字符串。剩下的逻辑与CookieUtil.set()一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 document.cookie=data=name=Nicholas&amp;book=Professional%20JavaScript </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置两个子 cookie </span></span><br><span class="line"><span class="title class_">SubCookieUtil</span>.<span class="title function_">set</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>); </span><br><span class="line"><span class="title class_">SubCookieUtil</span>.<span class="title function_">set</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;Professional JavaScript&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置所有子 cookie 并传入过期时间 </span></span><br><span class="line"><span class="title class_">SubCookieUtil</span>.<span class="title function_">setAll</span>(<span class="string">&quot;data&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, <span class="attr">book</span>: <span class="string">&quot;Professional JavaScript&quot;</span> &#125;, </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;January 1, 2010&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改&quot;name&quot;的值并修改整个 cookie 的过期时间 </span></span><br><span class="line"><span class="title class_">SubCookieUtil</span>.<span class="title function_">set</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Michael&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;February 1, 2010&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>最后一组子 cookie 相关的方法是要删除子 cookie 的。常规 cookie 可以通过直接设置过期时间为某个过去的时间删除，但删除子 cookie 没有这么简单。为了删除子 cookie，需要先取得所有子 cookie，把要删除的那个删掉，然后再把剩下的子 cookie 设置回去。下面是相关方法的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubCookieUtil</span> &#123; </span><br><span class="line">  <span class="comment">// 省略之前的代码 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">unset</span>(<span class="params">name, subName, path, domain, secure</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> subcookies = <span class="title class_">SubCookieUtil</span>.<span class="title function_">getAll</span>(name); </span><br><span class="line">    <span class="keyword">if</span> (subcookies)&#123; </span><br><span class="line">      <span class="keyword">delete</span> subcookies[subName]; <span class="comment">// 删除 </span></span><br><span class="line">      <span class="title class_">SubCookieUtil</span>.<span class="title function_">setAll</span>(name, subcookies, <span class="literal">null</span>, path, domain, secure); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">unsetAll</span>(<span class="params">name, path, domain, secure</span>) &#123; </span><br><span class="line">    <span class="title class_">SubCookieUtil</span>.<span class="title function_">setAll</span>(name, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>), path, domain, secure); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义的这两个方法有两个不同的目的。unset()方法用于从 cookie 中删除一个子 cookie，其他子 cookie 不受影响；而unsetAll()方法与CookieUtil.unset()一样，会删除整个 cookie。与set()和setAll()一样，路径、域和secure标志必须与创建 cookie 时使用的一样。可以像下面这样使用这两个方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只删除&quot;name&quot;子 cookie </span></span><br><span class="line"><span class="title class_">SubCookieUtil</span>.<span class="title function_">unset</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;name&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除整个 cookie </span></span><br><span class="line"><span class="title class_">SubCookieUtil</span>.<span class="title function_">unsetAll</span>(<span class="string">&quot;data&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="25-1-5-使用-cookie-的注意事项"><a href="#25-1-5-使用-cookie-的注意事项" class="headerlink" title="25.1.5 使用 cookie 的注意事项"></a>25.1.5 使用 cookie 的注意事项</h4><p>HTTP-only 可以在浏览器设置，也可以在服务器设置，但只能在服务器上读取，这是因为 JavaScript 无法取得这种 cookie 的值。<br>因为所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长。即使浏览器对 cookie 大小有限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。<br>对 cookie 的限制及其特性决定了 cookie 并不是存储大量数据的理想方式。因此，其他客户端存储技术出现了。</p>
<blockquote>
<p>不要在 cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因此任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在 cookie 中。</p>
</blockquote>
<h3 id="25-2-Web-Storage"><a href="#25-2-Web-Storage" class="headerlink" title="25.2 Web Storage"></a>25.2 Web Storage</h3><p>Web Storage 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。</p>
<p>Web Storage 规范有两个目标：</p>
<ul>
<li><p>提供在 cookie 之外的存储会话数据的途径；</p>
</li>
<li><p>提供跨会话持久化存储大量数据的机制。</p>
</li>
</ul>
<p>localStorage和sessionStorage。localStorage是永久存储机制，sessionStorage是跨会话的存储机制。这两种浏览器存储 API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。</p>
<h4 id="25-2-1-Storage类型"><a href="#25-2-1-Storage类型" class="headerlink" title="25.2.1 Storage类型"></a>25.2.1 Storage类型</h4><p>Storage类型用于保存名/值对数据，直至存储空间上限（由浏览器决定）。Storage的实例与其他对象一样，但增加了以下方法。</p>
<ul>
<li><p>clear()：删除所有值；不在 Firefox 中实现。</p>
</li>
<li><p>getItem(name)：取得给定name的值。</p>
</li>
<li><p>key(index)：取得给定数值位置的名称。</p>
</li>
<li><p>removeItem(name)：删除给定name的名/值对。</p>
</li>
<li><p>setItem(name, value)：设置给定name的值。</p>
</li>
</ul>
<p>getItem()、removeItem()和setItem()方法可以直接或间接通过Storage对象调用。因为每个数据项都作为属性存储在该对象上，所以可以使用点或方括号操作符访问这些属性，通过同样的操作来设置值，也可以使用delete操作符删除属性。即便如此，通常还是建议使用方法而非属性来执行这些操作，以免意外重写某个已存在的对象成员。<br>通过length属性可以确定Storage对象中保存了多少名/值对。</p>
<blockquote>
<p>torage类型只能存储字符串。非字符串数据在存储之前会自动转换为字符串。注意，这种转换不能在获取数据时撤销。</p>
</blockquote>
<h4 id="25-2-2-sessionStorage对象"><a href="#25-2-2-sessionStorage对象" class="headerlink" title="25.2.2 sessionStorage对象"></a>25.2.2 sessionStorage对象</h4><p>sessionStorage对象只存储会话数据，这意味着数据只会存储到浏览器关闭。这跟浏览器关闭时会消失的会话 cookie 类似。存储在sessionStorage中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复。</p>
<p>因为sessionStorage对象与服务器会话紧密相关，所以在运行本地文件时不能使用。存储在sessionStorage对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限。</p>
<p>sessionStorage对象是Storage的实例，所以可以通过使用setItem()方法或直接给属性赋值给它添加数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法存储数据 </span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用属性存储数据 </span></span><br><span class="line">sessionStorage.<span class="property">book</span> = <span class="string">&quot;Professional JavaScript&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>所有现代浏览器在实现存储写入时都使用了同步阻塞方式，因此数据会被立即提交到存储。</p>
<p>通过 Web Storage 写入的任何数据都可以立即被读取。</p>
<p>在 IE8 中可以在数据赋值前调用begin()、之后调用commit()来强制将数据写入磁盘。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅适用于 IE8 </span></span><br><span class="line">sessionStorage.<span class="title function_">begin</span>(); </span><br><span class="line">sessionStorage.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">sessionStorage.<span class="property">book</span> = <span class="string">&quot;Professional JavaScript&quot;</span>; </span><br><span class="line">sessionStorage.<span class="title function_">commit</span>();</span><br></pre></td></tr></table></figure>

<p>以上代码确保了”name”和”book”在commit()调用之后会立即写入磁盘。调用begin()是为了保证在代码执行期间不会有写入磁盘的操作。对于少量数据，这个过程不是必要的，但对于较大的数据量，如文档，则可以考虑使用这种事务性方法。<br>对存在于sessionStorage上的数据，可以使用getItem()或直接访问属性名来取得。</p>
<p>可以结合sessionStorage的length属性和key()方法遍历所有的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = sessionStorage.<span class="property">length</span>; i &lt; len; i++)&#123; </span><br><span class="line">  <span class="keyword">let</span> key = sessionStorage.<span class="title function_">key</span>(i); </span><br><span class="line">  <span class="keyword">let</span> value = sessionStorage.<span class="title function_">getItem</span>(key); </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=`</span>$&#123;value&#125;<span class="string">`); </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用for-in循环迭代sessionStorage的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> sessionStorage)&#123; </span><br><span class="line">  <span class="keyword">let</span> value = sessionStorage.<span class="title function_">getItem</span>(key); </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要从sessionStorage中删除数据，可以使用delete操作符直接删除对象属性，也可以使用removeItem()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 delete 删除值 </span></span><br><span class="line"><span class="keyword">delete</span> sessionStorage.<span class="property">name</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法删除值 </span></span><br><span class="line">sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;book&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>sessionStorage对象应该主要用于存储只在会话期间有效的小块数据。如果需要跨会话持久存储数据，可以使用globalStorage或localStorage。</p>
<h4 id="25-2-3-localStorage对象"><a href="#25-2-3-localStorage对象" class="headerlink" title="25.2.3 localStorage对象"></a>25.2.3 localStorage对象</h4><p>localStorage对象作为在客户端持久存储数据的机制。要访问同一个localStorage对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法存储数据 </span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用属性存储数据 </span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="property">book</span> = <span class="string">&quot;Professional JavaScript&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法取得数据 </span></span><br><span class="line"><span class="keyword">let</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;name&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用属性取得数据 </span></span><br><span class="line"><span class="keyword">let</span> book = <span class="variable language_">localStorage</span>.<span class="property">book</span>;</span><br></pre></td></tr></table></figure>

<p>两种存储方法的区别在于，存储在localStorage中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。localStorage数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失。</p>
<h4 id="25-2-4-存储事件"><a href="#25-2-4-存储事件" class="headerlink" title="25.2.4 存储事件"></a>25.2.4 存储事件</h4><p>每当Storage对象发生变化时，都会在文档上触发storage事件。使用属性或setItem()设置值、使用delete或removeItem()删除值，以及每次调用clear()时都会触发这个事件。这个事件的事件对象有如下 4 个属性。</p>
<ul>
<li><p>domain：存储变化对应的域。</p>
</li>
<li><p>key：被设置或删除的键。</p>
</li>
<li><p>newValue：键被设置的新值，若键被删除则为null。</p>
</li>
<li><p>oldValue：键变化之前的值。</p>
</li>
</ul>
<p>可以使用如下代码监听storage事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;storage&quot;</span>, </span><br><span class="line">    <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;Storage changed for $&#123;event.domain&#125;&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>对于sessionStorage和localStorage上的任何更改都会触发storage事件，但storage事件不会区分这两者。</p>
<h4 id="25-2-5-限制"><a href="#25-2-5-限制" class="headerlink" title="25.2.5 限制"></a>25.2.5 限制</h4><p>不同浏览器给localStorage和sessionStorage设置了不同的空间限制，但大多数会限制为每个源 5MB。</p>
<h3 id="25-3-IndexedDB"><a href="#25-3-IndexedDB" class="headerlink" title="25.3 IndexedDB"></a>25.3 IndexedDB</h3><p>Indexed Database API 简称 IndexedDB，是浏览器中存储结构化数据的一个方案。</p>
<p>IndexedDB 的设计几乎完全是异步的。为此，大多数操作以请求的形式执行，这些请求会异步执行，产生成功的结果或错误。绝大多数 IndexedDB 操作要求添加onerror和onsuccess事件处理程序来确定输出。</p>
<h4 id="25-3-1-数据库"><a href="#25-3-1-数据库" class="headerlink" title="25.3.1 数据库"></a>25.3.1 数据库</h4><p>IndexedDB 是类似于 MySQL 或 Web SQL Database 的数据库。与传统数据库最大的区别在于，IndexedDB 使用对象存储而不是表格保存数据。IndexedDB 数据库就是在一个公共命名空间下的一组对象存储，类似于 NoSQL 风格的实现。<br>使用 IndexedDB 数据库的第一步是调用indexedDB.open()方法，并给它传入一个要打开的数据库名称。如果给定名称的数据库已存在，则会发送一个打开它的请求；如果不存在，则会发送创建并打开这个数据库的请求。这个方法会返回IDBRequest的实例，可以在这个实例上添加onerror和onsuccess事件处理程序。举例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db, </span><br><span class="line">    request, </span><br><span class="line">    version = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">request = indexedDB.<span class="title function_">open</span>(<span class="string">&quot;admin&quot;</span>, version); </span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> </span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`Failed to open: <span class="subst">$&#123;event.target.errorCode&#125;</span>`</span>); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在两个事件处理程序中，event.target都指向request，因此使用哪个都可以。如果onsuccess事件处理程序被调用，说明可以通过event.target.result访问数据库（IDBDatabase）实例了，这个实例会保存到db变量中。之后，所有与数据库相关的操作都要通过db对象本身来进行。如果打开数据库期间发生错误，event.target.errorCode中就会存储表示问题的错误码。</p>
<h4 id="25-3-2-对象存储"><a href="#25-3-2-对象存储" class="headerlink" title="25.3.2 对象存储"></a>25.3.2 对象存储</h4><p>建立了数据库连接之后，下一步就是使用对象存储。如果数据库版本与期待的不一致，那可能需要创建对象存储。不过，在创建对象存储前，有必要想一想要存储什么类型的数据。<br>假设要存储包含用户名、密码等内容的用户记录。可以用如下对象来表示一条记录：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; </span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;007&quot;</span>, </span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;James&quot;</span>, </span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Bond&quot;</span>, </span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户名必须全局唯一，它也是大多数情况下访问数据的凭据。这个键很重要，因为创建对象存储时必须指定一个键。</p>
<p>数据库的版本决定了数据库模式，包括数据库中的对象存储和这些对象存储的结构。如果数据库还不存在，open()操作会创建一个新数据库，然后触发upgradeneeded事件。可以为这个事件设置处理程序，并在处理程序中创建数据库模式。如果数据库存在，而你指定了一个升级版的版本号，则会立即触发upgradeneeded事件，因而可以在事件处理程序中更新数据库模式。<br>下面的代码演示了为存储上述用户信息如何创建对象存储：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在则删除当前 objectStore。测试的时候可以这样做 </span></span><br><span class="line">  <span class="comment">// 但这样会在每次执行事件处理程序时删除已有数据 </span></span><br><span class="line">  <span class="keyword">if</span> (db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&quot;users&quot;</span>)) &#123; </span><br><span class="line">    db.<span class="title function_">deleteObjectStore</span>(<span class="string">&quot;users&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;users&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;username&quot;</span> &#125;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="25-3-3-事务"><a href="#25-3-3-事务" class="headerlink" title="25.3.3 事务"></a>25.3.3 事务</h4><p>创建了对象存储之后，剩下的所有操作都是通过事务完成的。事务要通过调用数据库对象的transaction()方法创建。任何时候，只要想要读取或修改数据，都要通过事务把所有修改操作组织起来。最简单的情况下，可以像下面这样创建事务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>();</span><br></pre></td></tr></table></figure>

<p>如果不指定参数，则对数据库中所有的对象存储有只读权限。更具体的方式是指定一个或多个要访问的对象存储的名称：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样可以确保在事务期间只加载users对象存储的信息。如果想要访问多个对象存储，可以给第一个参数传入一个字符串数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&quot;users&quot;</span>, <span class="string">&quot;anotherStore&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>如前所述，每个事务都以只读方式访问数据。要修改访问模式，可以传入第二个参数。这个参数应该是下列三个字符串之一：”readonly”、”readwrite”或”versionchange”。比如：</p>
<p>有了事务的引用，就可以使用objectStore()方法并传入对象存储的名称以访问特定的对象存储。然后，可以使用add()和put()方法添加和更新对象，使用get()取得对象，使用delete()删除对象，使用clear()删除所有对象。其中，get()和delete()方法都接收对象键作为参数，这 5 个方法都创建新的请求对象。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    request = store.<span class="title function_">get</span>(<span class="string">&quot;007&quot;</span>); </span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Did not get the object!&quot;</span>); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">result</span>.<span class="property">firstName</span>);</span><br></pre></td></tr></table></figure>

<p>因为一个事务可以完成任意多个请求，所以事务对象本身也有事件处理程序：onerror和oncomplete。这两个事件可以用来获取事务级的状态信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transaction.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 整个事务被取消 </span></span><br><span class="line">&#125;; </span><br><span class="line">transaction.<span class="property">oncomplete</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 整个事务成功完成 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能通过oncomplete事件处理程序的event对象访问get()请求返回的任何数据。因此，需要通过这些请求的onsuccess事件处理程序来获取数据。</p>
</blockquote>
<h4 id="25-3-4-插入对象"><a href="#25-3-4-插入对象" class="headerlink" title="25.3.4 插入对象"></a>25.3.4 插入对象</h4><p>使用add()或put()写入数据了。这两个方法都接收一个参数，即要存储的对象，并把对象保存到对象存储。这两个方法只在对象存储中已存在同名的键时有区别。这种情况下，add()会导致错误，而put()会简单地重写该对象。更简单地说，可以把add()想象成插入新值，而把put()想象为更新值。因此第一次初始化对象存储时，可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users 是一个用户数据的数组 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) &#123; </span><br><span class="line">   store.<span class="title function_">add</span>(user); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用add()或put()都会创建对象存储的新更新请求。如果想验证请求成功与否，可以把请求对象保存到一个变量，然后为它添加onerror和onsuccess事件处理程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users 是一个用户数据的数组 </span></span><br><span class="line"><span class="keyword">let</span> request, </span><br><span class="line">    requests = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> users) &#123; </span><br><span class="line">  request = store.<span class="title function_">add</span>(user); </span><br><span class="line">  request.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 处理错误 </span></span><br><span class="line">  &#125;; </span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 处理成功 </span></span><br><span class="line">  &#125;; </span><br><span class="line">  requests.<span class="title function_">push</span>(request); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-3-5-通过游标查询"><a href="#25-3-5-通过游标查询" class="headerlink" title="25.3.5 通过游标查询"></a>25.3.5 通过游标查询</h4><p>使用事务可以通过一个已知键取得一条记录。如果想取得多条数据，则需要在事务中创建一个游标。游标是一个指向结果集的指针。与传统数据库查询不同，游标不会事先收集所有结果。相反，游标指向第一个结果，并在接到指令前不会主动查找下一条数据。<br>需要在对象存储上调用openCursor()方法创建游标。与其他 IndexedDB操作一样，openCursor()方法也返回一个请求，因此必须为它添加onsuccess和onerror事件处理程序。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    request = store.<span class="title function_">openCursor</span>(); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 处理成功 </span></span><br><span class="line">&#125;; </span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 处理错误 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在调用onsuccess事件处理程序时，可以通过event.target.result访问对象存储中的下一条记录，这个属性中保存着IDBCursor的实例（有下一条记录时）或null（没有记录时）。这个IDBCursor实例有几个属性。</p>
<ul>
<li><p>direction：字符串常量，表示游标的前进方向以及是否应该遍历所有重复的值。可能的值包括：NEXT(“next”)、NEXTUNIQUE(“nextunique”)、PREV(“prev”)、PREVUNIQUE(“prevunique”)。</p>
</li>
<li><p>key：对象的键。</p>
</li>
<li><p>value：实际的对象。</p>
</li>
<li><p>primaryKey：游标使用的键。可能是对象键或索引键。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">$&#123;cursor.key&#125;</span>, Value: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(cursor.value)&#125;</span>`</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个例子中的cursor.value保存着实际的对象。正因为如此，在显示它之前才需要使用JSON 来编码。</p>
</blockquote>
<p>游标可用于更新个别记录。update()方法使用指定的对象更新当前游标对应的值。与其他类似操作一样，调用update()会创建一个新请求，因此如果想知道结果，需要为onsuccess和onerror赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line">  <span class="keyword">let</span> value, </span><br><span class="line">      updateRequest; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查 </span></span><br><span class="line">    <span class="keyword">if</span> (cursor.<span class="property">key</span> == <span class="string">&quot;foo&quot;</span>) &#123; </span><br><span class="line">      value = cursor.<span class="property">value</span>;                 <span class="comment">// 取得当前对象 </span></span><br><span class="line">      value.<span class="property">password</span> = <span class="string">&quot;magic!&quot;</span>;            <span class="comment">// 更新密码 </span></span><br><span class="line">      updateRequest = cursor.<span class="title function_">update</span>(value); <span class="comment">// 请求保存更新后的对象 </span></span><br><span class="line">      updateRequest.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 处理成功 </span></span><br><span class="line">      &#125;; </span><br><span class="line">      updateRequest.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 处理错误 </span></span><br><span class="line">      &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以调用delelte()来删除游标位置的记录，与update()一样，这也会创建一个请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line">  <span class="keyword">let</span> value, </span><br><span class="line">      deleteRequest; </span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查 </span></span><br><span class="line">    <span class="keyword">if</span> (cursor.<span class="property">key</span> == <span class="string">&quot;foo&quot;</span>) &#123; </span><br><span class="line">      deleteRequest = cursor.<span class="title function_">delete</span>();  <span class="comment">// 请求删除对象 </span></span><br><span class="line">      deleteRequest.<span class="property">onsuccess</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 处理成功 </span></span><br><span class="line">      &#125;; </span><br><span class="line">      deleteRequest.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 处理错误 </span></span><br><span class="line">      &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果事务没有修改对象存储的权限，update()和delete()都会抛出错误。<br>默认情况下，每个游标只会创建一个请求。要创建另一个请求，必须调用下列中的一个方法。</p>
<ul>
<li><p>continue(key)：移动到结果集中的下一条记录。参数key是可选的。如果没有指定key，游标就移动到下一条记录；如果指定了，则游标移动到指定的键。</p>
</li>
<li><p>advance(count)：游标向前移动指定的count条记录。</p>
</li>
</ul>
<p>这两个方法都会让游标重用相同的请求，因此也会重用onsuccess和onerror处理程序，直至不再需要。例如，下面的代码迭代了一个对象存储中的所有记录：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123;  <span class="comment">// 永远要检查 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">$&#123;cursor.key&#125;</span>, Value: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(cursor.value)&#125;</span>`</span>); </span><br><span class="line">    cursor.<span class="title function_">continue</span>();  <span class="comment">// 移动到下一条记录 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done!&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="25-3-6-键范围"><a href="#25-3-6-键范围" class="headerlink" title="25.3.6 键范围"></a>25.3.6 键范围</h4><p>使用键范围（key range）可以让游标更容易管理。键范围对应IDBKeyRange的实例。有四种方式指定键范围，第一种是使用only()方法并传入想要获取的键：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onlyRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">only</span>(<span class="string">&quot;007&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个范围保证只获取键为”007”的值。使用这个范围创建的游标类似于直接访问对象存储并调用get(“007”)。<br>第二种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从”007”这个键开始，直到最后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从&quot;007&quot;记录开始，直到最后 </span></span><br><span class="line"><span class="keyword">const</span> lowerRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">lowerBound</span>(<span class="string">&quot;007&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果想从”007”后面的记录开始，可以再传入第二个参数true。</p>
<p>第三种键范围可以定义结果集的上限，通过调用upperBound()方法可以指定游标不会越过的记录。</p>
<p>要同时指定下限和上限，可以使用bound()方法。这个方法接收四个参数：下限的键、上限的键、可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限。下面是几个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从&quot;007&quot;记录开始，到&quot;ace&quot;记录停止 </span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>); </span><br><span class="line"><span class="comment">// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;记录停止 </span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 从&quot;007&quot;的下一条记录开始，到&quot;ace&quot;的前一条记录停止 </span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 从&quot;007&quot;记录开始，到&quot;ace&quot;的前一条记录停止 </span></span><br><span class="line"><span class="keyword">const</span> boundRange = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>定义了范围之后，把它传给openCursor()方法，就可以得到位于该范围内的游标：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>).<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    range = <span class="title class_">IDBKeyRange</span>.<span class="title function_">bound</span>(<span class="string">&quot;007&quot;</span>, <span class="string">&quot;ace&quot;</span>); </span><br><span class="line">    request = store.<span class="title function_">openCursor</span>(range); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123; </span><br><span class="line">  <span class="keyword">const</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line">  <span class="keyword">if</span> (cursor) &#123; <span class="comment">// 永远要检查 </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Key: <span class="subst">$&#123;cursor.key&#125;</span>, Value: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(cursor.value)&#125;</span>`</span>); </span><br><span class="line">    cursor.<span class="title function_">continue</span>(); <span class="comment">// 移动到下一条记录 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done!&quot;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="25-3-7-设置游标方向"><a href="#25-3-7-设置游标方向" class="headerlink" title="25.3.7 设置游标方向"></a>25.3.7 设置游标方向</h4><p>openCursor()方法实际上可以接收两个参数，第一个是IDBKeyRange的实例，第二个是表示方向的字符串。通常，游标都是从对象存储的第一条记录开始，每次调用continue()或advance()都会向最后一条记录前进。这样的游标其默认方向为”next”。如果对象存储中有重复的记录，可能需要游标跳过那些重复的项。为此，可以给openCursor()的第二个参数传入”nextunique”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    request = store.<span class="title function_">openCursor</span>(<span class="literal">null</span>, <span class="string">&quot;nextunique&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>openCursor()的第一个参数是null，表示默认的键范围是所有值。此游标会遍历对象存储中的记录，从第一条记录开始迭代，到最后一条记录，但会跳过重复的记录。</p>
</blockquote>
<p>另外，也可以创建在对象存储中反向移动的游标，从最后一项开始向第一项移动。此时需要给openCursor()传入”prev”或”prevunique”作为第二个参数（后者的意思当然是避免重复）。</p>
<p>在使用”prev”或”prevunique”打开游标时，每次调用continue()或advance()都会在对象存储中反向移动游标。</p>
<h4 id="25-3-8-索引"><a href="#25-3-8-索引" class="headerlink" title="25.3.8 索引"></a>25.3.8 索引</h4><p>对某些数据集，可能需要为对象存储指定多个键。</p>
<p>要创建新索引，首先要取得对象存储的引用，然后像下面的例子一样调用createIndex()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    index = store.<span class="title function_">createIndex</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;username&quot;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>createIndex()的第一个参数是索引的名称，第二个参数是索引属性的名称，第三个参数是包含键unique的options对象。这个选项中的unique应该必须指定，表示这个键是否在所有记录中唯一。因为username可能不会重复，所以这个键是唯一的。<br>createIndex()返回的是IDBIndex实例。在对象存储上调用index()方法也可以得到同一个实例。例如，要使用一个已存在的名为”username”的索引，可以像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>索引非常像对象存储。可以在索引上使用openCursor()方法创建新游标，这个游标与在对象存储上调用openCursor()创建的游标完全一样。只是其result.key属性中保存的是索引键，而不是主键。下面看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>), </span><br><span class="line">    request = index.<span class="title function_">openCursor</span>(); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 处理成功 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用openKeyCursor()方法也可以在索引上创建特殊游标，只返回每条记录的主键。这个方法接收的参数与openCursor()一样。最大的不同在于，event.result.key是索引键，且event.result.value是主键而不是整个记录。</p>
<p>可以使用get()方法并传入索引键通过索引取得单条记录，这会创建一个新请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>), </span><br><span class="line">    request = index.<span class="title function_">get</span>(<span class="string">&quot;007&quot;</span>); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 处理成功 </span></span><br><span class="line">&#125;; </span><br><span class="line">request.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 处理错误 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果想只取得给定索引键的主键，可以使用getKey()方法。这样也会创建一个新请求，但result.value等于主键而不是整个记录：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    index = store.<span class="title function_">index</span>(<span class="string">&quot;username&quot;</span>), </span><br><span class="line">    request = index.<span class="title function_">getKey</span>(<span class="string">&quot;007&quot;</span>); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 处理成功 </span></span><br><span class="line">  <span class="comment">// event.target.result.key 是索引键，event.target.result.value 是主键 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个onsuccess事件处理程序中，event.target.result.value中应该是用户 ID。<br>任何时候，都可以使用IDBIndex对象的下列属性取得索引的相关信息。</p>
<ul>
<li><p>name：索引的名称。</p>
</li>
<li><p>keyPath：调用createIndex()时传入的属性路径。</p>
</li>
<li><p>objectStore：索引对应的对象存储。</p>
</li>
<li><p>unique：表示索引键是否唯一的布尔值。</p>
</li>
</ul>
<p>对象存储自身也有一个indexNames属性，保存着与之相关索引的名称。使用如下代码可以方便地了解对象存储上已存在哪些索引：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    indexNames = store.<span class="property">indexNames</span> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> indexName <span class="keyword">in</span> indexNames) &#123; </span><br><span class="line">    <span class="keyword">const</span> index = store.<span class="title function_">index</span>(indexName); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Index name: <span class="subst">$&#123;index.name&#125;</span> </span></span><br><span class="line"><span class="string">                 KeyPath: <span class="subst">$&#123;index.keyPath&#125;</span> </span></span><br><span class="line"><span class="string">                 Unique: <span class="subst">$&#123;index.unique&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象存储上调用deleteIndex()方法并传入索引的名称可以删除索引：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;users&quot;</span>), </span><br><span class="line">    store.<span class="title function_">deleteIndex</span>(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为删除索引不会影响对象存储中的数据，所以这个操作没有回调。</p>
<h4 id="25-3-9-并发问题"><a href="#25-3-9-并发问题" class="headerlink" title="25.3.9 并发问题"></a>25.3.9 并发问题</h4><p>IndexedDB 虽然是网页中的异步 API，但仍存在并发问题。</p>
<p>第一次打开数据库时，添加onversionchange事件处理程序非常重要。另一个同源标签页将数据库打开到新版本时，将执行此回调。对这个事件最好的回应是立即关闭数据库，以便完成版本升级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request, database; </span><br><span class="line"></span><br><span class="line">request = indexedDB.<span class="title function_">open</span>(<span class="string">&quot;admin&quot;</span>, <span class="number">1</span>); </span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line">  database = event.<span class="property">target</span>.<span class="property">result</span>; </span><br><span class="line">  database.<span class="property">onversionchange</span> = <span class="function">() =&gt;</span> database.<span class="title function_">close</span>(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>应该在每次成功打开数据库后都指定onversionchange事件处理程序。记住，onversionchange有可能会被其他标签页触发。<br>通过始终都指定这些事件处理程序，可以保证 Web 应用程序能够更好地处理与 IndexedDB 相关的并发问题。</p>
<h4 id="25-3-10-限制"><a href="#25-3-10-限制" class="headerlink" title="25.3.10 限制"></a>25.3.10 限制</h4><p>首先，IndexedDB 数据库是与页面源（协议、域和端口）绑定的，因此信息不能跨域共享。这意味着 <a target="_blank" rel="noopener" href="http://www.wrox.com/">www.wrox.com</a> 和 p2p.wrox.com 会对应不同的数据存储。<br>其次，每个源都有可以存储的空间限制。当前 Firefox 的限制是每个源 50MB，而 Chrome 是 5MB。移动版 Firefox 有 5MB 限制，如果用度超出配额则会请求用户许可。<br>Firefox 还有一个限制——本地文本不能访问 IndexedDB 数据库。Chrome 没有这个限制。因此在本地运行本书示例时，要使用 Chrome。</p>
<h3 id="25-4-小结"><a href="#25-4-小结" class="headerlink" title="25.4 小结"></a>25.4 小结</h3><p>Web Storage 定义了两个对象用于存储数据：sessionStorage和localStorage。前者用于严格保存浏览器一次会话期间的数据，因为数据会在浏览器关闭时被删除。后者用于会话之外持久保存数据。<br>IndexedDB 是类似于 SQL 数据库的结构化数据存储机制。不同的是，IndexedDB 存储的是对象，而不是数据表。对象存储是通过定义键然后添加数据来创建的。游标用于查询对象存储中的特定数据，而索引可以针对特定属性实现更快的查询。<br>有了这些存储手段，就可以在客户端通过使用 JavaScript 存储可观的数据。因为这些数据没有加密，所以要注意不能使用它们存储敏感信息。</p>
<h2 id="二十六、模块"><a href="#二十六、模块" class="headerlink" title="二十六、模块"></a>二十六、模块</h2><h3 id="26-1-理解模块模式"><a href="#26-1-理解模块模式" class="headerlink" title="26.1 理解模块模式"></a>26.1 理解模块模式</h3><p>将代码拆分成独立的块，然后再把这些块连接起来可以通过模块模式来实现。这种模式背后的思想很简单：把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。</p>
<h4 id="26-1-1-模块标识符"><a href="#26-1-1-模块标识符" class="headerlink" title="26.1.1 模块标识符"></a>26.1.1 模块标识符</h4><p>模块标识符是所有模块系统通用的概念。模块系统本质上是键/值实体，其中每个模块都有个可用于引用它的标识符。这个标识符在模拟模块的系统中可能是字符串，在原生实现的模块系统中可能是模块文件的实际路径。<br>有的模块系统支持明确声明模块的标识，还有的模块系统会隐式地使用文件名作为模块标识符。不管怎样，完善的模块系统一定不会存在模块标识冲突的问题，且系统中的任何模块都应该能够无歧义地引用其他模块。<br>将模块标识符解析为实际模块的过程要根据模块系统对标识符的实现。原生浏览器模块标识符必须提供实际 JavaScript 文件的路径。除了文件路径，Node.js 还会搜索 node_modules 目录，用标识符去匹配包含 index.js 的目录。</p>
<h4 id="26-1-2-模块依赖"><a href="#26-1-2-模块依赖" class="headerlink" title="26.1.2 模块依赖"></a>26.1.2 模块依赖</h4><p>模块系统的核心是管理依赖。指定依赖的模块与周围的环境会达成一种契约。本地模块向模块系统声明一组外部模块（依赖），这些外部模块对于当前模块正常运行是必需的。模块系统检视这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖。<br>每个模块都会与某个唯一的标识符关联，该标识符可用于检索模块。这个标识符通常是 JavaScript文件的路径，但在某些模块系统中，这个标识符也可以是在模块本身内部声明的命名空间路径字符串。</p>
<h4 id="26-1-3-模块加载"><a href="#26-1-3-模块加载" class="headerlink" title="26.1.3 模块加载"></a>26.1.3 模块加载</h4><p>加载模块的概念派生自依赖契约。当一个外部模块被指定为依赖时，本地模块期望在执行它时，依赖已准备好并已初始化。<br>在浏览器中，加载模块涉及几个步骤。加载模块涉及执行其中的代码，但必须是在所有依赖都加载并执行之后。如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回。收到模块代码之后，浏览器必须确定刚收到的模块是否也有依赖。然后递归地评估并加载所有依赖，直到所有依赖模块都加载完成。只有整个依赖图都加载完成，才可以执行入口模块。</p>
<h4 id="26-1-4-入口"><a href="#26-1-4-入口" class="headerlink" title="26.1.4 入口"></a>26.1.4 入口</h4><p>相互依赖的模块必须指定一个模块作为入口（entry point），这也是代码执行的起点。</p>
<p>模块化 JavaScript 应用程序的所有模块会构成依赖图。</p>
<p>可以通过有向图来表示应用程序中各模块的依赖关系。</p>
<p>在 JavaScript 中，“加载”的概念可以有多种实现方式。因为模块是作为包含将立即执行的 JavaScript代码的文件实现的，所以一种可能是按照依赖图的要求依次请求各个脚本。</p>
<p>模块加载是“阻塞的”，这意味着前置操作必须完成才能执行后续操作。每个模块在自己的代码到达浏览器之后完成加载，此时其依赖已经加载并初始化。</p>
<h4 id="26-1-5-异步依赖"><a href="#26-1-5-异步依赖" class="headerlink" title="26.1.5 异步依赖"></a>26.1.5 异步依赖</h4><p>可以让 JavaScript 通知模块系统在必要时加载新模块，并在模块加载完成后提供回调。在代码层面，可以通过下面的伪代码来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在模块 A 里面 </span></span><br><span class="line"><span class="title function_">load</span>(<span class="string">&#x27;moduleB&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">moduleB</span>) &#123; </span><br><span class="line">  moduleB.<span class="title function_">doStuff</span>(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果重写前面的应用程序，只使用动态模块加载，那么使用一个&lt;**script**&gt;标签即可完成模块 A 的加载。模块 A 会按需请求模块文件，而不会生成必需的依赖列表。这样有几个好处，其中之一就是性能，因为在页面加载时只需同步加载一个文件。</p>
<h4 id="26-1-6-动态依赖"><a href="#26-1-6-动态依赖" class="headerlink" title="26.1.6 动态依赖"></a>26.1.6 动态依赖</h4><p>动态添加的依赖有别于模块开头列出的常规依赖，这些依赖必须在模块执行前加载完毕。<br>下面是动态依赖加载的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loadCondition) &#123; </span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态依赖可以支持更复杂的依赖关系，但代价是增加了对模块进行静态分析的难度。</p>
<h4 id="26-1-7-静态分析"><a href="#26-1-7-静态分析" class="headerlink" title="26.1.7 静态分析"></a>26.1.7 静态分析</h4><p>模块中包含的发送到浏览器的 JavaScript 代码经常会被静态分析，分析工具会检查代码结构并在不实际执行代码的情况下推断其行为。对静态分析友好的模块系统可以让模块打包系统更容易将代码处理为较少的文件。它还将支持在智能编辑器里智能自动完成。<br>更复杂的模块行为，例如动态依赖，会导致静态分析更困难。不同的模块系统和模块加载器具有不同层次的复杂度。至于模块的依赖，额外的复杂度会导致相关工具更难预测模块在执行时到底需要哪些依赖。</p>
<h4 id="26-1-8-循环依赖"><a href="#26-1-8-循环依赖" class="headerlink" title="26.1.8 循环依赖"></a>26.1.8 循环依赖</h4><p>包括 CommonJS、AMD 和ES6 在内的所有模块系统都支持循环依赖。</p>
<h3 id="26-2-凑合的模块系统"><a href="#26-2-凑合的模块系统" class="headerlink" title="26.2 凑合的模块系统"></a>26.2 凑合的模块系统</h3><p>为按照模块模式提供必要的封装，ES6 之前的模块有时候会使用函数作用域和立即调用函数表达式（IIFE，Immediately Invoked Function Expression）将模块定义封装在匿名闭包中。模块定义是立即执行的，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="comment">// 私有 Foo 模块的代码 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>如果把这个模块的返回值赋给一个变量，那么实际上就为模块创建了命名空间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为了暴露公共 API，模块 IIFE 会返回一个对象，其属性就是模块命名空间中的公共成员：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span>, </span><br><span class="line">    <span class="attr">baz</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">bar</span>); <span class="comment">// &#x27;baz&#x27; </span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">baz</span>();            <span class="comment">// &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类似地，还有一种模式叫作“泄露模块模式”（revealing module pattern）。这种模式只返回一个对象，其属性是私有数据和成员的引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line">  <span class="keyword">var</span> baz = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">bar</span>: bar, </span><br><span class="line">    <span class="attr">baz</span>: baz </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">bar</span>); <span class="comment">// &#x27;baz&#x27; </span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">baz</span>();            <span class="comment">// &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在模块内部也可以定义模块，这样可以实现命名空间嵌套：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span> </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">baz</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">qux</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">bar</span>); <span class="comment">// &#x27;baz&#x27; </span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">baz</span>.<span class="title function_">qux</span>();        <span class="comment">// &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为了让模块正确使用外部的值，可以将它们作为参数传给 IIFE：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalBar = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params">bar</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">bar</span>: bar, </span><br><span class="line">    <span class="attr">baz</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(bar); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;)(globalBar); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">bar</span>); <span class="comment">// &#x27;baz&#x27; </span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">baz</span>();            <span class="comment">// &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为这里的模块实现其实就是在创建 JavaScript 对象的实例，所以完全可以在定义之后再扩展模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的 Foo </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params">bar</span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">bar</span>: bar </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 Foo </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params">FooModule</span>) &#123; </span><br><span class="line">  <span class="title class_">FooModule</span>.<span class="property">baz</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FooModule</span>.<span class="property">bar</span>); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">FooModule</span>; </span><br><span class="line">&#125;)(<span class="title class_">Foo</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">bar</span>); <span class="comment">// &#x27;baz&#x27; </span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">baz</span>();            <span class="comment">// &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>无论模块是否存在，配置模块扩展以执行扩展也很有用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展 Foo 以增加新方法 </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params">FooModule</span>) &#123; </span><br><span class="line">  <span class="title class_">FooModule</span>.<span class="property">baz</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FooModule</span>.<span class="property">bar</span>); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">FooModule</span>; </span><br><span class="line">&#125;)(<span class="title class_">Foo</span> || &#123;&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 Foo 以增加新数据 </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Foo</span> = (<span class="keyword">function</span>(<span class="params">FooModule</span>) &#123; </span><br><span class="line">  <span class="title class_">FooModule</span>.<span class="property">bar</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">FooModule</span>; </span><br><span class="line">&#125;)(<span class="title class_">Foo</span> || &#123;&#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">bar</span>); <span class="comment">// &#x27;baz&#x27; </span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">baz</span>();            <span class="comment">// &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="26-3-使用-ES6-之前的模块加载器"><a href="#26-3-使用-ES6-之前的模块加载器" class="headerlink" title="26.3 使用 ES6 之前的模块加载器"></a>26.3 使用 ES6 之前的模块加载器</h3><p>在 ES6 原生支持模块之前，使用模块的 JavaScript 代码本质上是希望使用默认没有的语言特性。因此，必须按照符合某种规范的模块语法来编写代码，另外还需要单独的模块工具把这些模块语法与JavaScript 运行时连接起来。这里的模块语法和连接方式有不同的表现形式，通常需要在浏览器中额外加载库或者在构建时完成预处理。</p>
<h4 id="26-3-1-CommonJS"><a href="#26-3-1-CommonJS" class="headerlink" title="26.3.1 CommonJS"></a>26.3.1 CommonJS</h4><p>CommonJS 规范概述了同步声明依赖的模块定义。这个规范主要用于在服务器端实现模块化代码组织，但也可用于定义在浏览器中使用的模块依赖。CommonJS 模块语法不能在浏览器中直接运行。</p>
<blockquote>
<p>一般认为，Node.js的模块系统使用了 CommonJS规范，实际上并不完全正确。Node.js使用了轻微修改版本的 CommonJS，因为 Node.js 主要在服务器环境下使用，所以不需要考虑网络延迟问题。</p>
</blockquote>
<p>CommonJS 模块定义需要使用require()指定依赖，而使用exports对象定义自己的公共 API。</p>
<p>求模块会加载相应模块，而把模块赋值给变量也非常常见，但赋值给变量不是必需的。调用require()意味着模块会原封不动地加载进来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;moduleA&#x27;</span>); </span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>); <span class="comment">// &quot;moduleA&quot;</span></span><br></pre></td></tr></table></figure>

<p>无论一个模块在require()中被引用多少次，模块永远是单例。</p>
<p>模块第一次加载后会被缓存，后续加载会取得缓存的模块（如下代码所示）。模块加载顺序由依赖图决定。</p>
<p>在 CommonJS 中，模块加载是模块系统执行的同步操作。因此require()可以像下面这样以编程方式嵌入在模块中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;moduleA&#x27;</span>); </span><br><span class="line"><span class="keyword">if</span> (loadCondition) &#123; </span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node.js 会使用require()调用中的模块标识符字符串去解析模块引用。在Node.js中可以使用绝对或相对路径，也可以使用安装在 node_modules 目录中依赖的模块标识符。</p>
<p>所有 CommonJS 风格的实现共同之处是模块不会指定自己的标识符，它们的标识符由其在模块文件层级中的位置决定。<br>指向模块定义的路径可能引用一个目录，也可能是一个 JavaScript 文件。</p>
<p>如果有模块想使用这个接口，可以像下面这样导入它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(moduleA.<span class="property">stuff</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此模块不导出任何内容。即使它没有公共接口，如果应用程序请求了这个模块，那也会在加载时执行这个模块体。</p>
</blockquote>
<p>module.exports对象非常灵活，有多种使用方式。如果只想导出一个实体，可以直接给module. exports赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>导出多个值也很常见，可以使用对象字面量赋值或每个属性赋一次值来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价操作： </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">  <span class="attr">b</span>: <span class="string">&#x27;B&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">a</span> = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">b</span> = <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>模块的一个主要用途是托管类定义。</p>
<p>也可以将类实例作为导出值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br></pre></td></tr></table></figure>

<p>此外，CommonJS 也支持动态依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123; </span><br><span class="line">  <span class="keyword">var</span> A = <span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CommonJS 依赖几个全局属性如require和module.exports。如果想在浏览器中使用 CommonJS模块，就需要与其非原生的模块语法之间构筑“桥梁”。模块级代码与浏览器运行时之间也需要某种“屏障”，因为没有封装的 CommonJS 代码在浏览器中执行会创建全局变量。这显然与模块模式的初衷相悖。<br>常见的解决方案是提前把模块文件打包好，把全局属性转换为原生 JavaScript 结构，将模块代码封装在函数闭包中，最终只提供一个文件。为了以正确的顺序打包模块，需要事先生成全面的依赖图。</p>
<h4 id="26-3-2-异步模块定义"><a href="#26-3-2-异步模块定义" class="headerlink" title="26.3.2 异步模块定义"></a>26.3.2 异步模块定义</h4><p>CommonJS 以服务器端为目标环境，能够一次性把所有模块都加载到内存，而异步模块定义（AMD，Asynchronous Module Definition）的模块定义系统则以浏览器为目标执行环境，这需要考虑网络延迟的问题。AMD 的一般策略是让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块。<br>AMD 模块实现的核心是用函数包装模块定义。这样可以防止声明全局变量，并允许加载器库控制何时加载模块。包装函数也便于模块代码的移植，因为包装函数内部的所有模块代码使用的都是原生JavaScript 结构。包装模块的函数是全局define的参数，它是由 AMD 加载器库的实现定义的。<br>AMD 模块可以使用字符串标识符指定自己的依赖，而 AMD 加载器会在所有依赖模块加载完毕后立即调用模块工厂函数。与 CommonJS 不同，AMD 支持可选地为模块指定字符串标识符。</p>
<p>AMD 也支持require和exports对象，通过它们可以在 AMD 模块工厂函数内部定义 CommonJS风格的模块。</p>
<p>动态依赖也是通过这种方式支持的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;moduleA&#x27;</span>, [<span class="string">&#x27;require&#x27;</span>], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (condition) &#123; </span><br><span class="line">    <span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">&#x27;moduleB&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="26-3-3-通用模块定义"><a href="#26-3-3-通用模块定义" class="headerlink" title="26.3.3 通用模块定义"></a>26.3.3 通用模块定义</h4><p>为了统一 CommonJS 和 AMD 生态系统，通用模块定义（UMD，Universal Module Definition）规范应运而生。UMD 可用于创建这两个系统都可以使用的模块代码。本质上，UMD 定义的模块会在启动时检测要使用哪个模块系统，然后进行适当配置，并把所有逻辑包装在一个立即调用的函数表达式（IIFE）中。</p>
<p>下面是只包含一个依赖的 UMD 模块定义的示例（来源为 GitHub 上的 UMD 仓库）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123; </span><br><span class="line">      <span class="comment">// AMD。注册为匿名模块 </span></span><br><span class="line">      <span class="title function_">define</span>([<span class="string">&#x27;moduleB&#x27;</span>], factory); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) &#123; </span><br><span class="line">    <span class="comment">// Node。不支持严格 CommonJS </span></span><br><span class="line">    <span class="comment">// 但可以在 Node 这样支持 module.exports 的 </span></span><br><span class="line">    <span class="comment">// 类 CommonJS 环境下使用 </span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27; moduleB &#x27;</span>)); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 浏览器全局上下文（root 是 window） </span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root. moduleB); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">moduleB</span>) &#123; </span><br><span class="line">  <span class="comment">// 以某种方式使用 moduleB </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将返回值作为模块的导出 </span></span><br><span class="line">  <span class="comment">// 这个例子返回了一个对象 </span></span><br><span class="line">  <span class="comment">// 但是模块也可以返回函数作为导出值 </span></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>此模式有支持严格 CommonJS 和浏览器全局上下文的变体。</p>
<h4 id="26-3-4-模块加载器终将没落"><a href="#26-3-4-模块加载器终将没落" class="headerlink" title="26.3.4 模块加载器终将没落"></a>26.3.4 模块加载器终将没落</h4><p>随着 ECMAScript 6 模块规范得到越来越广泛的支持，本节展示的模式最终会走向没落。尽管如此，为了了解为什么选择设计决策，了解 ES6 模块规范的由来仍是非常有用的。CommonJS 与 AMD 之间的冲突正是我们现在享用的 ECMAScript 6 模块规范诞生的温床。</p>
<h3 id="26-4-使用-ES6-模块"><a href="#26-4-使用-ES6-模块" class="headerlink" title="26.4 使用 ES6 模块"></a>26.4 使用 ES6 模块</h3><p>ES6 最大的一个改进就是引入了模块规范。</p>
<h4 id="26-4-1-模块标签及定义"><a href="#26-4-1-模块标签及定义" class="headerlink" title="26.4.1 模块标签及定义"></a>26.4.1 模块标签及定义</h4><p>ECMAScript 6 模块是作为一整块 JavaScript 代码而存在的。带有type=”module”属性的&lt;**script**&gt;标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。模块可以嵌入在网页中，也可以作为外部文件引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt; </span><br><span class="line">  <span class="comment">// 模块代码 </span></span><br><span class="line">&lt;/script&gt; </span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>与传统脚本不同，所有模块都会像</p>
<h4 id="26-4-1-模块标签及定义-1"><a href="#26-4-1-模块标签及定义-1" class="headerlink" title="26.4.1 模块标签及定义"></a>26.4.1 模块标签及定义</h4><p>ECMAScript 6 模块是作为一整块 JavaScript 代码而存在的。带有type=”module”属性的&lt;**script**&gt;标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。模块可以嵌入在网页中，也可以作为外部文件引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt; </span><br><span class="line">  <span class="comment">// 模块代码 </span></span><br><span class="line">&lt;/script&gt; </span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>与传统脚本不同，所有模块都会像&lt;**script** defer&gt;加载的脚本一样按顺序执行。解析到&lt;**script** type=”module”&gt;标签后会立即下载模块文件，但执行会延迟到文档解析完成。无论对嵌入的模块代码，还是引入的外部模块文件，都是这样。&lt;**script** type=”module”&gt;在页面中出现的顺序就是它们执行的顺序。与&lt;**script** defer&gt;一样，修改模块标签的位置，无论是在还是在中，只会影响文件什么时候加载，而不会影响模块什么时候加载。</p>
<p>也可以给模块标签添加async属性。这样影响就是双重的：不仅模块执行顺序不再与&lt;**script**&gt;标签在页面中的顺序绑定，模块也不会等待文档完成解析才执行。不过，入口模块仍必须等待其依赖加载完成。<br>与&lt;**script** type=”module”&gt;标签关联的 ES6 模块被认为是模块图中的入口模块。一个页面上有多少个入口模块没有限制，重复加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次，如下面的代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- moduleA 在这个页面上只会被加载一次 --&gt; </span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt; </span><br><span class="line">  import &#x27;./moduleA.js&#x27; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">&lt;script type=&quot;module&quot;&gt; </span><br><span class="line">  import &#x27;./moduleA.js&#x27; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;./moduleA.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>嵌入的模块定义代码不能使用import加载到其他模块。只有通过外部文件加载的模块才可以使用import加载。因此，嵌入模块只适合作为入口模块。</p>
<h4 id="26-4-2-模块加载"><a href="#26-4-2-模块加载" class="headerlink" title="26.4.2 模块加载"></a>26.4.2 模块加载</h4><p>ECMAScript 6 模块的独特之处在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。</p>
<p>完全支持 ECMAScript 6 模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。浏览器会解析入口模块，确定依赖，并发送对依赖模块的请求。这些文件通过网络返回后，浏览器就会解析它们的内容，确定它们的依赖，如果这些二级依赖还没有加载，则会发送更多请求。这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。解析完依赖图，应用程序就可以正式加载模块了。<br>这个过程与 AMD 风格的模块加载非常相似。模块文件按需加载，且后续模块的请求会因为每个依赖模块的网络延迟而同步延迟。即，如果moduleA依赖moduleB，moduleB依赖moduleC。浏览器在对moduleB的请求完成之前并不知道要请求moduleC。这种加载方式效率很高，也不需要外部工具，但加载大型应用程序的深度依赖图可能要花费很长时间。</p>
<h4 id="26-4-3-模块行为"><a href="#26-4-3-模块行为" class="headerlink" title="26.4.3 模块行为"></a>26.4.3 模块行为</h4><p>ECMAScript 6 模块借用了 CommonJS 和 AMD 的很多优秀特性。</p>
<ul>
<li><p>模块代码只在加载后执行。</p>
</li>
<li><p>模块只能加载一次。</p>
</li>
<li><p>模块是单例。</p>
</li>
<li><p>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。</p>
</li>
<li><p>模块可以请求加载其他模块。</p>
</li>
<li><p>支持循环依赖。</p>
</li>
</ul>
<p>ES6 模块系统也增加了一些新行为。</p>
<ul>
<li><p>ES6 模块默认在严格模式下执行。</p>
</li>
<li><p>ES6 模块不共享全局命名空间。</p>
</li>
<li><p>模块顶级this的值是undefined（常规脚本中是window）。</p>
</li>
<li><p>模块中的var声明不会添加到window对象。</p>
</li>
<li><p>ES6 模块是异步加载和执行的。</p>
</li>
</ul>
<p>浏览器运行时在知道应该把某个文件当成模块时，会有条件地按照上述 ECMAScript 6 模块行为来施加限制。与&lt;**script** type=”module”&gt;关联或者通过import语句加载的 JavaScript 文件会被认定为模块。</p>
<h4 id="26-4-4-模块导出"><a href="#26-4-4-模块导出" class="headerlink" title="26.4.4 模块导出"></a>26.4.4 模块导出</h4><p>ES6 模块支持两种导出：命名导出和默认导出。</p>
<p>export关键字用于声明一个值为命名导出。导出语句必须在模块顶级，不能嵌套在某个块中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许 </span></span><br><span class="line"><span class="keyword">export</span> ... </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许 </span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123; </span><br><span class="line">   <span class="keyword">export</span> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导出值对模块内部 JavaScript 的执行没有直接影响，因此export语句与导出值的相对位置或者export关键字在模块中出现的顺序没有限制。export语句甚至可以出现在它要导出的值之前：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许 </span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> &#123; foo &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许，但应该避免 </span></span><br><span class="line"><span class="keyword">export</span> &#123; foo &#125;; </span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>命名导出（named export）就好像模块是被导出值的容器。行内命名导出，顾名思义，可以在同一行执行变量声明。下面展示了一个声明变量同时又导出变量的例子。外部模块可以导入这个模块，而foo将成为这个导入模块的一个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>变量声明跟导出可以不在一行。可以在export子句中执行声明并将标识符导出到模块的其他地方：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> &#123; foo &#125;;</span><br></pre></td></tr></table></figure>

<p>导出时也可以提供别名，别名必须在export子句的大括号语法中指定。因此，声明值、导出值和为导出值提供别名不能在一行完成。在下面的例子中，导入这个模块的外部模块可以使用myFoo访问导出的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo &#125;;</span><br></pre></td></tr></table></figure>

<p>因为 ES6 命名导出可以将模块作为容器，所以可以在一个模块中声明多个命名导出。导出的值可以在导出语句中声明，也可以在导出之前声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baz = <span class="string">&#x27;baz&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>ES6 模块也支持对导出声明分组，可以同时为部分或全部导出值指定别名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar <span class="keyword">as</span> myBar, baz &#125;;</span><br></pre></td></tr></table></figure>

<p>默认导出（default export）就好像模块与被导出的值是一回事。默认导出使用default关键字将一个值声明为默认导出，每个模块只能有一个默认导出。重复的默认导出会导致SyntaxError。<br>下面的例子定义了一个默认导出，外部模块可以导入这个模块，而这个模块本身就是foo的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure>

<p>另外，ES6 模块系统会识别作为别名提供的default关键字。此时，虽然对应的值是使用命名语法导出的，实际上则会成为默认导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 export default foo; </span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>因为命名导出和默认导出不会冲突，所以 ES6 支持在一个模块中同时定义这两种导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; bar &#125;; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo; </span><br><span class="line"><span class="comment">// 这两个export语句可以组合为一行： </span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span>, bar &#125;;</span><br></pre></td></tr></table></figure>

<p>ES6 规范对不同形式的export语句中可以使用什么不可以使用什么规定了限制。某些形式允许声明和赋值，某些形式只允许表达式，而某些形式则只允许简单标识符。注意，有的形式使用了分号，有的则没有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名行内导出 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baz = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>, bar = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名子句导出 </span></span><br><span class="line"><span class="keyword">export</span> &#123; foo &#125;; </span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;; </span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo, bar &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">123</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> /[a-z]*/; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; </span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar <span class="keyword">as</span> <span class="keyword">default</span> &#125;; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>*() &#123;&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 会导致错误的不同形式： </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行内默认导出中不能出现变量声明 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有标识符可以出现在 export 子句中 </span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="number">123</span> <span class="keyword">as</span> foo &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 别名只能在 export 子句中出现 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span> <span class="keyword">as</span> myFoo;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般来说，声明、赋值和导出标识符最好分开。</p>
</blockquote>
<h4 id="26-4-5-模块导入"><a href="#26-4-5-模块导入" class="headerlink" title="26.4.5 模块导入"></a>26.4.5 模块导入</h4><p>模块可以通过使用import关键字使用其他模块导出的值。与export类似，import必须出现在模块的顶级。</p>
<p>import语句被提升到模块顶部。因此，与export关键字类似，import语句与使用导入值的语句的相对位置并不重要。不过，还是推荐把导入语句放在模块顶部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许 </span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./fooModule.js&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// &#x27;foo&#x27; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许，但应该避免 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// &#x27;foo&#x27; </span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./fooModule.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径。它必须是纯字符串，不能是动态计算的结果。例如，不能是拼接的字符串。<br>如果在浏览器中通过标识符原生加载模块，则文件必须带有.js 扩展名，不然可能无法正确解析。不过，如果是通过构建工具或第三方模块加载器打包或解析的 ES6 模块，则可能不需要包含文件扩展名。</p>
<p>不是必须通过导出的成员才能导入模块。如果不需要模块的特定导出，但仍想加载和执行模块以利用其副作用，可以只通过路径加载它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>导入对模块而言是只读的，实际上相当于const声明的变量。在使用*执行批量导入时，赋值给别名的命名导出就好像使用Object.freeze()冻结过一样。直接修改导出的值是不可能的，但可以修改导出对象的属性。同样，也不能给导出的集合添加或删除导出的属性。要修改导出的值，必须使用有内部变量和属性访问权限的导出方法。</p>
<p>命名导出和默认导出的区别也反映在它们的导入上。命名导出可以使用*批量获取并赋值给保存导出集合的别名，而无须列出每个标识符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>, bar = <span class="string">&#x27;bar&#x27;</span>, baz = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar, baz &#125; </span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">foo</span>); <span class="comment">// foo </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">bar</span>); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property">baz</span>); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<p>要指名导入，需要把标识符放在import子句中。使用import子句可以为导入的值指定别名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo, bar, baz <span class="keyword">as</span> myBaz &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);   <span class="comment">// foo </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);   <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myBaz); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<p>默认导出就好像整个模块就是导出的值一样。可以使用default关键字并提供别名来导入。也可以不使用大括号，此时指定的标识符就是默认导出的别名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等效 </span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果模块同时导出了命名导出和默认导出，则可以在import语句中同时取得它们。可以依次列出特定导出的标识符来取得，也可以使用*来取得：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo, &#123; bar, baz &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo, bar, baz &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo, * <span class="keyword">as</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="26-4-6-模块转移导出"><a href="#26-4-6-模块转移导出" class="headerlink" title="26.4.6 模块转移导出"></a>26.4.6 模块转移导出</h4><p>模块导入的值可以直接通过管道转移到导出。此时，也可以将默认导出转换为命名导出，或者相反。如果想把一个模块的所有命名导出集中在一块，可以像下面这样在 bar.js 中使用*导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="26-4-7-工作者模块"><a href="#26-4-7-工作者模块" class="headerlink" title="26.4.7 工作者模块"></a>26.4.7 工作者模块</h4><p>ECMAScript 6 模块与Worker实例完全兼容。在实例化时，可以给工作者传入一个指向模块文件的路径，与传入常规脚本文件一样。Worker构造函数接收第二个参数，用于说明传入的是模块文件。<br>下面是两种类型的Worker的实例化行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数默认为&#123; type: &#x27;classic&#x27; &#125; </span></span><br><span class="line"><span class="keyword">const</span> scriptWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;scriptWorker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;moduleWorker.js&#x27;</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在基于模块的工作者内部，self.importScripts()方法通常用于在基于脚本的工作者中加载外部脚本，调用它会抛出错误。这是因为模块的import行为包含了importScripts()。</p>
<h4 id="26-4-8-向后兼容"><a href="#26-4-8-向后兼容" class="headerlink" title="26.4.8 向后兼容"></a>26.4.8 向后兼容</h4><p>ECMAScript 模块的兼容是个渐进的过程，能够同时兼容支持和不支持的浏览器对早期采用者是有价值的。对于想要尽可能在浏览器中原生使用 ECMAScript 6 模块的用户，可以提供两个版本的代码：基于模块的版本与基于脚本的版本。如果嫌麻烦，可以使用第三方模块系统（如 SystemJS）或在构建时将 ES6 模块进行转译，这都是不错的方案。<br>第一种方案涉及在服务器上检查浏览器的用户代理，与支持模块的浏览器名单进行匹配，然后基于匹配结果决定提供哪个版本的 JavaScript 文件。这个方法不太可靠，而且比较麻烦，不推荐。更好、更优雅的方案是利用脚本的type属性和nomodule属性。<br>浏览器在遇到&lt;**script**&gt;标签上无法识别的type属性时会拒绝执行其内容。对于不支持模块的浏览器，这意味着</p>
<p>浏览器在遇到&lt;**script**&gt;标签上无法识别的type属性时会拒绝执行其内容。对于不支持模块的浏览器，这意味着&lt;**script** type=”module”&gt;不会被执行。因此，可以在&lt;**script** type=”module”&gt;标签旁边添加一个回退&lt;**script**&gt;标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不支持模块的浏览器不会执行这里的代码 </span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不支持模块的浏览器会执行这里的代码 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>当然，这样一来支持模块的浏览器就有麻烦了。此时，前面的代码会执行两次，显然这不是我们想要的结果。为了避免这种情况，原生支持 ECMAScript 6 模块的浏览器也会识别nomodule属性。此属性通知支持 ES6 模块的浏览器不执行脚本。不支持模块的浏览器无法识别该属性，从而忽略这个属性的存在。<br>因此，下面代码会生成一个设置，在这个设置中，支持模块和不支持模块的浏览器都只会执行一段脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持模块的浏览器会执行这段脚本 </span></span><br><span class="line"><span class="comment">// 不支持模块的浏览器不会执行这段脚本 </span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持模块的浏览器不会执行这段脚本 </span></span><br><span class="line"><span class="comment">// 不支持模块的浏览器会执行这段脚本 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="26-5-小结"><a href="#26-5-小结" class="headerlink" title="26.5 小结"></a>26.5 小结</h3><p>模块模式是管理复杂性的永恒工具。开发者可以通过它创建逻辑彼此独立的代码段，在这些代码段之间声明依赖，并将它们连接在一起。此外，这种模式也是经证明能够优雅扩展到任意复杂度且跨平台的方案。<br>多年以来，CommonJS 和 AMD 这两个分别针对服务器端环境和受延迟限制的客户端环境的模块系统长期分裂。两个系统都获得了爆炸性增强，但为它们编写的代码则在很多方面不一致，经常也会带有冗余的样板代码。而且，这两个系统都没有在浏览器中实现。缺乏兼容导致出现了相关工具，从而让在浏览器中实现模块模式成为可能。<br>ECMAScript 6 规范重新定义了浏览器模块，集之前两个系统之长于一身，并通过更简单的声明性语法暴露出来。浏览器对原生模块的支持越来越好，但也提供了稳健的工具以实现从不支持到支持 ES6模块的过渡。</p>
<h2 id="二十七、工作者线程"><a href="#二十七、工作者线程" class="headerlink" title="二十七、工作者线程"></a>二十七、工作者线程</h2><h3 id="27-1-工作者线程简介"><a href="#27-1-工作者线程简介" class="headerlink" title="27.1 工作者线程简介"></a>27.1 工作者线程简介</h3><p>JavaScript 环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分配一个它自己的环境。这样，每个页面都有自己的内存、事件循环、DOM，等等。每个页面就相当于一个沙盒，不会干扰其他页面。对于浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境都是并行执行的。<br>使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。这个子环境不能与依赖单线程交互的 API（如 DOM）互操作，但可以与父环境并行执行代码。</p>
<h4 id="27-1-1-工作者线程与线程"><a href="#27-1-1-工作者线程与线程" class="headerlink" title="27.1.1 工作者线程与线程"></a>27.1.1 工作者线程与线程</h4><ul>
<li><p>工作者线程是以实际线程实现的。</p>
</li>
<li><p>工作者线程并行执行。虽然页面和工作者线程都是单线程 JavaScript 环境，每个环境中的指令则可以并行执行。</p>
</li>
<li><p>工作者线程可以共享某些内存。工作者线程能够使用SharedArrayBuffer在多个环境间共享内容。虽然线程会使用锁实现并发控制，但 JavaScript 使用Atomics接口实现并发控制。</p>
</li>
</ul>
<p>工作者线程与线程有很多类似之处，但也有重要的区别。</p>
<ul>
<li><p>工作者线程不共享全部内存。在传统线程模型中，多线程有能力读写共享内存空间。除了SharedArrayBuffer外，从工作者线程进出的数据需要复制或转移。</p>
</li>
<li><p>工作者线程不一定在同一个进程里。通常，一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者线程可能与页面属于同一进程，也可能不属于。例如，Chrome 的 Blink 引擎对共享工作者线程和服务工作者线程使用独立的进程。</p>
</li>
<li><p>创建工作者线程的开销更大。工作者线程有自己独立的事件循环、全局对象、事件处理程序和其他 JavaScript 环境必需的特性。创建这些结构的代价不容忽视</p>
</li>
</ul>
<h4 id="27-1-2-工作者线程的类型"><a href="#27-1-2-工作者线程的类型" class="headerlink" title="27.1.2 工作者线程的类型"></a>27.1.2 工作者线程的类型</h4><p>Web 工作者线程规范中定义了三种主要的工作者线程：专用工作者线程、共享工作者线程和服务工作者线程。</p>
<ol>
<li>专用工作者线程</li>
</ol>
<p>专用工作者线程，通常简称为工作者线程、Web Worker 或 Worker，是一种实用的工具，可以让脚本单独创建一个 JavaScript 线程，以执行委托的任务。专用工作者线程，顾名思义，只能被创建它的页面使用。</p>
<ol start="2">
<li>共享工作者线程</li>
</ol>
<p>共享工作者线程与专用工作者线程非常相似。主要区别是共享工作者线程可以被多个不同的上下文使用，包括不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。</p>
<ol start="3">
<li>服务工作者线程</li>
</ol>
<p>服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的主要用途是拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者的角色。</p>
<h4 id="27-1-3-WorkerGlobalScope"><a href="#27-1-3-WorkerGlobalScope" class="headerlink" title="27.1.3 WorkerGlobalScope"></a>27.1.3 WorkerGlobalScope</h4><p>在工作者线程内部，没有window的概念。这里的全局对象是WorkerGlobalScope的实例，通过self关键字暴露出来。</p>
<ol>
<li>WorkerGlobalScope属性和方法</li>
</ol>
<p>self上可用的属性是window对象上属性的严格子集。其中有些属性会返回特定于工作者线程的版本。</p>
<ul>
<li><p>navigator：返回与工作者线程关联的WorkerNavigator。</p>
</li>
<li><p>self：返回WorkerGlobalScope对象。</p>
</li>
<li><p>location：返回与工作者线程关联的WorkerLocation。</p>
</li>
<li><p>performance：返回（只包含特定属性和方法的）Performance对象。</p>
</li>
<li><p>console：返回与工作者线程关联的Console对象；对 API 没有限制。</p>
</li>
<li><p>caches：返回与工作者线程关联的CacheStorage对象；对 API 没有限制。</p>
</li>
<li><p>indexedDB：返回IDBFactory对象。</p>
</li>
<li><p>isSecureContext：返回布尔值，表示工作者线程上下文是否安全。</p>
</li>
<li><p>origin：返回WorkerGlobalScope的源。</p>
</li>
</ul>
<p>self对象上暴露的一些方法也是window上方法的子集。这些self上的方法也与window上对应的方法操作一样。</p>
<ul>
<li><p>atob()</p>
</li>
<li><p>btoa()</p>
</li>
<li><p>clearInterval()</p>
</li>
<li><p>clearTimeout()</p>
</li>
<li><p>createImageBitmap()</p>
</li>
<li><p>fetch()</p>
</li>
<li><p>setInterval()</p>
</li>
<li><p>setTimeout()</p>
</li>
</ul>
<p>WorkerGlobalScope还增加了新的全局方法importScripts()，只在工作者线程内可用。</p>
<ol start="2">
<li>WorkerGlobalScope的子类</li>
</ol>
<p>实际上并不是所有地方都实现了WorkerGlobalScope。每种类型的工作者线程都使用了自己特定的全局对象，这继承自WorkerGlobalScope。</p>
<ul>
<li><p>专用工作者线程使用DedicatedWorkerGlobalScope。</p>
</li>
<li><p>共享工作者线程使用SharedWorkerGlobalScope。</p>
</li>
<li><p>服务工作者线程使用ServiceWorkerGlobalScope。</p>
</li>
</ul>
<h3 id="27-2-专用工作者线程"><a href="#27-2-专用工作者线程" class="headerlink" title="27.2 专用工作者线程"></a>27.2 专用工作者线程</h3><p>专用工作者线程是最简单的 Web 工作者线程，网页中的脚本可以创建专用工作者线程来执行在页面线程之外的其他任务。这样的线程可以与父页面交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，以及实现其他不适合在页面执行线程里做的任务（否则会导致页面响应迟钝）。</p>
<h4 id="27-2-1-专用工作者线程的基本概念"><a href="#27-2-1-专用工作者线程的基本概念" class="headerlink" title="27.2.1 专用工作者线程的基本概念"></a>27.2.1 专用工作者线程的基本概念</h4><p>可以把专用工作者线程称为后台脚本（background script）。JavaScript 线程的各个方面，包括生命周期管理、代码路径和输入/输出，都由初始化线程时提供的脚本来控制。该脚本也可以再请求其他脚本，但一个线程总是从一个脚本源开始。</p>
<ol>
<li>创建专用工作者线程</li>
</ol>
<p>创建专用工作者线程最常见的方式是加载 JavaScript 文件。把文件路径提供给Worker构造函数，然后构造函数再在后台异步加载脚本并实例化工作者线程。传给构造函数的文件路径可以是多种形式。</p>
<p>创建空的专用工作者线程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> emptyWorker.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 空的 JS 工作者线程文件 </span></span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>); <span class="comment">// &quot;https://example.com/&quot; </span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(location.<span class="property">href</span> + <span class="string">&#x27;emptyWorker.js&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(worker);        <span class="comment">// Worker &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>emptyWorker.js 文件是从绝对路径加载的。根据应用程序的结构，使用绝对 URL 经常是多余的。</p>
</li>
<li><p>这个文件是在后台加载的，工作者线程的初始化完全独立于 main.js。</p>
</li>
<li><p>工作者线程本身存在于一个独立的 JavaScript 环境中，因此 main.js 必须以Worker对象为代理实现与工作者线程通信。在上面的例子中，该对象被赋值给了worker变量。</p>
</li>
<li><p>虽然相应的工作者线程可能还不存在，但该Worker对象已在原始环境中可用了。</p>
</li>
</ul>
<p>前面的例子可修改为使用相对路径。不过，这要求 main.js 必须与 emptyWorker.js 在同一个路径下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./emptyWorker.js&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(worker);   <span class="comment">// Worker &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>工作者线程安全限制</li>
</ol>
<p>工作者线程的脚本文件只能从与父页面相同的源加载。从其他源加载工作者线程的脚本文件会导致错误，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试基于 https://example.com/worker.js 创建工作者线程 </span></span><br><span class="line"><span class="keyword">const</span> sameOriginWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试基于 https://untrusted.com/worker.js 创建工作者线程 </span></span><br><span class="line"><span class="keyword">const</span> remoteOriginWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;https://untrusted.com/worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Uncaught DOMException: Failed to construct &#x27;Worker&#x27;: </span></span><br><span class="line"><span class="comment">// Script at https://untrusted.com/main.js cannot be accessed </span></span><br><span class="line"><span class="comment">// from origin https://example.com</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能使用非同源脚本创建工作者线程，并不影响执行其他源的脚本。在工作者线程内部，使用importScripts()可以加载其他源的脚本。</p>
</blockquote>
<p>基于加载脚本创建的工作者线程不受文档的内容安全策略限制，因为工作者线程在与父文档不同的上下文中运行。不过，如果工作者线程加载的脚本带有全局唯一标识符（与加载自一个二进制大文件一样），就会受父文档内容安全策略的限制。</p>
<ol start="3">
<li>使用Worker对象</li>
</ol>
<p>Worker()构造函数返回的Worker对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文间传输信息，以及捕获专用工作者线程发出的事件。</p>
<blockquote>
<p>要管理好使用Worker()创建的每个Worker对象。在终止工作者线程之前，它不会被垃圾回收，也不能通过编程方式恢复对之前Worker对象的引用。</p>
</blockquote>
<p>Worker对象支持下列事件处理程序属性。</p>
<ul>
<li><p>onerror：在工作者线程中发生ErrorEvent类型的错误事件时会调用指定给该属性的处理程序。</p>
<ul>
<li><p>该事件会在工作者线程中抛出错误时发生。</p>
</li>
<li><p>该事件也可以通过worker.addEventListener(‘error’, handler)的形式处理。</p>
</li>
</ul>
</li>
<li><p>onmessage：在工作者线程中发生MessageEvent类型的消息事件时会调用指定给该属性的处理程序。</p>
<ul>
<li><p>该事件会在工作者线程向父上下文发送消息时发生。</p>
</li>
<li><p>该事件也可以通过使用worker.addEventListener(‘message’, handler)处理。</p>
</li>
</ul>
</li>
<li><p>onmessageerror：在工作者线程中发生MessageEvent类型的错误事件时会调用指定给该属性的处理程序。</p>
<ul>
<li><p>该事件会在工作者线程收到无法反序列化的消息时发生。</p>
</li>
<li><p>该事件也可以通过使用worker.addEventListener(‘messageerror’, handler)处理。</p>
</li>
</ul>
</li>
</ul>
<p>Worker对象还支持下列方法。</p>
<ul>
<li><p>postMessage()：用于通过异步消息事件向工作者线程发送信息。</p>
</li>
<li><p>terminate()：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。</p>
</li>
</ul>
<ol start="4">
<li>DedicatedWorkerGlobalScope</li>
</ol>
<p>在专用工作者线程内部，全局作用域是DedicatedWorkerGlobalScope的实例。因为这继承自WorkerGlobalScope，所以包含它的所有属性和方法。工作者线程可以通过self关键字访问该全局作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">globalScopeWorker.<span class="property">js</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inside worker:&#x27;</span>, self); </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./globalScopeWorker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;created worker:&#x27;</span>, worker); </span><br><span class="line"></span><br><span class="line"><span class="comment">// created worker: Worker &#123;&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inside worker: DedicatedWorkerGlobalScope &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>顶级脚本和工作者线程中的console对象都将写入浏览器控制台，这对于调试非常<br>有用。因为工作者线程具有不可忽略的启动延迟，所以即使Worker对象存在，工作者线程的日志也会在主线程的日志之后打印出来。</p>
<blockquote>
<p>这里两个独立的 JavaScript 线程都在向一个console对象发消息，该对象随后将消息序列化并在浏览器控制台打印出来。浏览器从两个不同的 JavaScript 线程收到消息，并按照自己认为合适的顺序输出这些消息。为此，在多线程应用程序中使用日志确定操作顺序时必须要当心。</p>
</blockquote>
<p>DedicatedWorkerGlobalScope在WorkerGlobalScope基础上增加了以下属性和方法。</p>
<ul>
<li><p>name：可以提供给Worker构造函数的一个可选的字符串标识符。</p>
</li>
<li><p>postMessage()：与worker.postMessage()对应的方法，用于从工作者线程内部向父上下文发送消息。</p>
</li>
<li><p>close()：与worker.terminate()对应的方法，用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。</p>
</li>
<li><p>importScripts()：用于向工作者线程中导入任意数量的脚本。</p>
</li>
</ul>
<h4 id="27-2-2-专用工作者线程与隐式MessagePorts"><a href="#27-2-2-专用工作者线程与隐式MessagePorts" class="headerlink" title="27.2.2 专用工作者线程与隐式MessagePorts"></a>27.2.2 专用工作者线程与隐式MessagePorts</h4><p>专用工作者线程的Worker对象和DedicatedWorkerGlobalScope与MessagePorts有一些相同接口处理程序和方法：onmessage、onmessageerror、close()和postMessage()。这不是偶然的，因为专用工作者线程隐式使用了MessagePorts在两个上下文之间通信。<br>父上下文中的Worker对象和DedicatedWorkerGlobalScope实际上融合了MessagePort，并在自己的接口中分别暴露了相应的处理程序和方法。换句话说，消息还是通过MessagePort发送，只是没有直接使用MessagePort而已。<br>也有不一致的地方，比如start()和close()约定。专用工作者线程会自动发送排队的消息，因此start()也就没有必要了。另外，close()在专用工作者线程的上下文中没有意义，因为这样关闭MessagePort会使工作者线程孤立。因此，在工作者线程内部调用close()（或在外部调用terminate()）不仅会关闭MessagePort，也会终止线程。</p>
<h4 id="27-2-3-专用工作者线程的生命周期"><a href="#27-2-3-专用工作者线程的生命周期" class="headerlink" title="27.2.3 专用工作者线程的生命周期"></a>27.2.3 专用工作者线程的生命周期</h4><p>调用Worker()构造函数是一个专用工作者线程生命的起点。调用之后，它会初始化对工作者线程脚本的请求，并把Worker对象返回给父上下文。虽然父上下文中可以立即使用这个Worker对象，但与之关联的工作者线程可能还没有创建，因为存在请求脚本的网格延迟和初始化延迟。<br>一般来说，专用工作者线程可以非正式区分为处于下列三个状态：初始化（initializing）、活动（active）和终止（terminated）。这几个状态对其他上下文是不可见的。</p>
<p>与活动的专用工作者线程关联的Worker对象和与终止的专用工作者线程关联的Worker对象无法分别。<br>初始化时，虽然工作者线程脚本尚未执行，但可以先把要发送给工作者线程的消息加入队列。这些消息会等待工作者线程的状态变为活动，再把消息添加到它的消息队列。下面的代码演示了这个过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">initializingWorker.<span class="property">js</span> </span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data)); </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./initializingWorker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 可能仍处于初始化状态 </span></span><br><span class="line"><span class="comment">// 但 postMessage()数据可以正常处理 </span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure>

<p>创建之后，专用工作者线程就会伴随页面的整个生命期而存在，除非自我终止（self.close()）或通过外部终止（worker.terminate()）。即使线程脚本已运行完成，线程的环境仍会存在。只要工作者线程仍存在，与之关联的Worker对象就不会被当成垃圾收集掉。<br>自我终止和外部终止最终都会执行相同的工作者线程终止例程。来看下面的例子，其中工作者线程在发送两条消息中间执行了自我终止：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">closeWorker.<span class="property">js</span> </span><br><span class="line">self.<span class="title function_">postMessage</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">self.<span class="title function_">close</span>(); </span><br><span class="line">self.<span class="title function_">postMessage</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> self.<span class="title function_">postMessage</span>(<span class="string">&#x27;baz&#x27;</span>), <span class="number">0</span>); </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./closeWorker.js&#x27;</span>); </span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line"></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>虽然调用了close()，但显然工作者线程的执行并没有立即终止。close()在这里会通知工作者线程取消事件循环中的所有任务，并阻止继续添加新任务。这也是为什么”baz”没有打印出来的原因。工作者线程不需要执行同步停止，因此在父上下文的事件循环中处理的”bar”仍会打印出来。</p>
<p>下面来看外部终止的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">terminateWorker.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./terminateWorker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 1000 毫秒让工作者线程初始化 </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">  worker.<span class="title function_">terminate</span>(); </span><br><span class="line">  worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;baz&#x27;</span>), <span class="number">0</span>); </span><br><span class="line">&#125;, <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>一旦调用了terminate()，工作者线程的消息队列就会被清理并锁住，这也是只是打印”foo”的原因。</p>
<blockquote>
<p>close()和terminate()是幂等操作，多次调用没有问题。这两个方法仅仅是将Worker标记为teardown，因此多次调用不会有不好的影响</p>
</blockquote>
<p>在整个生命周期中，一个专用工作者线程只会关联一个网页（Web 工作者线程规范称其为一个文档）。除非明确终止，否则只要关联文档存在，专用工作者线程就会存在。如果浏览器离开网页（通过导航或关闭标签页或关闭窗口），它会将与其关联的工作者线程标记为终止，它们的执行也会立即停止。</p>
<h4 id="27-2-4-配置Worker选项"><a href="#27-2-4-配置Worker选项" class="headerlink" title="27.2.4 配置Worker选项"></a>27.2.4 配置Worker选项</h4><p>Worker()构造函数允许将可选的配置对象作为第二个参数。该配置对象支持下列属性。</p>
<ul>
<li><p>name：可以在工作者线程中通过self.name读取到的字符串标识符。</p>
</li>
<li><p>type：表示加载脚本的运行方式，可以是”classic”或”module”。”classic”将脚本作为常规脚本来执行，”module”将脚本作为模块来执行。</p>
</li>
<li><p>credentials：在type为”module”时，指定如何获取与传输凭证数据相关的工作者线程模块脚本。值可以是”omit”、”same-orign”或”include”。这些选项与fetch()的凭证选项相同。在type为”classic”时，默认为”omit”。</p>
</li>
</ul>
<h4 id="27-2-5-在-JavaScript-行内创建工作者线程"><a href="#27-2-5-在-JavaScript-行内创建工作者线程" class="headerlink" title="27.2.5 在 JavaScript 行内创建工作者线程"></a>27.2.5 在 JavaScript 行内创建工作者线程</h4><p>工作者线程需要基于脚本文件来创建，但这并不意味着该脚本必须是远程资源。专用工作者线程也可以通过Blob对象 URL 在行内脚本创建。这样可以更快速地初始化工作者线程，因为没有网络延迟。<br>下面展示了一个在行内创建工作者线程的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建要执行的 JavaScript 代码字符串 </span></span><br><span class="line"><span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string">  self.onmessage = (&#123;data&#125;) =&gt; console.log(data); </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于脚本字符串生成 Blob 对象 </span></span><br><span class="line"><span class="keyword">const</span> workerScriptBlob = <span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 Blob 实例创建对象 URL </span></span><br><span class="line"><span class="keyword">const</span> workerScriptBlobUrl = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(workerScriptBlob); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于对象 URL 创建专用工作者线程 </span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(workerScriptBlobUrl); </span><br><span class="line"></span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;blob worker script&#x27;</span>); </span><br><span class="line"><span class="comment">// blob worker script</span></span><br></pre></td></tr></table></figure>

<p>工作者线程也可以利用函数序列化来初始化行内脚本。这是因为函数的toString()方法返回函数代码的字符串，而函数可以在父上下文中定义但在子上下文中执行。来看下面这个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">1</span> ? <span class="number">0</span> </span><br><span class="line">      : n &lt;= <span class="number">2</span> ? <span class="number">1</span> </span><br><span class="line">      : <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string">  self.postMessage( </span></span><br><span class="line"><span class="string">    (<span class="subst">$&#123;fibonacci.toString()&#125;</span>)(9) </span></span><br><span class="line"><span class="string">  ); </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript]))); </span><br><span class="line"></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 34</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>像这样序列化函数有个前提，就是函数体内不能使用通过闭包获得的引用，也包括全局变量，比如window，因为这些引用在工作者线程中执行时会出错。</p>
</blockquote>
<h4 id="27-2-6-在工作者线程中动态执行脚本"><a href="#27-2-6-在工作者线程中动态执行脚本" class="headerlink" title="27.2.6 在工作者线程中动态执行脚本"></a>27.2.6 在工作者线程中动态执行脚本</h4><p>工作者线程中的脚本并非铁板一块，而是可以使用importScripts()方法通过编程方式加载和执行任意脚本。该方法可用于全局Worker对象。这个方法会加载脚本并按照加载顺序同步执行。</p>
<p>importScripts()方法可以接收任意数量的脚本作为参数。浏览器下载它们的顺序没有限制，但执行则会严格按照它们在参数列表的顺序进行。</p>
<p>脚本加载受到常规 CORS 的限制，但在工作者线程内部可以请求来自任何源的脚本。这里的脚本导入策略类似于使用生成的&lt;**script**&gt;标签动态加载脚本。在这种情况下，所有导入的脚本也会共享作用域。下面的代码演示了这个事实：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// importing scripts in foo with bar </span></span><br><span class="line"><span class="comment">// scriptA executes in foo with bar </span></span><br><span class="line"><span class="comment">// scriptB executes in foo with bar </span></span><br><span class="line"><span class="comment">// scripts imported </span></span><br><span class="line">scriptA.<span class="property">js</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scriptA executes in <span class="subst">$&#123;self.name&#125;</span> with <span class="subst">$&#123;globalToken&#125;</span>`</span>); </span><br><span class="line">scriptB.<span class="property">js</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`scriptB executes in <span class="subst">$&#123;self.name&#125;</span> with <span class="subst">$&#123;globalToken&#125;</span>`</span>); </span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> globalToken = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`importing scripts in <span class="subst">$&#123;self.name&#125;</span> with <span class="subst">$&#123;globalToken&#125;</span>`</span>); </span><br><span class="line"></span><br><span class="line">importScripts(<span class="string">&#x27;./scriptA.js&#x27;</span>, <span class="string">&#x27;./scriptB.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scripts imported&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="27-2-7-委托任务到子工作者线程"><a href="#27-2-7-委托任务到子工作者线程" class="headerlink" title="27.2.7 委托任务到子工作者线程"></a>27.2.7 委托任务到子工作者线程</h4><p>有时候可能需要在工作者线程中再创建子工作者线程。在有多个 CPU 核心的时候，使用多个子工作者线程可以实现并行计算。使用多个子工作者线程前要考虑周全，确保并行计算的投入确实能够得到收益，毕竟同时运行多个子线程会有很大计算成本。<br>除了路径解析不同，创建子工作者线程与创建普通工作者线程是一样的。子工作者线程的脚本路径根据父工作者线程而不是相对于网页来解析。来看下面的例子（注意额外的 js 目录）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./js/worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// worker </span></span><br><span class="line"><span class="comment">// subworker </span></span><br><span class="line">js/worker.<span class="property">js</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;worker&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./subworker.js&#x27;</span>); </span><br><span class="line">js/subworker.<span class="property">js</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;subworker&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>顶级工作者线程的脚本和子工作者线程的脚本都必须从与主页相同的源加载。</p>
</blockquote>
<h4 id="27-2-8-处理工作者线程错误"><a href="#27-2-8-处理工作者线程错误" class="headerlink" title="27.2.8 处理工作者线程错误"></a>27.2.8 处理工作者线程错误</h4><p>如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。如下例所示，其中的try/catch块不会捕获到错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;no error&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught error&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// no error </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>相应的错误事件仍然会冒泡到工作者线程的全局上下文，因此可以通过在Worker对象上设置错误事件侦听器访问到。下面看这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line">worker.<span class="property">onerror</span> = <span class="variable language_">console</span>.<span class="property">log</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorEvent &#123;message: &quot;Uncaught Error: foo&quot;&#125; </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="27-2-9-与专用工作者线程通信"><a href="#27-2-9-与专用工作者线程通信" class="headerlink" title="27.2.9 与专用工作者线程通信"></a>27.2.9 与专用工作者线程通信</h4><p>与工作者线程的通信都是通过异步消息完成的，但这些消息可以有多种形式。</p>
<ol>
<li>使用postMessage()</li>
</ol>
<p>最简单也最常用的形式是使用postMessage()传递序列化的消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">factorialWorker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span>(n) &#123; result *= n--; &#125; </span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  self.<span class="title function_">postMessage</span>(<span class="string">`<span class="subst">$&#123;data&#125;</span>! = <span class="subst">$&#123;factorial(data)&#125;</span>`</span>); </span><br><span class="line">&#125;; </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> factorialWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./factorialWorker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line">factorialWorker.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line"></span><br><span class="line">factorialWorker.<span class="title function_">postMessage</span>(<span class="number">5</span>); </span><br><span class="line">factorialWorker.<span class="title function_">postMessage</span>(<span class="number">7</span>); </span><br><span class="line">factorialWorker.<span class="title function_">postMessage</span>(<span class="number">10</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5! = 120 </span></span><br><span class="line"><span class="comment">// 7! = 5040 </span></span><br><span class="line"><span class="comment">// 10! = 3628800</span></span><br></pre></td></tr></table></figure>

<p>对于传递简单的消息，使用postMessage()在主线程和工作者线程之间传递消息，与在两个窗口间传递消息非常像。主要区别是没有targetOrigin的限制，该限制是针对Window.prototype. postMessage的，对WorkerGlobalScope.prototype.postMessage或Worker.prototype. postMessage没有影响。这样约定的原因很简单：工作者线程脚本的源被限制为主页的源，因此没有必要再去过滤了。</p>
<ol start="2">
<li>使用MessageChannel</li>
</ol>
<p>无论主线程还是工作者线程，通过postMessage()进行通信涉及调用全局对象上的方法，并定义一个临时的传输协议。这个过程可以被 Channel Messaging API 取代，基于该 API 可以在两个上下文间明确建立通信渠道。<br>MessageChannel实例有两个端口，分别代表两个通信端点。要让父页面和工作线程通过MessageChannel通信，需要把一个端口传到工作者线程中，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">worker.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 在监听器中存储全局 messagePort  </span></span><br><span class="line"><span class="keyword">let</span> messagePort = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span>(n) &#123; result *= n--; &#125; </span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在全局对象上添加消息处理程序 </span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;ports&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 只设置一次端口 </span></span><br><span class="line">  <span class="keyword">if</span> (!messagePort) &#123; </span><br><span class="line">    <span class="comment">// 初始化消息发送端口， </span></span><br><span class="line">    <span class="comment">// 给变量赋值并重置监听器 </span></span><br><span class="line">messagePort = ports[<span class="number">0</span>]; </span><br><span class="line">    self.<span class="property">onmessage</span> = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在全局对象上设置消息处理程序 </span></span><br><span class="line">    messagePort.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="comment">// 收到消息后发送数据 </span></span><br><span class="line">      messagePort.<span class="title function_">postMessage</span>(<span class="string">`<span class="subst">$&#123;data&#125;</span>! = <span class="subst">$&#123;factorial(data)&#125;</span>`</span>); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>(); </span><br><span class="line"><span class="keyword">const</span> factorialWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把`MessagePort`对象发送到工作者线程 </span></span><br><span class="line"><span class="comment">// 工作者线程负责处理初始化信道 </span></span><br><span class="line">factorialWorker.<span class="title function_">postMessage</span>(<span class="literal">null</span>, [channel.<span class="property">port1</span>]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过信道实际发送数据 </span></span><br><span class="line">channel.<span class="property">port2</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作者线程通过信道响应 </span></span><br><span class="line">channel.<span class="property">port2</span>.<span class="title function_">postMessage</span>(<span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5! = 120</span></span><br></pre></td></tr></table></figure>

<p>使用MessageChannel实例与父页面通信很大程度上是多余的。这是因为全局postMessage()方法本质上与channel.postMessage()执行的是同样的操作（不考虑MessageChannel接口的其他特性）。MessageChannel真正有用的地方是让两个工作者线程之间直接通信。这可以通过把端口传给另一个工作者线程实现。下面的例子把一个数组传给了一个工作者线程，这个线程又把它传另一个工作者线程，然后再传回主页：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>(); </span><br><span class="line"><span class="keyword">const</span> workerA = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> workerB = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line">workerA.<span class="title function_">postMessage</span>(<span class="string">&#x27;workerA&#x27;</span>, [channel.<span class="property">port1</span>]); </span><br><span class="line">workerB.<span class="title function_">postMessage</span>(<span class="string">&#x27;workerB&#x27;</span>, [channel.<span class="property">port2</span>]); </span><br><span class="line"></span><br><span class="line">workerA.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line">workerB.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line"></span><br><span class="line">workerA.<span class="title function_">postMessage</span>([<span class="string">&#x27;page&#x27;</span>]); </span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#x27;page&#x27;, &#x27;workerA&#x27;, &#x27;workerB&#x27;] </span></span><br><span class="line"></span><br><span class="line">workerB.<span class="title function_">postMessage</span>([<span class="string">&#x27;page&#x27;</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#x27;page&#x27;, &#x27;workerB&#x27;, &#x27;workerA&#x27;] </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">let</span> messagePort = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> contextIdentifier = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addContextAndSend</span>(<span class="params">data, destination</span>) &#123; </span><br><span class="line">  <span class="comment">// 添加标识符以标识当前工作者线程 </span></span><br><span class="line">  data.<span class="title function_">push</span>(contextIdentifier); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数据发送到下一个目标 </span></span><br><span class="line">  destination.<span class="title function_">postMessage</span>(data); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data, ports&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 如果消息里存在端口（ports） </span></span><br><span class="line">  <span class="comment">// 则初始化工作者线程 </span></span><br><span class="line">  <span class="keyword">if</span> (ports.<span class="property">length</span>) &#123; </span><br><span class="line">    <span class="comment">// 记录标识符 </span></span><br><span class="line">    contextIdentifier = data; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MessagePort </span></span><br><span class="line">    messagePort = ports[<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加处理程序把接收的数据 </span></span><br><span class="line">    <span class="comment">// 发回到父页面 </span></span><br><span class="line">    messagePort.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="title function_">addContextAndSend</span>(data, self); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">addContextAndSend</span>(data, messagePort); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用BroadcastChannel</li>
</ol>
<p>同源脚本能够通过BroadcastChannel相互之间发送和接收消息。这种通道类型的设置比较简单，不需要像MessageChannel那样转移乱糟糟的端口。这可以通过以下方式实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;worker_channel&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line">channel.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`heard <span class="subst">$&#123;data&#125;</span> on page`</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> channel.<span class="title function_">postMessage</span>(<span class="string">&#x27;foo&#x27;</span>), <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// heard foo in worker </span></span><br><span class="line"><span class="comment">// heard bar on page </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;worker_channel&#x27;</span>); </span><br><span class="line">channel.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`heard <span class="subst">$&#123;data&#125;</span> in worker`</span>); </span><br><span class="line">  channel.<span class="title function_">postMessage</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="27-2-10-工作者线程数据传输"><a href="#27-2-10-工作者线程数据传输" class="headerlink" title="27.2.10 工作者线程数据传输"></a>27.2.10 工作者线程数据传输</h4><p>使用工作者线程时，经常需要为它们提供某种形式的数据负载。工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。在支持传统多线程模型的语言中，可以使用锁、互斥量，以及volatile变量。在 JavaScript 中，有三种在上下文间转移信息的方式：结构化克隆算法（structured clone algorithm）、可转移对象（transferable objects）和共享数组缓冲区（shared array buffers）。</p>
<ol>
<li>结构化克隆算法</li>
</ol>
<p>结构化克隆算法可用于在两个独立上下文间共享数据。该算法由浏览器在后台实现，不能直接调用。<br>在通过postMessage()传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本。下列类型是结构化克隆算法支持的类型。</p>
<ul>
<li><p>除Symbol之外的所有原始类型</p>
</li>
<li><p>Boolean对象</p>
</li>
<li><p>String对象</p>
</li>
<li><p>BDate</p>
</li>
<li><p>RegExp</p>
</li>
<li><p>Blob</p>
</li>
<li><p>File</p>
</li>
<li><p>FileList</p>
</li>
<li><p>ArrayBuffer</p>
</li>
<li><p>ArrayBufferView</p>
</li>
<li><p>ImageData</p>
</li>
<li><p>Array</p>
</li>
<li><p>Object</p>
</li>
<li><p>Map</p>
</li>
<li><p>Set</p>
</li>
</ul>
<p>关于结构化克隆算法，有以下几点需要注意。</p>
<ul>
<li><p>复制之后，源上下文中对该对象的修改，不会传播到目标上下文中的对象。</p>
</li>
<li><p>结构化克隆算法可以识别对象中包含的循环引用，不会无穷遍历对象。</p>
</li>
<li><p>克隆Error对象、Function对象或 DOM 节点会抛出错误。</p>
</li>
<li><p>结构化克隆算法并不总是创建完全一致的副本。</p>
</li>
<li><p>对象属性描述符、获取方法和设置方法不会克隆，必要时会使用默认值。</p>
</li>
<li><p>原型链不会克隆。</p>
</li>
<li><p>RegExp.prototype.lastIndex属性不会克隆。</p>
</li>
</ul>
<blockquote>
<p>结构化克隆算法在对象比较复杂时会存在计算性消耗。因此，实践中要尽可能避免过大、过多的复制。</p>
</blockquote>
<ol start="2">
<li>可转移对象</li>
</ol>
<p>使用可转移对象（transferable objects）可以把所有权从一个上下文转移到另一个上下文。在不太可能在上下文间复制大量数据的情况下，这个功能特别有用。只有如下几种对象是可转移对象：</p>
<ul>
<li><p>ArrayBuffer</p>
</li>
<li><p>MessagePort</p>
</li>
<li><p>ImageBitmap</p>
</li>
<li><p>OffscreenCanvas</p>
</li>
</ul>
<p>postMessage()方法的第二个可选参数是数组，它指定应该将哪些对象转移到目标上下文。在遍历消息负载对象时，浏览器根据转移对象数组检查对象引用，并对转移对象进行转移而不复制它们。这意味着被转移的对象可以通过消息负载发送，消息负载本身会被复制，比如对象或数组。<br>下面的例子演示了工作者线程对ArrayBuffer的常规结构化克隆。这里没有对象转移：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 32 位缓冲区 </span></span><br><span class="line"><span class="keyword">const</span> arrayBuffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`page&#x27;s buffer size: <span class="subst">$&#123;arrayBuffer.byteLength&#125;</span>`</span>); <span class="comment">// 32 </span></span><br><span class="line"></span><br><span class="line">worker.<span class="title function_">postMessage</span>(arrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`page&#x27;s buffer size: <span class="subst">$&#123;arrayBuffer.byteLength&#125;</span>`</span>); <span class="comment">// 32 </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`worker&#x27;s buffer size: <span class="subst">$&#123;data.byteLength&#125;</span>`</span>);    <span class="comment">// 32 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果把ArrayBuffer指定为可转移对象，那么对缓冲区内存的引用就会从父上下文中抹去，然后分配给工作者线程。下面的例子演示了这个操作，结果分配给ArrayBuffer的内存从父上下文转移到了工作者线程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 32 位缓冲区 </span></span><br><span class="line"><span class="keyword">const</span> arrayBuffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`page&#x27;s buffer size: <span class="subst">$&#123;arrayBuffer.byteLength&#125;</span>`</span>); <span class="comment">// 32 </span></span><br><span class="line"></span><br><span class="line">worker.<span class="title function_">postMessage</span>(arrayBuffer, [arrayBuffer]); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`page&#x27;s buffer size: <span class="subst">$&#123;arrayBuffer.byteLength&#125;</span>`</span>); <span class="comment">// 0 </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`worker&#x27;s buffer size: <span class="subst">$&#123;data.byteLength&#125;</span>`</span>);    <span class="comment">// 32 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在其他类型的对象中嵌套可转移对象也完全没有问题。包装对象会被复制，而嵌套的对象会被转移：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 32 位缓冲区 </span></span><br><span class="line"><span class="keyword">const</span> arrayBuffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`page&#x27;s buffer size: <span class="subst">$&#123;arrayBuffer.byteLength&#125;</span>`</span>);      <span class="comment">// 32 </span></span><br><span class="line"></span><br><span class="line">worker.<span class="title function_">postMessage</span>(&#123;<span class="attr">foo</span>: &#123;<span class="attr">bar</span>: arrayBuffer&#125;&#125;, [arrayBuffer]); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`page&#x27;s buffer size: <span class="subst">$&#123;arrayBuffer.byteLength&#125;</span>`</span>);      <span class="comment">// 0 </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`worker&#x27;s buffer size: <span class="subst">$&#123;data.foo.bar.byteLength&#125;</span>`</span>); <span class="comment">// 32 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>SharedArrayBuffer</li>
</ol>
<p>既不克隆，也不转移，SharedArrayBuffer作为ArrayBuffer能够在不同浏览器上下文间共享。在把SharedArrayBuffer传给postMessage()时，浏览器只会传递原始缓冲区的引用。结果是，两个不同的 JavaScript 上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区，就跟修改常规ArrayBuffer一样。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 1 字节缓冲区 </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 1 字节缓冲区的视图 </span></span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 父上下文赋值 1 </span></span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`buffer value after worker modification: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送对 sharedArrayBuffer 的引用 </span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(sharedArrayBuffer); </span><br><span class="line"></span><br><span class="line"><span class="comment">// buffer value before worker modification: 1 </span></span><br><span class="line"><span class="comment">// buffer value after worker modification: 2 </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(data); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`buffer value before worker modification: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工作者线程为共享缓冲区赋值 </span></span><br><span class="line">  view[<span class="number">0</span>] += <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送空消息，通知赋值完成 </span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(<span class="literal">null</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SharedArrayBuffer实例实际上会被当成易变（volatile）内存。下面的例子演示了这一点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 创建包含 4 个线程的线程池 </span></span><br><span class="line"><span class="keyword">const</span> workers = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; </span><br><span class="line">  workers.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最后一个工作者线程完成后打印最终值 </span></span><br><span class="line"><span class="keyword">let</span> responseCount = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (++responseCount == workers.<span class="property">length</span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final buffer value: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 SharedArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 SharedArrayBuffer 发给每个线程 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="title function_">postMessage</span>(sharedArrayBuffer); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// （期待结果为 4000001。实际输出类似于：） </span></span><br><span class="line"><span class="comment">// Final buffer value: 2145106 </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(data); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 100 万次加操作 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1E6</span>; ++i) &#123; </span><br><span class="line">    view[<span class="number">0</span>] += <span class="number">1</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  self.<span class="title function_">postMessage</span>(<span class="literal">null</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在所有工作者线程读/写操作交织的过程中就会发生资源争用。</p>
<p>为解决该问题，可以使用Atomics对象让一个工作者线程获得SharedArrayBuffer实例的锁，在执行完全部读/写/读操作后，再允许另一个工作者线程执行操作。把Atomics.add()放到这个例子中就可以得到正确的最终值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 创建包含 4 个线程的线程池 </span></span><br><span class="line"><span class="keyword">const</span> workers = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; </span><br><span class="line">  workers.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最后一个工作者线程完成后打印最终值 </span></span><br><span class="line"><span class="keyword">let</span> responseCount = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (++responseCount == workers.<span class="property">length</span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final buffer value: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 SharedArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 SharedArrayBuffer 发给每个线程 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line">  worker.<span class="title function_">postMessage</span>(sharedArrayBuffer); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//（期待结果为 4000001） </span></span><br><span class="line"><span class="comment">// Final buffer value: 4000001 </span></span><br><span class="line">worker.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(data); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 100 万次加操作 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1E6</span>; ++i) &#123; </span><br><span class="line">    <span class="title class_">Atomics</span>.<span class="title function_">add</span>(view, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">  self.<span class="title function_">postMessage</span>(<span class="literal">null</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="27-2-11-线程池"><a href="#27-2-11-线程池" class="headerlink" title="27.2.11 线程池"></a>27.2.11 线程池</h4><p>工作者线程在执行计算时，会被标记为忙碌状态。直到它通知线程池自己空闲了，<br>才准备好接收新任务。这些活动线程就称为“线程池”或“工作者线程池”。</p>
<p>线程池中线程的数量最好为线程池大小的上限。</p>
<p>一种使用线程池的策略是每个线程都执行同样的任务，但具体执行什么任务由几个参数来控制。通过使用特定于任务的线程池，可以分配固定数量的工作者线程，并根据需要为他们提供参数。工作者线程会接收这些参数，执行耗时的计算，并把结果返回给线程池。然后线程池可以再将其他工作分派给工作者线程去执行。接下来的例子将构建一个相对简单的线程池，但可以涵盖上述思路的所有基本要求。<br>首先是定义一个TaskWorker类，它可以扩展Worker类。TaskWorker类负责两件事：跟踪线程是否正忙于工作，并管理进出线程的信息与事件。另外，传入给这个工作者线程的任务会封装到一个期约中，然后正确地解决和拒绝。这个类的定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskWorker</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Worker</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">notifyAvailable, ...workerArgs</span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(...workerArgs); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为不可用状态 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">available</span> = <span class="literal">false</span>; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolve</span> = <span class="literal">null</span>; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reject</span> = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池会传递回调 </span></span><br><span class="line">    <span class="comment">// 以便工作者线程发出它需要新任务的信号 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">notifyAvailable</span> = notifyAvailable; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程脚本在完全初始化之后 </span></span><br><span class="line">    <span class="comment">// 会发送一条&quot;ready&quot;消息 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setAvailable</span>(); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由线程池调用，以分派新任务 </span></span><br><span class="line">  <span class="title function_">dispatch</span>(<span class="params">&#123; resolve, reject, postMessageArgs &#125;</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">available</span> = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="title function_">resolve</span>(data); </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setAvailable</span>(); </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onerror</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="title function_">reject</span>(e); </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setAvailable</span>(); </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">postMessage</span>(...postMessageArgs); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="title function_">setAvailable</span>(<span class="params"></span>) &#123; </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">available</span> = <span class="literal">true</span>; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolve</span> = <span class="literal">null</span>; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reject</span> = <span class="literal">null</span>; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifyAvailable</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是定义使用TaskWorker类的WorkerPool类。它还必须维护尚未分派给工作者线程的任务队列。两个事件可以表明应该分派一个新任务：新任务被添加到队列中，或者工作者线程完成了一个任务，应该再发送另一个任务。WorkerPool类定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerPool</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">poolSize, ...workerArgs</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">taskQueue</span> = []; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">workers</span> = []; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程池 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; poolSize; ++i) &#123; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">workers</span>.<span class="title function_">push</span>( </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TaskWorker</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">dispatchIfAvailable</span>(), ...workerArgs)); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把任务推入队列 </span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">...postMessageArgs</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">taskQueue</span>.<span class="title function_">push</span>(&#123; resolve, reject, postMessageArgs &#125;); </span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">dispatchIfAvailable</span>(); </span><br><span class="line">    &#125;); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把任务发送给下一个空闲的线程（如果有的话） </span></span><br><span class="line">  <span class="title function_">dispatchIfAvailable</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">taskQueue</span>.<span class="property">length</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">workers</span>) &#123; </span><br><span class="line">      <span class="keyword">if</span> (worker.<span class="property">available</span>) &#123; </span><br><span class="line">        <span class="keyword">let</span> a = <span class="variable language_">this</span>.<span class="property">taskQueue</span>.<span class="title function_">shift</span>(); </span><br><span class="line">        worker.<span class="title function_">dispatch</span>(a); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 终止所有工作者线程 </span></span><br><span class="line">  <span class="title function_">close</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">workers</span>) &#123; </span><br><span class="line">      worker.<span class="title function_">terminate</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了这两个类之后，现在可以把任务分派到线程池，并在工作者线程可用时执行它们。在这个例子中，假设我们想计算 1000 万个浮点值之和。为节省转移成本，我们使用SharedArrayBuffer。工作者线程的脚本（worker.js）大致如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(data.<span class="property">arrayBuffer</span>) </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求和 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = data.<span class="property">startIdx</span>; i &lt; data.<span class="property">endIdx</span>; ++i) &#123; </span><br><span class="line">    <span class="comment">// 不需要原子操作，因为只需要读 </span></span><br><span class="line">    sum += view[i]; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把结果发送给工作者线程 </span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(sum); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息给 TaskWorker </span></span><br><span class="line"><span class="comment">// 通知工作者线程准备好接收任务了 </span></span><br><span class="line">self.<span class="title function_">postMessage</span>(<span class="string">&#x27;ready&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>有了以上代码，利用线程池分派任务的代码可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Class</span> <span class="title class_">TaskWorker</span> &#123; </span><br><span class="line">  ... </span><br><span class="line">] </span><br><span class="line"></span><br><span class="line"><span class="title class_">Class</span> <span class="title class_">WorkerPool</span> &#123; </span><br><span class="line">  ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> totalFloats = <span class="number">1E8</span>; </span><br><span class="line"><span class="keyword">const</span> numTasks = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">const</span> floatsPerTask = totalFloats / numTasks; </span><br><span class="line"><span class="keyword">const</span> numWorkers = <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池 </span></span><br><span class="line"><span class="keyword">const</span> pool = <span class="keyword">new</span> <span class="title class_">WorkerPool</span>(numWorkers, <span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充浮点值数组 </span></span><br><span class="line"><span class="keyword">let</span> arrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span> * totalFloats); </span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(arrayBuffer); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalFloats; ++i) &#123; </span><br><span class="line">  view[i] = <span class="title class_">Math</span>.<span class="title function_">random</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> partialSumPromises = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalFloats; i += floatsPerTask) &#123; </span><br><span class="line">  partialSumPromises.<span class="title function_">push</span>( </span><br><span class="line">    pool.<span class="title function_">enqueue</span>(&#123; </span><br><span class="line">      <span class="attr">startIdx</span>: i, </span><br><span class="line">      <span class="attr">endIdx</span>: i + floatsPerTask, </span><br><span class="line">      <span class="attr">arrayBuffer</span>: arrayBuffer </span><br><span class="line">    &#125;) </span><br><span class="line">  ); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待所有期约完成，然后求和 </span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(partialSumPromises) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">partialSums</span>) =&gt;</span> partialSums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//（在这个例子中，和应该约等于 1E8/2） </span></span><br><span class="line"><span class="comment">// 49997075.47203197</span></span><br></pre></td></tr></table></figure>

<h3 id="27-3-共享工作者线程"><a href="#27-3-共享工作者线程" class="headerlink" title="27.3 共享工作者线程"></a>27.3 共享工作者线程</h3><p>共享工作者线程或共享线程与专用工作者线程类似，但可以被多个可信任的执行上下文访问。例如，同源的两个标签页可以访问同一个共享工作者线程。SharedWorker与Worker的消息接口稍有不同，包括外部和内部。<br>共享线程适合开发者希望通过在多个上下文间共享线程减少计算性消耗的情形。</p>
<h4 id="27-3-1-共享工作者线程简介"><a href="#27-3-1-共享工作者线程简介" class="headerlink" title="27.3.1 共享工作者线程简介"></a>27.3.1 共享工作者线程简介</h4><p>从行为上讲，共享工作者线程可以看作是专用工作者线程的一个扩展。线程创建、线程选项、安全限制和importScripts()的行为都是相同的。与专用工作者线程一样，共享工作者线程也在独立执行上下文中运行，也只能与其他上下文异步通信。</p>
<ol>
<li>创建共享工作者线程</li>
</ol>
<p>与专用工作者线程一样，创建共享工作者线程非常常用的方式是通过加载 JavaScript 文件创建。此时，需要给SharedWorker构造函数传入文件路径，该构造函数在后台异步加载脚本并实例化共享工作者线程。</p>
<p>也可以在行内脚本中创建共享工作者线程，但这样做没什么意义。因为每个基于行内脚本字符串创建的Blob都会被赋予自己唯一的浏览器内部 URL，所以行内脚本中创建的共享工作者线程始终是唯一的。</p>
<ol start="2">
<li>SharedWorker标识与独占</li>
</ol>
<p>共享工作者线程与专用工作者线程的一个重要区别在于，虽然Worker()构造函数始终会创建新实例，而SharedWorker()则只会在相同的标识不存在的情况下才创建新实例。如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。<br>共享工作者线程标识源自解析后的脚本 URL、工作者线程名称和文档源。例如，下面的脚本将实例化一个共享工作者线程并添加两个连接：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个共享工作者线程 </span></span><br><span class="line"><span class="comment">//  - 全部基于同源调用构造函数 </span></span><br><span class="line"><span class="comment">//  - 所有脚本解析为相同的 URL </span></span><br><span class="line"><span class="comment">//  - 所有线程都有相同的名称 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>); </span><br><span class="line">类似地，因为下面三个脚本字符串都解析到相同的 <span class="variable constant_">URL</span>，所以也只会创建一个共享工作者线程： </span><br><span class="line"><span class="comment">// 实例化一个共享工作者线程 </span></span><br><span class="line"><span class="comment">//  - 全部基于同源调用构造函数 </span></span><br><span class="line"><span class="comment">//  - 所有脚本解析为相同的 URL </span></span><br><span class="line"><span class="comment">//  - 所有线程都有相同的名称 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;sharedWorker.js&#x27;</span>); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;https://www.example.com/sharedWorker.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>因为可选的工作者线程名称也是共享工作者线程标识的一部分，所以不同的线程名称会强制浏览器创建多个共享工作者线程。对下面的例子而言，一个名为’foo’，另一个名为’bar’，尽管它们同源且脚本 URL 相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个共享工作者线程 </span></span><br><span class="line"><span class="comment">//  - 全部基于同源调用构造函数 </span></span><br><span class="line"><span class="comment">//  - 所有脚本解析为相同的 URL </span></span><br><span class="line"><span class="comment">//  - 一个线程名称为&#x27;foo&#x27;，一个线程名称为&#x27;bar&#x27; </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>&#125;); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>&#125;); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;bar&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>共享线程，顾名思义，可以在不同标签页、不同窗口、不同内嵌框架或同源的其他工作者线程之间共享。因此，下面的脚本如果在多个标签页运行，只会在第一次执行时创建一个共享工作者线程，后续执行会连接到该线程。</p>
<p>初始化共享线程的脚本只会限制 URL，因此下面的代码会创建两个共享工作者线程，尽管加载了相同的脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个共享工作者线程 </span></span><br><span class="line"><span class="comment">//  - 全部基于同源调用构造函数 </span></span><br><span class="line"><span class="comment">//  - &#x27;?&#x27;导致了两个不同的 URL </span></span><br><span class="line"><span class="comment">//  - 所有线程都有相同的名称 </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js?&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果该脚本在两个不同的标签页中运行，同样也只会创建两个共享工作者线程。每个构造函数都会检查匹配的共享工作者线程，然后连接到已存在的那个。</p>
<ol start="3">
<li>使用SharedWorker对象</li>
</ol>
<p>SharedWorker()构造函数返回的SharedWorker对象被用作与新创建的共享工作者线程通信的连接点。它可以用来通过MessagePort在共享工作者线程和父上下文间传递信息，也可以用来捕获共享线程中发出的错误事件。</p>
<p>SharedWorker对象支持以下属性。</p>
<ul>
<li><p>onerror：在共享线程中发生ErrorEvent类型的错误事件时会调用指定给该属性的处理程序。</p>
<ul>
<li><p>此事件会在共享线程抛出错误时发生。</p>
</li>
<li><p>此事件也可以通过使用sharedWorker.addEventListener(‘error’, handler)处理。</p>
</li>
</ul>
</li>
<li><p>port：专门用来跟共享线程通信的MessagePort。</p>
</li>
</ul>
<ol start="4">
<li>SharedWorkerGlobalScope</li>
</ol>
<p>在共享线程内部，全局作用域是SharedWorkerGlobalScope的实例。SharedWorkerGlobalScope继承自WorkerGlobalScope，因此包括它所有的属性和方法。与专用工作者线程一样，共享工作者线程也可以通过self关键字访问该全局上下文。<br>SharedWorkerGlobalScope通过以下属性和方法扩展了WorkerGlobalScope。</p>
<ul>
<li><p>name：可选的字符串标识符，可以传给SharedWorker构造函数。</p>
</li>
<li><p>importScripts()：用于向工作者线程中导入任意数量的脚本。</p>
</li>
<li><p>close()：与worker.terminate()对应，用于立即终止工作者线程。没有给工作者线程提供终止前清理的机会；脚本会突然停止。</p>
</li>
<li><p>onconnect：与共享线程建立新连接时，应将其设置为处理程序。connect事件包括MessagePort实例的ports数组，可用于把消息发送回父上下文。</p>
<ul>
<li><p>在通过worker.port.onmessage或worker.port.start()与共享线程建立连接时都会触发connect事件。</p>
</li>
<li><p>connect事件也可以通过使用sharedWorker.addEventListener(‘connect’, handler)处理。</p>
</li>
</ul>
</li>
</ul>
<h4 id="27-3-2-理解共享工作者线程的生命周期"><a href="#27-3-2-理解共享工作者线程的生命周期" class="headerlink" title="27.3.2 理解共享工作者线程的生命周期"></a>27.3.2 理解共享工作者线程的生命周期</h4><p>共享工作者线程的生命周期具有与专用工作者线程相同的阶段的特性。不同之处在于，专用工作者线程只跟一个页面绑定，而共享工作者线程只要还有一个上下文连接就会持续存在。<br>比如下面的脚本，每次调用它都会创建一个专用工作者线程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>脚本执行次数、打开标签页数和运行的线程数是对等关系。</p>
<p>下面再来看看这个简单的脚本，每次执行它都会创建或者连接到共享线程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>随着连接的增加和移除，浏览器会记录连接总数。在连接数为 0 时，线程被终止。</p>
<p>SharedWorker对象上没有terminate()方法。在共享线程端口（稍后讨论）上调用close()时，只要还有一个端口连接到该线程就不会真的终止线程。<br>SharedWorker的“连接”与关联MessagePort或MessageChannel的状态无关。只要建立了连接，浏览器会负责管理该连接。建立的连接会在页面的生命周期内持续存在，只有当页面销毁且没有连接时，浏览器才会终止共享线程。</p>
<h4 id="27-3-3-连接到共享工作者线程"><a href="#27-3-3-连接到共享工作者线程" class="headerlink" title="27.3.3 连接到共享工作者线程"></a>27.3.3 连接到共享工作者线程</h4><p>每次调用SharedWorker()构造函数，无论是否创建了工作者线程，都会在共享线程内部触发connect事件。下面的例子演示了这一点，在循环中调用SharedWorker()构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line">self.<span class="property">onconnect</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`connected <span class="subst">$&#123;++i&#125;</span> times`</span>); </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// connected 1 times </span></span><br><span class="line"><span class="comment">// connected 2 times </span></span><br><span class="line"><span class="comment">// connected 3 times </span></span><br><span class="line"><span class="comment">// connected 4 times </span></span><br><span class="line"><span class="comment">// connected 5 times</span></span><br></pre></td></tr></table></figure>

<p>下面的代码演示了访问事件对象的ports数组。这里使用了Set来保证只跟踪唯一的对象实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.<span class="property">js</span> </span><br><span class="line"><span class="keyword">const</span> connectedPorts = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"></span><br><span class="line">self.<span class="property">onconnect</span> = <span class="function">(<span class="params">&#123;ports&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  connectedPorts.<span class="title function_">add</span>(ports[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;connectedPorts.size&#125;</span> unique connected ports`</span>); </span><br><span class="line">&#125;; </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 unique connected ports </span></span><br><span class="line"><span class="comment">// 2 unique connected ports </span></span><br><span class="line"><span class="comment">// 3 unique connected ports </span></span><br><span class="line"><span class="comment">// 4 unique connected ports </span></span><br><span class="line"><span class="comment">// 5 unique connected ports</span></span><br></pre></td></tr></table></figure>

<p>关键在于，共享线程与父上下文的启动和关闭不是对称的。每个新SharedWorker连接都会触发一个事件，但没有事件对应断开SharedWorker实例的连接（如页面关闭）。<br>在前面的例子中，随着与相同共享线程连接和断开连接的页面越来越多，connectedPorts集合中会受到死端口的污染，没有办法识别它们。一个解决方案是在beforeunload事件即将销毁页面时，明确发送卸载消息，让共享线程有机会清除死端口。</p>
<h3 id="27-4-服务工作者线程"><a href="#27-4-服务工作者线程" class="headerlink" title="27.4 服务工作者线程"></a>27.4 服务工作者线程</h3><p>服务工作者线程（service worker）是一种类似浏览器中代理服务器的线程，可以拦截外出请求和缓存响应。这可以让网页在没有网络连接的情况下正常使用，因为部分或全部页面可以从服务工作者线程缓存中提供服务。服务工作者线程也可以使用 Notifications API、Push API、Background Sync API 和Channel Messaging API。<br>与共享工作者线程类似，来自一个域的多个页面共享一个服务工作者线程。不过，为了使用 Push API等特性，服务工作者线程也可以在相关的标签页或浏览器关闭后继续等待到来的推送事件。<br>无论如何，对于大多数开发者而言，服务工作者线程在两个主要任务上最有用：充当网络请求的缓存层和启用推送通知。在这个意义上，服务工作者线程就是用于把网页变成像原生应用程序一样的工具。</p>
<blockquote>
<p>服务工作者线程的生命周期取决于打开的同源标签页（称为“客户端”）数量、页面是否发生导航，以及服务脚本是否改变（以及其他一些因素）。如果对服务工作者线程的生命周期认识不够，本节的一些例子可能会让人觉得出乎意料。27.4.5 节详细解释了服务工作者线程的生命周期。<br>另外，在调试服务工作者线程时，要谨慎使用浏览器的强制刷新功能（Ctrl+Shift+R）。强制刷新会强制浏览器忽略所有网络缓存，而服务工作者线程对大多数主流浏览器而言就是网络缓存</p>
</blockquote>
<h4 id="27-4-1-服务工作者线程基础"><a href="#27-4-1-服务工作者线程基础" class="headerlink" title="27.4.1 服务工作者线程基础"></a>27.4.1 服务工作者线程基础</h4><p>作为一种工作者线程，服务工作者线程与专用工作者线程和共享工作者线程拥有很多共性。比如，在独立上下文中运行，只能通过异步消息通信。不过，服务工作者线程与专用工作者线程和共享工作者线程还是有很多本质区别的。</p>
<ol>
<li>ServiceWorkerContainer</li>
</ol>
<p>服务工作者线程与专用工作者线程或共享工作者线程的一个区别是没有全局构造函数。服务工作者线程是通过ServiceWorkerContainer来管理的，它的实例保存在navigator.serviceWorker属性中。该对象是个顶级接口，通过它可以让浏览器创建、更新、销毁或者与服务工作者线程交互。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">serviceWorker</span>); </span><br><span class="line"><span class="comment">// ServiceWorkerContainer &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建服务工作者线程</li>
</ol>
<p>与共享工作者线程类似，服务工作者线程同样是在还不存在时创建新实例，在存在时连接到已有实例。ServiceWorkerContainer没有通过全局构造函数创建，而是暴露了register()方法，该方法以与Worker()或SharedWorker()构造函数相同的方式传递脚本 URL：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emptyServiceWorker.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 空服务脚本 </span></span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./emptyServiceWorker.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>register()方法返回一个期约，该期约解决为ServiceWorkerRegistration对象，或在注册失败时拒绝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">emptyServiceWorker.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 空服务脚本 </span></span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 注册成功，成功回调（解决） </span></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./emptyServiceWorker.js&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="variable language_">console</span>.<span class="property">error</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceWorkerRegistration &#123; ... &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不存在的文件注册，失败回调（拒绝） </span></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./doesNotExist.js&#x27;</span>) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>

<p>服务工作者线程对于何时注册是比较灵活的。在第一次调用register()激活服务工作者线程后，后续在同一个页面使用相同 URL 对register()的调用实际上什么也不会执行。此外，即使浏览器未全局支持服务工作者线程，服务工作者线程本身对页面也应该是不可见的。这是因为它的行为类似代理，就算有需要它处理的操作，也仅仅是发送常规的网络请求。<br>考虑到上述情况，注册服务工作者线程的一种非常常见的模式是基于特性检测，并在页面的load事件中操作。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123; </span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有load事件这个门槛，服务工作者线程的注册就会与页面资源的加载重叠，进而拖慢初始页面渲染的过程。除非该服务工作者线程负责管理缓存（这样的话就需要尽早注册，比如使用clients.claim()），否则等待load事件是个明智的选择，这样同样可以发挥服务工作者线程的价值。</p>
<ol start="3">
<li>使用ServiceWorkerContainer对象</li>
</ol>
<p>ServiceWorkerContainer接口是浏览器对服务工作者线程生态的顶部封装。它为管理服务工作者线程状态和生命周期提供了便利。<br>ServiceWorkerContainer始终可以在客户端上下文中访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">serviceWorker</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceWorkerContainer &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<p>ServiceWorkerContainer支持以下事件处理程序。</p>
<ul>
<li><p>oncontrollerchange：在ServiceWorkerContainer触发controllerchange事件时会调用指定的事件处理程序。</p>
<ul>
<li><p>此事件在获得新激活的ServiceWorkerRegistration时触发。</p>
</li>
<li><p>此事件也可以使用navigator.serviceWorker.addEventListener(‘controllerchange’, handler)处理。</p>
</li>
</ul>
</li>
<li><p>onerror：在关联的服务工作者线程触发ErrorEvent错误事件时会调用指定的事件处理程序。</p>
<ul>
<li><p>此事件在关联的服务工作者线程内部抛出错误时触发。</p>
</li>
<li><p>此事件也可以使用navigator.serviceWorker.addEventListener(‘error’, handler)处理。</p>
</li>
</ul>
</li>
<li><p>onmessage：在服务工作者线程触发MessageEvent事件时会调用指定的事件处理程序。</p>
<ul>
<li><p>此事件在服务脚本向父上下文发送消息时触发。</p>
</li>
<li><p>此事件也可以使用navigator.serviceWorker.addEventListener(‘message’, handler)处理。</p>
</li>
</ul>
</li>
</ul>
<p>ServiceWorkerContainer支持下列属性。</p>
<ul>
<li><p>ready：返回期约，解决为激活的ServiceWorkerRegistration对象。该期约不会拒绝。</p>
</li>
<li><p>controller：返回与当前页面关联的激活的ServiceWorker对象，如果没有激活的服务工作者线程则返回null。</p>
</li>
</ul>
<p>ServiceWorkerContainer支持下列方法。</p>
<ul>
<li><p>register()：使用接收的url和options对象创建或更新ServiceWorkerRegistration。</p>
</li>
<li><p>getRegistration()：返回期约，解决为与提供的作用域匹配的ServiceWorkerRegistration对象；如果没有匹配的服务工作者线程则返回undefined。</p>
</li>
<li><p>getRegistrations()：返回期约，解决为与ServiceWorkerContainer关联的ServiceWorkerRegistration对象的数组；如果没有关联的服务工作者线程则返回空数组。</p>
</li>
<li><p>startMessage()：开始传送通过Client.postMessage()派发的消息。</p>
</li>
</ul>
<ol start="4">
<li>使用ServiceWorkerRegistration对象</li>
</ol>
<p>ServiceWorkerRegistration对象表示注册成功的服务工作者线程。该对象可以在register()返回的解决期约的处理程序中访问到。通过它的一些属性可以确定关联服务工作者线程的生命周期状态。<br>调用navigator.serviceWorker.register()之后返回的期约会将注册成功的Service- WorkerRegistration对象（注册对象）发送给处理函数。在同一页面使用同一 URL 多次调用该方法会返回相同的注册对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registrationA</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(registrationA); </span><br><span class="line"></span><br><span class="line">  navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker2.js&#x27;</span>) </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">registrationB</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(registrationA === registrationB); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ServiceWorkerRegistration支持以下事件处理程序。</p>
<ul>
<li>onupdatefound：在服务工作者线程触发updatefound事件时会调用指定的事件处理程序。<ul>
<li><p>此事件会在服务工作者线程开始安装新版本时触发，表现为ServiceWorkerRegistration. installing收到一个新的服务工作者线程。</p>
</li>
<li><p>此事件也可以使用serv serviceWorkerRegistration.addEventListener(‘updatefound’, handler)处理。</p>
</li>
</ul>
</li>
</ul>
<p>ServiceWorkerRegistration支持以下通用属性。</p>
<ul>
<li><p>scope：返回服务工作者线程作用域的完整 URL 路径。该值源自接收服务脚本的路径和在register()中提供的作用域。</p>
</li>
<li><p>navigationPreload：返回与注册对象关联的NavigationPreloadManager实例。</p>
</li>
<li><p>pushManager：返回与注册对象关联的pushManager实例。</p>
</li>
</ul>
<p>ServiceWorkerRegistration还支持以下属性，可用于判断服务工作者线程处于生命周期的什么阶段。</p>
<ul>
<li><p>installing：如果有则返回状态为installing（安装）的服务工作者线程，否则为null。</p>
</li>
<li><p>waiting：如果有则返回状态为waiting（等待）的服务工作者线程，否则为null。</p>
</li>
<li><p>active：如果有则返回状态activating或active（活动）的服务工作者线程，否则为null。</p>
</li>
</ul>
<blockquote>
<p>这些属性都是服务工作者线程状态的一次性快照。</p>
</blockquote>
<p>ServiceWorkerRegistration支持下列方法。</p>
<ul>
<li><p>getNotifications()：返回期约，解决为Notification对象的数组。</p>
</li>
<li><p>showNotifications()：显示通知，可以配置title和options参数。</p>
</li>
<li><p>update()：直接从服务器重新请求服务脚本，如果新脚本不同，则重新初始化。</p>
</li>
<li><p>unregister()：取消服务工作者线程的注册。该方法会在服务工作者线程执行完再取消注册。</p>
</li>
</ul>
<ol start="5">
<li>使用ServiceWorker对象</li>
</ol>
<p>ServiceWorker对象可以通过两种方式获得：通过ServiceWorkerContainer对象的controller属性和通过ServiceWorkerRegistration的active属性。该对象继承Worker原型，因此包括其所有属性和方法，但没有terminate()方法。<br>ServiceWorker支持以下事件处理程序。</p>
<ul>
<li>onstatechange：ServiceWorker发生statechange事件时会调用指定的事件处理程序。<ul>
<li><p>此事件会在ServiceWorker.state变化时发生。</p>
</li>
<li><p>此事件也可以使用serviceWorker.addEventListener(‘statechange’, handler)处理。</p>
</li>
</ul>
</li>
</ul>
<p>ServiceWorker支持以下属性。</p>
<ul>
<li><p>scriptURL：解析后注册服务工作者线程的 URL。例如，如果服务工作者线程是通过相对路径’./serviceWorker.js’创建的，且注册在 <a target="_blank" rel="noopener" href="https://www.example.com/">https://www.example.com</a> 上，则scriptURL属性将<br>返回”<a target="_blank" rel="noopener" href="https://www.example.com/serviceWorker.js%22%E3%80%82">https://www.example.com/serviceWorker.js”。</a></p>
</li>
<li><p>state：表示服务工作者线程状态的字符串，可能的值如下。</p>
<ul>
<li><p>installing</p>
</li>
<li><p>installed</p>
</li>
<li><p>activating</p>
</li>
<li><p>activated</p>
</li>
<li><p>redundant</p>
</li>
</ul>
</li>
</ul>
<ol start="6">
<li>服务工作者线程的安全限制</li>
</ol>
<p>与其他工作者线程一样，服务工作者线程也受加载脚本对应源的常规限制。此外，由于服务工作者线程几乎可以任意修改和重定向网络请求，以及加载静态资源，服务工作者线程API 只能在安全上下文（HTTPS）下使用。在非安全上下文（HTTP）中，navigator.serviceWorker是undefined。为方便开发，浏览器豁免了通过localhost或127.0.0.1在本地加载的页面的安全上下文规则。</p>
<ol start="7">
<li>ServiceWorkerGlobalScope</li>
</ol>
<p>在服务工作者线程内部，全局上下文是ServiceWorkerGlobalScope的实例。ServiceWorkerGlobalScope继承自WorkerGlobalScope，因此拥有它的所有属性和方法。服务工作者线程可以通过self关键字访问该全局上下文。<br>ServiceWorkerGlobalScope通过以下属性和方法扩展了WorkerGlobalScope。</p>
<ul>
<li><p>caches：返回服务工作者线程的CacheStorage对象。</p>
</li>
<li><p>clients：返回服务工作者线程的Clients接口，用于访问底层Client对象。</p>
</li>
<li><p>registration：返回服务工作者线程的ServiceWorkerRegistration对象。</p>
</li>
<li><p>skipWaiting()：强制服务工作者线程进入活动状态；需要跟Clients.claim()一起使用。</p>
</li>
<li><p>fetch()：在服务工作者线程内发送常规网络请求；用于在服务工作者线程确定有必要发送实际网络请求（而不是返回缓存值）时。</p>
</li>
</ul>
<p>虽然专用工作者线程和共享工作者线程只有一个message事件作为输入，但服务工作者线程则可以接收很多事件，包括页面操作、通知操作触发的事件或推送事件。</p>
<p>服务工作者线程的全局作用域可以监听以下事件，这里进行了分类。</p>
<ul>
<li>服务工作者线程状态<br>install：在服务工作者线程进入安装状态时触发（在客户端可以通过ServiceWorkerRegistration.installing判断）。也可以在self.onintall属性上指定该事件的处理程序。<ul>
<li><p>这是服务工作者线程接收的第一个事件，在线程一开始执行时就会触发。</p>
</li>
<li><p>每个服务工作者线程只会调用一次。</p>
</li>
</ul>
</li>
</ul>
<p>activate： 在 服 务 工 作 者 线 程 进 入 激 活 或 已 激 活 状 态 时 触 发 （ 在 客 户 端 可 以 通 过ServiceWorkerRegistration.active判断）。也可以在self.onactive属性上指定该事件的处理程序。</p>
<ul>
<li><p>此事件在服务工作者线程准备好处理功能性事件和控制客户端时触发。</p>
</li>
<li><p>此事件并不代表服务工作者线程在控制客户端，只表明具有控制客户端的条件。</p>
</li>
<li><p>Fetch API</p>
<p>fetch：在服务工作者线程截获来自主页面的fetch()请求时触发。服务工作者线程的fetch事件处理程序可以访问FetchEvent，可以根据需要调整输出。也可以在self.onfetch属性上指定该事件的处理程序。</p>
</li>
<li><p>Message API</p>
<p>message：在服务工作者线程通过postMesssage()获取数据时触发。也可以在self.onmessage属性上指定该事件的处理程序。</p>
</li>
<li><p>Notification API<br>notificationclick：在系统告诉浏览器用户点击了ServiceWorkerRegistration.showNotification()生成的通知时触发。也可以在self.onnotificationclick属性上指定该事件的处理程序。<br>notificationclose：在系统告诉浏览器用户关闭或取消显示了ServiceWorkerRegistration. showNotification()生成的通知时触发。也可以在self.onnotificationclose属性上指定该事件的处理程序。</p>
</li>
<li><p>Push API<br>push：在服务工作者线程接收到推送消息时触发。也可以在self.onpush属性上指定该事件的处理程序。<br>pushsubscriptionchange：在应用控制外的因素（非 JavaScript 显式操作）导致推送订阅状态变化时触发。也可以在self.onpushsubscriptionchange属性上指定该事件的处理程序。</p>
</li>
</ul>
<ol start="8">
<li>服务工作者线程作用域限制</li>
</ol>
<p>服务工作者线程只能拦截其作用域内的客户端发送的请求。作用域是相对于获取服务脚本的路径定义的。如果没有在register()中指定，则作用域就是服务脚本的路径。</p>
<p>下面第一个例子演示通过根目录获取服务脚本对应的默认根作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">serviceWorkerRegistration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(serviceWorkerRegistration.<span class="property">scope</span>); </span><br><span class="line">  <span class="comment">// https://example.com/ </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下请求都会被拦截： </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo.js&#x27;); </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo/fooScript.js&#x27;); </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/baz/bazScript.js&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>下面的例子演示了通过根目录获取服务脚本但指定了同一目录作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/serviceWorker.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;./&#x27;</span>&#125;) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">serviceWorkerRegistration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(serviceWorkerRegistration.<span class="property">scope</span>); </span><br><span class="line">  <span class="comment">// https://example.com/ </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下请求都会被拦截： </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo.js&#x27;); </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo/fooScript.js&#x27;); </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/baz/bazScript.js&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>下面的例子演示了通过根目录获取服务脚本但限定了目录作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/serviceWorker.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;./foo&#x27;</span>&#125;) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">serviceWorkerRegistration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(serviceWorkerRegistration.<span class="property">scope</span>); </span><br><span class="line">  <span class="comment">// https://example.com/foo/ </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下请求都会被拦截： </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo/fooScript.js&#x27;); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下请求都不会被拦截： </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo.js&#x27;); </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/baz/bazScript.js&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>下面的例子演示了通过嵌套的二级目录获取服务脚本对应的同一目录作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/foo/serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">serviceWorkerRegistration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(serviceWorkerRegistration.<span class="property">scope</span>); </span><br><span class="line">  <span class="comment">// https://example.com/foo/ </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下请求都会被拦截： </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo/fooScript.js&#x27;); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下请求都不会被拦截： </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/foo.js&#x27;); </span></span><br><span class="line"><span class="comment">// fetch(&#x27;/baz/bazScript.js&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>服务工作者线程的作用域实际上遵循了目录权限模型，即只能相对于服务脚本所在路径缩小作用域。像下面这样扩展作用域会抛出错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/foo/serviceWorker.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;/&#x27;</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: The path of the provided scope &#x27;https://example.com/&#x27; </span></span><br><span class="line"><span class="comment">// is not under the max scope allowed &#x27;https://example.com/foo/&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通常，服务工作者线程作用域会使用末尾带斜杠的绝对路径来定义，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/serviceWorker.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;/foo/&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>这样定义作用域有两个目的：将脚本文件的相对路径与作用域的相对路径分开，同时将该路径本身排除在作用域之外。例如，对于前面的代码片段而言，可能不需要在服务工作者线程的作用域中包含路径/foo。在末尾加上一个斜杠就可以明确排除/foo。当然，这要求绝对作用域路径不能扩展到服务工作者线程路径外。<br>如果想扩展服务工作者线程的作用域，主要有两种方式。</p>
<ul>
<li><p>通过包含想要的作用域的路径提供（获取）服务脚本。</p>
</li>
<li><p>给服务脚本的响应添加Service-Worker-Allowed头部，把它的值设置为想要的作用域。该作用域值应该与register()中的作用域值一致。</p>
</li>
</ul>
<h4 id="27-4-2-服务工作者线程缓存"><a href="#27-4-2-服务工作者线程缓存" class="headerlink" title="27.4.2 服务工作者线程缓存"></a>27.4.2 服务工作者线程缓存</h4><p>服务工作者线程的一个主要能力是可以通过编程方式实现真正的网络请求缓存机制。与 HTTP 缓存或 CPU 缓存不同，服务工作者线程缓存非常简单。</p>
<ul>
<li><p>服务工作者线程缓存不自动缓存任何请求。所有缓存都必须明确指定。</p>
</li>
<li><p>服务工作者线程缓存没有到期失效的概念。除非明确删除，否则缓存内容一直有效。</p>
</li>
<li><p>服务工作者线程缓存必须手动更新和删除。</p>
</li>
<li><p>缓存版本必须手动管理。每次服务工作者线程更新，新服务工作者线程负责提供新的缓存键以保存新缓存。</p>
</li>
<li><p>唯一的浏览器强制逐出策略基于服务工作者线程缓存占用的空间。服务工作者线程负责管理自己缓存占用的空间。缓存超过浏览器限制时，浏览器会基于最近最少使用（LRU，Least Recently Used）原则为新缓存腾出空间。</p>
</li>
</ul>
<p>本质上，服务工作者线程缓存机制是一个双层字典，其中顶级字典的条目映射到二级嵌套字典。顶级字典是CacheStorage对象，可以通过服务工作者线程全局作用域的caches属性访问。顶级字典中的每个值都是一个Cache对象，该对象也是个字典，是Request对象到Response对象的映射。<br>与LocalStorage一样，Cache对象在CacheStorage字典中无限期存在，会超出浏览器会话的界限。此外，Cache条目只能以源为基础存取。</p>
<ol>
<li>CacheStorage对象</li>
</ol>
<p>CacheStorage对象是映射到Cache对象的字符串键/值存储。CacheStorage提供的 API 类似于异步Map。CacheStorage的接口通过全局对象的caches属性暴露出来。</p>
<p>CacheStorage中的每个缓存可以通过给caches.open()传入相应字符串键取得。非字符串键会转换为字符串。如果缓存不存在，就会创建。<br>Cache对象是通过期约返回的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>与Map类似，CacheStorage也有has()、delete()和keys()方法。这些方法与Map上对应方法类似，但都基于期约。</p>
<p>CacheStorage接口还有一个match()方法，可以根据Request对象搜索CacheStorage中的所有Cache对象。搜索顺序是CacheStorage.keys()的顺序，返回匹配的第一个响应：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个请求键和两个响应值 </span></span><br><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;v1&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> response2 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;v2&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用同一个键创建两个缓存对象，最终会先找到 v1 </span></span><br><span class="line"><span class="comment">// 因为它排在 caches.keys()输出的前面 </span></span><br><span class="line">caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">v1cache</span>) =&gt;</span> v1cache.<span class="title function_">put</span>(request, response1)) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> caches.<span class="title function_">open</span>(<span class="string">&#x27;v2&#x27;</span>)) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">v2cache</span>) =&gt;</span> v2cache.<span class="title function_">put</span>(request, response2)) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> caches.<span class="title function_">match</span>(request)) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>()) </span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// v1</span></span><br></pre></td></tr></table></figure>

<p>CacheStorage.match()可以接收一个options配置对象。</p>
<ol start="2">
<li>Cache对象</li>
</ol>
<p>CacheStorage通过字符串映射到Cache对象。Cache对象跟CacheStorage一样，类似于异步的Map。Cache键可以是URL字符串，也可以是Request对象。这些键会映射到Response对象。<br>服务工作者线程缓存只考虑缓存 HTTP 的 GET 请求。这样是合理的，因为 GET 请求的响应通常不会随时间而改变。另一方面，默认情况下，Cache不允许使用 POST、PUT 和 DELETE 等请求方法。这些方法意味着与服务器动态交换信息，因此不适合客户端缓存。 为填充Cache，可能使用以下三个方法。</p>
<ul>
<li><p>put(request, response)：在键（Request对象或 URL 字符串）和值（Response对象）同时存在时用于添加缓存项。该方法返回期约，在添加成功后会解决。</p>
</li>
<li><p>add(request)：在只有Request对象或 URL 时使用此方法发送fetch()请求，并缓存响应。该方法返回期约，期约在添加成功后会解决。</p>
</li>
<li><p>addAll(requests)：在希望填充全部缓存时使用，比如在服务工作者线程初始化时也初始化缓存。该方法接收 URL 或Request对象的数组。addAll()会对请求数组中的每一项分别调用add()。该方法返回期约，期约在所有缓存内容添加成功后会解决。</p>
</li>
</ul>
<p>与Map类似，Cache也有delete()和keys()方法。这些方法与Map上对应方法类似，但都基于期约。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.foo.com&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;fooResponse&#x27;</span>); </span><br><span class="line"></span><br><span class="line">caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123; </span><br><span class="line">  cache.<span class="title function_">put</span>(request1, response1) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">keys</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)  <span class="comment">// [Request] </span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">delete</span>(request1)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">keys</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// [] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>要检索Cache，可以使用下面的两个方法。</p>
<ul>
<li><p>matchAll(request, options)：返回期约，期约解决为匹配缓存中Response对象的数组。</p>
<ul>
<li><p>此方法对结构类似的缓存执行批量操作，比如删除所有缓存在/images 目录下的值。</p>
</li>
<li><p>可以通过options对象配置请求匹配方式。</p>
</li>
</ul>
</li>
<li><p>match(request, options)：返回期约，期约解决为匹配缓存中的Response对象；如果没命中缓存则返回undefined。</p>
<ul>
<li><p>本质上相当于matchAll(request, options)[0]。</p>
</li>
<li><p>可以通过options对象配置请求匹配方式。</p>
</li>
</ul>
</li>
</ul>
<p>缓存是否命中取决于 URL 字符串和/或Request对象 URL 是否匹配。URL 字符串和Request对象是可互换的，因为匹配时会提取Request对象的 URL。下面的例子演示了这种互换性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request1 = <span class="string">&#x27;https://www.foo.com&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> request2 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.bar.com&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;fooResponse&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> response2 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;barResponse&#x27;</span>); </span><br><span class="line"></span><br><span class="line">caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123; </span><br><span class="line">  cache.<span class="title function_">put</span>(request1, response1) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">put</span>(request2, response2)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.foo.com&#x27;</span>))) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)  <span class="comment">// fooResponse </span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">match</span>(<span class="string">&#x27;https://www.bar.com&#x27;</span>)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// barResponse </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Cache对象使用Request和Response对象的clone()方法创建副本，并把它们存储为键/值对。下面的例子演示了这一点，因为从缓存中取得的实例并不等于原始的键/值对：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.foo.com&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;fooResponse&#x27;</span>); </span><br><span class="line"></span><br><span class="line">caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123; </span><br><span class="line">  cache.<span class="title function_">put</span>(request1, response1) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">keys</span>()) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">keys</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(keys[<span class="number">0</span>] === request1))        <span class="comment">// false </span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">match</span>(request1)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response === response1)); <span class="comment">// false </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Cache.match()、Cache.matchAll()和CacheStorage.match()都支持可选的options对象，它允许通过设置以下属性来配置 URL 匹配的行为。</p>
<ul>
<li><p>cacheName：只有CacheStorage.matchAll()支持。设置为字符串时，只会匹配Cache键为指定字符串的缓存值。</p>
</li>
<li><p>ignoreSearch：设置为true时，在匹配 URL 时忽略查询字符串，包括请求查询和缓存键。例如，<a target="_blank" rel="noopener" href="https://example.com/?foo=bar">https://example.com?foo=bar</a> 会匹配 <a target="_blank" rel="noopener" href="https://example.com./">https://example.com。</a></p>
</li>
<li><p>ignoreMethod：设置为true时，在匹配 URL 时忽略请求查询的 HTTP 方法。比如下面的例子展示了 POST 请求匹配 GET 请求：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.foo.com&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;fooResponse&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postRequest1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.foo.com&#x27;</span>, </span><br><span class="line">                                 &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line">caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123; </span><br><span class="line">  cache.<span class="title function_">put</span>(request1, response1) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">match</span>(postRequest1)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)  <span class="comment">// undefined </span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">match</span>(postRequest1, &#123; <span class="attr">ignoreMethod</span>: <span class="literal">true</span> &#125;)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// Response &#123;&#125; </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>ignoreVary：匹配的时候考虑 HTTP 的Vary头部，该头部指定哪个请求头部导致服务器响应不同的值。ignoreVary设置为true时，在匹配 URL 时忽略Vary头部。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.foo.com&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;fooResponse&#x27;</span>, </span><br><span class="line">                               &#123; <span class="attr">headers</span>: &#123;<span class="string">&#x27;Vary&#x27;</span>: <span class="string">&#x27;Accept&#x27;</span> &#125;&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> acceptRequest1 = <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://www.foo.com&#x27;</span>, </span><br><span class="line">                                   &#123; <span class="attr">headers</span>: &#123; <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/json&#x27;</span> &#125; &#125;); </span><br><span class="line"></span><br><span class="line">caches.<span class="title function_">open</span>(<span class="string">&#x27;v1&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">cache</span>) =&gt;</span> &#123; </span><br><span class="line">  cache.<span class="title function_">put</span>(request1, response1) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">match</span>(acceptRequest1)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)  <span class="comment">// undefined </span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> cache.<span class="title function_">match</span>(acceptRequest1, &#123; <span class="attr">ignoreVary</span>: <span class="literal">true</span> &#125;)) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// Response &#123;&#125; </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最大存储空间</li>
</ol>
<p>浏览器需要限制缓存占用的磁盘空间，否则无限制存储势必会造成滥用。该存储空间的限制没有任何规范定义，完全由浏览器供应商的个人喜好决定。<br>使用 StorageEstimate API 可以近似地获悉有多少空间可用（以字节为单位），以及当前使用了多少空间。此方法只在安全上下文中可用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">storage</span>.<span class="title function_">estimate</span>() </span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同浏览器的输出可能不同： </span></span><br><span class="line"><span class="comment">// &#123; quota: 2147483648, usage: 590845 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="27-4-3-服务工作者线程客户端"><a href="#27-4-3-服务工作者线程客户端" class="headerlink" title="27.4.3 服务工作者线程客户端"></a>27.4.3 服务工作者线程客户端</h4><p>服务工作者线程会使用Client对象跟踪关联的窗口、工作线程或服务工作者线程。服务工作者线程可以通过Clients接口访问这些Client对象。该接口暴露在全局上下文的self.clients属性上。<br>Client对象支持以下属性和方法。</p>
<ul>
<li><p>id：返回客户端的全局唯一标识符，例如7e4248ec-b25e-4b33-b15f-4af8bb0a3ac4。id可用于通过Client.get()获取客户端的引用。</p>
</li>
<li><p>type：返回表示客户端类型的字符串。type可能的值是window、worker或sharedworker。</p>
</li>
<li><p>url：返回客户端的 URL。</p>
</li>
<li><p>postMessage()：用于向单个客户端发送消息。</p>
</li>
</ul>
<p>Clients接口支持通过get()或matchAll()访问Client对象。这两个方法都通过期约返回结果。matchAll()也可以接收options对象，该对象支持以下属性。</p>
<ul>
<li><p>includeUncontrolled：在设置为true时，返回结果包含不受当前服务工作者线程控制的客户端。默认为false。</p>
</li>
<li><p>type：可以设置为window、worker或sharedworker，对返回结果进行过滤。默认为all，返回所有类型的客户端。</p>
</li>
</ul>
<p>Clients接口也支持以下方法。</p>
<ul>
<li><p>openWindow(url)：在新窗口中打开指定 URL，实际上会给当前服务工作者线程添加一个新Client。这个新Client对象以解决的期约形式返回。该方法可用于回应点击通知的操作，此时服务工作者线程可以检测单击事件并作为响应打开一个窗口。</p>
</li>
<li><p>claim()：强制性设置当前服务工作者线程以控制其作用域中的所有客户端。claim()可用于不希望等待页面重新加载而让服务工作者线程开始管理页面。</p>
</li>
</ul>
<h4 id="27-4-4-服务工作者线程与一致性"><a href="#27-4-4-服务工作者线程与一致性" class="headerlink" title="27.4.4 服务工作者线程与一致性"></a>27.4.4 服务工作者线程与一致性</h4><p>理解服务工作者线程最终用途十分重要：让网页能够模拟原生应用程序。要像原生应用程序一样，服务工作者线程必须支持版本控制（versioning）。<br>从全局角度说，服务工作者线程的版本控制可以确保任何时候两个网页的操作都有一致性。该一致性可以表现为如下两种形式。</p>
<ul>
<li><p>代码一致性。网页不是像原生应用程序那样基于一个二进制文件创建，而是由很多 HTML、CSS、JavaScript、图片、JSON，以及页面可能加载的任何类型的文件创建。网页经常会递增更新，即版本升级，以增加或修改行为。如果网页总共加载了 100 个文件，而加载的资源同时来自第 1版和第 2 版，那么就会导致完全无法预测，而且很可能出错。服务工作者线程为此提供了一种强制机制，确保来自同源的所有并存页面始终会使用来自相同版本的资源。</p>
</li>
<li><p>数据一致性。网页并非与外界隔绝的应用程序。它们会通过各种浏览器 API 如LocalStorage或IndexedDB在本地读取并写入数据；也会向远程 API 发送请求并获取数据。这些获取和写入数据的格式在不同版本中可能也会变化。如果一个页面以第 1 版中的格式写入了数据，第二个页面以第 2 版中的格式读取该数据就会导致无法预测的结果甚至出错。服务工作者线程的资源一致性机制可以保证网页输入/输出行为对同源的所有并存网页都相同。</p>
</li>
</ul>
<p>为确保一致性，服务工作者线程的生命周期不遗余力地避免出现有损一致性的现象。比如下面这些可能。</p>
<ul>
<li><p>服务工作者线程提早失败。在安装服务工作者线程时，任何预料之外的问题都可能阻止服务工作者线程成功安装。包括服务脚本加载失败、服务脚本中存在语法或运行时错误、无法通过importScripts()加载工作者线程依赖，甚至加载某个缓存资源失败。</p>
</li>
<li><p>服务工作者线程激进更新。浏览器再次加载服务脚本时（无论通过register()手动加载还是基于页面重载），服务脚本或通过importScripts()加载的依赖中哪怕有一个字节的差异，也会启动安装新版本的服务工作者线程。</p>
</li>
<li><p>未激活服务工作者线程消极活动。当页面上第一次调用register()时，服务工作者线程会被安装，但不会被激活，并且在导航事件发生前不会控制页面。这应该是合理的：可以认为当前页面已加载了资源，因此服务工作者线程不应该被激活，否则就会加载不一致的资源。</p>
</li>
<li><p>活动的服务工作者线程粘连。只要至少有一个客户端与关联到活动的服务工作者线程，浏览器就会在该源的所有页面中使用它。浏览器可以安装新服务工作者线程实例以替代这个活动的实例，但浏览器在与活动实例关联的客户端为 0（或强制更新服务工作者线程）之前不会切换到新工作者线程。这个服务工作者线程逐出策略能够防止两个客户端同时运行两个不同版本的服务工作者线程。</p>
</li>
</ul>
<h4 id="27-4-5-理解服务工作者线程的生命周期"><a href="#27-4-5-理解服务工作者线程的生命周期" class="headerlink" title="27.4.5 理解服务工作者线程的生命周期"></a>27.4.5 理解服务工作者线程的生命周期</h4><p>Service Worker 规范定义了 6 种服务工作者线程可能存在的状态：已解析（parsed）、安装中（installing）、已安装（installed）、激活中（activating）、已激活（activated）和已失效（redundant）。完整的服务工作者线程生命周期会以该顺序进入相应状态，尽管有可能不会进入每个状态。安装或激活服务工作者线程时遇到错误会跳到已失效状态。<br>上述状态的每次变化都会在ServiceWorker对象上触发statechange事件，可以像下面这样为它添加一个事件处理程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  registration.<span class="property">installing</span>.<span class="property">onstatechange</span> = <span class="function">(<span class="params">&#123; target: &#123; state &#125; &#125;</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state changed to&#x27;</span>, state); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>已解析状态</li>
</ol>
<p>调用navigator.serviceWorker.register()会启动创建服务工作者线程实例的过程。刚创建的服务工作者线程实例会进入已解析状态。该状态没有事件，也没有与之相关的ServiceWorker.state值。</p>
<blockquote>
<p>虽然已解析（parsed）是 Service Worker 规范正式定义的一个状态，但ServiceWorker.prototype.state永远不会返回”parsed”。通过该属性能够返回的最早阶段是installing。</p>
</blockquote>
<p>浏览器获取脚本文件，然后执行一些初始化任务，服务工作者线程的生命周期就开始了。<br>(1) 确保服务脚本来自相同的源。<br>(2) 确保在安全上下文中注册服务工作者线程。<br>(3) 确保服务脚本可以被浏览器 JavaScript 解释器成功解析而不会抛出任何错误。<br>(4) 捕获服务脚本的快照。下一次浏览器下载到服务脚本，会与这个快照对比差异，并据此决定是否应该更新服务工作者线程。<br>所有这些任务全部成功，则register()返回的期约会解决为一个ServiceWorkerRegistration对象。新创建的服务工作者线程实例进入到安装中状态。</p>
<ol start="2">
<li>安装中状态</li>
</ol>
<p>安装中状态是执行所有服务工作者线程设置任务的状态。这些任务包括在服务工作者线程控制页面前必须完成的操作。<br>在客户端，这个阶段可以通过检查ServiceWorkerRegistration.installing是否被设置为ServiceWorker实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (registration.<span class="property">installing</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the installing state&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>关联的ServiceWorkerRegistration对象也会在服务工作者线程到达该状态时触发updatefound事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  registration.<span class="property">onupdatefound</span> = <span class="function">() =&gt;</span> </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the installing state&#x27;</span>); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在服务工作者线程中，这个阶段可以通过给install事件添加处理程序来确定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">oninstall</span> = <span class="function">(<span class="params">installEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the installing state&#x27;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>安装中状态频繁用于填充服务工作者线程的缓存。服务工作者线程在成功缓存指定资源之前可以一直处于该状态。如果任何资源缓存失败，服务工作者线程都会安装失败并跳至已失效状态。<br>服务工作者线程可以通过ExtendableEvent停留在安装中状态。InstallEvent继承自ExtendableEvent，因此暴露了一个 API，允许将状态过渡延迟到期约解决。为此要调用ExtendableEvent. waitUntil()方法，该方法接收一个期约参数，会将状态过渡延迟到这个期约解决。</p>
<p>通过Cache.addAll()缓存一组资源之后再过渡：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">CACHE_KEY</span> = <span class="string">&#x27;v1&#x27;</span>; </span><br><span class="line"></span><br><span class="line">self.<span class="property">oninstall</span> = <span class="function">(<span class="params">installEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  installEvent.<span class="title function_">waitUntil</span>( </span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="variable constant_">CACHE_KEY</span>) </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">cache</span>) =&gt;</span> cache.<span class="title function_">addAll</span>([ </span><br><span class="line">      <span class="string">&#x27;foo.js&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;bar.html&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;baz.css&#x27;</span>, </span><br><span class="line">    ])) </span><br><span class="line">  ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果没有错误发生或者没有拒绝，服务工作者线程就会前进到已安装状态。</p>
<ol start="3">
<li>已安装状态</li>
</ol>
<p>已安装状态也称为等待中（waiting）状态，意思是服务工作者线程此时没有别的事件要做，只是准备在得到许可的时候去控制客户端。如果没有活动的服务工作者线程，则新安装的服务工作者线程会跳到这个状态，并直接进入激活中状态，因为没有必要再等了。<br>在客户端，这个阶段可以通过检查ServiceWorkerRegistration.waiting是否被设置为一个ServiceWorker实例来确定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (registration.<span class="property">waiting</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the installing/waiting state&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果已有了一个活动的服务工作者线程，则已安装状态是触发逻辑的好时机，这样会把这个新服务工作者线程推进到激活中状态。可以通过self.skipWaiting()强制推进服务工作者线程的状态，也可以通过提示用户重新加载应用程序，从而使浏览器可以按部就班地推进。</p>
<ol start="4">
<li>激活中状态</li>
</ol>
<p>激活中状态表示服务工作者线程已经被浏览器选中即将变成可以控制页面的服务工作者线程。如果浏览器中没有活动服务工作者线程，这个新服务工作者线程会自动到达激活中状态。如果有一个活动服务工作者线程，则这个作为替代的服务工作者线程可以通过如下方式进入激活中状态。</p>
<ul>
<li><p>原有服务工作者线程控制的客户端数量变为 0。这通常意味着所有受控的浏览器标签页都被关闭。在下一个导航事件时，新服务工作者线程会到达激活中状态。</p>
</li>
<li><p>已安装的服务工作者线程调用self.skipWaiting()。这样可以立即生效，而不必等待一次导航事件。</p>
</li>
</ul>
<p>在激活中状态下，不能像已激活状态中那样执行发送请求或推送事件的操作。<br>在客户端，这个阶段大致可以通过检查ServiceWorkerRegistration.active是否被设置为一个ServiceWorker实例来确定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (registration.<span class="property">active</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the activating/activated state&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ServiceWorkerRegistration.active属性表示服务工作者线程可能在激活中状态，也可能在已激活状态。</p>
</blockquote>
<p>在这个服务工作者线程内部，可以通过给activate事件添加处理程序来获悉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">oninstall</span> = <span class="function">(<span class="params">activateEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the activating state&#x27;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>activate事件表示可以将老服务工作者线程清理掉了，该事件经常用于清除旧缓存数据和迁移数据库。</p>
<p>activate事件也继承自ExtendableEvent，因此也支持waitUntil()方法，可以延迟过渡到已激活状态，或者基于期约拒绝过渡到已失效状态。</p>
<blockquote>
<p>服务工作者线程中的activate事件并不代表服务工作者线程正在控制客户端。</p>
</blockquote>
<ol start="5">
<li>已激活状态</li>
</ol>
<p>已激活状态表示服务工作者线程正在控制一个或多个客户端。在这个状态，服务工作者线程会捕获其作用域中的fetch()事件、通知和推送事件。<br>在客户端，这个阶段大致可以通过检查ServiceWorkerRegistration.active是否被设置为一个ServiceWorker实例来确定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (registration.<span class="property">active</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the activating/activated state&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ServiceWorkerRegistration.active属性表示服务工作者线程可能在激活中状态，也可能在已激活状态。</p>
</blockquote>
<p>更可靠的确定服务工作者线程处于已激活状态一种方式是检查ServiceWorkerRegistration的controller属性。该属性会返回激活的ServiceWorker实例，即控制页面的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (registration.<span class="property">controller</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker is in the activated state&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在新服务工作者线程控制客户端时，该客户端中的ServiceWorkerContainer会触发controllerchange事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">oncontrollerchange</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A new service worker is controlling this client&#x27;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外，也可以使用ServiceWorkerContainer.ready期约来检测活动服务工作者线程。该期约会在当前页面拥有活动工作者线程时立即解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A new service worker is controlling this client&#x27;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>已失效状态</li>
</ol>
<p>已失效状态表示服务工作者线程已被宣布死亡。不会再有事件发送给它，浏览器随时可能销毁它并回收它的资源。</p>
<ol start="7">
<li>更新服务工作者线程</li>
</ol>
<p>因为版本控制的概念根植于服务工作者线程的整个生命周期，所以服务工作者线程会随着版本变化。为此，服务工作者线程提供了稳健同时也复杂的流程，以安装替换过时的服务工作者线程。<br>这个更新流程的初始阶段是更新检查，也就是浏览器重新请求服务脚本。以下事件可以触发更新检查。</p>
<ul>
<li><p>以创建当前活动服务工作者线程时不一样的URL调用navigator.serviceWorker.register()。</p>
</li>
<li><p>浏览器导航到服务工作者线程作用域中的一个页面。</p>
</li>
<li><p>发生了fetch()或push()等功能性事件，且至少 24 小时内没有发生更新检查。</p>
</li>
</ul>
<p>新获取的服务脚本会与当前服务工作者线程的脚本比较差异。如果不相同，浏览器就会用新脚本初始化一个新的服务工作者线程。更新的服务工作者线程进入自己的生命周期，直至抵达已安装状态。到达已安装状态后，更新服务工作者线程会等待浏览器决定让它安全地获得页面的控制权（或用户强制它获得页面控制权）。<br>关键在于，刷新页面不会让更新服务工作者线程进入激活状态并取代已有的服务工作者线程。比如，有个打开的页面，其中有一个服务工作者线程正在控制它，而一个更新服务工作者线程正在已安装状态中等待。客户端在页面刷新期间会发生重叠，即旧页面还没有卸载，新页面已加载了。因此，现有的服务工作者线程永远不会让出控制权，毕竟至少还有一个客户端在它的控制之下。为此，取代现有服务工作者线程唯一的方式就是关闭所有受控页面。</p>
<h4 id="27-4-6-控制反转与服务工作者线程持久化"><a href="#27-4-6-控制反转与服务工作者线程持久化" class="headerlink" title="27.4.6 控制反转与服务工作者线程持久化"></a>27.4.6 控制反转与服务工作者线程持久化</h4><p>用工作者线程和共享工作者线程是有状态的，但服务工作者线程是无状态的。更具体地说，服务工作者线程遵循控制反转（IoC，Inversion of Control）模式并且是事件驱动的。<br>这样就意味着服务工作者线程不应该依赖工作者线程的全局状态。服务工作者线程中的绝大多数代码应该在事件处理程序中定义。当然，服务工作者线程的版本作为全局常量是个显而易见的例外。服务脚本执行的次数变化很大，高度依赖浏览器状态，因此服务脚本的行为应该是幂等的。</p>
<h4 id="27-4-7-通过updateViaCache管理服务文件缓存"><a href="#27-4-7-通过updateViaCache管理服务文件缓存" class="headerlink" title="27.4.7 通过updateViaCache管理服务文件缓存"></a>27.4.7 通过updateViaCache管理服务文件缓存</h4><p>正常情况下，浏览器加载的所有 JavaScript 资源会按照它们的Cache-Control头部纳入 HTTP 缓存管理。因为服务脚本没有优先权，所以浏览器不会在缓存文件失效前接收更新的服务脚本。<br>为了尽可能传播更新后的服务脚本，常见的解决方案是在响应服务脚本时设置Cache-Control: max-age=0头部。这样浏览器就能始终取得最新的脚本文件。<br>这个即时失效的方案能够满足需求，但仅仅依靠 HTTP 头部来决定是否更新意味着只能由服务器控制客户端。为了让客户端能控制自己的更新行为，可以通过updateViaCache属性设置客户端对待服务脚本的方式。该属性可以在注册服务工作者线程时定义，可以是如下三个字符串值。</p>
<ul>
<li><p>imports：默认值。顶级服务脚本永远不会被缓存，但通过importScripts()在服务工作者线程内部导入的文件会按照Cache-Control头部设置纳入 HTTP 缓存管理。</p>
</li>
<li><p>all：服务脚本没有任何特殊待遇。所有文件都会按照Cache-Control头部设置纳入 HTTP 缓存管理。</p>
</li>
<li><p>none：顶级服务脚本和通过importScripts()在服务工作者线程内部导入的文件永远都不会被缓存。</p>
</li>
</ul>
<p>可以像下面这样使用updateViaCache属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/serviceWorker.js&#x27;</span>, &#123; </span><br><span class="line">  <span class="attr">updateViaCache</span>: <span class="string">&#x27;none&#x27;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>浏览器仍在渐进地支持这个选项，因此强烈推荐读者同时使用updateViaCache和CacheControl头部指定客户端的缓存行为。</p>
<h4 id="27-4-8-强制性服务工作者线程操作"><a href="#27-4-8-强制性服务工作者线程操作" class="headerlink" title="27.4.8 强制性服务工作者线程操作"></a>27.4.8 强制性服务工作者线程操作</h4><p>某些情况下，有必要尽可能快地让服务工作者线程进入已激活状态，即使可能会造成资源版本控制不一致。该操作通常适合在安装事件中缓存资源，此时要强制服务工作者线程进入活动状态，然后再强制活动服务工作者线程去控制关联的客户端。 实现上述操作的基本代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">CACHE_KEY</span> = <span class="string">&#x27;v1&#x27;</span>;  </span><br><span class="line"></span><br><span class="line">self.<span class="property">oninstall</span> = <span class="function">(<span class="params">installEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 填充缓存，然后强制服务工作者线程进入已激活状态 </span></span><br><span class="line">  <span class="comment">// 这样会触发 activate 事件 </span></span><br><span class="line">  installEvent.<span class="title function_">waitUntil</span>( </span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="variable constant_">CACHE_KEY</span>) </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">cache</span>) =&gt;</span> cache.<span class="title function_">addAll</span>([ </span><br><span class="line">      <span class="string">&#x27;foo.css&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;bar.js&#x27;</span>, </span><br><span class="line">    ])) </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> self.<span class="title function_">skipWaiting</span>()) </span><br><span class="line">  ); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制服务工作者线程接管客户端 </span></span><br><span class="line"><span class="comment">// 这会在每个客户端触发 controllerchange 事件 </span></span><br><span class="line">self.<span class="property">onactivate</span> = <span class="function">(<span class="params">activateEvent</span>) =&gt;</span> clients.<span class="title function_">claim</span>();</span><br></pre></td></tr></table></figure>

<p>浏览器会在每次导航事件中检查新服务脚本，但有时候这样也太不够了。ServiceWorkerRegistration对象为此提供了一个update()方法，可以用来告诉浏览器去重新获取服务脚本，与现有的比较，然后必要时安装更新的服务工作者线程。可以这样来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 每 17 分钟左右检查一个更新版本 </span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> registration.<span class="title function_">update</span>(), <span class="number">1E6</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="27-4-9-服务工作者线程消息"><a href="#27-4-9-服务工作者线程消息" class="headerlink" title="27.4.9 服务工作者线程消息"></a>27.4.9 服务工作者线程消息</h4><p>与专用工作者线程和共享工作者线程一样，服务工作者线程也能与客户端通过postMessage()交换消息。实现通信的最简单方式是向活动工作者线程发送一条消息，然后使用事件对象发送回应。发送给服务工作者线程的消息可以在全局作用域处理，而发送回客户端的消息则可以在ServiceWorkerContext对象上处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ServiceWorker</span>.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data, source&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;service worker heard:&#x27;</span>, data); </span><br><span class="line"></span><br><span class="line">  source.<span class="title function_">postMessage</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client heard:&#x27;</span>, data); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (registration.<span class="property">active</span>) &#123; </span><br><span class="line">    registration.<span class="property">active</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// service worker heard: foo </span></span><br><span class="line"><span class="comment">// client heard: bar</span></span><br></pre></td></tr></table></figure>

<p>也可以简单地使用serviceWorker.controller属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ServiceWorker</span>.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data, source&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;service worker heard:&#x27;</span>, data); </span><br><span class="line"></span><br><span class="line">  source.<span class="title function_">postMessage</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client heard:&#x27;</span>, data); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (navigator.<span class="property">serviceWorker</span>.<span class="property">controller</span>) &#123; </span><br><span class="line">    navigator.<span class="property">serviceWorker</span>.<span class="property">controller</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// service worker heard: foo  </span></span><br><span class="line"><span class="comment">// client heard: bar</span></span><br></pre></td></tr></table></figure>

<p>前面的例子在每次页面重新加载时都会运行。这是因为服务工作者线程会回应每次刷新后客户端脚本发送的消息。在通过新标签页打开这个页面时也一样。<br>如果服务工作者线程需要率先发送消息，可以像下面这样获得客户端的引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ServiceWorker</span>.<span class="property">js</span> </span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;service worker heard:&#x27;</span>, data); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">self.<span class="property">onactivate</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  self.<span class="property">clients</span>.<span class="title function_">matchAll</span>(&#123;<span class="attr">includeUncontrolled</span>: <span class="literal">true</span>&#125;) </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">clientMatches</span>) =&gt;</span> clientMatches[<span class="number">0</span>].<span class="title function_">postMessage</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line">&#125;; </span><br><span class="line">main.<span class="property">js</span> </span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data, source&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client heard:&#x27;</span>, data); </span><br><span class="line"></span><br><span class="line">  source.<span class="title function_">postMessage</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// client heard: foo </span></span><br><span class="line"><span class="comment">// service worker heard: bar</span></span><br></pre></td></tr></table></figure>

<p>前面的例子只会运行一次，因为活动事件在每个服务工作者线程上只会触发一次。<br>因为客户端和服务工作者线程可以相互之间发送消息，所以通过MessageChannel或BroadcastChannel实现通信也是可能的。</p>
<h4 id="27-4-10-拦截fetch事件"><a href="#27-4-10-拦截fetch事件" class="headerlink" title="27.4.10 拦截fetch事件"></a>27.4.10 拦截fetch事件</h4><p>服务工作者线程最重要的一个特性就是拦截网络请求。服务工作者线程作用域中的网络请求会注册为fetch事件。这种拦截能力不限于fetch()方法发送的请求，也能拦截对 JavaScript、CSS、图片和HTML（包括对主 HTML 文档本身）等资源发送的请求。这些请求可以来自 JavaScript，也可以通过&lt;**script**&gt;、&lt;**link**&gt;或img标签创建。直观地说，这样是合理的：如果想让服务工作者线程模拟离线<br>应用程序，它就必须能够把控页面正常运行所需的所有请求资源。<br>FetchEvent继承自ExtendableEvent。让服务工作者线程能够决定如何处理fetch事件的方法是event.respondWith()。该方法接收期约，该期约会解决为一个Response对象。当然，该Response对象实际上来自哪里完全由服务工作者线程决定。可以来自网络，来自缓存，或者动态创建。</p>
<ol>
<li>从网络返回</li>
</ol>
<p>这个策略就是简单地转发fetch事件。那些绝对需要发送到服务器的请求例如 POST 请求就适合该策略。可以像下面实现这一策略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onfetch</span> = <span class="function">(<span class="params">fetchEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  fetchEvent.<span class="title function_">respondWith</span>(<span class="title function_">fetch</span>(fetchEvent.<span class="property">request</span>)); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从缓存返回</li>
</ol>
<p>这个策略其实就是缓存检查。对于任何肯定有缓存的资源（如在安装阶段缓存的资源），可以采用该策略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onfetch</span> = <span class="function">(<span class="params">fetchEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  fetchEvent.<span class="title function_">respondWith</span>(caches.<span class="title function_">match</span>(fetchEvent.<span class="property">request</span>)); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从网络返回，缓存作后备</li>
</ol>
<p>这个策略把从网络获取最新的数据作为首选，但如果缓存中有值也会返回缓存的值。如果应用程序需要尽可能展示最新数据，但在离线的情况下仍要展示一些信息，就可以采用该策略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onfetch</span> = <span class="function">(<span class="params">fetchEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  fetchEvent.<span class="title function_">respondWith</span>( </span><br><span class="line">    <span class="title function_">fetch</span>(fetchEvent.<span class="property">request</span>) </span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> caches.<span class="title function_">match</span>(fetchEvent.<span class="property">request</span>)) </span><br><span class="line">  ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>从缓存返回，网络作后备</li>
</ol>
<p>这个策略优先考虑响应速度，但仍会在没有缓存的情况下发送网络请求。这是大多数渐进式 Web应用程序（PWA，Progressive Web Application）采取的首选策略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onfetch</span> = <span class="function">(<span class="params">fetchEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  fetchEvent.<span class="title function_">respondWith</span>( </span><br><span class="line">    caches.<span class="title function_">match</span>(fetchEvent.<span class="property">request</span>) </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response || <span class="title function_">fetch</span>(fetchEvent.<span class="property">request</span>)) </span><br><span class="line">  ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通用后备</li>
</ol>
<p>应用程序需要考虑缓存和网络都不可用的情况。服务工作者线程可以在安装时缓存后备资源，然后在缓存和网络都失败时返回它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onfetch</span> = <span class="function">(<span class="params">fetchEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  fetchEvent.<span class="title function_">respondWith</span>( </span><br><span class="line">    <span class="comment">// 开始执行“从缓存返回，以网络为后备”策略 </span></span><br><span class="line">    caches.<span class="title function_">match</span>(fetchEvent.<span class="property">request</span>) </span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response || <span class="title function_">fetch</span>(fetchEvent.<span class="property">request</span>)) </span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> caches.<span class="title function_">match</span>(<span class="string">&#x27;/fallback.html&#x27;</span>)) </span><br><span class="line">  ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="27-4-11-推送通知"><a href="#27-4-11-推送通知" class="headerlink" title="27.4.11 推送通知"></a>27.4.11 推送通知</h4><p>对于模拟原生应用程序的 Web 应用程序而言，必须支持推送消息。这意味着网页必须能够接收服务器的推送事件，然后在设备上显示通知（即使应用程序没有运行）。当然，这在常规网页中肯定是不可能的。不过，有了服务工作者线程就可以实现该行为。<br>为了在 PWA 应用程序中支持推送通知，必须支持以下 4 种行为。</p>
<ul>
<li><p>服务工作者线程必须能够显示通知。</p>
</li>
<li><p>服务工作者线程必须能够处理与这些通知的交互。</p>
</li>
<li><p>服务工作者线程必须能够订阅服务器发送的推送通知。</p>
</li>
<li><p>服务工作者线程必须能够处理推送消息，即使应用程序没在前台运行或者根本没打开。</p>
</li>
</ul>
<ol>
<li>显示通知</li>
</ol>
<p>服务工作者线程可以通过它们的注册对象使用 Notification API。这样做有很好的理由：与服务工作者线程关联的通知也会触发服务工作者线程内部的交互事件。<br>显示通知要求向用户明确地请求授权。授权完成后，可以通过ServiceWorkerRegistration. showNotification()显示通知。下面是示例实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>() </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">status</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">&#x27;granted&#x27;</span>) &#123; </span><br><span class="line">      registration.<span class="title function_">showNotification</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在服务工作者线程内部可以使用全局registration属性触发通知：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onactivate</span> = <span class="function">() =&gt;</span> self.<span class="property">registration</span>.<span class="title function_">showNotification</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，获得显示通知的授权后，会把foo通知显示在浏览器中。该通知与使用new Notification()创建的通知看不出有任何差别。此外，显示该通知不需要服务工作者线程额外做任何事情。服务工作者线程只在需要处理通知事件时才会发挥作用。</p>
<ol start="2">
<li>处理通知事件</li>
</ol>
<p>通过ServiceWorkerRegistration对象创建的通知会向服务工作者线程发送notificationclick和notificationclose事件。假设前面例子中的服务脚本定义了如下事件处理程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onnotificationclick</span> = <span class="function">(<span class="params">&#123;notification&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;notification click&#x27;</span>, notification); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">self.<span class="property">onnotificationclose</span> = <span class="function">(<span class="params">&#123;notification&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">onsole.<span class="title function_">log</span>(<span class="string">&#x27;notification close&#x27;</span>, notification); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，与通知的两种交互操作都在服务工作者线程中注册了处理程序。这里的notification事件对象暴露了notification属性，其中包含着生成该事件Notification对象。这些处理程序可以决定交互操作之后的响应方式。<br>一般来说，单击通知意味着用户希望转到某个具体的页面。在服务工作者线程处理程序中，可以通过clients.openWindow()打开相应的 URL，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onnotificationclick</span> = <span class="function">(<span class="params">&#123;notification&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  clients.<span class="title function_">openWindow</span>(<span class="string">&#x27;https://foo.com&#x27;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>订阅推送事件</li>
</ol>
<p>对于发送给服务工作者线程的推送消息，必须通过服务工作者线程的PushManager来订阅。这样服务工作者线程就可以在push事件处理程序中处理推送消息。<br>下面展示了使用ServiceWorkerRegistration.pushManager订阅推送消息的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  registration.<span class="property">pushManager</span>.<span class="title function_">subscribe</span>(&#123; </span><br><span class="line">    <span class="attr">applicationServerKey</span>: key, <span class="comment">// 来自服务器的公钥 </span></span><br><span class="line">    <span class="attr">userVisibleOnly</span>: <span class="literal">true</span> </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，服务工作者线程也可以使用全局的registration属性自己订阅：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onactivate</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  self.<span class="property">registration</span>.<span class="property">pushManager</span>.<span class="title function_">subscribe</span>(&#123; </span><br><span class="line">    <span class="attr">applicationServerKey</span>: key, <span class="comment">// 来自服务器的公钥 </span></span><br><span class="line">    <span class="attr">userVisibleOnly</span>: <span class="literal">true</span> </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>处理推送事件</li>
</ol>
<p>订阅之后，服务工作者线程会在每次服务器推送消息时收到push事件。这时候它可以这样来处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="property">onpush</span> = <span class="function">(<span class="params">pushEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker was pushed data:&#x27;</span>, pushEvent.<span class="property">data</span>.<span class="title function_">text</span>()); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为实现真正的推送通知，这个处理程序只需要通过注册对象创建一个通知即可。不过，完善的推送通知需要创建它的服务工作者线程保持活动足够长时间，以便处理后续的交互事件。<br>要实现这一点，push事件继承了ExtendableEvent。可以把showNotification()返回的期约传给waitUntil()，这样就会让服务工作者线程一直活动到通知的期约解决。<br>下面展示了实现上述逻辑的简单框架：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./serviceWorker.js&#x27;</span>) </span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 请求显示通知的授权 </span></span><br><span class="line">  <span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>() </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">status</span>) =&gt;</span> &#123; </span><br><span class="line"><span class="keyword">if</span> (status === <span class="string">&#x27;granted&#x27;</span>) &#123; </span><br><span class="line">      <span class="comment">// 如果获得授权，只订阅推送消息 </span></span><br><span class="line">      registration.<span class="property">pushManager</span>.<span class="title function_">subscribe</span>(&#123; </span><br><span class="line">        <span class="attr">applicationServerKey</span>: key, <span class="comment">// 来自服务器的公钥 </span></span><br><span class="line">        <span class="attr">userVisibleOnly</span>: <span class="literal">true</span> </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="title class_">ServiceWorker</span>.<span class="property">js</span> </span><br><span class="line"><span class="comment">// 收到推送事件后，在通知中以文本形式显示数据 </span></span><br><span class="line">self.<span class="property">onpush</span> = <span class="function">(<span class="params">pushEvent</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 保持服务工作者线程活动到通知期约解决 </span></span><br><span class="line">  pushEvent.<span class="title function_">waitUntil</span>( </span><br><span class="line">    self.<span class="property">registration</span>.<span class="title function_">showNotification</span>(pushEvent.<span class="property">data</span>.<span class="title function_">text</span>()) </span><br><span class="line">  ); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用户单击通知，则打开相应的应用程序页面 </span></span><br><span class="line">self.<span class="property">onnotificationclick</span> = <span class="function">(<span class="params">&#123;notification&#125;</span>) =&gt;</span> &#123; </span><br><span class="line">  clients.<span class="title function_">openWindow</span>(<span class="string">&#x27;https://example.com/clicked-notification&#x27;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="27-5-小结"><a href="#27-5-小结" class="headerlink" title="27.5 小结"></a>27.5 小结</h3><p>工作者线程可以运行异步 JavaScript 而不阻塞用户界面。这非常适合复杂计算和数据处理，特别是需要花较长时间因而会影响用户使用网页的处理任务。工作者线程有自己独立的环境，只能通过异步消息与外界通信。<br>工作者线程可以是专用线程、共享线程。专用线程只能由一个页面使用，而共享线程则可以由同源的任意页面共享。<br>服务工作者线程用于让网页模拟原生应用程序。服务工作者线程也是一种工作者线程，但它们更像是网络代理，而非独立的浏览器线程。可以把它们看成是高度定制化的网络缓存，它们也可以在 PWA中支持推送通知。</p>
<h2 id="二十八、最佳实践"><a href="#二十八、最佳实践" class="headerlink" title="二十八、最佳实践"></a>二十八、最佳实践</h2><h3 id="28-1-可维护性"><a href="#28-1-可维护性" class="headerlink" title="28.1 可维护性"></a>28.1 可维护性</h3><h4 id="28-1-1-什么是可维护的代码"><a href="#28-1-1-什么是可维护的代码" class="headerlink" title="28.1.1 什么是可维护的代码"></a>28.1.1 什么是可维护的代码</h4><p>“可维护”就意味着它具备如下特点：</p>
<ul>
<li><p>容易理解：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它是怎么实现的。</p>
</li>
<li><p>符合常识：代码中的一切都显得顺理成章，无论操作有多么复杂。</p>
</li>
<li><p>容易适配：即使数据发生变化也不用完全重写。</p>
</li>
<li><p>容易扩展：代码架构经过认真设计，支持未来扩展核心功能。</p>
</li>
<li><p>容易调试：出问题时，代码可以给出明确的信息，通过它能直接定位问题。</p>
</li>
</ul>
<h4 id="28-1-2-编码规范"><a href="#28-1-2-编码规范" class="headerlink" title="28.1.2 编码规范"></a>28.1.2 编码规范</h4><p>编写可维护代码的第一步是认真考虑编码规范。</p>
<ol>
<li>可读性</li>
</ol>
<p>要想让代码容易维护，首先必须使其可读。可读性必须考虑代码是一种文本文件。为此，代码缩进是保证可读性的重要基础。</p>
<p>可读性的另一方面是代码注释。</p>
<p>一般来说，以下这些地方应该写注释。</p>
<ul>
<li><p>函数和方法。每个函数和方法都应该有注释来描述其用途，以及完成任务所用的算法。同时，也写清使用这个函数或方法的前提（假设）、每个参数的含义，以及函数是否返回值（因为通过函数定义看不出来）。</p>
</li>
<li><p>大型代码块。多行代码但用于完成单一任务的，应该在前面给出注释，把要完成的任务写清楚。</p>
</li>
<li><p>复杂的算法。如果使用了独特的方法解决问题，要通过注释解释明白。这样不仅可以帮助别人查看代码，也可以帮助自己今后查看代码。</p>
</li>
<li><p>使用黑科技。由于浏览器之间的差异，JavaScript 代码中通常包含一些黑科技。不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用途写出来。这样可以避免别人误以为黑科技没有用而把它“修复”掉，结果你已解决的问题又会出现。</p>
</li>
</ul>
<ol start="2">
<li>变量和函数命名</li>
</ol>
<p>代码中变量和函数的适当命名对于其可读性和可维护性至关重要。</p>
<p>以下是关于命名的通用规则。</p>
<ul>
<li><p>变量名应该是名词，例如car或person。</p>
</li>
<li><p>函数名应该以动词开始，例如getName()。返回布尔值的函数通常以is开头，比如isEnabled()。</p>
</li>
<li><p>对变量和函数都使用符合逻辑的名称，不用担心长度。长名字的问题可以通过后处理和压缩解决。</p>
</li>
<li><p>变量、函数和方法应该以小写字母开头，使用驼峰大小写（camelCase）形式，如getName()和isPerson。类名应该首字母大写，如Person、RequestFactory。常量值应该全部大写并以下划线相接，比如REQUEST_TIMEOUT。</p>
</li>
<li><p>名称要尽量用描述性和直观的词汇，但不要过于冗长。getName()一看就知道会返回名称，而PersonFactory一看就知道会产生某个Person对象或实体。</p>
</li>
</ul>
<ol start="3">
<li>变量类型透明化</li>
</ol>
<p>有三种方式可以标明变量的数据类型。<br>第一种标明变量类型的方式是通过初始化。定义变量时，应该立即将其初始化为一个将来要使用的类型值。</p>
<p>初始化为特定数据类型的值可以明确表示变量的类型。</p>
<p>第二种标明变量类型的方式是使用匈牙利表示法。匈牙利表示法指的是在变量名前面前缀一个或多个字符表示数据类型。对于基本数据类型，JavaScript 传统的匈牙利表示法用o表示对象，s表示字符串，i表示整数，f表示浮点数，b表示布尔值。</p>
<p>匈牙利表示法也可以很好地应用于函数参数。它的缺点是使代码可读性下降、不够直观，并破坏了类似句子的自然阅读流畅性。</p>
<p>最后一种标明变量类型的方式是使用类型注释。类型注释放在变量名后面、初始化表达式的前面。基本思路是在变量旁边使用注释说明类型，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用类型注释表明数据类型 </span></span><br><span class="line"><span class="keyword">let</span> found  <span class="comment">/*:Boolean*/</span> = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> count  <span class="comment">/*:int*/</span>     = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">let</span> name   <span class="comment">/*:String*/</span>  = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> person <span class="comment">/*:Object*/</span>  = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>类型注释在保持代码整体可读性的同时向其注释了类型信息。类型注释的缺点是不能再使用多行注释把大型代码块注释掉了。因为类型注释也是多行注释，所以会造成干扰。</p>
<h4 id="28-1-3-松散耦合"><a href="#28-1-3-松散耦合" class="headerlink" title="28.1.3 松散耦合"></a>28.1.3 松散耦合</h4><p>考虑到相关的技术，Web 应用程序在某些情况下可能变得过于紧密耦合。关键在于有这个意识，随时注意不要让代码产生紧密耦合。</p>
<ol>
<li>解耦 HTML/JavaScript</li>
</ol>
<p>Web 开发中最常见的耦合是 HTML/JavaScript 耦合。在网页中，HTML 和 JavaScript 分别代表不同层面的解决方案。HTML 是数据，JavaScript 是行为。这是因为它们之间要交互操作，需要通过不同的方式将这两种技术联系起来。</p>
<p>把 JavaScript 直接嵌入在 HTML 中，要么使用包含嵌入代码的&lt;**script**&gt;元素，要么使用 HTML 属性添加事件处理程序，这些都会造成紧密耦合。</p>
<p>理想情况下，HTML 和 JavaScript 应该完全分开，通过外部文件引入 JavaScript，然后使用DOM 添加行为。</p>
<p>在相反的情况下，HTML 和 JavaScript 也会变得紧密耦合：把 HTML 包含在 JavaScript 中。这种情况通常发生在把一段 HTML 通过innerHTML插入到页面中时，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 紧密耦合到了 JavaScript </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertMessage</span>(<span class="params">msg</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>); </span><br><span class="line">  container.<span class="property">innerHTML</span> = <span class="string">`&lt;div class=&quot;msg&quot;&gt; </span></span><br><span class="line"><span class="string">    &lt;p&gt; class=&quot;post&quot;&gt;<span class="subst">$&#123;msg&#125;</span>&lt;/p&gt; </span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;em&gt;Latest message above.&lt;/em&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，应该避免在 JavaScript 中创建大量 HTML。同样，这主要是为了做到数据层和行为层各司其职，在出错时更容易定位问题所在。</p>
<p>HTML 渲染应该尽可能与 JavaScript 分开。在使用 JavaScript 插入数据时，应该尽可能不要插入标记。相应的标记可以包含并隐藏在页面中，在需要的时候 JavaScript 可以直接用它来显示，而不需要动态生成。另一个办法是通过 Ajax 请求获取要显示的 HTML，这样也可以保证同一个渲染层（PHP、JSP、Ruby 等）负责输出标记，而不是把标记嵌在 JavaScript 中。<br>解耦 HTML 和 JavaScript 可以节省排错时间，因为更容易定位错误来源。同样解耦也有助于保证可维护性。修改行为只涉及 JavaScript，修改标记只涉及要渲染的文件。</p>
<ol start="2">
<li>解耦 CSS/JavaScript</li>
</ol>
<p>与 HTML 和 JavaScript 的情况类似，CSS 也可能与 JavaScript 产生紧密耦<br>合。最常见的例子就是使用 JavaScript 修改个别样式，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSS 紧耦合到了 JavaScript </span></span><br><span class="line">element.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line">element.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;blue&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>现代 Web 应用程序经常使用 JavaScript 改变样式，因此虽然不太可能完全解耦 CSS 和 JavaScript，但可以让这种耦合变成更松散。这主要可以通过动态修改类名而不是样式来实现，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSS 与 JavaScript 松散耦合 </span></span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;edit&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>通过修改元素的 CSS 类名，可以把大部分样式限制在 CSS 文件里。JavaScript 只负责修改应用样式的类名，而不直接影响元素的样式。只要应用的类名没错，那么显示的问题就只跟 CSS 有关，而跟JavaScript 无关。<br>同样，保证层与层之间的适当分离至关重要。显示出问题就应该只到 CSS 中解决，行为出问题就应该只找 JavaScript 的问题。这些层之间的松散耦合可以提升整个应用程序的可维护性。</p>
<ol start="3">
<li>解耦应用程序逻辑/事件处理程序</li>
</ol>
<p>每个 Web 应用程序中都会有大量事件处理程序在监听各种事件。可是，其中很少能真正做到应用程序逻辑与事件处理程序分离。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleKeyPress</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">keyCode</span> == <span class="number">13</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> target = event.<span class="property">target</span>; </span><br><span class="line">    <span class="keyword">let</span> value = <span class="number">5</span> * <span class="built_in">parseInt</span>(target.<span class="property">value</span>); </span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">10</span>) &#123; </span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;error-msg&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导致代码重复，或者把它提取到单独的函数中。无论情况如何，都会导致原本不必要的多余工作。 更好的做法是将应用程序逻辑与事件处理程序分开，各自负责处理各自的事情。事件处理程序应该专注于event对象的相关信息，然后把这些信息传给处理应用程序逻辑的某些方法。例如，前面的例子可以重写为如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">validateValue</span>(<span class="params">value</span>) &#123; </span><br><span class="line">  value = <span class="number">5</span> * <span class="built_in">parseInt</span>(value); </span><br><span class="line">  <span class="keyword">if</span> (value &gt; <span class="number">10</span>) &#123; </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;error-msg&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleKeyPress</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">keyCode</span> == <span class="number">13</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> target = event.<span class="property">target</span>; </span><br><span class="line">    <span class="title function_">validateValue</span>(target.<span class="property">value</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把应用程序逻辑从事件处理程序中分离出来有很多好处。首先，这可以让我们以最少的工作量轻松地修改触发某些流程的事件。如果原来是通过鼠标单击触发流程，而现在又想增加键盘操作来触发，那么修改起来也很简单。其次，可以在不用添加事件的情况下测试代码，这样创建单元测试或自动化应用程序流都会更简单。<br>以下是在解耦应用程序逻辑和业务逻辑时应该注意的几点。</p>
<ul>
<li><p>不要把event对象传给其他方法，而是只传递event对象中必要的数据。</p>
</li>
<li><p>应用程序中每个可能的操作都应该无须事件处理程序就可以执行。</p>
</li>
<li><p>事件处理程序应该处理事件，而把后续处理交给应用程序逻辑。</p>
</li>
</ul>
<h4 id="28-1-4-编码惯例"><a href="#28-1-4-编码惯例" class="headerlink" title="28.1.4 编码惯例"></a>28.1.4 编码惯例</h4><ol>
<li>尊重对象所有权</li>
</ol>
<p>JavaScript 的动态特性意味着几乎可以在任何时候修改任何东西。</p>
<p>对象默认还是可以修改的。</p>
<p>在企业开发中，非常重要的编码惯例就是尊重对象所有权，这意味着不要修改不属于你的对象。简单来讲，如果你不负责创建和维护某个对象及其构造函数或方法，就不应该对其进行任何修改。更具体一点说，就是如下惯例。</p>
<ul>
<li><p>不要给实例或原型添加属性。</p>
</li>
<li><p>不要给实例或原型添加方法。</p>
</li>
<li><p>不要重定义已有的方法。</p>
</li>
</ul>
<p>只有你自己创建的才是你的对象，包括自定义类型和对象字面量。</p>
<p>可以按如下这样为对象添加新功能。</p>
<ul>
<li><p>创建包含想要功能的新对象，通过它与别人的对象交互。</p>
</li>
<li><p>创建新自定义类型继承本来想要修改的类型，可以给自定义类型添加新功能。</p>
</li>
</ul>
<ol start="2">
<li>不声明全局变量</li>
</ol>
<p>与尊重对象所有权密切相关的是尽可能不声明全局变量和函数。同样，这也关系到创建一致和可维护的脚本运行环境。最多可以创建一个全局变量，作为其他对象和函数的命名空间。</p>
<p>这样一个全局对象可以扩展为命名空间的概念。命名空间涉及创建一个对象，然后通过这个对象来暴露能力。</p>
<p>虽然命名空间需要多写一点代码，但从可维护性角度看，这个代价还是非常值得的。命名空间可以确保代码与页面上的其他代码互不干扰。</p>
<ol start="3">
<li>不要比较null</li>
</ol>
<p>JavaScript 不会自动做任何类型检查，因此就需要开发者担起这个责任。</p>
<p>现实当中，单纯比较null通常是不够的。检查值的类型就要真的检查类型，而不是检查它不能是什么。</p>
<p>如果看到比较null的代码，可以使用下列某种技术替换它。</p>
<ul>
<li><p>如果值应该是引用类型，则使用instanceof操作符检查其构造函数。</p>
</li>
<li><p>如果值应该是原始类型，则使用typeof检查其类型。</p>
</li>
<li><p>如果希望值是有特定方法名的对象，则使用typeof操作符确保对象上存在给定名字的方法。</p>
</li>
</ul>
<ol start="4">
<li>使用常量</li>
</ol>
<p>依赖常量的目标是从应用程序逻辑中分离数据，以便修改数据时不会引发错误。显示在用户界面上的字符串就应该以这种方式提取出来，可以方便实现国际化。URL 也应该这样提取出来，因为随着应用程序越来越复杂，URL 极有可能变化。基本上，像这种地方将来因为某种原因而需要修改时，可能就要找到某个函数并修改其中的代码。每次像这样修改应用程序逻辑，都可能引入新错误。为此，可以把这些可能会修改的数据提取出来，放在单独定义的常量中，以实现数据与逻辑分离。<br>关键在于把数据从使用它们的逻辑中分离出来。可以使用以下标准检查哪些数据需要提取。</p>
<ul>
<li><p>重复出现的值：任何使用超过一次的值都应该提取到常量中，这样可以消除一个值改了而另一个值没改造成的错误。这里也包括 CSS 的类名。</p>
</li>
<li><p>用户界面字符串：任何会显示给用户的字符串都应该提取出来，以方便实现国际化。</p>
</li>
<li><p>URL：Web 应用程序中资源的地址经常会发生变化，因此建议把所有 URL 集中放在一个地方管理。</p>
</li>
<li><p>任何可能变化的值：任何时候，只要在代码中使用字面值，就问问自己这个值将来是否可能会变。如果答案是“是”，那么就应该把它提取到常量中。</p>
</li>
</ul>
<h3 id="28-2-性能"><a href="#28-2-性能" class="headerlink" title="28.2 性能"></a>28.2 性能</h3><h4 id="28-2-1-作用域意识"><a href="#28-2-1-作用域意识" class="headerlink" title="28.2.1 作用域意识"></a>28.2.1 作用域意识</h4><p>随着作用域链中作用域数量的增加，访问当前作用域外部变量所需的时间也会增加。访问全局变量始终比访问局部变量慢，因为必须遍历作用域链。任何可以缩短遍历作用域链时间的举措都能提升代码性能。</p>
<ol>
<li>避免全局查找</li>
</ol>
<p>改进代码性能非常重要的一件事，可能就是要提防全局查询。全局变量和函数相比于局部值始终是最费时间的，因为需要经历作用域链查找。来看下面的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateUI</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> imgs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = imgs.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line">    imgs[i].<span class="property">title</span> = <span class="string">&#x27;$&#123;document.title&#125; image $&#123;i&#125;&#x27;</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> msg = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;msg&quot;</span>); </span><br><span class="line">  msg.<span class="property">innerHTML</span> = <span class="string">&quot;Update complete.&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在局部作用域中保存document对象的引用，能够明显提升这个函数的性能，因为只需要作用域链查找。通过创建一个指向document对象的局部变量，可以通过将全局查找的数量限制为一个来提高这个函数的性能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateUI</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> doc = <span class="variable language_">document</span>; </span><br><span class="line">  <span class="keyword">let</span> imgs = doc.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = imgs.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line">    imgs[i].<span class="property">title</span> = <span class="string">&#x27;$&#123;doc.title&#125; image $&#123;i&#125;&#x27;</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> msg = doc.<span class="title function_">getElementById</span>(<span class="string">&quot;msg&quot;</span>); </span><br><span class="line">  msg.<span class="property">innerHTML</span> = <span class="string">&quot;Update complete.&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个经验规则就是，只要函数中有引用超过两次的全局对象，就应该把这个对象保存为一个局部变量。</p>
<ol start="2">
<li>不使用with语句</li>
</ol>
<p>在性能很重要的代码中，应避免使用with语句。与函数类似，with语句会创建自己的作用域，因此也会加长其中代码的作用域链。在with语句中执行的代码一定比在它外部执行的代码慢，因为作用域链查找时多一步。</p>
<h4 id="28-2-2-选择正确的方法"><a href="#28-2-2-选择正确的方法" class="headerlink" title="28.2.2 选择正确的方法"></a>28.2.2 选择正确的方法</h4><ol>
<li>避免不必要的属性查找</li>
</ol>
<p>最简单同时也最快的算法可以表示为常量值或 O(1)。然后，稍微复杂一些的算法同时执行时间也更长一些。</p>
<p>常量值或 O(1)，指字面量和保存在变量中的值，表示读取常量值所需的时间不会因值的多少而变化。读取常量值是效率极高的操作，因此非常快。</p>
<p>使用变量和数组相比访问对象属性效率更高，访问对象属性的算法复杂度是 O(n)。访问对象的每个属性都比访问变量或数组花费的时间长，因为查找属性名要搜索原型链。简单来说，查找的属性越多，执行时间就越长。</p>
<p>特别要注意避免通过多次查找获取一个值。</p>
<p>通常，只要能够降低算法复杂度，就应该尽量通过在局部变量中保存值来替代属性查找。另外，如果实现某个需求既可以使用数组的数值索引，又可以使用命名属性（比如NodeList对象），那就都应该使用数值索引。</p>
<ol start="2">
<li>优化循环</li>
</ol>
<p>循环是编程中常用的语法构造，因此在 JavaScript 中也十分常见。</p>
<p>优化循环的基本步骤如下。<br>(1) 简化终止条件。因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要避免属性查找或其他 O(n)操作。<br>(2) 简化循环体。循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外部的密集计算。<br>(3) 使用后测试循环。最常见的循环就是for和while循环，这两种循环都属于先测试循环。do-while就是后测试循环，避免了对终止条件初始评估 ，因此应该会更快。</p>
<p>使用后测试循环时要注意，一定是至少有一个值需要处理一次。如果这里的数组是空的，那么会浪费一次循环，而先测试循环就可以避免这种情况。</p>
<ol start="3">
<li>展开循环</li>
</ol>
<p>如果循环的次数是有限的，那么通常抛弃循环而直接多次调用函数会更快。</p>
<p>如果不能提前预知循环的次数，那么或许可以使用一种叫作达夫设备（Duff’s Device）的技术。该技术是以其发明者 Tom Duff 命名的，他最早建议在 C 语言中使用该技术。在 JavaScript 实现达夫设备的人是 Jeff Greenberg。达夫设备的基本思路是以 8 的倍数作为迭代次数从而将循环展开为一系列语句。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：Jeff Greenberg 在 JavaScript 中实现的达夫设备 </span></span><br><span class="line"><span class="comment">// 假设 values.length &gt; 0 </span></span><br><span class="line"><span class="keyword">let</span> iterations = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(values.<span class="property">length</span> / <span class="number">8</span>); </span><br><span class="line"><span class="keyword">let</span> startAt = values.<span class="property">length</span> % <span class="number">8</span>; </span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">  <span class="keyword">switch</span>(startAt) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  &#125; </span><br><span class="line">  startAt = <span class="number">0</span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (--iterations &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Andrew B. King 在 Speed Up Your Site 一书中提出了更快的达夫设备实现，他将do-while循环分成了两个单独的循环，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来源：Speed Up Your Site（New Riders，2003） </span></span><br><span class="line"><span class="keyword">let</span> iterations = <span class="title class_">Math</span>.<span class="title function_">floor</span>(values.<span class="property">length</span> / <span class="number">8</span>); </span><br><span class="line"><span class="keyword">let</span> leftover = values.<span class="property">length</span> % <span class="number">8</span>; </span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123; </span><br><span class="line">  <span class="keyword">do</span> &#123; </span><br><span class="line">    <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  &#125; <span class="keyword">while</span> (--leftover &gt; <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">  <span class="title function_">process</span>(values[i++]); </span><br><span class="line">&#125; <span class="keyword">while</span> (--iterations &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>展开循环对于大型数据集可以节省很多时间，但对于小型数据集来说，则可能不值得。因为实现同样的任务需要多写很多代码，所以如果处理的数据量不大，那么显然没有必要。</p>
<ol start="4">
<li>避免重复解释</li>
</ol>
<p>重复解释的问题存在于 JavaScript 代码尝试解释 JavaScript 代码的情形。在使用eval()函数或Function构造函数，或者给setTimeout()传入字符串参数时会出现这种情况。下面是几个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对代码求值：不要 </span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;Hello world!&#x27;)&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新函数：不要 </span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;console.log(&#x27;Hello world!&#x27;)&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置超时函数：不要 </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;console.log(&#x27;Hello world!&#x27;)&quot;</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>这些情况都有对应的解决方案。很少有情况绝对需要使用eval()，因此应该尽可能不使用它。此时，只要把代码直接写出来就好了。对于Function构造函数，重写为常规函数也很容易。而调用setTimeout()时则可以直接把函数作为第一个参数。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接写出来 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world!&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新函数：直接写出来 </span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world!&#x27;</span>); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置超时函数：直接写出来 </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world!&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>为了提升代码性能，应该尽量避免使用要当作 JavaScript 代码解释的字符串。</p>
<ol start="5">
<li>其他性能优化注意事项</li>
</ol>
<p>在评估代码性能时还有一些地方需要注意。</p>
<ul>
<li><p>原生方法很快。应该尽可能使用原生方法，而不是使用 JavaScript 写的方法。原生方法是使用 C或 C++等编译型语言写的，因此比 JavaScript 写的方法要快得多。JavaScript 中经常被忽视的是Math对象上那些执行复杂数学运算的方法。这些方法总是比执行相同任务的 JavaScript 函数快得多，比如求正弦、余弦等。</p>
</li>
<li><p>switch语句很快。如果代码中有复杂的if-else语句，将其转换成switch语句可以变得更快。然后，通过重新组织分支，把最可能的放前面，不太可能的放后面，可以进一步提升性能。</p>
</li>
<li><p>位操作很快。在执行数学运算操作时，位操作一定比任何布尔值或数值计算更快。选择性地将某些数学操作替换成位操作，可以极大提升复杂计算的效率。像求模、逻辑 AND 与和逻辑 OR或都很适合替代成位操作。</p>
</li>
</ul>
<h4 id="28-2-3-语句最少化"><a href="#28-2-3-语句最少化" class="headerlink" title="28.2.3 语句最少化"></a>28.2.3 语句最少化</h4><p>JavaScript 代码中语句的数量影响操作执行的速度。一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快。那么优化的目标就是寻找可以合并的语句，以减少整个脚本的执行时间。为此，可以参考如下几种模式。</p>
<ol>
<li>多个变量声明</li>
</ol>
<p>声明多个变量时很容易出现多条语句。</p>
<p>在强类型语言中，不同数据类型的变量必须在不同的语句中声明。但在 JavaScript 中，所有变量都可以使用一个let语句声明。</p>
<ol start="2">
<li>插入迭代性值</li>
</ol>
<p>任何时候只要使用迭代性值（即会递增或递减的值），都要尽可能使用组合语句。</p>
<ol start="3">
<li>使用数组和对象字面量</li>
</ol>
<p>使用构造函数始终会产生比单纯插入元素或定义属性更多的语句，而字面量只需一条语句即可完成全部操作。</p>
<p>应尽可能使用数组或对象字面量，以消除不必要的语句。</p>
<h4 id="28-2-4-优化-DOM-交互"><a href="#28-2-4-优化-DOM-交互" class="headerlink" title="28.2.4 优化 DOM 交互"></a>28.2.4 优化 DOM 交互</h4><p>DOM 操作和交互需要占用大量时间，因为经常需要重新渲染整个或部分页面。</p>
<ol>
<li>实时更新最小化</li>
</ol>
<p>访问 DOM 时，只要访问的部分是显示页面的一部分，就是在执行实时更新操作。之所以称其为实时更新，是因为涉及立即（实时）更新页面的显示，让用户看到。每次这样的更新，无论是插入一个字符还是删除页面上的一节内容，都会导致性能损失。这是因为浏览器需要为此重新计算数千项指标，之后才能执行更新。实时更新的次数越多，执行代码所需的时间也越长。反之，实时更新的次数越少，代码执行就越快。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myList&quot;</span>), </span><br><span class="line">  item; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">  item = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>); </span><br><span class="line">  list.<span class="title function_">appendChild</span>(item); </span><br><span class="line">  item.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Item $&#123;i&#125;&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码向列表中添加了 10 项。每添加 1 项，就会有两次实时更新：一次添加&lt;**li**&gt;元素，一次为它添加文本节点。因为要添加 10 项，所以整个操作总共要执行 20 次实时更新。</p>
<p>使用文档片段构建 DOM 结构，然后一次性将它添加到list元素。这<br>个办法可以减少实时更新，也可以避免页面闪烁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myList&quot;</span>), </span><br><span class="line">  fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>(), </span><br><span class="line">  item; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">  item = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>); </span><br><span class="line">  fragment.<span class="title function_">appendChild</span>(item); </span><br><span class="line">  item.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Item &quot;</span> + i)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">list.<span class="title function_">appendChild</span>(fragment);</span><br></pre></td></tr></table></figure>

<p>只要是必须更新 DOM，就尽量考虑使用文档片段来预先构建 DOM 结构，然后再把构建好的 DOM结构实时更新到文档中。</p>
<ol start="2">
<li>使用innerHTML</li>
</ol>
<p>在页面中创建新 DOM 节点的方式有两种：使用 DOM 方法如createElement()和appendChild()，以及使用innerHTML。对于少量 DOM 更新，这两种技术区别不大，但对于大量 DOM 更新，使用innerHTML要比使用标准 DOM 方法创建同样的结构快很多。 在给innerHTML赋值时，后台会创建 HTML 解析器，然后会使用原生 DOM 调用而不是 JavaScript的 DOM 方法来创建 DOM 结构。原生 DOM 方法速度更快，因为该方法是执行编译代码而非解释代码。前面的例子如果使用innerHTML重写就是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myList&quot;</span>), </span><br><span class="line">  html = <span class="string">&quot;&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">  html += <span class="string">&#x27;&lt;li&gt;Item $&#123;i&#125;&lt;/li&gt;&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">list.<span class="property">innerHTML</span> = html;</span><br></pre></td></tr></table></figure>

<p>与其他 DOM 操作一样，使用innerHTML的关键在于最小化调用次数。</p>
<blockquote>
<p>使用innerHTML可以提升性能，但也会暴露巨大的 XSS 攻击面。无论何时使用它填充不受控的数据，都有可能被攻击者注入可执行代码。此时必须要当心。</p>
</blockquote>
<ol start="3">
<li>使用事件委托</li>
</ol>
<p>一个页面中事件处理程序的数量与页面响应用户交互的速度有直接关系。为了减少对页面响应的影响，应该尽可能使用事件委托。<br>事件委托利用了事件的冒泡。任何冒泡的事件都可以不在事件目标上，而在目标的任何祖先元素上处理。基于这个认知，可以把事件处理程序添加到负责处理多个目标的高层元素上。只要可能，就应该在文档级添加事件处理程序，因为在文档级可以处理整个页面的事件。</p>
<ol start="4">
<li>注意HTMLCollection</li>
</ol>
<p>任何时候，只要访问HTMLCollection，无论是它的属性还是方法，就会触发查询文档，而这个查询相当耗时。减少访问HTMLCollection的次数可以极大地提升脚本的性能。<br>可 能 优 化HTMLCollection访 问 最 关 键 地 方 就 是 循 环 了 。</p>
<p>编写 JavaScript 代码时，关键是要记住，只要返回HTMLCollection对象，就应该尽量不访问它。以下情形会返回HTMLCollection：</p>
<ul>
<li><p>调用getElementsByTagName()；</p>
</li>
<li><p>读取元素的childNodes属性；</p>
</li>
<li><p>读取元素的attributes属性；</p>
</li>
<li><p>访问特殊集合，如document.form、document.images等。</p>
</li>
</ul>
<h3 id="28-3-部署"><a href="#28-3-部署" class="headerlink" title="28.3 部署"></a>28.3 部署</h3><h4 id="28-3-1-构建流程"><a href="#28-3-1-构建流程" class="headerlink" title="28.3.1 构建流程"></a>28.3.1 构建流程</h4><p>你写的代码不应该不做任何处理就直接交给浏览器，原因如下。</p>
<ul>
<li><p>知识产权问题：如果把满是注释的代码放到网上，其他人就很容易了解你在做什么，重用它，并可能发现安全漏洞。</p>
</li>
<li><p>文件大小：你写的代码可读性很好，容易维护，但性能不好。浏览器不会因为代码中多余的空格、缩进、冗余的函数和变量名而受益。</p>
</li>
<li><p>代码组织：为保证可维护性而组织的代码不一定适合直接交付给浏览器。</p>
</li>
</ul>
<ol>
<li>文件结构</li>
</ol>
<p>构建流程首先定义在源代码控制中存储文件的逻辑结构。最好不要在一个文件中包含所有JavaScript 代码。相反，要遵循面向对象编程语言的典型模式，把对象和自定义类型保存到自己独立的文件中。这样可以让每个文件只包含最小量的代码，让后期修改更方便，也不易引入错误。此外，在使用并发源代码控制系统（如 Git、CVS 或 Subversion）的环境中，这样可以减少合并时发生冲突的风险。<br>注意，把代码分散到多个文件是从可维护性而不是部署角度出发的。对于部署，应该把所有源文件合并为一个或多个汇总文件。Web 应用程序使用的 JavaScript 文件越少越好，因为 HTTP 请求对某些 Web应用程序而言是主要的性能瓶颈。而且，使用</p>
<p>构建流程首先定义在源代码控制中存储文件的逻辑结构。最好不要在一个文件中包含所有JavaScript 代码。相反，要遵循面向对象编程语言的典型模式，把对象和自定义类型保存到自己独立的文件中。这样可以让每个文件只包含最小量的代码，让后期修改更方便，也不易引入错误。此外，在使用并发源代码控制系统（如 Git、CVS 或 Subversion）的环境中，这样可以减少合并时发生冲突的风险。<br>注意，把代码分散到多个文件是从可维护性而不是部署角度出发的。对于部署，应该把所有源文件合并为一个或多个汇总文件。Web 应用程序使用的 JavaScript 文件越少越好，因为 HTTP 请求对某些 Web应用程序而言是主要的性能瓶颈。而且，使用&lt;**script**&gt;标签包含 JavaScript 是阻塞性操作，这导致代码下载和执行期间停止所有其他下载任务。因此，要尽量以符合逻辑的方式把 JavaScript 代码组织到部署文件中。</p>
<ol start="2">
<li>任务运行器</li>
</ol>
<p>任务运行器可以完成代码检查、打包、转译、启动本地服务器、部署，以及其他可以脚本化的任务。</p>
<p>如果你使用 Node.js 和 npm 打印 JavaScript 资源，Grunt 和 Gulp 是两个主流的任务运行器。它们非常稳健，其任务和指令都是通过配置文件，以纯 JavaScript 形式指定的。使用 Grunt 和 Gulp 的好处是它们分别有各自的插件生态，因此可以直接使用 npm 包。</p>
<ol start="3">
<li>摇树优化</li>
</ol>
<p>摇树优化（tree shaking）是非常常见且极为有效的减少冗余代码的策略。</p>
<p>使用静态模块声明风格意味着构建工具可以确定代码各部分之间的依赖关系。更重要的是，摇树优化还能确定代码中的哪些内容是完全不需要的。<br>实现了摇树优化策略的构建工具能够分析出选择性导入的代码，其余模块文件中的代码可以在最终打包得到的文件中完全省略。假设下面是个示例应用程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="string">&#x27;bar&#x27;</span>;  <span class="comment">// unused</span></span><br></pre></td></tr></table></figure>

<p>静态分析也意味着构建工具可以确定未使用的依赖，同样也会排除掉。通过摇树优化，最终打包得到的文件可以瘦身很多。</p>
<ol start="4">
<li>模块打包器</li>
</ol>
<p>通常，由大量模块组成的 JavaScript代码在构建时需要打包到一起，然后只交付一个或少数几个 JavaScript 文件。<br>模块打包器的工作是识别应用程序中涉及的 JavaScript 依赖关系，将它们组合成一个大文件，完成对模块的串行组织和拼接，然后生成最终提供给浏览器的输出文件。 能够实现模块打包的工具非常多。Webpack、Rollupt 和 Browserify 只是其中的几个，可以将基于模块的代码转换为普遍兼容的网页脚本。</p>
<h4 id="28-3-2-验证"><a href="#28-3-2-验证" class="headerlink" title="28.3.2 验证"></a>28.3.2 验证</h4><p>有一些工具可以帮我们发现 JavaScript 代码中潜在的问题，最流行的是 Douglas Crockford 的 JSLint 和 ESLint。<br>这些代码检查工具可以发现 JavaScript 代码中的语法错误和常见的编码错误。下面是它们会报告的一些问题：</p>
<ul>
<li><p>使用eval()；</p>
</li>
<li><p>使用未声明的变量；</p>
</li>
<li><p>遗漏了分号；</p>
</li>
<li><p>不适当地换行；</p>
</li>
<li><p>不正确地使用逗号；</p>
</li>
<li><p>遗漏了包含语句的括号；</p>
</li>
<li><p>遗漏了switch分支中的break；</p>
</li>
<li><p>重复声明变量；</p>
</li>
<li><p>使用了with；</p>
</li>
<li><p>错误地使用等号（应该是两个或三个等号）；</p>
</li>
<li><p>执行不到的代码。</p>
</li>
</ul>
<h4 id="28-3-3-压缩"><a href="#28-3-3-压缩" class="headerlink" title="28.3.3 压缩"></a>28.3.3 压缩</h4><p>谈到 JavaScript 文件压缩，实际上主要是两件事：代码大小（code size）和传输负载（wire weight）。代码大小指的是浏览器需要解析的字节数，而传输负载是服务器实际发送给浏览器的字节数。</p>
<ol>
<li>代码压缩</li>
</ol>
<p>JavaScript 不是编译成字节码，而是作为源代码传输的，所以源代码文件通常包含对浏览器的JavaScript 解释器没有用的额外信息和格式。JavaScript 压缩工具可以把源代码文件中的这些信息删除，并在保证程序逻辑不变的前提下缩小文件大小。<br>注释、额外的空格、长变量或函数名都能提升开发者的可读性，但对浏览器而言这些都是多余的字节。压缩工具可以通过如下操作减少代码大小：</p>
<ul>
<li><p>删除空格（包括换行）；</p>
</li>
<li><p>删除注释；</p>
</li>
<li><p>缩短变量名、函数名和其他标识符。</p>
</li>
</ul>
<p>所有 JavaScript 文件都应该在部署到线上环境前进行压缩。在构建流程中加入这个环节压缩JavaScript 文件是很容易的。</p>
<blockquote>
<p>在 Web 开发的上下文中，“压缩”（compression）经常意味着“最小化”（minification）。虽然这两个术语可以互换使用，但实际上它们的含义并不相同。 最小化是指把文件大小减少到比原始大小还要小，但结果文件包含的仍是语法正确的代码。通常，最小化只适合 JavaScript 等解释型语言，编译为二进制的语言自然会被编译器<br>最小化。<br>压缩与最小化的区别在于前者得到的文件不再包含语法正确的代码。压缩后的文件必须通过解压缩才能恢复为代码可读的格式。压缩通常能得到比最小化更小的文件，压缩算法不用考虑保留语法结构，因此自由度更高。</p>
</blockquote>
<ol start="2">
<li>JavaScript 编译</li>
</ol>
<p>JavaScript 代码编译通常指的是把源代码转换为一种逻辑相同但字节更少的形式。与最小化的不同之处在于，编译后代码的结构可能不同，但仍然具备与原始代码相同的行为。编译器通过输入全部 JavaScript 代码可以对程序流执行稳健的分析。<br>编译可能会执行如下操作：</p>
<ul>
<li><p>删除未使用的代码；</p>
</li>
<li><p>将某些代码转换为更简洁的语法；</p>
</li>
<li><p>全局函数调用、常量和变量行内化。</p>
</li>
</ul>
<ol start="3">
<li>JavaScript 转译</li>
</ol>
<p>通过 JavaScript 转译，可以在开发时使用最新的语法特性而不用担心浏览器的兼容性问题。转译可以将现代的代码转换成更早的 ECMAScript 版本，通常是 ES3 或 ES5，具体取决于你的需求。这样可以确保代码能够跨浏览器兼容。</p>
<ol start="4">
<li>HTTP 压缩</li>
</ol>
<p>传输负载是从服务器发送给浏览器的实际字节数。这个字节数不一定与代码大小相同，因为服务器和浏览器都具有压缩能力。所有当前主流的浏览器（IE/Edge、Firefox、Safari、Chrome 和 Opera）都支持客户端解压缩收到的资源。服务器则可以根据浏览器通过请求头部（Accept-Encoding）标明自己支持的格式，选择一种用来压缩 JavaScript 文件。在传输压缩后的文件时，服务器响应的头部会有字段（Content-Encoding）标明使用了哪种压缩格式。浏览器看到这个头部字段后，就会根据这个压缩格式进行解压缩。结果是通过网络传输的字节数明显小于原始代码大小。</p>
<h3 id="28-4-小结"><a href="#28-4-小结" class="headerlink" title="28.4 小结"></a>28.4 小结</h3><p>随着 JavaScript 开发日益成熟，最佳实践不断涌现。曾经的业余爱好如今也成为了正式的职业。因此，前端开发也需要像其他编程语言一样，注重可维护性、性能优化和部署。</p>
<p>为保证 JavaScript 代码的可维护性，可以参考如下编码惯例。</p>
<ul>
<li><p>其他语言的编码惯例可以作为添加注释和确定缩进的参考，但 JavaScript 作为一门适合松散类型的语言也有自己的一些特殊要求。</p>
</li>
<li><p>由于 JavaScript 必须与 HTML 和 CSS 共存，因此各司其职尤为重要：JavaScript 负责定义行为，HTML 负责定义内容，而 CSS 负责定义外观。</p>
</li>
<li><p>如果三者职责混淆，则可能导致难以调试的错误和可维护性问题。</p>
</li>
</ul>
<p>随着 Web 应用程序中 JavaScript 代码量的激增，性能也越来越重要。因此应该牢记如下这些事项。</p>
<ul>
<li><p>执行 JavaScript 所需的时间直接影响网页性能，其重要性不容忽视。</p>
</li>
<li><p>很多适合 C 语言的性能优化策略同样也适合 JavaScript，包括循环展开和使用switch语句而不是if语句。</p>
</li>
<li><p>另一个需要重视的方面是 DOM 交互很费时间，因此应该尽可能限制 DOM 操作的数量。</p>
</li>
</ul>
<p>开发 Web 应用程序的最后一步是上线部署。以下是本章讨论的相关要点。</p>
<ul>
<li><p>为辅助部署，应该建立构建流程，将 JavaScript 文件合并为较少的（最好是只有一个）文件。</p>
</li>
<li><p>构建流程可以实现很多源代码处理任务的自动化。例如，可以运行 JavaScript 验证程序，确保没有语法错误和潜在的问题。</p>
</li>
<li><p>压缩可以让文件在部署之前变得尽量小。</p>
</li>
<li><p>启用 HTTP 压缩可以让网络传输的 JavaScript 文件尽可能小，从而提升页面的整体性能。</p>
</li>
</ul>
</style></p>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/Webchat.png" alt="墨韵 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>墨韵
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://moyun.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="JavaScript高级程序设计">http://moyun.com/javascript高级程序设计/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a>
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E4%BA%BA%E9%97%B4%E5%91%8A%E7%99%BD/" rel="prev" title="人间告白">
                  <i class="fa fa-chevron-left"></i> 人间告白
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/es6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/" rel="next" title="ES6标准入门">
                  ES6标准入门 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MOYUN</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1.3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">19:25</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!-- 网站运行时间的设置 -->
<span id="sitetime"></span>
<script language=javascript>
  	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
         		*/
		var t1 = Date.UTC(2020,02,13,15,00,00); //北京时间2018-2-13 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>
    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- 多级目录 -->
  <script type="text/javascript" src="/js/category.js"></script>
</body>
</html>
