<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"moyun.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="freeCodeCamp —- Front End Development Libraries React1. 创建一个简单的 JSX 元素简介：React 是由 Facebook 创建和维护的开源视图库。 它是渲染现代 Web 应用程序用户界面（UI）的好工具。">
<meta property="og:type" content="article">
<meta property="og:title" content="Front End Development Libraries(四)">
<meta property="og:url" content="http://moyun.com/front-end-development-libraries-%E5%9B%9B/index.html">
<meta property="og:site_name" content="MoYun">
<meta property="og:description" content="freeCodeCamp —- Front End Development Libraries React1. 创建一个简单的 JSX 元素简介：React 是由 Facebook 创建和维护的开源视图库。 它是渲染现代 Web 应用程序用户界面（UI）的好工具。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-18T08:04:56.719Z">
<meta property="article:modified_time" content="2023-06-18T08:08:02.613Z">
<meta property="article:author" content="墨韵">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://moyun.com/front-end-development-libraries-%E5%9B%9B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://moyun.com/front-end-development-libraries-%E5%9B%9B/","path":"front-end-development-libraries-四/","title":"Front End Development Libraries(四)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Front End Development Libraries(四) | MoYun</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="MoYun" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MoYun</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-demo"><a href="/demo/" rel="section"><i class="fa fa-file-code fa-fw"></i>demo</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#freeCodeCamp-%E2%80%94-Front-End-Development-Libraries"><span class="nav-text">freeCodeCamp —- Front End Development Libraries</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#React"><span class="nav-text">React</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-JSX-%E5%85%83%E7%B4%A0"><span class="nav-text">1. 创建一个简单的 JSX 元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84-JSX-%E5%85%83%E7%B4%A0"><span class="nav-text">2. 创建一个复杂的 JSX 元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9C%A8-JSX-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A"><span class="nav-text">3. 在 JSX 中添加注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B8%B2%E6%9F%93-HTML-%E5%85%83%E7%B4%A0%E4%B8%BA-DOM-%E6%A0%91"><span class="nav-text">4. 渲染 HTML 元素为 DOM 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9C%A8-JSX-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-HTML-Class"><span class="nav-text">5. 在 JSX 中定义一个 HTML Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BA%86%E8%A7%A3%E8%87%AA%E9%97%AD%E5%90%88-JSX-%E6%A0%87%E7%AD%BE"><span class="nav-text">6. 了解自闭合 JSX 标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="nav-text">7. 创建一个无状态的函数组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-React-%E7%BB%84%E4%BB%B6"><span class="nav-text">8. 创建一个 React 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E7%94%A8%E7%BB%84%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-React-%E7%BB%84%E4%BB%B6"><span class="nav-text">9. 用组合的方式创建一个 React 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%BD%BF%E7%94%A8-React-%E6%B8%B2%E6%9F%93%E5%B5%8C%E5%A5%97%E7%BB%84%E4%BB%B6"><span class="nav-text">10. 使用 React 渲染嵌套组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%BB%84%E5%90%88-React-%E7%BB%84%E4%BB%B6"><span class="nav-text">11. 组合 React 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%B0%86-class-%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%B0-DOM-%E6%A0%91"><span class="nav-text">12. 将 class 组件渲染到 DOM 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%80%E4%B8%AA-React-%E7%BB%84%E4%BB%B6"><span class="nav-text">13. 从零开始写一个 React 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%B0%86-Props-%E4%BC%A0%E9%80%92%E7%BB%99%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="nav-text">14. 将 Props 传递给无状态函数组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA-Props"><span class="nav-text">15. 传递一个数组作为 Props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84-Props"><span class="nav-text">16. 使用默认的 Props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E8%A6%86%E7%9B%96%E9%BB%98%E8%AE%A4%E7%9A%84-Props"><span class="nav-text">17. 覆盖默认的 Props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E4%BD%BF%E7%94%A8-PropTypes-%E6%9D%A5%E5%AE%9A%E4%B9%89-Props-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">18. 使用 PropTypes 来定义 Props 的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E4%BD%BF%E7%94%A8-this-props-%E8%AE%BF%E9%97%AE-Props"><span class="nav-text">19. 使用 this.props 访问 Props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E5%A4%8D%E4%B9%A0%E4%BD%BF%E7%94%A8%E6%97%A0%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84-Props"><span class="nav-text">20. 复习使用无状态函数组件的 Props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-text">21. 创建一个有状态的组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E5%9C%A8%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81"><span class="nav-text">22. 在用户界面中渲染状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E4%BB%A5%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%9C%A8%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81"><span class="nav-text">23. 以另一种方式在用户界面中渲染状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E7%94%A8-this-setState-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81"><span class="nav-text">24. 用 this.setState 设置状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-%E5%B0%86-this-%E7%BB%91%E5%AE%9A%E5%88%B0-Class-%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="nav-text">25. 将 this 绑定到 Class 方法上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E4%BD%BF%E7%94%A8-State-%E5%88%87%E6%8D%A2%E5%85%83%E7%B4%A0"><span class="nav-text">26. 使用 State 切换元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">27. 写一个简单的计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E7%9A%84%E8%BE%93%E5%85%A5%E6%A1%86"><span class="nav-text">28. 创建一个可以控制的输入框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E7%9A%84%E8%A1%A8%E5%8D%95"><span class="nav-text">29. 创建一个可以控制的表单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-%E5%B0%86-State-%E4%BD%9C%E4%B8%BA-Props-%E4%BC%A0%E9%80%92%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="nav-text">30. 将 State 作为 Props 传递给子组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-%E4%BC%A0%E9%80%92%E5%9B%9E%E8%B0%83%E4%BD%9C%E4%B8%BA-Props"><span class="nav-text">31. 传递回调作为 Props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95-componentWillMount"><span class="nav-text">32. 使用生命周期方法 componentWillMount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%EF%BC%9AcomponentDidMount"><span class="nav-text">33. 使用生命周期方法：componentDidMount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-text">34. 添加事件侦听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-%E4%BD%BF%E7%94%A8-shouldComponentUpdate-%E4%BC%98%E5%8C%96%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93"><span class="nav-text">35. 使用 shouldComponentUpdate 优化重新渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-%E4%BB%8B%E7%BB%8D%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="nav-text">36. 介绍内联样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-%E5%9C%A8-React-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="nav-text">37. 在 React 中添加内联样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-%E5%9C%A8-React-Render-%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8-JavaScript"><span class="nav-text">38. 在 React Render 方法中使用 JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-%E4%BD%BF%E7%94%A8-If-Else-%E6%9D%A1%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%B8%B2%E6%9F%93"><span class="nav-text">39. 使用 If-Else 条件进行渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E4%BD%BF%E7%94%A8-amp-amp-%E8%8E%B7%E5%BE%97%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">40. 使用 &amp;&amp; 获得更简洁的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%E4%BD%BF%E7%94%A8%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="nav-text">41. 使用三元表达式进行条件渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E4%BD%BF%E7%94%A8-Props-%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E6%B8%B2%E6%9F%93"><span class="nav-text">42. 使用 Props 有条件地渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E6%A0%B9%E6%8D%AE%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E6%9B%B4%E6%94%B9%E5%86%85%E8%81%94-CSS"><span class="nav-text">43. 根据组件状态有条件地更改内联 CSS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E4%BD%BF%E7%94%A8-Array-map-%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E5%85%83%E7%B4%A0"><span class="nav-text">44. 使用 Array.map() 动态渲染元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-%E7%BB%99%E5%90%8C%E7%BA%A7%E5%85%83%E7%B4%A0%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E7%9A%84%E9%94%AE%E5%B1%9E%E6%80%A7"><span class="nav-text">45. 给同级元素一个唯一的键属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-%E4%BD%BF%E7%94%A8-Array-Filter-%E5%8A%A8%E6%80%81%E8%BF%87%E6%BB%A4%E6%95%B0%E7%BB%84"><span class="nav-text">46. 使用 Array.Filter() 动态过滤数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-%E7%94%A8-renderToString-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%B8%B2%E6%9F%93-React"><span class="nav-text">47. 用 renderToString 在服务器上渲染 React</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="墨韵"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">墨韵</p>
  <div class="site-description" itemprop="description">ZERO-学习博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/moyunzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moyunzero" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zero305747648@gmail.com" title="E-Mail → mailto:zero305747648@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://moyun.com/front-end-development-libraries-%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="墨韵">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MoYun">
      <meta itemprop="description" content="ZERO-学习博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Front End Development Libraries(四) | MoYun">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Front End Development Libraries(四)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-06-18 16:04:56 / 修改时间：16:08:02" itemprop="dateCreated datePublished" datetime="2023-06-18T16:04:56+08:00">2023-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/freeCodeCamp/" itemprop="url" rel="index"><span itemprop="name">freeCodeCamp</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/freeCodeCamp/Front-End-Development-Libraries/" itemprop="url" rel="index"><span itemprop="name">Front End Development Libraries</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>29k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="freeCodeCamp-—-Front-End-Development-Libraries"><a href="#freeCodeCamp-—-Front-End-Development-Libraries" class="headerlink" title="freeCodeCamp —- Front End Development Libraries"></a>freeCodeCamp —- Front End Development Libraries</h1><hr>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="1-创建一个简单的-JSX-元素"><a href="#1-创建一个简单的-JSX-元素" class="headerlink" title="1. 创建一个简单的 JSX 元素"></a>1. 创建一个简单的 JSX 元素</h3><p>简介：React 是由 Facebook 创建和维护的开源视图库。 它是渲染现代 Web 应用程序用户界面（UI）的好工具。</p>
<span id="more"></span>
<p>React 使用名为 JSX 的 JavaScript 语法扩展，可以直接在 JavaScript 中编写 HTML。 这有几个好处。 可以在 HTML 中使用 JavaScript 的完整程序功能，并有助于保持代码的可读性。 在大多数情况下，JSX 类似于已经学过的 HTML，但是在这些挑战中将会涉及一些关键差异。</p>
<p>例如，因为 JSX 是 JavaScript 的语法扩展，所以实际上可以直接在 JSX 中编写 JavaScript。 要做到这一点，只需在花括号中包含希望被视为 JavaScript 的代码：<code>&#123; &#39;this is treated as JavaScript code&#39; &#125;</code>（这被视为 JavaScript 代码）。 请牢记这个写法，将会在接下来的挑战中使用。</p>
<p>但是，由于浏览器不能解析 JSX，因此必须将 JSX 代码编译为 JavaScript。 在这个过程中，转换器 Babel 是一个很受欢迎的工具。 后续挑战已经在后台引入了 Babel，可以直接写 JSX 代码。 如果代码不符合 JSX 语法，那么挑战中的第一个测试就不会通过。</p>
<p>值得注意的是，这些挑战在底层调用 <code>ReactDOM.render(JSX, document.getElementById(&#39;root&#39;))</code>。 这个函数调用将 JSX 置于 React 自己的轻量级 DOM 中。 然后，React 使用自己的 DOM 快照来实现增量更新。</p>
<h3 id="2-创建一个复杂的-JSX-元素"><a href="#2-创建一个复杂的-JSX-元素" class="headerlink" title="2. 创建一个复杂的 JSX 元素"></a>2. 创建一个复杂的 JSX 元素</h3><p>关于嵌套的 JSX，需要知道的一件重要的事情，那就是它必须返回单个元素。</p>
<p>这个父元素将包裹所有其他级别的嵌套元素。</p>
<p>例如，几个作为兄弟元素编写的 JSX 元素而没有父元素包裹将不会被转换。</p>
<p>这里是一个示例：</p>
<p><strong>有效的 JSX：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph One<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph Two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph Three<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>无效的 JSX：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;<span class="title class_">Paragraph</span> <span class="title class_">One</span>&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph Two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph Three<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<p>定义一个新的常量 <code>JSX</code>，渲染一个 <code>div</code>，其中依次包含以下元素：</p>
<p>一个 <code>h1</code>，一个 <code>p</code>，一个包含三个 <code>li</code> 项的无序列表。 可以在每个元素中包含任意文本。</p>
<p><strong>注意：</strong> 当像这样渲染多个元素时，可以把它们都用圆括号括起来，但是这并不是必须的。 另外，此挑战使用 <code>div</code> 标签把所有子元素包裹在里面。 如果删除 <code>div</code>，JSX 将不会编译这些元素。 请记住这一点，因为在 React 组件中返回 JSX 元素时也适用。</p>
<h3 id="3-在-JSX-中添加注释"><a href="#3-在-JSX-中添加注释" class="headerlink" title="3. 在 JSX 中添加注释"></a>3. 在 JSX 中添加注释</h3><p>JSX 是一种可以编译成 JavaScript 的语法。 有时，为了便于阅读，可能需要在代码中添加注释。 像大多数编程语言一样，JSX 也有自己的方法来实现这一点。</p>
<p>要将注释放在 JSX 中，可以使用 <code>&#123;/* */&#125;</code> 语法来包裹注释文本。</p>
<hr>
<p>代码编辑器中的 JSX 元素与在上一个挑战中创建的元素类似。 在提供的 <code>div</code> 元素里添加注释，不修改现有的 <code>h1</code> 或 <code>p</code> 元素。</p>
<h3 id="4-渲染-HTML-元素为-DOM-树"><a href="#4-渲染-HTML-元素为-DOM-树" class="headerlink" title="4. 渲染 HTML 元素为 DOM 树"></a>4. 渲染 HTML 元素为 DOM 树</h3><p>到目前为止，已经了解到 JSX 是一种在 JavaScript 中编写可读 HTML 的便捷工具。 在 React 中，可以使用它的的渲染 API（ReactDOM）将此 JSX 直接渲染到 HTML DOM。</p>
<p>ReactDOM 提供了一个简单的方法来将 React 元素呈现给 DOM，如下所示：<code>ReactDOM.render(componentToRender, targetNode)</code>，其中第一个参数是要渲染的 React 元素或组件，第二个参数是组件将要渲染到的 DOM 节点。</p>
<p>如你所料，必须在 JSX 元素声明之后调用 <code>ReactDOM.render()</code>，就像在使用变量之前必须声明它一样。</p>
<hr>
<p>代码编辑器有一个简单的 JSX 组件。 使用 <code>ReactDOM.render()</code> 方法将该组件渲染到页面。 可以将定义好的 JSX 元素直接作为第一个参数传入，然后使用 <code>document.getElementById()</code> 来选择要渲染到的 DOM 节点， 在这个挑战中，请渲染到 <code>id=&#39;challenge-node&#39;</code>的 <code>div</code> 中。 确保没有修改 <code>JSX</code> 常量。</p>
<h3 id="5-在-JSX-中定义一个-HTML-Class"><a href="#5-在-JSX-中定义一个-HTML-Class" class="headerlink" title="5. 在 JSX 中定义一个 HTML Class"></a>5. 在 JSX 中定义一个 HTML Class</h3><p>现在已经习惯了编写 JSX，可能想知道它与 HTML 有什么不同。</p>
<p>到目前为止，HTML 和 JSX 似乎完全相同。</p>
<p>JSX 的一个关键区别是你不能再使用 <code>class</code> 这个单词来做为 HTML 的 class 名。 这是因为 <code>class</code> 是 JavaScript 中的关键字。 而 JSX 使用 <code>className</code> 来代替。</p>
<p>事实上，JSX 中所有 HTML 属性和事件引用的命名约定都变成了驼峰式。 例如，JSX 中的单击事件是 <code>onClick</code>，而不是 <code>onclick</code>。 同样，<code>onchange</code> 变成了<code>onChange</code>。 虽然这是一个微小的差异，但请你一定要记住。</p>
<h3 id="6-了解自闭合-JSX-标签"><a href="#6-了解自闭合-JSX-标签" class="headerlink" title="6. 了解自闭合 JSX 标签"></a>6. 了解自闭合 JSX 标签</h3><p>到目前为止，已经看到 JSX 与 HTML 的关键不同在于使用 <code>className</code> 还是 <code>class</code> 来定义 HTML 的 class。</p>
<p>JSX 不同于 HTML 的另一个重要方面是自闭合标签。</p>
<p>在HTML中，几乎所有的标签都有一个开始和结束标签：<code>&lt;div&gt;&lt;/div&gt;</code>，结束标签在你要关闭的标签名之前始终具有正斜杠。 但是，HTML 中有一些被称为“自闭合标签”的特殊实例，它们在另一个标签开始之前，不需要开始和结束标签都存在。</p>
<p>例如，换行标签可以写成 <code>&lt;br&gt;</code> 或者 <code>&lt;br /&gt;</code>，但是不应该写成 <code>&lt;br&gt;&lt;/br&gt;</code>，因为它不包含任何内容。</p>
<p>在 JSX 中，规则略有不同。 任何 JSX 元素都可以使用自闭合标签编写，并且每个元素都必须关闭。 例如，为了通过编译换行标签必须始终编写为 <code>&lt;br /&gt;</code>。 另一方面 <code>&lt;div&gt;</code> 可以写成 <code>&lt;div /&gt;</code> 或者 <code>&lt;div&gt;&lt;/div&gt;</code>。 不同之处在于，在第一个语法版本中，无法在 <code>&lt;div /&gt;</code> 中包含任何内容。 在后面的挑战中你会发现，这种语法在渲染 React 组件时非常有用。</p>
<hr>
<p>修复代码编辑器中的错误，使其成为有效的 JSX 并成功编译。 确保不更改任何内容 – 只需要在需要的地方关闭标签。</p>
<h3 id="7-创建一个无状态的函数组件"><a href="#7-创建一个无状态的函数组件" class="headerlink" title="7. 创建一个无状态的函数组件"></a>7. 创建一个无状态的函数组件</h3><p>组件是 React 的核心。 React 中的所有内容都是一个组件，在这里将学习如何创建一个组件。</p>
<p>有两种方法可以创建 React 组件。 第一种方法是使用 JavaScript 函数。 以这种方式定义组件会创建<em>无状态函数组件</em>。 将在以后的挑战中介绍应用程序中状态的概念。 目前为止，可以将无状态组件视为能接收数据并对其进行渲染，但不管理或跟踪该数据的更改的组件。 (我们将下一个挑战使用中第二种方式创建 React 组件。)</p>
<p>要用函数创建组件，只需编写一个返回 JSX 或 <code>null</code> 的 JavaScript 函数。 需要注意的一点是，React 要求你的函数名以大写字母开头。 下面是一个无状态功能组件的示例，该组件在 JSX 中分配一个 HTML 的 class：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">DemoComponent</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;customClass&#x27;</span> /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>翻译完成后， <code>&lt;div&gt;</code> 将有一个 <code>customClass</code> 的 CSS class。</p>
<p>因为 JSX 组件代表 HTML，所以你可以将几个组件放在一起以创建更复杂的 HTML 页面。 这是 React 提供的组件架构的关键优势之一。 它允许用许多独立的组件组合成 UI。 这使得构建和维护复杂的用户界面变得更加容易。</p>
<hr>
<p>代码编辑器中有一个名为 <code>MyComponent</code> 的函数。 完成此函数，使其返回包含一些文本字符串的单个 <code>div</code> 元素。</p>
<p><strong>注意：</strong> 文本被视为是 <code>div</code> 的子元素，因此不能使用自闭合标签。</p>
<h3 id="8-创建一个-React-组件"><a href="#8-创建一个-React-组件" class="headerlink" title="8. 创建一个 React 组件"></a>8. 创建一个 React 组件</h3><p>定义 React 组件的另一种方法是使用 ES6 的 <code>class</code>语法。 在以下示例中，<code>Kitten</code> 扩展了<code>React.Component</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Kitten</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将创建一个 ES6 类 <code>Kitten</code>，它扩展了 <code>React.Component</code> 类。 因此，<code>Kitten</code> 类现在可以访问许多有用的 React 功能，例如本地状态和生命周期钩子。 如果还不熟悉这些术语，请不要担心，在以后的挑战中我们将更详细地介绍它们。 另请注意，<code>Kitten</code> 类中定义了一个调用 <code>super()</code> 方法的 <code>constructor</code>。 它使用 <code>super()</code> 调用父类的构造函数，即本例中的 <code>React.Component</code>。 构造函数是使用 <code>class</code> 关键字创建的特殊方法，它在实例初始化之前调用。 最佳做法是在组件的 <code>constructor</code> 里调用 <code>super</code>，并将 <code>props</code> 传递给它们， 这样可以保证组件能够正确地初始化。 目前为止 ，需要知道这些代码是必要的。 很快会了解到到构造函数的其他用途以及 <code>props</code>。</p>
<hr>
<p><code>MyComponent</code> 是使用类语法在代码编辑器中定义的。 完成 <code>render</code> 方法的编写，使其返回 <code>div</code> 元素，其中包含文本内容为 <code>Hello React!</code> 的 <code>h1</code> 元素。</p>
<h3 id="9-用组合的方式创建一个-React-组件"><a href="#9-用组合的方式创建一个-React-组件" class="headerlink" title="9. 用组合的方式创建一个 React 组件"></a>9. 用组合的方式创建一个 React 组件</h3><p>现在来看看如何组合多个 React 组件。 想象一下，现在正在构建一个应用程序，并创建了三个组件：<code>Navbar</code>、<code>Dashboard</code> 和 <code>Footer</code>。</p>
<p>要将这些组件组合在一起，可以创建一个 <code>App</code> <em>父组件</em>，将这三个组件分别渲染成为<em>子组件</em>。 要在 React 组件中渲染一个子组件，需要在 JSX 中将组件名称写作自定义的 HTML 标签。 例如，在 <code>render</code> 方法中，可以这样编写：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Navbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">App</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当 React 遇到一个自定义 HTML 标签引用另一个组件的时（如本例所示，组件名称包含在 <code>&lt; /&gt;</code> 中），它在自定义标签的位置渲染该组件的标签。 这可以说明 <code>App</code> 组件和 <code>Navbar</code>、<code>Dashboard</code> 以及 <code>Footer</code> 之间的父子关系。</p>
<hr>
<p>在代码编辑器中，有一个名为 <code>ChildComponent</code> 的简单函数组件和一个名为 <code>ParentComponent</code> 的 React 组件。 通过在 <code>ParentComponent</code> 中渲染 <code>ChildComponent</code> 来将两者组合在一起。 确保使用正斜杠关闭 <code>ChildComponent</code> 标签。</p>
<p><strong>注意：</strong> <code>ChildComponent</code> 是使用 ES6 的箭头函数定义的，这是使用 React 时非常常见的做法。 但是，要知道这只是一个函数。 如果你不熟悉箭头函数语法，请参阅 JavaScript 部分。</p>
<h3 id="10-使用-React-渲染嵌套组件"><a href="#10-使用-React-渲染嵌套组件" class="headerlink" title="10. 使用 React 渲染嵌套组件"></a>10. 使用 React 渲染嵌套组件</h3><p>上一个挑战显示了组合两个组件的简单方法，但是有许多不同的方法可以把 React 组件组合在一起。</p>
<p>组件组合是 React 的强大功能之一。 当使用 React 时，应当先用组件的思路考虑清楚用户界面的结构（如上一个挑战中的 App 示例）。 可以将 UI 分解为基本的构建块，这些构建块就是组件。 这样做有助于将负责 UI 的代码与负责处理应用程序逻辑的代码分开， 并可以大大简化复杂项目的开发和维护。</p>
<hr>
<p>代码编辑器中定义了两个功能组件，分别是 <code>TypesOfFruit</code> 和 <code>Fruits</code>。 请用组合或者<em>嵌套</em>把 <code>TypesOfFruit</code> 组件放到 <code>Fruits</code> 组件中， 然后把 <code>Fruits</code> 组件放到 <code>TypesOfFood</code> 组件中。 结果应该是子组件嵌套在父组件中，父组件嵌套在它本身的父组件中！</p>
<h3 id="11-组合-React-组件"><a href="#11-组合-React-组件" class="headerlink" title="11. 组合 React 组件"></a>11. 组合 React 组件</h3><p>随着挑战继续，将组合使用更复杂的 React 组件和 JSX，有一点需要注意。 在其它组件中渲染 ES6 风格的类组件和渲染在过去几个挑战中使用的简单组件没有什么不同。 可以在其它组件中渲染 JSX 元素、无状态函数组件和 ES6 类组件。</p>
<hr>
<p>在代码编辑器中，<code>TypesOfFood</code> 组件已经渲染了一个名为 <code>Vegetables</code> 的组件。 此外，还有上次挑战中的 <code>Fruits</code> 组件。</p>
<p>在 <code>Fruits</code> 中嵌套两个组件，首先 <code>NonCitrus</code>，然后是 <code>Citrus</code>， 这两个组件都已经引入。 接下来，将 <code>Fruits</code> 类组件嵌套到 <code>TypesOfFood</code> 组件中，位于 <code>h1</code> 标题元素下方和 <code>Vegetables</code> 上方。 结果应该是一系列嵌套的组件，它们使用两种不同的组件类型。</p>
<h3 id="12-将-class-组件渲染到-DOM-树"><a href="#12-将-class-组件渲染到-DOM-树" class="headerlink" title="12. 将 class 组件渲染到 DOM 树"></a>12. 将 class 组件渲染到 DOM 树</h3><p>还记不记得在之前的挑战中使用 ReactDOM API 将 JSX 元素渲染到 DOM， 这与渲染 React 组件的过程十分相似。 过去的几个挑战主要针对组件和组合，因此渲染是在幕后完成的。 但是，如果不调用 ReactDOM API，编写的任何 React 代码都不会渲染到 DOM。</p>
<p>复习一下语法： <code>ReactDOM.render(componentToRender, targetNode)</code>。 第一个参数是要渲染的 React 组件。 第二个参数是要在其中渲染该组件的 DOM 节点。</p>
<p>传递到<code>ReactDOM.render()</code> 的React 组件与 JSX 元素略有不同。 对于 JSX 元素，传入的是要渲染的元素的名称。 但是，对于 React 组件，需要使用与渲染嵌套组件相同的语法，例如<code>ReactDOM.render(&lt;ComponentToRender /&gt;, targetNode)</code>。 此语法用于 ES6 class 组件和函数组件都可以。</p>
<hr>
<p>在后台引入了 <code>Fruits</code> 和 <code>Vegetables</code> 组件。 将两个组件渲染为 <code>TypesOfFood</code> 组件的子组件，然后将 <code>TypesOfFood</code> 渲染到 DOM 节点， 在这个挑战中，请渲染到 <code>id=&#39;challenge-node&#39;</code>的 <code>div</code> 中。</p>
<h3 id="13-从零开始写一个-React-组件"><a href="#13-从零开始写一个-React-组件" class="headerlink" title="13. 从零开始写一个 React 组件"></a>13. 从零开始写一个 React 组件</h3><p>你已经了解了 JSX 和 React 组件的基础知识，是时候自己编写一个组件了。 React 组件是 React 应用程序的核心组成部分，因此熟练编写它们是非常重要的。 记住，典型的 React 组件是 ES6 <code>class</code>，它扩展了 <code>React.Component</code>。 它有一个返回 HTML（从 JSX 返回）或 <code>null</code> 的渲染方法， 这是 React 组件的基本形式。 理解了这一点之后，就可以开始构建更复杂的 React 项目了。</p>
<hr>
<p>定义一个 <code>MyComponent</code> 类，它是 <code>React.Component</code> 的扩展。 它的渲染方法应该返回一个 <code>div</code>，其中包含一个 <code>h1</code> 标签，标签文本为：<code>My First React Component!</code>。 准确使用此文本，大小写和标点符号也要考虑。 确保也调用组件的构造器。</p>
<p>使用 <code>ReactDOM.render()</code> 把该组件渲染到 DOM 中。 有一个 <code>id=&#39;challenge-node&#39;</code> 的 <code>div</code> 可供渲染。</p>
<h3 id="14-将-Props-传递给无状态函数组件"><a href="#14-将-Props-传递给无状态函数组件" class="headerlink" title="14. 将 Props 传递给无状态函数组件"></a>14. 将 Props 传递给无状态函数组件</h3><p>之前的挑战涵盖了关于在 React 中创建和组合 JSX 元素、函数组件和 ES6 风格的类组件的很多内容。 有了这个基础，现在是时候看看 React 中的另一个常见特性 <strong>props</strong> 了。 在 React 中，可以将属性传递给子组件。 假设有一个 <code>App</code> 组件，该组件渲染了一个名为 <code>Welcome</code> 的子组件，它是一个无状态函数组件。 可以通过以下方式给 <code>Welcome</code> 传递一个 <code>user</code> 属性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">App</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">user</span>=<span class="string">&#x27;Mark&#x27;</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">App</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以把创建的 React 支持的<strong>自定义 HTML 属性</strong>传递给组件。 在上面的例子里，将创建的属性 <code>user</code> 传递给组件 <code>Welcome</code>。 由于 <code>Welcome</code> 是一个无状态函数组件，它可以像这样访问该值：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Welcome</span> = (<span class="params">props</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.user&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>调用 <code>props</code> 这个值是常见做法，当处理无状态函数组件时，基本上可以将其视为返回 JSX 的函数的参数。 这样，你就可以在函数体中访问该值。 但对于类组件，访问方式会略有不同。</p>
<hr>
<p>代码编辑器中有 <code>Calendar</code> 和 <code>CurrentDate</code> 组件。 从 <code>Calendar</code> 组件渲染 <code>CurrentDate</code> 时，从 JavaScript 的 <code>Date</code> 对象分配当前日期，并将其作为 <code>date</code> 属性传入。 然后访问 <code>CurrentDate</code> 组件的 <code>prop</code>，并在 <code>p</code> 标签中显示其值。 请注意，要将 <code>prop</code> 的值视为 JavaScript，必须将它们括在花括号中，例如<code>date=&#123;Date()&#125;</code>。</p>
<h3 id="15-传递一个数组作为-Props"><a href="#15-传递一个数组作为-Props" class="headerlink" title="15. 传递一个数组作为 Props"></a>15. 传递一个数组作为 Props</h3><p>上一个挑战演示了如何将来自父组件的信息作为 <code>props</code> 传递给子组件。 这个挑战着眼于如何将数组作为 <code>props</code> 传递。 要将数组传递给 JSX 元素，必须将其视为 JavaScript 并用花括号括起来。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ParentComponent</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">colors</span>=<span class="string">&#123;[</span>&quot;<span class="attr">green</span>&quot;, &quot;<span class="attr">blue</span>&quot;, &quot;<span class="attr">red</span>&quot;]&#125; /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ParentComponent</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这样，子组件就可以访问数组属性 <code>colors</code>。 访问属性时可以使用 <code>join()</code> 等数组方法。 <code>const ChildComponent = (props) =&gt; &lt;p&gt;&#123;props.colors.join(&#39;, &#39;)&#125;&lt;/p&gt;</code> 这将把所有 <code>colors</code> 数组项连接成一个逗号分隔的字符串并生成： <code>&lt;p&gt;green, blue, red&lt;/p&gt;</code> 稍后，我们将了解在 React 中渲染数组数据的其他常用方法。</p>
<hr>
<p>代码编辑器中有 <code>List</code> 和 <code>ToDo</code> 组件。 在 <code>ToDo</code> 组件中渲染每个 <code>List</code> 时，传入 <code>tasks</code> 属性并将其分配给待办任务数组，例如 <code>[&quot;walk dog&quot;, &quot;workout&quot;]</code>。 然后访问 <code>List</code> 组件中的 <code>tasks</code> 数组，在<code>p</code>元素中显示其值。 使用 <code>join(&quot;, &quot;)</code> 把 <code>props.tasks</code> 数组作为逗号分隔列表显示在 <code>p</code> 元素中。 今天的列表应该至少有 2 个任务，明天的列表应该至少有 3 个任务。</p>
<h3 id="16-使用默认的-Props"><a href="#16-使用默认的-Props" class="headerlink" title="16. 使用默认的 Props"></a>16. 使用默认的 Props</h3><p>React 还有一个设置默认 props 的选项。 可以将默认 props 作为组件本身的属性分配给组件，React 会在必要时分配默认 prop。 如果没有显式的提供任何值，这允许指定 prop 值应该是什么。 例如，如果声明 <code>MyComponent.defaultProps = &#123; location: &#39;San Francisco&#39; &#125;</code>，即定义一个 location 属性，并且其值在没有另行制定的情况下被设置为字符串 <code>San Francisco</code>。 如果 props 未定义，则 React 会分配默认 props，但如果你将 <code>null</code> 作为 prop 的值，它将保持 <code>null</code>。</p>
<hr>
<p>代码编辑器中有一个 <code>ShoppingCart</code> 组件。 在这个组件上定义默认 props，它指定一个 <code>items</code> prop，其值为 <code>0</code>。</p>
<h3 id="17-覆盖默认的-Props"><a href="#17-覆盖默认的-Props" class="headerlink" title="17. 覆盖默认的 Props"></a>17. 覆盖默认的 Props</h3><p>在 React 中，设置默认的 props 是一个很有用的特性， 显式设置组件的 prop 值即可覆盖默认 props。</p>
<hr>
<p><code>ShoppingCart</code> 组件现在渲染了一个子组件 <code>Items</code>。 该 <code>Items</code> 组件有一个默认 <code>quantity</code> prop，其值被设置为整数 <code>0</code>。 通过传入数值 <code>10</code> 来覆盖 <code>quantity</code> 的默认 prop。</p>
<p><strong>注意：</strong> 请记住，向组件添加 prop 的语法与添加 HTML 属性类似。 但是，由于 <code>quantity</code> 的值是整数，所以它不会加引号，但应该用花括号括起来， 例如<code>&#123;100&#125;</code>。 这个语法告诉 JSX 直接将花括号中的值解释为 JavaScript。</p>
<h3 id="18-使用-PropTypes-来定义-Props-的类型"><a href="#18-使用-PropTypes-来定义-Props-的类型" class="headerlink" title="18. 使用 PropTypes 来定义 Props 的类型"></a>18. 使用 PropTypes 来定义 Props 的类型</h3><p>React 提供了有用的类型检查特性，以验证组件是否接收了正确类型的 props。 例如，应用程序调用 API 来检索数据是否是数组，然后将数据作为 prop 传递给组件。 可以在组件上设置 <code>propTypes</code>，以要求数据的类型为 <code>array</code>。 当数据是任何其它类型时，都会抛出警告。</p>
<p>当提前知道 prop 的类型时，最佳实践是设置其 <code>propTypes</code>。 可以为组件定义 <code>propTypes</code> 属性，方法与定义 <code>defaultProps</code> 相同。 这样做将检查一个键的 prop 是否是给定类型。 这里有一个示例，表示名为 <code>handleClick</code> 的 prop 应为 <code>function</code> 类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyComponent</span>.<span class="property">propTypes</span> = &#123; <span class="attr">handleClick</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>PropTypes.func</code> 部分检查 <code>handleClick</code> 是否为函数。 添加 <code>isRequired</code>，告诉 React <code>handleClick</code> 是该组件的必需属性。 如果没有那个属性，将出现警告。 还要注意 <code>func</code> 代表 <code>function</code> 。 在 7 种 JavaScript 原始类型中，<code>function</code> 和 <code>boolean</code>（写为 <code>bool</code> ）是唯一使用异常拼写的两种类型。 除了原始类型，还有其他类型可用。 例如，你可以检查 prop 是否为 React 元素。 请查看<a target="_blank" rel="noopener" href="https://reactjs.org/docs/typechecking-with-proptypes.html#proptypes">文档</a>以获取所有选项。</p>
<p><strong>注意：</strong>在 React v15.5.0 中, <code>PropTypes</code> 可以从 React 中单独引入，例如：<code>import PropTypes from &#39;prop-types&#39;;</code>。</p>
<hr>
<p>为 <code>Items</code> 组件定义 <code>propTypes</code>，以要求 <code>quantity</code> 作为 prop，并验证它是否为 <code>number</code> 类型。</p>
<h3 id="19-使用-this-props-访问-Props"><a href="#19-使用-this-props-访问-Props" class="headerlink" title="19. 使用 this.props 访问 Props"></a>19. 使用 this.props 访问 Props</h3><p>前几项挑战涵盖了将 props 传递给子组件的基本方法。 但是，倘若接收 prop 的子组件不是无状态函数组件，而是一个 ES6 类组件，又当如何呢？ ES6 类组件访问 props 的方法略有不同。</p>
<p>任何时候，如果要引用类组件本身，可以使用 <code>this</code> 关键字。 要访问类组件中的 props，需要在在访问它的代码前面添加 <code>this</code>。 例如，如果 ES6 类组件有一个名为 <code>data</code> 的 prop，可以在 JSX 中这样写：<code>&#123;this.props.data&#125;</code>。</p>
<hr>
<p>在父组件 <code>App</code> 中渲染 <code>Welcome</code> 组件的一个实例。 在这里，给 <code>Welcome</code> 一个 <code>name</code> 的 prop，并给它赋值一个字符串。 在 <code>Welcome</code> 的子节点里，访问 <code>strong</code> 标签内的 <code>name</code> prop。</p>
<h3 id="20-复习使用无状态函数组件的-Props"><a href="#20-复习使用无状态函数组件的-Props" class="headerlink" title="20. 复习使用无状态函数组件的 Props"></a>20. 复习使用无状态函数组件的 Props</h3><p>除了上一个挑战，一直在将 props 传递给无状态的函数组件。 这些组件就像纯函数， 它们接收 props 作为输入，并在每次传递相同 props 时返回相同的视图。 你可能好奇什么是状态，下一个挑战将会更详细地讲述它。 在此之前，我们先来回顾一下组件的术语。</p>
<p><em>无状态函数组件</em>是一个函数，它接收 props 作为输入并返回 JSX。 另一方面，<em>无状态组件</em>是一个类，它扩展了<code>React.Component</code>，但是不使用内部状态（下一个挑战中讨论）。 最后，<em>状态组件</em>是指维护其自身内部状态的组件， 它简称组件或 React 组件。</p>
<p>一种常见的应用模式是尽可能减少状态组件并创建无状态的函数组件。 这有助于将状态管理包含到应用程序的特定区域。 反过来，通过更容易地跟踪状态变化如何影响其行为，可以改善应用程序的开发和维护。</p>
<hr>
<p>在代码编辑器中有一个 <code>CampSite</code> 组件，它把 <code>Camper</code> 组件渲染为自己的子组件。 定义 <code>Camper</code> 组件，并为其分配默认 props <code>&#123; name: &#39;CamperBot&#39; &#125;</code>。 可以在 <code>Camper</code> 组件内部渲染任何你想要的代码，但是要确保有一个 <code>p</code> 元素，它只包含作为 <code>prop</code> 传递的 <code>name</code> 值。 最后，在 <code>Camper</code> 组件上定义 <code>propTypes</code>，要求提供 <code>name</code> 作为 prop，并验证它是 <code>string</code> 类型。</p>
<h3 id="21-创建一个有状态的组件"><a href="#21-创建一个有状态的组件" class="headerlink" title="21. 创建一个有状态的组件"></a>21. 创建一个有状态的组件</h3><p>React 中最重要的主题之一是 <code>state</code>。 state 包含应用程序需要了解的任何数据，这些数据可能会随时间而变化。 应用程序能够响应 state 的变更，并在必要时显示更新后的 UI。 React 为现代 Web 应用程序的状态管理提供了一个很好的解决方案。</p>
<p>可以在类组件的 <code>constructor</code> 上声明 <code>state</code> 属性来在 React 组件中创建 state， 它在创建时使用 <code>state</code> 初始化组件。 <code>state</code> 属性必须设置为 JavaScript <code>object</code>（对象）。 声明如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在组件的整个生命周期内访问 <code>state</code> 对象， 可以更新它、在 UI 中渲染它，也可以将其作为 props 传递给子组件。 <code>state</code> 对象的使用可以很简单，亦可以很复杂，就看你怎么用了。 请注意，必须通过扩展 <code>React.Component</code> 来创建类组件，以便像这样创建 <code>state</code>。</p>
<hr>
<p>在代码编辑器里，有一个组件尝试渲染 <code>state</code> 中的 <code>firstName</code> 属性。 但是 <code>state</code> 还没有定义。 在 <code>constructor</code> 中使用 <code>state</code> 初始化这个组件，并将你的名字赋值给 <code>firstName</code> 属性。</p>
<h3 id="22-在用户界面中渲染状态"><a href="#22-在用户界面中渲染状态" class="headerlink" title="22. 在用户界面中渲染状态"></a>22. 在用户界面中渲染状态</h3><p>定义了组件的初始 state 之后，就可以在要渲染的 UI 中显示它。 如果组件是有状态的，它将始终可以访问 <code>render()</code> 方法中 <code>state</code> 的数据。 就可以使用 <code>this.state</code> 访问数据。</p>
<p>如果想在 render 方法的 <code>return</code> 中访问 state 值，必须把这个值用花括号括起来。</p>
<p><code>state</code> 是 React 组件中最强大的特性之一， 它可以跟踪应用程序中的重要数据，并根据数据的变化渲染 UI。 如果数据发生变化，UI 也会随之改变。 React 使用所谓的虚拟 DOM 来跟踪幕后的变化。 当 state 数据更新时，它会使用该数据触发组件的重新渲染 – 包括接收 prop 数据的子组件。 React 只在必要的时候更新实际的 DOM， 这意味着你不必担心 DOM 的变更， 只需声明 UI 的外观即可。</p>
<p>注意，如果组件是有状态的，其它组件并不知道它的 <code>state</code>。 它的 <code>state</code> 是完全封装的，或者是局限于组件本身的，除非你将 state 数据作为 <code>props</code> 传递给子组件。 封装 <code>state</code> 的概念非常重要，因为它允许编写特定的逻辑，然后将该逻辑包含并隔离在代码中的某个位置。</p>
<hr>
<p>在代码编辑器中，<code>MyComponent</code> 是一个有状态组件， 在组件的 render 方法中定义一个<code>h1</code>标签，该方法从组件的 state 渲染 <code>name</code> 的值。</p>
<p><strong>注意：</strong> <code>h1</code> 应该只渲染来自 <code>state</code> 的值。 在 JSX 中，使用花括号 <code>&#123; &#125;</code> 编写的任何代码都将被视为 JavaScript。 因此，要访问 <code>state</code> 中的值，只需将引用括在花括号中即可。</p>
<h3 id="23-以另一种方式在用户界面中渲染状态"><a href="#23-以另一种方式在用户界面中渲染状态" class="headerlink" title="23. 以另一种方式在用户界面中渲染状态"></a>23. 以另一种方式在用户界面中渲染状态</h3><p>还有另一种方法可以访问组件中的 <code>state</code>。 在 <code>render()</code> 方法中，在 <code>return</code> 语句之前，可以直接编写 JavaScript。 例如，可以声明函数、从 <code>state</code> 或 <code>props</code> 中访问数据、对此数据执行计算等。 然后，可以将任何数据赋值给 <code>return</code> 语句中可以访问的变量。</p>
<hr>
<p>在 <code>MyComponent</code> 的 render 方法中，定义一个名为 <code>name</code> 的 <code>const</code>（常量），并将其设置为组件 <code>state</code> 中的 name 值。 因为可以直接在代码部分编写 JavaScript，所以不需要用大括号括起来。</p>
<p>接下来，在 return 语句中，在 <code>h1</code> 标签中渲染变量 <code>name</code> 的值。 记住，在 return 语句中需要使用 JSX 语法（用到 JavaScript 的花括号）。</p>
<h3 id="24-用-this-setState-设置状态"><a href="#24-用-this-setState-设置状态" class="headerlink" title="24. 用 this.setState 设置状态"></a>24. 用 this.setState 设置状态</h3><p>前面的挑战涵盖了组件的 <code>state</code> 以及如何在 <code>constructor</code> 中初始化 state。 还有一种方法可以更改组件的 <code>state</code>。 React 提供了 <code>setState</code> 方法来更新组件的 <code>state</code>。 在组件类中调用 <code>setState</code> 方法如下所示：<code>this.setState()</code>，传入键值对的对象， 其中键是 state 属性，值是更新后的 state 数据。 例如，如果我们在 state 中存储 <code>username</code>，并想要更新它，代码如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;Lewis&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>React 要求永远不要直接修改 <code>state</code>，而是在 state 发生改变时始终使用 <code>this.setState()</code>。 此外，应该注意，React 可以批量处理多个 state 更新以提高性能。 这意味着通过 <code>setState</code> 方法进行的 state 更新可以是异步的。 <code>setState</code> 方法有一种替代语法可以解决异步问题， 虽然这很少用到，但是最好还是记住它！ 请查阅我们的 <a target="_blank" rel="noopener" href="https://www.freecodecamp.org/chinese/news/what-is-state-in-react-explained-with-examples/">React 文章</a>了解更多详情。</p>
<hr>
<p>代码编辑器中有一个 <code>button</code> 元素，它有一个 <code>onClick()</code> handler。 当 <code>button</code> 在浏览器中接收到单击事件时触发此 handler，并运行 <code>MyComponent</code> 中定义的 <code>handleClick</code> 方法。 在 <code>handleClick</code> 方法中，使用 <code>this.setState()</code> 更新组件的 <code>state</code>。 设置 <code>state</code> 中的 <code>name</code> 属性为字符串 <code>React Rocks!</code></p>
<h3 id="25-将-this-绑定到-Class-方法上"><a href="#25-将-this-绑定到-Class-方法上" class="headerlink" title="25. 将 this 绑定到 Class 方法上"></a>25. 将 this 绑定到 Class 方法上</h3><p>除了设置和更新 <code>state</code> 之外，还可以为组件类定义方法。 类方法通常需要使用 <code>this</code> 关键字，以便它可以访问方法中类的属性（例如 <code>state</code> 和 <code>props</code>）。 有几种方法可以让类方法访问 <code>this</code>。</p>
<p>一种常见的方法是在构造函数中显式地绑定 <code>this</code>，这样当组件初始化时，<code>this</code> 就会绑定到类方法。 你可能已经注意到上一个挑战在构造函数中的 <code>handleClick</code> 方法使用了 <code>this.handleClick = this.handleClick.bind(this)</code>。 然后，当在类方法中调用像 <code>this.setState()</code> 这样的函数时，<code>this</code> 指的是这个类，而不是 <code>undefined</code>。</p>
<p><strong>注意：</strong> <code>this</code>关键字是 JavaScript 中最令人困惑的方面之一，但它在 React 中扮演着重要的角色。 虽然它的行为在这里是完全正常的，但是这些课程并不深入研究<code>this</code>，所以如果以上内容令你感到困惑，请参考其他课程！</p>
<hr>
<p>代码编辑器有一个带有 <code>state</code> 的组件，用于跟踪项目计数。 它还有一个方法，允许设置文本为 <code>You clicked!</code>。 但是，该方法不起作用，因为它使用了未定义的 <code>this</code> 关键字。 可以通过将 <code>this</code> 显式绑定到组件构造函数中的 <code>handleClick()</code>方法来修复它。</p>
<p>接下来，向 render 方法中的 <code>button</code> 元素添加一个单击处理程序。 当按钮接收到单击事件时，它应该触发 <code>handleClick()</code> 方法。 记住，传递给 <code>onClick</code> 处理程序的方法需要使用花括号，因为它应该直接被解释为 JavaScript。</p>
<p>完成上述步骤后，可以单击按钮并看到 <code>You clicked!</code>。</p>
<h3 id="26-使用-State-切换元素"><a href="#26-使用-State-切换元素" class="headerlink" title="26. 使用 State 切换元素"></a>26. 使用 State 切换元素</h3><p>有时可能在更新状态的时候想知道上一个状态是什么。 但是状态更新是异步的，这意味着 React 可能会把多个 <code>setState()</code> 集中在一起批量更新。 所以计算下一个值时 <code>this.state</code> 或者 <code>this.props</code> 不能作为当前值。 所以最好不要写如下的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">increment</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>正确的做法是，给 <code>setState</code> 传入一个函数，这个函数可以访问 state 和 props。 给 <code>setState</code> 传入函数可以保证 state 和 props 是正确的值。 代码可以重写为这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>如果只需要 <code>state</code>，那么用下面没有 <code>props</code> 的格式也是可以的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.<span class="property">counter</span> + <span class="number">1</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>注意一定要把 object 放在括号里，否则 JavaScript 会认为这只是代码片段。</p>
<hr>
<p><code>MyComponent</code> 有一个初始值为 <code>false</code> 的<code>visibility</code> 属性。 如果 <code>visibility</code> 的值为 true，render 方法返回一个视图，如果为 false，返回另一个视图。</p>
<p>目前，无法更新组件 <code>state</code> 中的 <code>visibility</code> 属性， 该值应在 true 和 false 之间来回切换。 按钮上有一个单击处理程序，它触发一个名为 <code>toggleVisibility()</code> 的类方法。 给函数传入 <code>setState</code> 来定义此方法，以便 <code>visibility</code> 的 <code>state</code> 在调用方法时切换到相反的值。 如果 <code>visibility</code> 是 <code>false</code>，则该方法将其设置为<code>true</code>，反之亦然。</p>
<p>最后，单击按钮以查看基于其 <code>state</code> 的组件的条件渲染。</p>
<p><strong>提示：</strong> 不要忘记将 <code>this</code> 关键字绑定到 <code>constructor</code> 中的方法上！</p>
<h3 id="27-写一个简单的计数器"><a href="#27-写一个简单的计数器" class="headerlink" title="27. 写一个简单的计数器"></a>27. 写一个简单的计数器</h3><p>可以结合目前为止所涵盖的概念来设计更复杂的有状态组件。 这包括初始化 <code>state</code>，编写设置 <code>state</code> 的方法，以及指定单击处理程序来触发这些方法。</p>
<hr>
<p><code>Counter</code> 组件跟踪 <code>state</code> 中的 <code>count</code> 值。 有两个按钮分别调用 <code>increment()</code> 和 <code>decrement()</code> 方法。 编写这些方法，使计数器值在单击相应按钮时增加或减少 1。 另外，创建一个 <code>reset()</code> 方法，当单击 reset 按钮时，把计数设置为 0。</p>
<p><strong>注意：</strong> 确保没有修改按钮的 <code>className</code>。 另外，请记住在构造函数中为新创建的方法添加必要的绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">increment</span> = <span class="variable language_">this</span>.<span class="property">increment</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">decrement</span> = <span class="variable language_">this</span>.<span class="property">decrement</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reset</span> = <span class="variable language_">this</span>.<span class="property">reset</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="title function_">reset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#x27;inc&#x27;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#x27;dec&#x27;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.decrement&#125;</span>&gt;</span>Decrement!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#x27;reset&#x27;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.reset&#125;</span>&gt;</span>Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Current Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="28-创建一个可以控制的输入框"><a href="#28-创建一个可以控制的输入框" class="headerlink" title="28. 创建一个可以控制的输入框"></a>28. 创建一个可以控制的输入框</h3><p>应用程序可能在 <code>state</code> 和渲染的 UI 之间有更复杂的交互。 例如，用于文本输入的表单控件元素（如 <code>input</code> 和 <code>textarea</code>）在用户键入时在 DOM 中维护自己的 state。 通过 React，可以将这种可变 state 转移到 React 组件的 <code>state</code> 中。 用户的输入变成了应用程序 <code>state</code> 的一部分，因此 React 控制该输入字段的值。 通常，如果 React 组件具有用户可以键入的输入字段，那么它将是一个受控的输入表单。</p>
<hr>
<p>代码编辑器具有一个名为 <code>ControlledInput</code> 的组件框架，用于创建受控的 <code>input</code> 元素。 组件的 <code>state</code> 已经被包含空字符串的 <code>input</code> 属性初始化。 此值表示用户在 <code>input</code> 字段中键入的文本。</p>
<p>首先，创建一个名为 <code>handleChange()</code> 的方法，该方法具有一个名为 <code>event</code> 的参数。 方法被调用时，它接收一个 <code>event</code> 对象，该对象包含一个来自 <code>input</code> 元素的字符串文本。 可以使用方法内的 <code>event.target.value</code> 来访问这个字符串。 用这个新字符串更新组件的<code>state</code>的<code>input</code>属性。</p>
<p>在 <code>render</code> 方法中的 <code>h4</code> 标签之上创建 <code>input</code> 元素。 添加一个 <code>value</code> 属性，使其等于组件 <code>state</code> 的 <code>input</code> 属性。 然后将 <code>onChange()</code> 事件处理程序设置到 <code>handleChange()</code> 方法中。</p>
<p>在输入框中键入时，文本由 <code>handleChange()</code> 方法处理，文本被设置为本地 <code>state</code> 中的 <code>input</code> 属性，并渲染在页面上的 <code>input</code> 框中。 组件 <code>state</code> 是输入数据的唯一真实来源。</p>
<p>最后，不要忘记在构造函数中添加必要的绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ControlledInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Change code below this line</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// Change code above this line</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Change code below this line</span></span><br><span class="line">  handleChange (event) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Change code above this line</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; /* Change code below this line */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;this.state.input&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; /* Change code above this line */&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Controlled Input:<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.input&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="29-创建一个可以控制的表单"><a href="#29-创建一个可以控制的表单" class="headerlink" title="29. 创建一个可以控制的表单"></a>29. 创建一个可以控制的表单</h3><p><code>MyForm</code> 组件中是一个带有提交处理程序的空 <code>form</code> 元素， 提交处理程序将在提交表单时被调用。</p>
<p>我们增加了一个提交表单的按钮。 可以看到它的 <code>type</code> 被设置为 <code>submit</code>，表明它是控制表单提交的按钮。 在 <code>form</code> 中添加 <code>input</code> 元素，并像上个挑战一样设置其 <code>value</code> 和 <code>onChange()</code> 属性。 然后，应该完成 <code>handleSubmit</code> 方法，以便将组件 state 属性 <code>submit</code> 设置为本地 <code>state</code> 下的当前输入值。</p>
<p><strong>注意：</strong> 还必须在提交处理程序中调用 <code>event.preventDefault()</code>，以防止将会刷新网页的默认的表单提交行为。 为了便于学员操作，默认行为在这里被禁用，以防止重置挑战的代码。</p>
<p>最后，在 <code>form</code> 元素之后创建一个 <code>h1</code> 标签，该标签从组件的 <code>state</code> 渲染 <code>submit</code> 的值。 然后，可以在表单中键入任何内容，然后单击按钮（或按 enter 键），输入会渲染到页面上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">input</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">submit</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">input</span>: event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改这行下面的代码</span></span><br><span class="line">      event.<span class="title function_">preventDefault</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">submit</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">input</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 修改这行上面的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;this.state.input&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span>&gt;</span>Submit!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.state.submit&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30-将-State-作为-Props-传递给子组件"><a href="#30-将-State-作为-Props-传递给子组件" class="headerlink" title="30. 将 State 作为 Props 传递给子组件"></a>30. 将 State 作为 Props 传递给子组件</h3><p>在之前的挑战中，看到了很多将 props 传递给子 JSX 元素和子 React 组件的例子。 你可能想知道那些 props 是从哪里来的。 一个常见的模式是：有状态组件中包含对应用程序很重要的 <code>state</code>，然后用它渲染子组件。 如果想让这些组件能够访问该 <code>state</code> 的某些部分，就把这些部分作为 props 传入。</p>
<p>例如，有一个 <code>App</code> 组件可以渲染 <code>Navbar</code> 以及其他组件。 <code>App</code> 里的 <code>state</code> 包含大量用户信息，但 <code>Navbar</code> 只需要访问用户的用户名，以便显示它。 将该 <code>state</code> 作为 prop 传递给<code>Navbar</code>组件。</p>
<p>这个模式说明了 React 中的一些重要范例。 第一个是<em>单向数据流</em>， state 沿着应用程序组件树的一个方向流动，从有状态父组件到子组件， 子组件只接收它们需要的 state 数据。 第二，复杂的有状态应用程序可以分解成几个，或者可能是一个单一的有状态组件。 其余组件只是从父组件简单的接收 state 作为 props，并从该 state 渲染 UI。 它开始创建一种分离，在这种分离中，state 管理在代码的一部分中处理，而 UI 渲染在另一部分中处理。 将 state 逻辑与 UI 逻辑分离是 React 的关键原则之一。 当它被正确使用时，它使得复杂的、有状态的应用程序的设计变得更容易管理。</p>
<hr>
<p><code>MyApp</code> 组件是有状态的，并将 <code>Navbar</code> 组件渲染为子组件。 将 <code>state</code> 的 <code>name</code> 属性向下传递给子组件，然后在 <code>h1</code> 中显示该 <code>name</code> ，h1 是 <code>Navbar</code> render方法的一部分。 <code>name</code> 应该显示在文本 <code>Hello, my name is:</code> 后面。</p>
<h3 id="31-传递回调作为-Props"><a href="#31-传递回调作为-Props" class="headerlink" title="31. 传递回调作为 Props"></a>31. 传递回调作为 Props</h3><p>可以将 <code>state</code> 作为 props 传递给子组件，但不仅限于传递数据。 你也可以将处理函数或在 React 组件中定义的任何方法传递给子组件。 这就是子组件与父组件交互的方式。 可以把方法像普通 prop 一样传递给子组件， 它会被分配一个名字，可以在子组件中的 <code>this.props</code> 下访问该方法的名字。</p>
<hr>
<p>代码编辑器中列出了三个组件。 <code>MyApp</code> 是父组件，<code>GetInput</code> 和<code>RenderInput</code> 是它将要渲染的子组件。 将 <code>GetInput</code> 组件添加到 <code>MyApp</code> 的 render 方法，然后将 <code>MyApp</code> 的 <code>state</code> 中的 <code>inputValue</code> 传入名为 <code>input</code> 的 prop。 还要创建一个名为 <code>handleChange</code> 的 prop，并将输入处理程序 <code>handleChange</code> 传递给它。</p>
<p>接下来，将 <code>RenderInput</code> 添加到 <code>MyApp</code> 中的 render 方法中，然后创建一个名为 <code>input</code> 的 prop，并将 <code>state</code> 中的 <code>inputValue</code> 传递给它。 完成后，可以在 <code>GetInput</code> 组件中的 <code>input</code> 字段中键入内容，然后该组件通过 props 调用其父组件中的处理函数方法。 这将更新处于父组件 <code>state</code> 中的 input，该 input 将作为 props 传递给两个子组件。 观察数据如何在组件之间流动，以及单一数据源如何保持父组件<code>state</code>。 诚然，这个示例有点刻意，但是应该能用来说明数据和回调是如何在 React 组件之间传递的。</p>
<h3 id="32-使用生命周期方法-componentWillMount"><a href="#32-使用生命周期方法-componentWillMount" class="headerlink" title="32. 使用生命周期方法 componentWillMount"></a>32. 使用生命周期方法 componentWillMount</h3><p>React 组件有几种特殊方法，可以在组件生命周期的特定点执行操作。 这些称为生命周期方法或生命周期钩子，允许在特定时间点捕获组件。 这可以在渲染之前、更新之前、接收 props 之前、卸载之前等等。 以下是一些主要生命周期方法的列表： <code>componentWillMount()</code> <code>componentDidMount()</code> <code>shouldComponentUpdate()</code> <code>componentDidUpdate()</code> <code>componentWillUnmount()</code> 接下来的几节课将讲述这些生命周期方法的一些基本用例。</p>
<hr>
<p>当组件被挂载到 DOM 时，<code>componentWillMount()</code> 方法在 <code>render()</code> 方法之前被调用。 在 <code>componentWillMount()</code> 中将一些内容记录到控制台 – 可能需要打开浏览器控制台以查看输出。</p>
<h3 id="33-使用生命周期方法：componentDidMount"><a href="#33-使用生命周期方法：componentDidMount" class="headerlink" title="33. 使用生命周期方法：componentDidMount"></a>33. 使用生命周期方法：componentDidMount</h3><p>某些时候，大多数 web 开发人员需要调用 API 接口来获取数据。 如果正在使用 React，知道在哪里执行这个动作是很重要的。</p>
<p>React 的最佳实践是在生命周期方法 <code>componentDidMount()</code> 中对服务器进行 API 调用或任何其它调用。 将组件装载到 DOM 后会调用此方法。 此处对 <code>setState()</code> 的任何调用都将触发组件的重新渲染。 在此方法中调用 API 并用 API​​ 返回的数据设置 state 时，一旦收到数据，它将自动触发更新。</p>
<hr>
<p><code>componentDidMount()</code> 中有一个模拟 API 调用。 它在 2.5 秒后设置 state，以模拟调用服务器检索数据。 本示例请求站点的当前活动用户总数。 在 render 方法中，把 <code>activeUsers</code> 渲染到文字 <code>Active Users:</code> 后的 <code>h1</code> 标签中。 观看预览中发生的事情，随意更改超时时间以查看不同的效果。</p>
<h3 id="34-添加事件侦听器"><a href="#34-添加事件侦听器" class="headerlink" title="34. 添加事件侦听器"></a>34. 添加事件侦听器</h3><p><code>componentDidMount()</code> 方法也是添加特定功能所需的任何事件监听器的最佳位置。 React 提供了一个合成事件系统，它封装了浏览器中的事件系统。 这意味着，不管用户用的是什么浏览器，合成事件系统的行为都完全相同 – 即使不同浏览器之间的本地事件的行为可能不同。</p>
<p>之前已经接触了一些合成事件处理程序，如<code>onClick()</code>。 React 的合成事件系统非常适合用于在 DOM 元素上管理的大多数交互。 但是，如果要将事件处理程序附加到 document 或 window 对象，则必须直接执行此操作。</p>
<hr>
<p>在 <code>componentDidMount()</code> 方法中为 <code>keydown</code> 事件添加事件监听器，并让这些事件触发回调 <code>handleKeyPress()</code>。 可以使用 <code>document.addEventListener()</code>，它将事件（用引号括起来）作为第一个参数，将回调作为第二个参数。</p>
<p>然后，在 <code>componentWillUnmount()</code> 中移除相同的事件监听器。 可以把相同的参数传递给 <code>document.removeEventListener()</code>。 在卸载和销毁 React 组件之前，最好在这个生命周期方法中对它们进行清理。 移除事件监听器就是这样一个清理操作的例子。</p>
<h3 id="35-使用-shouldComponentUpdate-优化重新渲染"><a href="#35-使用-shouldComponentUpdate-优化重新渲染" class="headerlink" title="35. 使用 shouldComponentUpdate 优化重新渲染"></a>35. 使用 shouldComponentUpdate 优化重新渲染</h3><p>到目前为止，如果任何组件接收到新的 <code>state</code> 或新的 <code>props</code>，它会重新渲染自己及其所有子组件。 这通常是好的。 但是 React 提供了一种生命周期方法，当子组件接收到新的 <code>state</code> 或 <code>props</code> 时，可以调用该方法，并特别声明组件是否应该更新。 这个方法就是 <code>shouldComponentUpdate()</code>，它将 <code>nextProps</code> 和 <code>nextState</code> 作为参数。</p>
<p>这种方法是优化性能的有效方法。 例如，默认行为是，当组件接收到新的 <code>props</code> 时，即使 <code>props</code> 没有改变，它也会重新渲染。 可以通过使用 <code>shouldComponentUpdate()</code> 比较 <code>props</code> 来防止这种情况发生。 该方法必须返回一个 <code>boolean</code>（布尔值），该值告诉 React 是否更新组件。 可以比较当前的 props（<code>this.props</code>）和下一个 props（<code>nextProps</code>），以确定你是否需要更新，并相应地返回 <code>true</code> 或 <code>false</code>。</p>
<hr>
<p>将 <code>shouldComponentUpdate()</code> 方法添加到名为 <code>OnlyEvens</code> 的组件中。 目前，该方法返回 <code>true</code>，因此每次收到新的 <code>props</code> 时，<code>OnlyEvens</code> 都会重新渲染。 修改该方法，以便 <code>OnlyEvens</code> 仅在其新 props 的 <code>value</code> 为偶数时更新。 单击 <code>Add</code> 按钮，在触发其他生命周期钩子时，在浏览器控制台中查看事件的顺序。</p>
<h3 id="36-介绍内联样式"><a href="#36-介绍内联样式" class="headerlink" title="36. 介绍内联样式"></a>36. 介绍内联样式</h3><p>如果从样式表导入样式，它就没有太大的不同。 使用 <code>className</code> 属性将 class 应用于 JSX 元素，并将样式应用于样式表中的 class。 另一种选择是使用内联样式，这在 ReactJS 开发中非常常见。</p>
<p>将内联样式应用于 JSX 元素，类似于在 HTML 中的操作方式，但有一些 JSX 差异。 以下是 HTML 中内联样式的示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;color: yellow; font-size: 16px&quot;</span>&gt;<span class="title class_">Mellow</span> <span class="title class_">Yellow</span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>JSX 元素使用 <code>style</code> 属性，但是鉴于 JSX 的编译方式，不能将值设置为 <code>string</code>（字符串）。 相反，你应该将其设置为等于 JavaScript <code>object</code> 。 如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">&quot;yellow&quot;</span>, <span class="attr">fontSize</span>: <span class="number">16</span>&#125;&#125;&gt;<span class="title class_">Mellow</span> <span class="title class_">Yellow</span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>注意到如何驼峰拼写 <code>fontSize</code> 属性了吗？ 这是因为 React 不接受样式对象中的 kebab-case 键。 React 将在 HTML 中为应用正确的属性名称。</p>
<hr>
<p>在代码编辑器中给 <code>div</code> 添加一个 <code>style</code> 属性，将文本颜色设置为红色，字体大小设置为 <code>72px</code>。</p>
<p>请注意，可以选择将字体大小设置为数字，省略单位 <code>px</code>，或者将其写为 <code>72px</code>。</p>
<h3 id="37-在-React-中添加内联样式"><a href="#37-在-React-中添加内联样式" class="headerlink" title="37. 在 React 中添加内联样式"></a>37. 在 React 中添加内联样式</h3><p>在上一次挑战中，你可能已经注意到，除了设置为 JavaScript 对象的 <code>style</code> 属性之外，与 HTML 内联样式相比，React 的内联样式还有其他几个语法差异。 首先，某些 CSS 样式属性的名称使用驼峰式命名。 例如，最后一个挑战用 <code>fontSize</code> 而不是 <code>font-size</code> 来设置字体的大小。 对于 JavaScript 对象属性来说，像 <code>font-size</code> 这样的连字符命名是无效的语法，所以 React 使用驼峰式命名。 通常，任何连字符的 style 属性在 JSX 中都是使用驼峰式命名的。</p>
<p>除非另有规定，否则所有属性值长度单位（如 <code>height</code>、<code>width</code> 和 <code>fontSize</code>）都假定为 <code>px</code>。 例如，如果要使用 <code>em</code>，可以用引号将值和单位括起来，例如 <code>&#123;fontSize: &quot;4em&quot;&#125;</code>。 除了默认为 <code>px</code> 的长度值之外，所有其他属性值都应该用引号括起来。</p>
<hr>
<p>如果你有大量样式，你可以将样式 <code>object</code>（对象）分配给一个常量，以保持代码组织有序。 在文件顶部将你的样式声明为全局变量。 定义一个 <code>styles</code> 常量，并将其声明为具有三个样式属性及对应值的 <code>object</code>（对象）。 使 <code>div</code> 的文字颜色为 <code>purple</code>、字体大小为 <code>40</code>、边框为 <code>2px solid purple</code>。 然后设置 <code>style</code> 属性，使其等于 <code>styles</code> 常量。</p>
<h3 id="38-在-React-Render-方法中使用-JavaScript"><a href="#38-在-React-Render-方法中使用-JavaScript" class="headerlink" title="38. 在 React Render 方法中使用 JavaScript"></a>38. 在 React Render 方法中使用 JavaScript</h3><p>在之前的挑战中，你学习了如何使用大括号 <code>&#123; &#125;</code> 将 JavaScript 代码插入到 JSX 代码中，用于访问 props、传递 props、访问 state、在代码中插入注释以及最近学习的定制组件样式等任务。 这些都是将 JavaScript 放在 JSX 中的常见用例，但是在 React 组件中使用 JavaScript 代码还有其他方式。</p>
<p>在 <code>render</code> 方法中编写 JavaScript，可以把 JavaScript 直接放在 <code>return</code> 语句之前，而<em><strong>不必</strong></em>将其插入大括号中。 这是因为它还不在 JSX 代码中。 如果之后想在 <code>return</code> 语句中的 JSX 代码<em>里面</em>使用变量时，可以将变量名放在大括号中。</p>
<hr>
<p>在提供的代码中，<code>render</code> 方法中有一个包含 20 个短语的数组，用于表示 20 世纪 80 年代经典魔术八球玩具中的答案。 绑定 <code>ask</code> 方法到按钮的单击事件，每次单击该按钮时，将生成随机数并将其存储为 state 中的 <code>randomIndex</code>。 在第 52 行，删除字符串 <code>change me!</code> 并重新分配 <code>answer</code> 常量，以便每次组件更新时，代码随机访问 <code>possibleAnswers</code> 数组的不同值。 最后，在 <code>p</code> 标签内插入 <code>answer</code> 常量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputStyle = &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">235</span>,</span><br><span class="line">  <span class="attr">margin</span>: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicEightBall</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">userInput</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">randomIndex</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ask</span> = <span class="variable language_">this</span>.<span class="property">ask</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">ask</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">userInput</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">randomIndex</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">20</span>),</span><br><span class="line">        <span class="attr">userInput</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">userInput</span>: event.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> possibleAnswers = [</span><br><span class="line">      <span class="string">&#x27;It is certain&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;It is decidedly so&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Without a doubt&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Yes, definitely&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;You may rely on it&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;As I see it, yes&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Outlook good&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Yes&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Signs point to yes&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Reply hazy try again&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Ask again later&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Better not tell you now&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Cannot predict now&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Concentrate and ask again&#x27;</span>,</span><br><span class="line">      <span class="string">&quot;Don&#x27;t count on it&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;My reply is no&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;My sources say no&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Most likely&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Outlook not so good&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Very doubtful&#x27;</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">const</span> answer = possibleAnswers[<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">randomIndex</span>]; <span class="comment">// 修改这一行</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&#123;this.state.userInput&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;inputStyle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.ask&#125;</span>&gt;</span>Ask the Magic Eight Ball!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Answer:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;/* 修改这行下面的代码 */&#125;</span></span><br><span class="line"><span class="language-xml">              &#123;answer&#125;</span></span><br><span class="line"><span class="language-xml">          &#123;/* 修改这行上面的代码 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-使用-If-Else-条件进行渲染"><a href="#39-使用-If-Else-条件进行渲染" class="headerlink" title="39. 使用 If-Else 条件进行渲染"></a>39. 使用 If-Else 条件进行渲染</h3><p>使用 JavaScript 控制渲染视图的另一个应用是按条件渲染元素。 当条件为真时，将呈现一个视图， 反之，则呈现另一种视图。 可以在 React 组件的 <code>render()</code> 方法中使用的标准 <code>if/else</code> 语句来实现这一点。</p>
<hr>
<p>MyComponent 的 state 中包含一个 <code>boolean</code>（布尔值），用于跟踪是否要在 UI 中显示某个元素。 <code>button</code> 切换此值的状态。 目前，它每次都呈现相同的 UI。 用 <code>if/else</code> 语句重写 <code>render()</code> 方法，如果 <code>display</code> 为 <code>true</code> 则返回当前标记。 否则，返回不带 <code>h1</code> 元素的标记。</p>
<p><strong>注意：</strong> 写 <code>if/else</code> 语句才能通过测试， 使用三元运算符是不会通过的。</p>
<h3 id="40-使用-amp-amp-获得更简洁的条件"><a href="#40-使用-amp-amp-获得更简洁的条件" class="headerlink" title="40. 使用 &amp;&amp; 获得更简洁的条件"></a>40. 使用 &amp;&amp; 获得更简洁的条件</h3><p><code>if/else</code> 语句在上一次挑战中是有效的，但是有一种更简洁的方法可以达到同样的结果。 假设正在跟踪组件中的几个条件，并且希望根据这些条件中的每一个来渲染不同的元素。 如果你写了很多 <code>else if</code> 语句来返回稍微不同的 UI，你可能会写很多重复代码，这就留下了出错的空间。 相反，你可以使用 <code>&amp;&amp;</code> 逻辑运算符以更简洁的方式执行条件逻辑。 这是完全可行的，因为你希望检查条件是否为 <code>true</code>。如果是，则返回一些标记。 下面是一个示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;condition &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>markup<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>condition</code> 为 <code>true</code>，则返回标记。 如果条件为 <code>false</code> ，则在评估 <code>condition</code> 后操作将立即返回 <code>false</code>，并且不返回任何内容。 可以将这些语句直接包含在 JSX 中，并通过在每个条件后面写 <code>&amp;&amp;</code> 来将多个条件串在一起。 这允许你在 <code>render()</code> 方法中处理更复杂的条件逻辑，而无需重复大量代码。</p>
<hr>
<p>再来看看前面的示例，<code>h1</code> 还是在 <code>display</code> 为 <code>true</code> 时渲染，但使用 <code>&amp;&amp;</code> 逻辑运算符代替 <code>if/else</code> 语句。</p>
<h3 id="41-使用三元表达式进行条件渲染"><a href="#41-使用三元表达式进行条件渲染" class="headerlink" title="41. 使用三元表达式进行条件渲染"></a>41. 使用三元表达式进行条件渲染</h3><p>在继续使用动态渲染技术之前，还有最后一种方法可以渲染想要的东西，它使用内置的 JavaScript 条件：三元运算符。 三元运算符经常被用作 JavaScript 中 <code>if/else</code> 语句的缩写。 它们不像传统的 <code>if/else</code> 语句那样强大，但是在 React 开发人员中非常流行， 原因之一就是 JSX 的编译原理，<code>if/else</code> 语句不能直接插入到 JSX 代码中。 可能你在前几个挑战就注意到了这一点——当需要 <code>if/else</code> 语句时，它总是在 <code>return</code> 语句的<em>外面</em>。 如果想在 JSX 中实现条件逻辑，三元表达式是一个很好的选择。 回想一下，三元运算符有三个部分，但是可以将多个三元表达式组合在一起。 以下是基本语法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expressionIfTrue : expressionIfFalse;</span><br></pre></td></tr></table></figure>

<hr>
<p>代码编辑器在 <code>CheckUserAge</code> 组件的 <code>render()</code> 方法中定义了三个常量， 它们分别是 <code>buttonOne</code>、<code>buttonTwo</code> 和 <code>buttonThree</code>。 每个都分配了一个表示按钮元素的简单 JSX 表达式。 首先，使用 <code>input</code> 和 <code>userAge</code> 初始化 <code>CheckUserAge</code> 的 state，并将其值设置为空字符串。</p>
<p>一旦组件将信息渲染给页面，用户应该有一种方法与之交互。 在组件的 <code>return</code> 语句中，设置一个实现以下逻辑的三元表达式：当页面首次加载时，将提交按钮 <code>buttonOne</code> 渲染到页面。 然后，当用户输入年龄并点击该按钮时，根据年龄渲染不同的按钮。 如果用户输入的数字小于<code>18</code>，则渲染<code>buttonThree</code>。 如果用户输入的数字大于或等于<code>18</code>，则渲染<code>buttonTwo</code>。</p>
<h3 id="42-使用-Props-有条件地渲染"><a href="#42-使用-Props-有条件地渲染" class="headerlink" title="42. 使用 Props 有条件地渲染"></a>42. 使用 Props 有条件地渲染</h3><p>到目前为止，你已经了解了如何使用 <code>if/else</code>、<code>&amp;&amp;</code> 和三元运算符（<code>condition ? expressionIfTrue : expressionIfFalse</code>）来决定渲染什么和何时渲染。 然而，还有一个重要的话题需要讨论，它可以让你将这些概念中的一个或所有与另一个强大的 React 特性结合起来：props。 使用 props 有条件地渲染代码对于 React 开发人员来说非常常见——也就是说，他们使用给定 props 的值来自动决定要渲染什么。</p>
<p>在这个挑战中，将设置一个子组件来根据 props 做出渲染决定。 可以使用三元运算符，但是可以看到过去几个挑战中涵盖的其他几个概念在这种情况下可能同样有用。</p>
<hr>
<p>代码编辑器有两个部分定义了的组件：一个名为 <code>GameOfChance</code> 的父组件和一个名为 <code>Results</code> 的子组件。 它们被用来创建一个简单的游戏，用户按下按钮来看它们是赢还是输。</p>
<p>首先，需要一个简单的表达式，每次运行时都会随机返回一个不同的值。 可以使用 <code>Math.random()</code>。 每次调用此方法时，此方法返回 <code>0</code>（包括）和 <code>1</code>（不包括）之间的值。 因此，对于 50/50 的几率，请在表达式中使用 <code>Math.random() &gt;= .5</code>。 从统计学上讲，这个表达式有 50％ 的几率返回 <code>true</code>，另外 50％ 返回 <code>false</code>。 在 render 方法里，用此表达式替换 <code>null</code> 以完成变量声明。</p>
<p>现在你有了一个表达式，可以使用该表达式在代码中做出随机决策。 接下来，需要实现此功能。 将 <code>Results</code> 组件渲染为 <code>GameOfChance</code> 的子 组件，并将 <code>expression</code> 作为名为 <code>fiftyFifty</code> 的 prop 传入 。 在 <code>Results</code> 组件中，编写一个三元表达式来渲染 <code>h1</code> 元素的文本。<code>GameOfChance</code> 传来的 prop <code>fiftyFifty</code> 来决定渲染文本 <code>You Win!</code> 还是 <code>You Lose!</code>。 最后，确保 <code>handleClick()</code> 方法正确计算每个回合，以便用户知道他们玩过多少次。 这也可以让用户知道组件实际上已经更新，以防他们连续赢两次或输两次时自己不知道。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Results</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#123;<span class="comment">/* 修改这行下面的代码 */</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.fiftyFifty ? &quot;You Win!&quot; : &quot;You Lose!&quot;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#123;<span class="comment">/* 修改这行上面的代码 */</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameOfChance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="number">1</span> <span class="comment">// change code here</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> expression = <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt;= <span class="number">0.5</span>; <span class="comment">// 修改这一行</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Play Again<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 修改这行下面的代码 */&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Results</span> <span class="attr">fiftyFifty</span>=<span class="string">&#123;expression&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 修改这行上面的代码 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#x27;Turn: &#x27; + this.state.counter&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="43-根据组件状态有条件地更改内联-CSS"><a href="#43-根据组件状态有条件地更改内联-CSS" class="headerlink" title="43. 根据组件状态有条件地更改内联 CSS"></a>43. 根据组件状态有条件地更改内联 CSS</h3><p>此时，已经看到了一些条件渲染的应用程序和内联样式的使用。 这里还有一个将这两个主题结合在一起的例子。 你也可以根据 React 组件的 state 有条件地渲染 CSS。 要执行此操作，请检查条件，如果满足该条件，则修改在 render 方法中分配给 JSX 元素的样式对象。</p>
<p>理解这个模式很重要，因为相比传统的方式（这在 jQuery 中非常常见），直接修改 DOM 元素来应用样式的方法是一个戏剧性的转变。 在该方法中，必须跟踪元素何时更改并直接处理实际操作。 跟踪更改可能变得很困难，可能会使 UI无法预测。 当根据一个条件设置一个样式对象时，描述了 UI 作为应用程序的状态函数应当如何展现。 如此便有一个清晰的单向流动的信息流。 这是使用 React 编写应用程序时的首选方法。</p>
<hr>
<p>代码编辑器有一个简单的带有边框样式的受控 input 组件。 如果用户在输入框中键入超过 15 个字符的文本，希望将此边框变成红色。 添加一个条件来检查这一点，如果条件有效，则将 input 的边框样式设置为<code>3px solid red</code>。 可以通过在 input 中输入文本来检测它。</p>
<h3 id="44-使用-Array-map-动态渲染元素"><a href="#44-使用-Array-map-动态渲染元素" class="headerlink" title="44. 使用 Array.map() 动态渲染元素"></a>44. 使用 Array.map() 动态渲染元素</h3><p>条件渲染很有用，但是可能需要组件来渲染未知数量的元素。 通常在响应式编程中，程序员在应用程序运行时之前无法知道其 state，因为这在很大程度上取决于用户与该程序的交互。 程序员需要提前编写代码来正确处理未知状态。 在 React 中使用 <code>Array.map()</code> 阐明了这个概念。</p>
<p>例如，创建一个简单的 “To Do List” 应用程序。 作为程序员，你无法知道用户可能在其列表中有多少项。 需要设置组件，以便在使用该程序的人决定今日待办事项之前动态渲染列表元素的正确数量。</p>
<hr>
<p>代码编辑器完成了 <code>MyToDoList</code> 组件的大部分设置。 如果完成了受控表单挑战，这些代码中的一些应该看起来很熟悉。 你会注意到一个 <code>textarea</code> 和一个 <code>button</code>，以及一些跟踪它们状态的方法，但是页面当前还没有任何东西被渲染。</p>
<p>在 <code>constructor</code> 中，创建一个 <code>this.state</code> 对象并定义两个 state：<code>userInput</code> 应该初始化为空字符串，<code>toDoList</code> 应该初始化为空数组。 接下来，在 <code>render()</code> 方法中删除 <code>items</code> 变量的 <code>null</code> 值。 取而代之的是，将存储在组件内部 state 中的 <code>toDoList</code> 数组一一遍历，并相应地动态呈现在 <code>li</code> 元素中。 尝试在 <code>textarea</code> 中输入 <code>eat, code, sleep, repeat</code>，然后点击按钮，看看会发生什么。</p>
<p><strong>注意：</strong> 像这样的映射操作创建的所有兄弟子元素都需要提供唯一的 <code>key</code> 属性。 别担心，这是下一个挑战的主题。</p>
<h3 id="45-给同级元素一个唯一的键属性"><a href="#45-给同级元素一个唯一的键属性" class="headerlink" title="45. 给同级元素一个唯一的键属性"></a>45. 给同级元素一个唯一的键属性</h3><p>上一个挑战展示了如何使用 <code>map</code> 方法根据用户输入动态渲染多个元素。 然而，这个例子中缺少一个重要的部分。 创建元素数组时，每个元素都需要一个设置为唯一值的 <code>key</code> 属性。 React 使用这些键来跟踪哪些项目被添加、更改或删除。 这有助于在以任何方式修改列表时提高重新渲染过程的效率。</p>
<p><strong>注意：</strong> 键只需要在兄弟元素之间是唯一的，它们不需要在应用程序中是全局唯一的。</p>
<hr>
<p>代码编辑器有一个数组，它包含一些前端框架和一个名为 <code>Frameworks()</code> 的无状态函数组件。 <code>Frameworks()</code> 需要将数组映射到无序列表，就像上一个挑战一样。 完成 <code>map</code> 回调，为 <code>frontEndFrameworks</code> 数组中的每个框架返回一个 <code>li</code> 元素。 这次，确保给每个 <code>li</code> 的 <code>key</code> 属性设置一个唯一的值。 <code>li</code> 元素还应该包含来自 <code>frontEndFrameworks</code> 的文本。</p>
<p>通常，希望使 key 能唯一标识要渲染的元素。 数组索引可以是最后的选择，但通常你应该尝试使用唯一标识。</p>
<h3 id="46-使用-Array-Filter-动态过滤数组"><a href="#46-使用-Array-Filter-动态过滤数组" class="headerlink" title="46. 使用 Array.Filter() 动态过滤数组"></a>46. 使用 Array.Filter() 动态过滤数组</h3><p><code>map</code> 数组方法是一个强大的工具，在使用 React 时经常使用。 与 <code>map</code> 相关的另一种方法是 <code>filter</code>，它根据条件过滤数组的内容，然后返回一个新数组。 例如，如果有一个 users 数组，每个数组元素都有一个可以设置为 <code>true</code> 或 <code>false</code> 的 <code>online</code> 属性，可以这样只过滤那些在线的用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onlineUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">online</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p>在代码编辑器中，<code>MyComponent</code> 的 <code>state</code> 被初始化为一个用户数组。 有些用户在线，有些则没有。 过滤数组，以便只查看在线用户。 要执行此操作，请首先使用 <code>filter</code> 返回仅包含 <code>online</code> 属性为 <code>true</code> 的用户的新数组。 然后，在 <code>renderOnline</code> 变量中，映射已过滤的数组，并为包含其 <code>username</code> 文本的每个用户返回 <code>li</code> 元素。 确保包含一个唯一的 <code>key</code>，就像上一个挑战一样。</p>
<h3 id="47-用-renderToString-在服务器上渲染-React"><a href="#47-用-renderToString-在服务器上渲染-React" class="headerlink" title="47. 用 renderToString 在服务器上渲染 React"></a>47. 用 renderToString 在服务器上渲染 React</h3><p>到目前为止，已经能够在客户端上渲染 React 组件， 一般来说我们都是这么做的。 然而，在一些用例中，需要在服务器上渲染一个 React 组件。 由于 React 是一个 JavaScript 视图库，所以通常使用 Node 让 JavaScript 运行在服务器上。 事实上，React 提供了一个可用于此目的的 <code>renderToString()</code> 方法。</p>
<p>有两个关键原因可以解释为什么服务器上的渲染可能会在真实世界的应用程序中使用。 首先，如果不这样做，当 React 应用程序最初加载到浏览器时，它将包含一个代码量很少的 HTML 文件和一大堆 JavaScript。 这对于搜索引擎来说可能不太理想，因为它们试图为网页内容生成索引，以便人们可以找到这个应用。 如果在服务器上渲染初始 HTML 标记并将其发送到客户端，则初始页面加载的内容包含搜索引擎可以抓取的所有页面标记。 其次，这创造了更快的初始页面加载体验，因为渲染的 HTML 代码量要比整个应用程序的 JavaScript 代码小。 React 仍然能够识别你的应用并在初始加载后进行管理。</p>
<hr>
<p><code>renderToString()</code> 方法由 <code>ReactDOMServer</code> 提供，在这里已为你定义成全局变量。 这个方法接收一个 React 元素作为参数。 用它来把 <code>App</code> 渲染成字符串。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/Webchat.png" alt="墨韵 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>墨韵
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://moyun.com/front-end-development-libraries-%E5%9B%9B/" title="Front End Development Libraries(四)">http://moyun.com/front-end-development-libraries-四/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a>
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
              <a href="/tags/React/" rel="tag"><i class="fa fa-tag"></i> React</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/front-end-development-libraries-%E4%BA%8C/" rel="prev" title="Front End Development Libraries(二)">
                  <i class="fa fa-chevron-left"></i> Front End Development Libraries(二)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/front-end-development-libraries-%E5%85%AD/" rel="next" title="Front End Development Libraries(六)">
                  Front End Development Libraries(六) <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MOYUN</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1.3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">19:25</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!-- 网站运行时间的设置 -->
<span id="sitetime"></span>
<script language=javascript>
  	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
         		*/
		var t1 = Date.UTC(2020,02,13,15,00,00); //北京时间2018-2-13 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>
    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- 多级目录 -->
  <script type="text/javascript" src="/js/category.js"></script>
</body>
</html>
